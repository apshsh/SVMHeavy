
//
// Generic type
//
// Version: 7
// Date: 08/04/2016
// Written by: Alistair Shilton (AlShilton@gmail.com)
// Copyright: all rights reserved
//

#include <stdio.h>
#include <stdlib.h>
#include <iostream>
#include <string.h>
#include <string>
#include <math.h>
#include <ctype.h>
#include <sstream>
#include <fstream>
#include <chrono>
#include "basefn.hpp"
#include "gentype.hpp"
#include "opttest.hpp"
#include "paretotest.hpp"
#include "basefn.hpp"
#include "memdebug.hpp"
#include "niceassert.hpp"
#include "vecstack.hpp"
#include "plotbase.hpp"
#include "randfun.hpp"


//static int xxxincalc = 0;

#define NUMSAMP 1000
//#define PARSYSCALL false

// MAXINTFACT is the largest number n for which n! fits in 32 bits, signed.
//            Tested by noting that 12!/11! = 12, but 13!/12! != 13.  I'm
//            being lazy here and assuming 32 bit integers.  Not terribly
//            important for >32 bits (bit of rounding is the only problem)
//            but for <32 bits this will lead to difficulties.
// NUMFNDEF number of defined functions

#define MAXINTFACT 12
#define NUMFNDEF   339

// Needed because you can't have commas in macro arguments

//typedef Dgraph<gentype,double> xDgraph;


static void evalgenFunc(int i, int j, const gentype &xa, int ia, const gentype &xb, int ib, gentype &res);

/* - commented out here, but KEEP FOR DOCUMENTATION
// Function information block.  This class contains all relevant information
// for a given function.

class fninfoblock
{
    public:
    // fnname:      function name
    // numargs:     number of arguments taken by function
    //
    // dirchkargs:  binary, bit set if functionality test in evaluation
    //              requires isValEqnDir true. eg: 6 = 110b means apply
    //              isValEqnDir to arguments 2 and 3 but not argument 1
    // widechkargs: like dirchkargs, but using isValEqn.
    //
    // Basically if an argument is elementwise you need to set dirchkargs,
    // and otherwise you need to set widechkargs.  For example sin is
    // elementwise and norm2 is not.
    //
    // preEvalArgs: binary, bit set if evaluate should be applied to this
    //              argument prior to evaluating the function itself.
    // derivDeffed: set if derivative is defined for this function.
    // isInDetermin:0 if function is deterministic (eg sin)
    //              1 global function indeterminant
    //              2 random indeterminant
    //
    // fn0arg: pointer to 0 argument fn
    // fn1arg: pointer to 1 argument fn
    // fn2arg: pointer to 2 argument fn
    // fn3arg: pointer to 3 argument fn
    // fn4arg: pointer to 4 argument fn
    // fn5arg: pointer to 5 argument fn
    // fn6arg: pointer to 6 argument fn
    //
    // fn0arg: pointer to 0 argument fn, operator type (if defined)
    // fn1arg: pointer to 1 argument fn, operator type (if defined)
    // fn2arg: pointer to 2 argument fn, operator type (if defined)
    // fn3arg: pointer to 3 argument fn, operator type (if defined)
    // fn4arg: pointer to 4 argument fn, operator type (if defined)
    // fn5arg: pointer to 5 argument fn, operator type (if defined)
    // fn6arg: pointer to 6 argument fn, operator type (if defined)
    //
    // conjargmod: if negative, reverse order post conjugation
    //             bit 0: conjugate arg 0 if set
    //             bit 1: conjugate arg 1 if set
    //                ...
    //
    // conjfnname: conjugated function name (~ means unchanged)
    //
    // fnconjind: index of conjugated function
    //
    // realargcopy: bit 0: argument 0 used if set
    //              bit 1: argument 1 used if set
    //                 ...
    // realdrvcopy: bit 0: derivative 0 used if set
    //              bit 1: derivative 1 used if set
    //                 ...
    // realderiv:   real derivative, parsed, if constructed.
    // realderivfn: real derivative string.
    //              var(0,i) is the argument i
    //              var(1,i) is the derivative of argument i

    const char *fnname;
    int numargs;
    int dirchkargs;
    int widechkargs;
    int preEvalArgs;
    int derivDeffed;
    int isInDetermin;

    gentype (*fn0arg)();
    gentype (*fn1arg)(const gentype &);
    gentype (*fn2arg)(const gentype &, const gentype &);
    gentype (*fn3arg)(const gentype &, const gentype &, const gentype &);
    gentype (*fn4arg)(const gentype &, const gentype &, const gentype &, const gentype &);
    gentype (*fn5arg)(const gentype &, const gentype &, const gentype &, const gentype &, const gentype &);
    gentype (*fn6arg)(const gentype &, const gentype &, const gentype &, const gentype &, const gentype &, const gentype &);

    gentype &(*OP_fn0arg)();
    gentype &(*OP_fn1arg)(gentype &);
    gentype &(*OP_fn2arg)(gentype &, const gentype &);
    gentype &(*OP_fn3arg)(gentype &, const gentype &, const gentype &);
    gentype &(*OP_fn4arg)(gentype &, const gentype &, const gentype &, const gentype &);
    gentype &(*OP_fn5arg)(gentype &, const gentype &, const gentype &, const gentype &, const gentype &);
    gentype &(*OP_fn6arg)(gentype &, const gentype &, const gentype &, const gentype &, const gentype &, const gentype &);

    int conjargmod;
    const char *conjfnname;
    int fnconjind; // index of conjugate function

    int realargcopy;
    int realdrvcopy;
    gentype *realderiv;
    const char *realderivfn;

    ~fninfoblock()
    {
        // NB: we *cannot* rely on deleting realderiv here, as that may require access to
        // parts of fninfo that have already been deleted (at fninfoblock is only used by
        // the global fninfo).  Instead we *must* use the atext function or let the memory
        // leak stand and hope the OS does appropriate cleanup).
        //
        //if ( realderiv )
        //{
        //    MEMDEL(realderiv);
        //    realderiv = nullptr;
        //}

        // All other pointers point to statics, so don't delete them

        return;
    }
};
*/


// getfninfo:    Return array containing all the function information
// getfnind:     Get the index for the function string given
// getfnindConj: Get the index for the conjugate fn of the fn string given
// getfninfo:    Get function information for given function

//const char *getfnname(int fnnameind);
//int getfnind(const std::string &fnname);
//int getfnindConj(int fnInd);
//const fninfoblock *getfninfo(int fnIndex);







class eqninfoblock
{
public:
    eqninfoblock() : text(), type(0), res(0), fnname(), commas(), isstr(0) { return; }

    // text:   relevant text for this block
    // type:   0 == opcode
    //         1 == number
    //         2 == expression
    // res:    for numbers, 1 = int,
    //         2 = real,
    //         3 = anion,
    //         4 = vector,
    //         5 = matrix,
    //         6 = string,
    //         7 = error,
    //         8 = set,
    //         9 = dgraph
    //         for expressions this is the number of arguments in the expression
    // fnname: for expressions this is the name of the function
    // commas: for expressions this is a vector containing the positions of all commas
    // isstr:  for expressions this indicates if the expression is a string (no following brackets)

    std::string text;
    int type;
    int res;
    std::string fnname;
    Vector<int> commas;
    int isstr;
};

std::istream &operator>>(std::istream &input, eqninfoblock &dest);
std::istream &streamItIn(std::istream &input, eqninfoblock &dest, int processxyzvw = 1);

std::istream &operator>>(std::istream &input, eqninfoblock &dest)                   { (void) dest;                      NiceThrow("Cant operator>> to eqninfoblock"); return input; }
std::istream &streamItIn(std::istream &input, eqninfoblock &dest, int processxyzvw) { (void) dest; (void) processxyzvw; NiceThrow("Cant streamItIn to eqninfoblock"); return input; }

STREAMINDUMMY(const eqninfoblock *)
STREAMINDUMMY(eqninfoblock *)



inline eqninfoblock &setident (eqninfoblock &a);
inline eqninfoblock &setzero  (eqninfoblock &a);
inline eqninfoblock &setposate(eqninfoblock &a);
inline eqninfoblock &setnegate(eqninfoblock &a);
inline eqninfoblock &setconj  (eqninfoblock &a);
inline eqninfoblock &setrand  (eqninfoblock &a); // random -1 or 1
inline eqninfoblock &leftmult (eqninfoblock &a, eqninfoblock  b);
inline eqninfoblock &rightmult(eqninfoblock  a, eqninfoblock &b);
inline eqninfoblock &postProInnerProd(eqninfoblock &a);

inline eqninfoblock &setident (eqninfoblock &a) { NiceThrow("Cant setident eqninfoblock");  return a;     }
inline eqninfoblock &setzero  (eqninfoblock &a) { eqninfoblock b;                           return a = b; }
inline eqninfoblock &setposate(eqninfoblock &a) {                                           return a;     }
inline eqninfoblock &setnegate(eqninfoblock &a) { NiceThrow("Cant setnegate eqninfoblock"); return a;     }
inline eqninfoblock &setconj  (eqninfoblock &a) { NiceThrow("Cant setconj eqninfoblock");   return a;     }
inline eqninfoblock &setrand  (eqninfoblock &a) { NiceThrow("Cant setrand eqninfoblock");   return a;     }
inline eqninfoblock &leftmult (eqninfoblock &a, eqninfoblock  b) { (void) b; NiceThrow("Cant leftmult eqninfoblock");  return a; }
inline eqninfoblock &rightmult(eqninfoblock  a, eqninfoblock &b) { (void) a; NiceThrow("Cant rightmult eqninfoblock"); return b; }
inline eqninfoblock &postProInnerProd(eqninfoblock &a) { return a; }



static int pairBrackets   (int start, int &end, const std::string &src, int LRorRL   );
static int processNumLtoR (int start, int &end, const std::string &src, bool &isconst);
static int processExprLtoR(int start, int &end, int &isitastring, const std::string &src, std::string &exprname, Vector<int> &commapos);

std::ostream &operator<<(std::ostream &output, const eqninfoblock &src );
void qswap(eqninfoblock &a, eqninfoblock &b);
int operatorToFunction(int LtoRRtoL, int UnaryBinary, const Vector<std::string> &opSymb, const Vector<std::string> &opFuncEquiv, const Vector<int> &opRevBinOrder, Vector<eqninfoblock> &srcxblock);



double gentypeToMatrixRep(const gentype &temp, int dim, int iq, int jq)
{
    double res;

    if ( ( iq >= dim ) || ( jq >= dim ) )
    {
        NiceThrow("Order error in matrix representation computation (mercer).");
    }

    if ( temp.isCastableToRealWithoutLoss() )
    {
        if ( iq == jq )
        {
            res = temp.cast_double(0);
        }

        else
        {
            res = 0.0;
        }
    }

    else if ( temp.isCastableToAnionWithoutLoss() )
    {
        int order = ceilintlog2(dim);

        d_anion restemp(temp.cast_anion(0));
        restemp.setorder(order);

        // Re(conj(x).Kij.y)
        // = xq.Kq.y0 + xq.K0.yq - x0.Kq.yq + xq.epsilon_qrs.Kr.ys
        //
        // Complex = [ x0 xi ] [ K0 -Ki ] [ y0 ]
        //                     [ Ki  K0 ] [ yi ]
        //
        // Quaternion = [ x0 xi xj xk ] [ K0 -Ki -Kj -Kk ] [ y0 ]
        //                              [ Ki  K0 -Kk  Kj ] [ yi ]
        //                              [ Kj  Kk  K0 -Ki ] [ yj ]
        //                              [ Kk -Kj  Ki  K0 ] [ yk ]

        if ( order == 0 )
        {
            // real case

            res = restemp(0);
        }

        else if ( order == 1 )
        {
            // complex case

            if (      ( iq == 0 ) && ( jq == 0 ) ) { res =  restemp(0); }
            else if ( ( iq == 0 ) && ( jq == 1 ) ) { res = -restemp(1); }
            else if ( ( iq == 1 ) && ( jq == 0 ) ) { res =  restemp(1); }
            else if ( ( iq == 1 ) && ( jq == 1 ) ) { res =  restemp(0); }

            else
            {
                NiceThrow("Order error in matrix representation computation (mercer).");
            }
        }

        else if ( order == 2 )
        {
            // quaternion case

            if (      ( iq == 0 ) && ( jq == 0 ) ) { res =  restemp(0); }
            else if ( ( iq == 0 ) && ( jq == 1 ) ) { res = -restemp(1); }
            else if ( ( iq == 0 ) && ( jq == 2 ) ) { res = -restemp(2); }
            else if ( ( iq == 0 ) && ( jq == 3 ) ) { res = -restemp(3); }
            else if ( ( iq == 1 ) && ( jq == 0 ) ) { res =  restemp(1); }
            else if ( ( iq == 1 ) && ( jq == 1 ) ) { res =  restemp(0); }
            else if ( ( iq == 1 ) && ( jq == 2 ) ) { res = -restemp(3); }
            else if ( ( iq == 1 ) && ( jq == 3 ) ) { res =  restemp(2); }
            else if ( ( iq == 2 ) && ( jq == 0 ) ) { res =  restemp(2); }
            else if ( ( iq == 2 ) && ( jq == 1 ) ) { res =  restemp(3); }
            else if ( ( iq == 2 ) && ( jq == 2 ) ) { res =  restemp(0); }
            else if ( ( iq == 2 ) && ( jq == 3 ) ) { res = -restemp(1); }
            else if ( ( iq == 3 ) && ( jq == 0 ) ) { res =  restemp(3); }
            else if ( ( iq == 3 ) && ( jq == 1 ) ) { res = -restemp(2); }
            else if ( ( iq == 3 ) && ( jq == 2 ) ) { res =  restemp(1); }
            else if ( ( iq == 3 ) && ( jq == 3 ) ) { res =  restemp(0); }

            else
            {
                NiceThrow("Order error in matrix representation computation (mercer).");
            }
        }

        else
        {
            // general case

            int r;

            if ( iq == jq )
            {
                res = restemp(0);
            }

            else if ( !iq )
            {
                res = -restemp(jq);
            }

            else if ( !jq )
            {
                res = restemp(iq);
            }

            else
            {
                r = 1;

                while ( !epsilon(order,iq,r,jq) && ( r < 1<<order ) )
                {
                    ++r;
                }

                if ( r < 1<<order )
                {
                    res = epsilon(order,iq,r,jq)*restemp(r);
                }

                else
                {
                    res = 0.0;
                }
            }
        }
    }

    else if ( temp.isCastableToMatrixWithoutLoss() )
    {
        res = (temp.cast_matrix(0))(iq,jq);
    }

    else
    {
        NiceThrow("Kernel error: non-matrix-castable result for matrix kernel");
    }

    return res;
}

Matrix<double> &gentypeToMatrixRep(Matrix<double> &res, const gentype &src, int spaceDim)
{
    res.resize(spaceDim,spaceDim);
    res = 0.0;

    if ( src.isCastableToRealWithoutLoss() )
    {
        double tempres = src.cast_double(0);

        int i;

        for ( i = 0 ; i < spaceDim ; ++i )
        {
            res("&",i,i) = tempres;
        }
    }

    else if ( src.isCastableToAnionWithoutLoss() )
    {
        int order = ceilintlog2(spaceDim);

        NiceAssert( spaceDim == 1<<order );

        d_anion tempres = src.cast_anion(0);

        int i;

        for ( i = 0 ; i < spaceDim ; ++i )
        {
            res("&",i,i) = tempres(0);
        }

        tempres.setorder(order);

        // Re(conj(x).Kij.y)
        // = xq.Kq.y0 + xq.K0.yq - x0.Kq.yq + xq.epsilon_qrs.Kr.ys
        //
        // Complex = [ x0 xi ] [ K0 -Ki ] [ y0 ]
        //                     [ Ki  K0 ] [ yi ]
        //
        // Quaternion = [ x0 xi xj xk ] [ K0 -Ki -Kj -Kk ] [ y0 ]
        //                              [ Ki  K0 -Kk  Kj ] [ yi ]
        //                              [ Kj  Kk  K0 -Ki ] [ yj ]
        //                              [ Kk -Kj  Ki  K0 ] [ yk ]

        if ( order == 0 )
        {
            // real case

            res("&",0,0) = tempres(0);
        }

        else if ( order == 1 )
        {
            // complex case

            res("&",0,0) =  tempres(0);
            res("&",0,1) = -tempres(1);
            res("&",1,0) =  tempres(1);
            res("&",1,1) =  tempres(0);
        }

        else if ( order == 2 )
        {
            // quaternion case

            res("&",0,0) =  tempres(0);
            res("&",0,1) = -tempres(1);
            res("&",0,2) = -tempres(2);
            res("&",0,3) = -tempres(3);
            res("&",1,0) =  tempres(1);
            res("&",1,1) =  tempres(0);
            res("&",1,2) = -tempres(3);
            res("&",1,3) =  tempres(2);
            res("&",2,0) =  tempres(2);
            res("&",2,1) =  tempres(3);
            res("&",2,2) =  tempres(0);
            res("&",2,3) = -tempres(1);
            res("&",3,0) =  tempres(3);
            res("&",3,1) = -tempres(2);
            res("&",3,2) =  tempres(1);
            res("&",3,3) =  tempres(0);
        }

        else
        {
            // general case

            int q,r,s;

            for ( q = 0 ; q < tempres.size() ; ++q )
            {
                for ( s = 0 ; s < tempres.size() ; ++s )
                {
                    if ( q == s )
                    {
                        res("&",q,s) = tempres(0);
                    }

                    else if ( !q )
                    {
                        res("&",q,s) = -tempres(s);
                    }

                    else if ( !s )
                    {
                        res("&",q,s) = tempres(q);
                    }

                    else
                    {
                        r = 1;

                        while ( !epsilon(order,q,r,s) && ( r < tempres.size() ) )
                        {
                            ++r;
                        }

                        if ( r < tempres.size() )
                        {
                            res("&",q,s) = epsilon(order,q,r,s)*tempres(r);
                        }

                        else
                        {
                            res("&",q,s) = 0;
                        }
                    }
                }
            }
        }
    }

    else if ( src.isCastableToMatrixWithoutLoss() )
    {
        res = src.cast_matrix_real(0);

/*
        int i,j;
        Matrix<gentype> tempres;

        tempres = src.cast_matrix(0);

        NiceAssert( spaceDim == tempres.numRows() );
        NiceAssert( tempres.isSquare() );

        if ( tempres.numRows() && tempres.numCols() )
        {
            for ( i = 0 ; i < tempres.numRows() ; ++i )
            {
                for ( j = 0 ; j < tempres.numCols() ; ++j )
                {
                    res("&",i,j) = tempres(i,j).cast_double(0);
                }
            }
        }
*/
    }

    else
    {
        NiceThrow("Kernel error: non-matrix-castable result for matrix kernel");
    }

    return res;
}











std::istream &operator>>(std::istream &input, gentype &dest)
{
    return streamItIn(input,dest);
}

std::ostream &operator<<(std::ostream &output, const gentype &src )
{
    // Aside: we don't use isCastableToIntegerWithoutLoss here, as this may
    // return true for an anion, and we want to preserve the *order* of the
    // anion (complex, quaternion, whatever).  Likewise we avoid demoting
    // anions to real even if it can be done, and we avoid demoting reals to
    // integers by optionally appending .0 to the end of the result.

    if ( src.scalarfn_isscalarfn() )
    {
        output << "@(";
        output << src.scalarfn_i() << ",";
        output << src.scalarfn_j() << ",";
        output << src.scalarfn_numpts() << "):";
    }

    //else if ( src.isValVector()  ) { output         << src.cast_vector(0); }

         if ( src.isValNull()    ) { output         << "null";                }
    else if ( src.isValInteger() ) { output         << src.cast_int(0);   if ( src.isNomConst ) { output << "c"; } }
    else if ( src.isValAnion()   ) { output         << src.cast_anion(0);     }
    else if ( src.isValVector()  ) { printoneline(output,src.cast_vector(0)); }
    else if ( src.isValMatrix()  ) { output << "M:" << src.cast_matrix(0);    }
    else if ( src.isValSet()     ) { output         << src.cast_set(0);       }
    else if ( src.isValDict()    ) { output         << src.cast_dict(0);      }
    else if ( src.isValDgraph()  ) { output << "G:" << src.cast_dgraph(0);    }

    else if ( src.isValReal() )
    {
        double srcdval = src.cast_double(0);

        if ( testisvnan(srcdval) )
        {
            output << "vnan()";
        }

        else if ( testispinf(srcdval) )
        {
            output << "pinf()";
        }

        else if ( testisninf(srcdval) )
        {
            output << "ninf()";
        }

	else
	{
            // Small niggle.  If number is real then we want to retain the
            // "realness" - that is, if read back it should parse as real.
            // To ensure this we need to add .0 to the end if neither e nor
            // . is present in the printed result.

            streamItOut(output,srcdval,1);

            if ( src.isNomConst ) { output << "c"; }

//            char tempres[100];
//            sprintf(tempres,"%.17g",srcdval);
//            std::string tempresb(tempres);
//            output << tempresb;
//
//            if ( !tempresb.find(".") && !tempresb.find("e") && !tempresb.find("E") )
//            {
//                output << ".0";
//            }
	}
    }

    else
    {
        std::string resstring(src.cast_string(0));

        // We want to be able to have "fake" sparse vectors by including relevant characters in
        // a vector (:, ::, :::, ::::, ~). We need to treat these as strings in the input (without
        // quotes) and also print them out without quotes.

        if ( src.isValString() && ( resstring != ":" ) && ( resstring != "::" ) && ( resstring != ":::" ) && ( resstring != "::::" ) && ( resstring != "~" ) )
        {
            output << '\"';
        }

	if ( resstring.size() )
	{
            size_t i;

            // Looping to maintain escape characters

            for ( i = 0 ; i < resstring.size() ; ++i )
            {
                if ( ( i == 2 ) && src.isValError() )
                {
                    output << '\"' << resstring[i];
                }

                //if ( resstring[i] == '\"' ) { output << "\\\""; }
                //else if ( resstring[i] == '\'' ) { output << "\\\'"; }
                //else if ( resstring[i] == '\?' ) { output << "\\\?"; }
                //else if ( resstring[i] == '\\' ) { output << "\\"; }
                //else if ( resstring[i] == '\a' ) { output << "\\a"; }
                //else if ( resstring[i] == '\b' ) { output << "\\b"; }
                //else if ( resstring[i] == '\f' ) { output << "\\f"; }
                //else if ( resstring[i] == '\n' ) { output << "\\n"; }
                //else if ( resstring[i] == '\r' ) { output << "\\r"; }
                //else if ( resstring[i] == '\t' ) { output << "\\t"; }
                //else if ( resstring[i] == '\v' ) { output << "\\v"; }

                else
                {
                    output << resstring[i];
                }
	    }
	}

        if ( src.isValString() && ( resstring != ":" ) && ( resstring != "::" ) && ( resstring != ":::" ) && ( resstring != "::::" ) && ( resstring != "~" ) )
        {
            output << '\"';
        }

        if ( src.isValError() )
        {
            output << '\"';
        }
    }

    return output;
}



std::istream &streamItIn(std::istream &input, gentype &dest, int processxyzvw)
{
    char tt;

    // Note: this bit is important.  Weirdness, but if you wonder
    // why try inputing
    //
    // [ 1
    // 2 ]
    //
    // (with the newline) directly into std::cin >> an instance of gentype.
    // Without the following "pause" code this will not work.

    while ( isspace(input.peek()) )
    {
	input.get(tt);
    }

    input.peek();

    // Need to look for scalar function indicator

    Vector<int> sfni(1);
    Vector<int> sfnj(1);

    sfni = (int) DEFAULTVARI;
    sfnj = (int) DEFAULTVARJ;

    dest.scalarfn_setisscalarfn(0);
    dest.scalarfn_setnumpts(DEFAULT_INTEGRAL_SLICES);

    dest.scalarfn_seti(sfni);
    dest.scalarfn_setj(sfnj);

    dest.isNomConst = false;

    if ( input.peek() == '@' )
    {
        dest.scalarfn_setisscalarfn(1);

        input.get(tt);
        NiceAssert( tt == '@' );
        input.get(tt);
        NiceAssert( tt == '(' );

        while ( isspace(input.peek()) )
        {
            input.get(tt);
        }

        if ( input.peek() == ')' )
        {
            input.get(tt);
            goto donepoint;
        }

        {
            Vector<int> nv;

            streamItIn(input,nv,processxyzvw);

            dest.scalarfn_seti(nv);
        }

        while ( isspace(input.peek()) )
        {
            input.get(tt);
        }

        input.get(tt);

        if ( tt == ')' )
        {
            goto donepoint;
        }

        NiceAssert( tt == ',' );

        while ( isspace(input.peek()) )
        {
            input.get(tt);
        }

        {
            Vector<int> nv;

            streamItIn(input,nv,processxyzvw);

            dest.scalarfn_setj(nv);
        }

        while ( isspace(input.peek()) )
        {
            input.get(tt);
        }

        input.get(tt);

        if ( tt == ')' )
        {
            goto donepoint;
        }

        NiceAssert( tt == ',' );

        while ( isspace(input.peek()) )
        {
            input.get(tt);
        }

        {
            int nv = 0;
            input.get(tt);

            while ( isdigit(tt) )
            {
                nv *= 10;
                nv += tt-'0';

                input.get(tt);
            }

            dest.scalarfn_setnumpts(nv);
        }

        while ( isspace(input.peek()) )
        {
            input.get(tt);
        }

        input.get(tt);
        NiceAssert( tt == ')' );

donepoint:

        input.get(tt);
        NiceAssert( tt == ':' );
    }

    // Treat any number as an equation.  Then, when we call makeEqn,
    // this will simplify if possible and convert number equations
    // into actual numbers.

    std::string resstore;

    if ( readParenString(input,resstore) )
    {
        //NiceThrow("Unpaired brackets in streamItIn gentype expression.");
        ;
    }

    else
    {
        if ( dest.makeEqn(resstore,processxyzvw) )
        {
//errstream() << "phantomxyz 0: " << resstore << "\n";
            //NiceThrow("Syntax error in streamItIn gentype expression.");
            ;
        }
    }

    return input;
}
















// -------------------------------------------------------------------------
// -------------------------------------------------------------------------
// -------------------------------------------------------------------------
// -------------------------------------------------------------------------
// -------------------------------------------------------------------------
// -------------------------------------------------------------------------
// -------------------------------------------------------------------------
// -------------------------------------------------------------------------
// -------------------------------------------------------------------------
// -------------------------------------------------------------------------
// -------------------------------------------------------------------------
// -------------------------------------------------------------------------
// -------------------------------------------------------------------------
// -------------------------------------------------------------------------
// -------------------------------------------------------------------------
// -------------------------------------------------------------------------
// -------------------------------------------------------------------------
// -------------------------------------------------------------------------
// -------------------------------------------------------------------------
// -------------------------------------------------------------------------
// -------------------------------------------------------------------------
// -------------------------------------------------------------------------
// -------------------------------------------------------------------------
// -------------------------------------------------------------------------
// -------------------------------------------------------------------------
// -------------------------------------------------------------------------
// -------------------------------------------------------------------------
// -------------------------------------------------------------------------
// -------------------------------------------------------------------------
// -------------------------------------------------------------------------
// -------------------------------------------------------------------------
// -------------------------------------------------------------------------
// -------------------------------------------------------------------------
// -------------------------------------------------------------------------
// -------------------------------------------------------------------------
// -------------------------------------------------------------------------
// -------------------------------------------------------------------------
// -------------------------------------------------------------------------
// -------------------------------------------------------------------------
// -------------------------------------------------------------------------
// -------------------------------------------------------------------------
// -------------------------------------------------------------------------
// -------------------------------------------------------------------------
// -------------------------------------------------------------------------
// -------------------------------------------------------------------------
// -------------------------------------------------------------------------
// -------------------------------------------------------------------------
// -------------------------------------------------------------------------
// -------------------------------------------------------------------------
// -------------------------------------------------------------------------
// -------------------------------------------------------------------------
// -------------------------------------------------------------------------
// -------------------------------------------------------------------------
// -------------------------------------------------------------------------
// -------------------------------------------------------------------------
// -------------------------------------------------------------------------
// -------------------------------------------------------------------------
// -------------------------------------------------------------------------
// -------------------------------------------------------------------------
// -------------------------------------------------------------------------
// -------------------------------------------------------------------------
// -------------------------------------------------------------------------
// -------------------------------------------------------------------------
// -------------------------------------------------------------------------
// -------------------------------------------------------------------------
// -------------------------------------------------------------------------
// -------------------------------------------------------------------------
// -------------------------------------------------------------------------
// -------------------------------------------------------------------------
// -------------------------------------------------------------------------
// -------------------------------------------------------------------------
// -------------------------------------------------------------------------
// -------------------------------------------------------------------------
// -------------------------------------------------------------------------
// -------------------------------------------------------------------------
// -------------------------------------------------------------------------
// -------------------------------------------------------------------------
// -------------------------------------------------------------------------
// -------------------------------------------------------------------------
// -------------------------------------------------------------------------
// -------------------------------------------------------------------------
// -------------------------------------------------------------------------
// -------------------------------------------------------------------------
// -------------------------------------------------------------------------
// -------------------------------------------------------------------------
// -------------------------------------------------------------------------
// -------------------------------------------------------------------------
// -------------------------------------------------------------------------
// -------------------------------------------------------------------------
// -------------------------------------------------------------------------
// -------------------------------------------------------------------------
// -------------------------------------------------------------------------
// -------------------------------------------------------------------------
// -------------------------------------------------------------------------
// -------------------------------------------------------------------------
// -------------------------------------------------------------------------
// -------------------------------------------------------------------------


const gentype &innerProduct(gentype &res, const gentype &a, const gentype &b)
{
    if ( ( &res == &a ) && ( &res == &b ) )
    {
        gentype aa(a);
        gentype bb(b);

        innerProduct(res,aa,bb);
    }

    else if ( &res == &a )
    {
        gentype aa(a);

        innerProduct(res,aa,b);
    }

    else if ( &res == &b )
    {
        gentype bb(b);

        innerProduct(res,a,bb);
    }

    else if ( a.scalarfn_isscalarfn() && b.scalarfn_isscalarfn() && ( a.scalarfn_i().size() == 0 ) )
    {
        NiceAssert( a.scalarfn_i().size() == a.scalarfn_j().size() );
        NiceAssert( a.scalarfn_i().size() == b.scalarfn_i().size() );
        NiceAssert( a.scalarfn_i().size() == b.scalarfn_j().size() );

        res.zero();
        res.scalarfn_setisscalarfn(0);
    }

    else if ( a.scalarfn_isscalarfn() && b.scalarfn_isscalarfn() && ( a.scalarfn_i().size() == 1 ) )
    {
        NiceAssert( a.scalarfn_i().size() == a.scalarfn_j().size() );
        NiceAssert( a.scalarfn_i().size() == b.scalarfn_i().size() );
        NiceAssert( a.scalarfn_i().size() == b.scalarfn_j().size() );

        int numpts = ( a.scalarfn_numpts() > b.scalarfn_numpts() ) ? a.scalarfn_numpts() : b.scalarfn_numpts();

        res.zero();

        SparseVector<SparseVector<gentype> > xa;
        SparseVector<SparseVector<gentype> > xb;

        gentype aa;
        gentype bb;

        for ( int i = 0 ; i < numpts ; ++i )
        {
            xa("&",a.scalarfn_i()(0))("&",a.scalarfn_j()(0)) = (((double) i)+0.5)/((double) numpts);
            xb("&",b.scalarfn_i()(0))("&",b.scalarfn_j()(0)) = (((double) i)+0.5)/((double) numpts);

            aa = a(xa);
            bb = b(xb);

            bb.conj();

            aa.finalise();
            bb.finalise();

            aa /= ((double) numpts);
            aa *= bb;

            res += aa;
        }

        res.scalarfn_setisscalarfn(0);
    }

    else if ( a.scalarfn_isscalarfn() && b.scalarfn_isscalarfn() )
    {
        NiceAssert( a.scalarfn_i().size() == a.scalarfn_j().size() );
        NiceAssert( a.scalarfn_i().size() == b.scalarfn_i().size() );
        NiceAssert( a.scalarfn_i().size() == b.scalarfn_j().size() );

        int numvar = a.scalarfn_i().size();
        int numpts = ( a.scalarfn_numpts() > b.scalarfn_numpts() ) ? a.scalarfn_numpts() : b.scalarfn_numpts();
        int numtot = (int) pow(numpts,numvar);

        Vector<int> k(numvar);

        k = 0;

        res.zero();

        SparseVector<SparseVector<gentype> > xa;
        SparseVector<SparseVector<gentype> > xb;

        gentype aa;
        gentype bb;

        for ( int i = 0 ; i < numtot ; ++i )
        {
            for ( int j = 0 ; j < numvar ; ++j )
            {
                xa("&",a.scalarfn_i()(j))("&",a.scalarfn_j()(j)) = (((double) k(j))+0.5)/((double) numpts);
                xb("&",b.scalarfn_i()(j))("&",b.scalarfn_j()(j)) = (((double) k(j))+0.5)/((double) numpts);
            }

            aa = a(xa);
            bb = b(xb);

            bb.conj();

            aa.finalise();
            bb.finalise();

            aa /= ((double) numtot);
            aa *= bb;

            res += aa;

            for ( int j = 0 ; j < numvar ; ++j )
            {
                ++(k("&",j));

                if ( k(j) >= numpts )
                {
                    k("&",j) = 0;
                }

                else
                {
                    break;
                }
            }
        }

        res.scalarfn_setisscalarfn(0);
    }

    else if ( a.scalarfn_isscalarfn() && b.isValVector() && b.infsize() && ( a.scalarfn_i().size() == 1 ) )
    {
        NiceAssert( a.scalarfn_i().size() == a.scalarfn_j().size() );

        int numpts = a.scalarfn_numpts();
        gentype aa;
        gentype bb;
        const Vector<gentype> &bvec = b.cast_vector(0);
        SparseVector<SparseVector<gentype> > x;

        res.zero();

        for ( int i = 0 ; i < numpts ; ++i )
        {
            x("&",a.scalarfn_i()(0))("&",a.scalarfn_j()(0)) = (((double) i)+0.5)/((double) numpts);

            aa = a(x);
            bb = bvec(x("&",a.scalarfn_i()(0))("&",a.scalarfn_j()(0)));

            bb.conj();

            aa.finalise();
            bb.finalise();

            aa /= ((double) numpts);
            aa *= bb;

            res += aa;
        }

        res.scalarfn_setisscalarfn(0);
    }

    else if ( b.scalarfn_isscalarfn() && a.isValVector() && a.infsize() && ( b.scalarfn_i().size() == 1 ) )
    {
        NiceAssert( b.scalarfn_i().size() == b.scalarfn_j().size() );

        int numpts = b.scalarfn_numpts();
        gentype aa;
        gentype bb;
        const Vector<gentype> &avec = a.cast_vector(0);
        SparseVector<SparseVector<gentype> > x;

        res.zero();

        for ( int i = 0 ; i < numpts ; ++i )
        {
            x("&",b.scalarfn_i()(0))("&",b.scalarfn_j()(0)) = (((double) i)+0.5)/((double) numpts);

            aa = avec(x("&",b.scalarfn_i()(0))("&",b.scalarfn_j()(0)));
            bb = b(x);

            bb.conj();

            aa.finalise();
            bb.finalise();

            aa /= ((double) numpts);
            aa *= bb;

            res += aa;
        }

        res.scalarfn_setisscalarfn(0);
    }

    else if ( a.isValVector() && b.scalarfn_isscalarfn() && ( b.scalarfn_i().size() == 1 ) )
    {
        NiceAssert( b.scalarfn_i().size() == b.scalarfn_j().size() );

        int numpts = b.scalarfn_numpts();

        int q;

        res.zero();

        SparseVector<SparseVector<gentype> > xb;

        gentype aa;
        gentype bb;

        for ( int i = 0 ; i < numpts ; ++i )
        {
            q = (int) (((((double) i)+0.5)/((double) numpts))*a.size()); // always rounds toward zero
            xb("&",b.scalarfn_i()(0))("&",b.scalarfn_j()(0)) = (((double) i)+0.5)/((double) numpts);

            aa = a(q);
            bb = b(xb);

            bb.conj();

            aa.finalise();
            bb.finalise();

            aa /= ((double) numpts);
            aa *= bb;

            res += aa;
        }

        res.scalarfn_setisscalarfn(0);
    }

    else if ( a.scalarfn_isscalarfn() && b.isValVector() && ( a.scalarfn_i().size() == 1 ) )
    {
        NiceAssert( a.scalarfn_i().size() == a.scalarfn_j().size() );

        int numpts = a.scalarfn_numpts();

        int q;

        res.zero();

        SparseVector<SparseVector<gentype> > xa;

        gentype aa;
        gentype bb;

        for ( int i = 0 ; i < numpts ; ++i )
        {
            xa("&",a.scalarfn_i()(0))("&",a.scalarfn_j()(0)) = (((double) i)+0.5)/((double) numpts);
            q = (int) (((((double) i)+0.5)/((double) numpts))*b.size()); // always rounds toward zero

            aa = a(xa);
            bb = b(q);

            bb.conj();

            aa.finalise();
            bb.finalise();

            aa /= ((double) numpts);
            aa *= bb;

            res += aa;
        }

        res.scalarfn_setisscalarfn(0);
    }

    else if ( a.isValEqnDir() || b.isValEqnDir() )
    {
        res = a;
        setconj(res);
        res *= b;
    }

    else if ( a.isValNull() || a.isValInteger() || a.isValReal() || a.isValAnion() )
    {
        res = a;
        setconj(res);
        res *= b;
    }

    else if ( a.isValVector() )
    {
        if ( b.isValVector() )
        {
            innerProduct(res,
            a.cast_vector(0),
            b.cast_vector(0));
        }

        else if ( b.isValMatrix() )
        {
            res.force_vector() = a.cast_vector(0);
            setconj(res.dir_vector());
            res.dir_vector() *= b.cast_matrix(0);
        }

        else
        {
            res.force_vector() = a.cast_vector(0);
            setconj(res.dir_vector());
            res.dir_vector() *= b;
        }
    }

    else if ( a.isValMatrix() )
    {
        if ( b.isValVector() )
        {
            res.force_vector() = b.cast_vector(0);
            setconj(res.dir_vector());
            res.dir_vector() *= a.cast_matrix(0);
            setconj(res.dir_vector());
        }

        else if ( b.isValMatrix() )
        {
            res.force_matrix() = a.cast_matrix(0);
            setconj(res.dir_matrix());
            res.dir_matrix() *= b.cast_matrix(0);
        }

        else
        {
            res.force_matrix() = a.cast_matrix(0);
            setconj(res.dir_matrix());
            res.dir_matrix() *= b;
        }
    }

    else
    {
        if ( b.isValVector() )
        {
            res.force_vector() = b.cast_vector(0);
            setconj(res.dir_vector());
            res.dir_vector() *= a;
            setconj(res.dir_vector());
        }

        else if ( b.isValMatrix() )
        {
            res.force_matrix() = b.cast_matrix(0);
            setconj(res.dir_matrix());
            res.dir_matrix() *= a;
            setconj(res.dir_matrix());
        }

        else
        {
            res = a;
            setconj(res);
            res *= b;
        }
    }

    return res;
}

const gentype &innerProductRevConj(gentype &res, const gentype &a, const gentype &b)
{
    if ( ( &res == &a ) && ( &res == &b ) )
    {
        gentype aa(a);
        gentype bb(b);

        innerProduct(res,aa,bb);
    }

    else if ( &res == &a )
    {
        gentype aa(a);

        innerProduct(res,aa,b);
    }

    else if ( &res == &b )
    {
        gentype bb(b);

        innerProduct(res,a,bb);
    }

    else if ( a.scalarfn_isscalarfn() && b.scalarfn_isscalarfn() && ( a.scalarfn_i().size() == 0 ) )
    {
        NiceAssert( a.scalarfn_i().size() == a.scalarfn_j().size() );
        NiceAssert( a.scalarfn_i().size() == b.scalarfn_i().size() );
        NiceAssert( a.scalarfn_i().size() == b.scalarfn_j().size() );

        res.zero();
        res.scalarfn_setisscalarfn(0);
    }

    else if ( a.scalarfn_isscalarfn() && b.scalarfn_isscalarfn() && ( a.scalarfn_i().size() == 1 ) )
    {
        NiceAssert( a.scalarfn_i().size() == a.scalarfn_j().size() );
        NiceAssert( a.scalarfn_i().size() == b.scalarfn_i().size() );
        NiceAssert( a.scalarfn_i().size() == b.scalarfn_j().size() );

        int numpts = ( a.scalarfn_numpts() > b.scalarfn_numpts() ) ? a.scalarfn_numpts() : b.scalarfn_numpts();

        res.zero();

        SparseVector<SparseVector<gentype> > xa;
        SparseVector<SparseVector<gentype> > xb;

        gentype aa;
        gentype bb;

        for ( int i = 0 ; i < numpts ; ++i )
        {
            xa("&",a.scalarfn_i()(0))("&",a.scalarfn_j()(0)) = (((double) i)+0.5)/((double) numpts);
            xb("&",b.scalarfn_i()(0))("&",b.scalarfn_j()(0)) = (((double) i)+0.5)/((double) numpts);

            aa = a(xa);
            bb = b(xb);

            aa.conj();

            aa.finalise();
            bb.finalise();

            aa /= ((double) numpts);
            aa *= bb;

            res += aa;
        }

        res.scalarfn_setisscalarfn(0);
    }

    else if ( a.scalarfn_isscalarfn() && b.scalarfn_isscalarfn() )
    {
        NiceAssert( a.scalarfn_i().size() == a.scalarfn_j().size() );
        NiceAssert( a.scalarfn_i().size() == b.scalarfn_i().size() );
        NiceAssert( a.scalarfn_i().size() == b.scalarfn_j().size() );

        int numvar = a.scalarfn_i().size();
        int numpts = ( a.scalarfn_numpts() > b.scalarfn_numpts() ) ? a.scalarfn_numpts() : b.scalarfn_numpts();
        int numtot = (int) pow(numpts,numvar);

        Vector<int> k(numvar);

        k = 0;

        res.zero();

        SparseVector<SparseVector<gentype> > xa;
        SparseVector<SparseVector<gentype> > xb;

        gentype aa;
        gentype bb;

        for ( int i = 0 ; i < numtot ; ++i )
        {
            for ( int j = 0 ; j < numvar ; ++j )
            {
                xa("&",a.scalarfn_i()(j))("&",a.scalarfn_j()(j)) = (((double) k(j))+0.5)/((double) numpts);
                xb("&",b.scalarfn_i()(j))("&",b.scalarfn_j()(j)) = (((double) k(j))+0.5)/((double) numpts);
            }

            aa = a(xa);
            bb = b(xb);

            aa.conj();

            aa.finalise();
            bb.finalise();

            aa /= ((double) numtot);
            aa *= bb;

            res += aa;

            for ( int j = 0 ; j < numvar ; ++j )
            {
                ++(k("&",j));

                if ( k(j) >= numpts )
                {
                    k("&",j) = 0;
                }

                else
                {
                    break;
                }
            }
        }

        res.scalarfn_setisscalarfn(0);
    }

    else if ( a.scalarfn_isscalarfn() && b.isValVector() && b.infsize() && ( a.scalarfn_i().size() == 1 ) )
    {
        NiceAssert( a.scalarfn_i().size() == a.scalarfn_j().size() );

        int numpts = a.scalarfn_numpts();
        gentype aa;
        gentype bb;
        const Vector<gentype> &bvec = b.cast_vector(0);
        SparseVector<SparseVector<gentype> > x;

        res.zero();

        for ( int i = 0 ; i < numpts ; ++i )
        {
            x("&",a.scalarfn_i()(0))("&",a.scalarfn_j()(0)) = (((double) i)+0.5)/((double) numpts);

            aa = a(x);
            bb = bvec(x("&",a.scalarfn_i()(0))("&",a.scalarfn_j()(0)));

            aa.conj();

            aa.finalise();
            bb.finalise();

            aa /= ((double) numpts);
            aa *= bb;

            res += aa;
        }

        res.scalarfn_setisscalarfn(0);
    }

    else if ( b.scalarfn_isscalarfn() && a.isValVector() && a.infsize() && ( b.scalarfn_i().size() == 1 ) )
    {
        NiceAssert( b.scalarfn_i().size() == b.scalarfn_j().size() );

        int numpts = b.scalarfn_numpts();
        gentype aa;
        gentype bb;
        const Vector<gentype> &avec = a.cast_vector(0);
        SparseVector<SparseVector<gentype> > x;

        res.zero();

        for ( int i = 0 ; i < numpts ; ++i )
        {
            x("&",b.scalarfn_i()(0))("&",b.scalarfn_j()(0)) = (((double) i)+0.5)/((double) numpts);

            aa = avec(x("&",b.scalarfn_i()(0))("&",b.scalarfn_j()(0)));
            bb = b(x);

            aa.conj();

            aa.finalise();
            bb.finalise();

            aa /= ((double) numpts);
            aa *= bb;

            res += aa;
        }

        res.scalarfn_setisscalarfn(0);
    }

    else if ( a.isValVector() && b.scalarfn_isscalarfn() && ( b.scalarfn_i().size() == 1 ) )
    {
        NiceAssert( b.scalarfn_i().size() == b.scalarfn_j().size() );

        int numpts = b.scalarfn_numpts();

        int q;

        res.zero();

        SparseVector<SparseVector<gentype> > xb;

        gentype aa;
        gentype bb;

        for ( int i = 0 ; i < numpts ; ++i )
        {
            q = (int) (((((double) i)+0.5)/((double) numpts))*a.size()); // always rounds toward zero
            xb("&",b.scalarfn_i()(0))("&",b.scalarfn_j()(0)) = (((double) i)+0.5)/((double) numpts);

            aa = a(q);
            bb = b(xb);

            aa.conj();

            aa.finalise();
            bb.finalise();

            aa /= ((double) numpts);
            aa *= bb;

            res += aa;
        }

        res.scalarfn_setisscalarfn(0);
    }

    else if ( a.scalarfn_isscalarfn() && b.isValVector() && ( a.scalarfn_i().size() == 1 ) )
    {
        NiceAssert( a.scalarfn_i().size() == a.scalarfn_j().size() );

        int numpts = a.scalarfn_numpts();

        int q;

        res.zero();

        SparseVector<SparseVector<gentype> > xa;

        gentype aa;
        gentype bb;

        for ( int i = 0 ; i < numpts ; ++i )
        {
            xa("&",a.scalarfn_i()(0))("&",a.scalarfn_j()(0)) = (((double) i)+0.5)/((double) numpts);
            q = (int) (((((double) i)+0.5)/((double) numpts))*b.size()); // always rounds toward zero

            aa = a(xa);
            bb = b(q);

            aa.conj();

            aa.finalise();
            bb.finalise();

            aa /= ((double) numpts);
            aa *= bb;

            res += aa;
        }

        res.scalarfn_setisscalarfn(0);
    }

    else if ( a.isValEqnDir() || b.isValEqnDir() )
    {
        res = b;
        setconj(res);
        rightmult(a,res);
    }

    else if ( a.isValNull() || a.isValInteger() || a.isValReal() || a.isValAnion() )
    {
        res = b;
        setconj(res);
        rightmult(a,res);
    }

    else if ( a.isValVector() )
    {
        if ( b.isValVector() )
        {
            innerProductRevConj(res,
            a.cast_vector(0),
            b.cast_vector(0));
        }

        else if ( b.isValMatrix() )
        {
            res.force_vector() = a.cast_vector(0);
            res.dir_vector() *= conj(b);
        }

        else
        {
            res.force_vector() = a.cast_vector(0);
            res.dir_vector() *= conj(b);
        }
    }

    else if ( a.isValMatrix() )
    {
        if ( b.isValVector() )
        {
            res.force_vector() = (a.cast_matrix(0))*conj(b);
        }

        else if ( b.isValMatrix() )
        {
            res.force_matrix() = a.cast_matrix(0);
            res.dir_matrix() *= conj(b);
        }

        else
        {
            res.force_matrix() = a.cast_matrix(0);
            res.dir_matrix() *= conj(b);
        }
    }

    else
    {
        if ( b.isValVector() )
        {
            res.force_vector() = a*conj(b);
        }

        else if ( b.isValMatrix() )
        {
            res.force_matrix() = a*conj(b);
        }

        else
        {
            res = a;
            res *= conj(b);
        }
    }

    return res;
}

const gentype &oneProduct(gentype &res, const gentype &a)
{
    if ( &res == &a )
    {
        gentype aa(a);

        oneProduct(res,aa);
    }

    else if ( a.scalarfn_isscalarfn() && ( a.scalarfn_i().size() == 0 ) )
    {
        NiceAssert( a.scalarfn_i().size() == a.scalarfn_j().size() );

        res.zero();
        res.scalarfn_setisscalarfn(0);
    }

    else if ( a.scalarfn_isscalarfn() && ( a.scalarfn_i().size() == 1 ) )
    {
        NiceAssert( a.scalarfn_i().size() == a.scalarfn_j().size() );

        int numpts = a.scalarfn_numpts();

        res.zero();

        SparseVector<SparseVector<gentype> > xa;

        gentype aa;

        for ( int i = 0 ; i < numpts ; ++i )
        {
            xa("&",a.scalarfn_i()(0))("&",a.scalarfn_j()(0)) = (((double) i)+0.5)/((double) numpts);

            aa = a(xa);

            aa.finalise();

            aa /= ((double) numpts);

            res += aa;
        }

        res.scalarfn_setisscalarfn(0);
    }

    else if ( a.scalarfn_isscalarfn() )
    {
        NiceAssert( a.scalarfn_i().size() == a.scalarfn_j().size() );

        int numvar = a.scalarfn_i().size();
        int numpts = a.scalarfn_numpts();
        int numtot = (int) pow(numpts,numvar);

        Vector<int> k(numvar);

        k = 0;

        res.zero();

        SparseVector<SparseVector<gentype> > xa;

        gentype aa;

        for ( int i = 0 ; i < numtot ; ++i )
        {
            for ( int j = 0 ; j < numvar ; ++j )
            {
                xa("&",a.scalarfn_i()(j))("&",a.scalarfn_j()(j)) = (((double) k(j))+0.5)/((double) numpts);
            }

            aa = a(xa);

            aa.finalise();

            aa /= ((double) numtot);

            res += aa;

            for ( int j = 0 ; j < numvar ; ++j )
            {
                ++(k("&",j));

                if ( k(j) >= numpts )
                {
                    k("&",j) = 0;
                }

                else
                {
                    break;
                }
            }
        }

        res.scalarfn_setisscalarfn(0);
    }

    else if ( a.isValVector() )
    {
        oneProduct(res,a.cast_vector(0));
    }

    else
    {
        res = a;
    }

    return res;
}

const gentype &twoProduct(gentype &res, const gentype &a, const gentype &b)
{
    if ( ( &res == &a ) && ( &res == &b ) )
    {
        gentype aa(a);
        gentype bb(b);

        innerProduct(res,aa,bb);
    }

    else if ( &res == &a )
    {
        gentype aa(a);

        innerProduct(res,aa,b);
    }

    else if ( &res == &b )
    {
        gentype bb(b);

        innerProduct(res,a,bb);
    }

    else if ( a.scalarfn_isscalarfn() && b.scalarfn_isscalarfn() && ( a.scalarfn_i().size() == 0 ) )
    {
        NiceAssert( a.scalarfn_i().size() == a.scalarfn_j().size() );
        NiceAssert( a.scalarfn_i().size() == b.scalarfn_i().size() );
        NiceAssert( a.scalarfn_i().size() == b.scalarfn_j().size() );

        res.zero();
        res.scalarfn_setisscalarfn(0);
    }

    else if ( a.scalarfn_isscalarfn() && b.scalarfn_isscalarfn() && ( a.scalarfn_i().size() == 1 ) )
    {
        NiceAssert( a.scalarfn_i().size() == a.scalarfn_j().size() );
        NiceAssert( a.scalarfn_i().size() == b.scalarfn_i().size() );
        NiceAssert( a.scalarfn_i().size() == b.scalarfn_j().size() );

        int numpts = ( a.scalarfn_numpts() > b.scalarfn_numpts() ) ? a.scalarfn_numpts() : b.scalarfn_numpts();

        res.zero();

        SparseVector<SparseVector<gentype> > xa;
        SparseVector<SparseVector<gentype> > xb;

        gentype aa;
        gentype bb;

        for ( int i = 0 ; i < numpts ; ++i )
        {
            xa("&",a.scalarfn_i()(0))("&",a.scalarfn_j()(0)) = (((double) i)+0.5)/((double) numpts);
            xb("&",b.scalarfn_i()(0))("&",b.scalarfn_j()(0)) = (((double) i)+0.5)/((double) numpts);

            aa = a(xa);
            bb = b(xb);

            aa.finalise();
            bb.finalise();

            aa /= ((double) numpts);
            aa *= bb;

            res += aa;
        }

        res.scalarfn_setisscalarfn(0);
    }

    else if ( a.scalarfn_isscalarfn() && b.scalarfn_isscalarfn() )
    {
        NiceAssert( a.scalarfn_i().size() == a.scalarfn_j().size() );
        NiceAssert( a.scalarfn_i().size() == b.scalarfn_i().size() );
        NiceAssert( a.scalarfn_i().size() == b.scalarfn_j().size() );

        int numvar = a.scalarfn_i().size();
        int numpts = ( a.scalarfn_numpts() > b.scalarfn_numpts() ) ? a.scalarfn_numpts() : b.scalarfn_numpts();
        int numtot = (int) pow(numpts,numvar);

        Vector<int> k(numvar);

        k = 0;

        res.zero();

        SparseVector<SparseVector<gentype> > xa;
        SparseVector<SparseVector<gentype> > xb;

        gentype aa;
        gentype bb;

        for ( int i = 0 ; i < numtot ; ++i )
        {
            for ( int j = 0 ; j < numvar ; ++j )
            {
                xa("&",a.scalarfn_i()(j))("&",a.scalarfn_j()(j)) = (((double) k(j))+0.5)/((double) numpts);
                xb("&",b.scalarfn_i()(j))("&",b.scalarfn_j()(j)) = (((double) k(j))+0.5)/((double) numpts);
            }

            aa = a(xa);
            bb = b(xb);

            aa.finalise();
            bb.finalise();

            aa /= ((double) numtot);
            aa *= bb;

            res += aa;

            for ( int j = 0 ; j < numvar ; ++j )
            {
                ++(k("&",j));

                if ( k(j) >= numpts )
                {
                    k("&",j) = 0;
                }

                else
                {
                    break;
                }
            }
        }

        res.scalarfn_setisscalarfn(0);
    }

    else if ( a.scalarfn_isscalarfn() && b.isValVector() && b.infsize() && ( a.scalarfn_i().size() == 1 ) )
    {
        NiceAssert( a.scalarfn_i().size() == a.scalarfn_j().size() );

        int numpts = a.scalarfn_numpts();
        gentype aa;
        gentype bb;
        const Vector<gentype> &bvec = b.cast_vector(0);
        SparseVector<SparseVector<gentype> > x;

        res.zero();

        for ( int i = 0 ; i < numpts ; ++i )
        {
            x("&",a.scalarfn_i()(0))("&",a.scalarfn_j()(0)) = (((double) i)+0.5)/((double) numpts);

            aa = a(x);
            bb = bvec(x("&",a.scalarfn_i()(0))("&",a.scalarfn_j()(0)));

            aa.finalise();
            bb.finalise();

            aa /= ((double) numpts);
            aa *= bb;

            res += aa;
        }

        res.scalarfn_setisscalarfn(0);
    }

    else if ( b.scalarfn_isscalarfn() && a.isValVector() && a.infsize() && ( b.scalarfn_i().size() == 1 ) )
    {
        NiceAssert( b.scalarfn_i().size() == b.scalarfn_j().size() );

        int numpts = b.scalarfn_numpts();
        gentype aa;
        gentype bb;
        const Vector<gentype> &avec = a.cast_vector(0);
        SparseVector<SparseVector<gentype> > x;

        res.zero();

        for ( int i = 0 ; i < numpts ; ++i )
        {
            x("&",b.scalarfn_i()(0))("&",b.scalarfn_j()(0)) = (((double) i)+0.5)/((double) numpts);

            aa = avec(x("&",b.scalarfn_i()(0))("&",b.scalarfn_j()(0)));
            bb = b(x);

            aa.finalise();
            bb.finalise();

            aa /= ((double) numpts);
            aa *= bb;

            res += aa;
        }

        res.scalarfn_setisscalarfn(0);
    }

    else if ( a.isValVector() && b.scalarfn_isscalarfn() && ( b.scalarfn_i().size() == 1 ) )
    {
        NiceAssert( b.scalarfn_i().size() == b.scalarfn_j().size() );

        int numpts = b.scalarfn_numpts();

        int q;

        res.zero();

        SparseVector<SparseVector<gentype> > xb;

        gentype aa;
        gentype bb;

        for ( int i = 0 ; i < numpts ; ++i )
        {
            q = (int) (((((double) i)+0.5)/((double) numpts))*a.size()); // always rounds toward zero
            xb("&",b.scalarfn_i()(0))("&",b.scalarfn_j()(0)) = (((double) i)+0.5)/((double) numpts);

            aa = a(q);
            bb = b(xb);

            aa.finalise();
            bb.finalise();

            aa /= ((double) numpts);
            aa *= bb;

            res += aa;
        }

        res.scalarfn_setisscalarfn(0);
    }

    else if ( a.scalarfn_isscalarfn() && b.isValVector() && ( a.scalarfn_i().size() == 1 ) )
    {
        NiceAssert( a.scalarfn_i().size() == a.scalarfn_j().size() );

        int numpts = a.scalarfn_numpts();

        int q;

        res.zero();

        SparseVector<SparseVector<gentype> > xa;

        gentype aa;
        gentype bb;

        for ( int i = 0 ; i < numpts ; ++i )
        {
            xa("&",a.scalarfn_i()(0))("&",a.scalarfn_j()(0)) = (((double) i)+0.5)/((double) numpts);
            q = (int) (((((double) i)+0.5)/((double) numpts))*b.size()); // always rounds toward zero

            aa = a(xa);
            bb = b(q);

            aa.finalise();
            bb.finalise();

            aa /= ((double) numpts);
            aa *= bb;

            res += aa;
        }

        res.scalarfn_setisscalarfn(0);
    }

    else if ( a.isValEqnDir() || b.isValEqnDir() )
    {
        res = a;
        res *= b;
    }

    else if ( a.isValNull() || a.isValInteger() || a.isValReal() || a.isValAnion() )
    {
        res = a;
        res *= b;
    }

    else if ( a.isValVector() )
    {
        if ( b.isValVector() )
        {
            twoProduct(res,a.cast_vector(0),b.cast_vector(0));
        }

        else if ( b.isValMatrix() )
        {
            res.force_vector() = a.cast_vector(0);
            res.dir_vector() *= b.cast_matrix(0);
        }

        else
        {
            res.force_vector() = a.cast_vector(0);
            res.dir_vector() *= b;
        }
    }

    else if ( a.isValMatrix() )
    {
        if ( b.isValVector() )
        {
            res.force_vector() = b.cast_vector(0);
            res.dir_vector() *= a.cast_matrix(0);
        }

        else if ( b.isValMatrix() )
        {
            res.force_matrix() = a.cast_matrix(0);
            res.dir_matrix() *= b.cast_matrix(0);
        }

        else
        {
            res.force_matrix() = a.cast_matrix(0);
            res.dir_matrix() *= b;
        }
    }

    else
    {
        if ( b.isValVector() )
        {
            res.force_vector() = b.cast_vector(0);
            res.dir_vector() *= a;
        }

        else if ( b.isValMatrix() )
        {
            res.force_matrix() = b.cast_matrix(0);
            res.dir_matrix() *= a;
        }

        else
        {
            res = a;
            res *= b;
        }
    }

    return res;
}

const gentype &threeProduct(gentype &res, const gentype &a, const gentype &b, const gentype &c)
{
    return oneProduct(res,a*b*c);
}

const gentype &fourProduct(gentype &res, const gentype &a, const gentype &b, const gentype &c, const gentype &d)
{
    return twoProduct(res,a*b,c*d);
}


// Assignment operators

gentype &gentype::fastcopy(const gentype &src, int areDistinct)
{
    // Very important subtlety here: often in the code we have expressions
    // like *this = eqnargs(i) - that is, the current node is overwritten by
    // one of its children.  Therefore we must preserve the contents of the
    // child nodes, vectors etc before assignment occurs.
    //
    // Relevant reversion branch: 23/6/2015

    if ( src.varid_isscalar )
    {
        varid_isscalar = src.varid_isscalar;
        varid_numpts   = src.varid_numpts;

        grabvarid_xi(src.varid_xi);
        grabvarid_xj(src.varid_xj);
    }

    if ( isfasttype() && src.isfasttype() )
    {
        //deleteVectMatMem(); just leave any temporaries lying around, they
        // will be deleted later anyhow and deleting them now wastes time.

        typeis     = src.typeis;
        isNomConst = src.isNomConst;
        intval     = src.intval;
        doubleval  = src.doubleval;
    }

    else if ( areDistinct )
    {
        if ( src.isValAnion() )
        {
            deleteVectMatMem('A');

            *anionval = *src.anionval;
        }

        else if ( src.isValVector() )
        {
            deleteVectMatMem('V',(*(src.vectorval)).size());

            if ( (*(src.vectorval)).infsize() )
            {
                (*(vectorval)) = *(src.vectorval);
            }

            else
            {
                (*vectorval).resize((*(src.vectorval)).size());

                for ( int i = 0 ; i < (*(src.vectorval)).size() ; ++i )
                {
                    (*vectorval)("&",i).fastcopy((*(src.vectorval))(i),areDistinct);
                }
            }
        }

        else if ( src.isValEqnDir() )
        {
            deleteVectMatMem();

            NiceAssert( src.eqnargs );

            MEMNEW(eqnargs,Vector<gentype>((*(src.eqnargs)).size()));

            NiceAssert( eqnargs );

            for ( int i = 0 ; i < (*(src.eqnargs)).size() ; ++i )
            {
                (*eqnargs)("&",i).fastcopy((*(src.eqnargs))(i),areDistinct);
            }
        }

        else if ( src.isValMatrix() )
        {
            deleteVectMatMem('M',(*(src.matrixval)).numRows(),(*(src.matrixval)).numCols());

            //(*(matrixval)).resize((*(src.matrixval)).numRows(),(*(src.matrixval)).numCols());

            for ( int i = 0 ; i < (*(src.matrixval)).numRows() ; ++i )
            {
                for ( int j = 0 ; j < (*(src.matrixval)).numCols() ; ++j )
                {
                    (*matrixval)("&",i,j).fastcopy((*(src.matrixval))(i,j),areDistinct);
                }
            }
        }

        else if ( src.isValSet() )
        {
            deleteVectMatMem('X');

            *setval = *(src.setval);
        }

        else if ( src.isValDict() )
        {
            deleteVectMatMem('D');

            *dictval = *(src.dictval);
        }

        else if ( src.isValDgraph() )
        {
            deleteVectMatMem('G');

            *dgraphval = *(src.dgraphval);
        }

        else if ( src.isValString() )
        {
            deleteVectMatMem('S');

            *stringval = *(src.stringval);
        }

        else if ( src.isValError() )
        {
            deleteVectMatMem('E');

            *stringval = *(src.stringval);
        }

        else
        {
            deleteVectMatMem();
        }

        typeis     = src.typeis;
        intval     = src.intval;
        isNomConst = src.isNomConst;
        doubleval  = src.doubleval;
        fnnameind  = src.fnnameind;
        thisfninfo = src.thisfninfo;
    }

    else
    {
        d_anion                   *anistore = nullptr;
        Vector<gentype>           *vecstore = nullptr;
        Matrix<gentype>           *matstore = nullptr;
        Set<gentype>              *setstore = nullptr;
        Dict<gentype,dictkey>     *dctstore = nullptr;
        Dgraph<gentype,double>    *dgrstore = nullptr;
        Vector<gentype>           *eqnstore = nullptr;
        std::string               *strstore = nullptr;

        int wasValAnion  = src.isValAnion();
        int wasValVector = src.isValVector();
        int wasValMatrix = src.isValMatrix();
        int wasValSet    = src.isValSet();
        int wasValDict   = src.isValDict();
        int wasValDgraph = src.isValDgraph();
        int wasValEqn    = src.isValEqnDir();
        int wasValStrErr = src.isValStrErr();
        int wasValError  = src.isValError();

        if ( wasValAnion  ) { MEMNEW(anistore,d_anion(*(src.anionval)));                 }
        if ( wasValVector ) { MEMNEW(vecstore,Vector<gentype       >(*(src.vectorval))); }
        if ( wasValMatrix ) { MEMNEW(matstore,Matrix<gentype       >(*(src.matrixval))); }
        if ( wasValSet    ) { MEMNEW(setstore,Set<   gentype       >(*(src.setval)));    }
        if ( wasValDict   ) { MEMNEW(dctstore,xDict                 (*(src.dictval)));   }
        if ( wasValDgraph ) { MEMNEW(dgrstore,xDgraph               (*(src.dgraphval))); }
        if ( wasValEqn    ) { MEMNEW(eqnstore,Vector<gentype       >(*(src.eqnargs)));   }
        if ( wasValStrErr ) { MEMNEW(strstore,std::string(*(src.stringval)));            }

        char              srctypeis      = src.typeis;
        int               srcintval      = src.intval;
        double            srcdoubleval   = src.doubleval;
        bool              srcisNomConst  = src.isNomConst;
        int               srcfnnameind   = src.fnnameind;
        const fninfoblock *srcthisfninfo = src.thisfninfo;

        // Only now can we safely delete the contents of *this

        if ( wasValEqn )
        {
            deleteVectMatMem();
        }

        typeis     = srctypeis;
        isNomConst = src.isNomConst;
        intval     = srcintval;
        doubleval  = srcdoubleval;
        isNomConst = srcisNomConst;
        fnnameind  = srcfnnameind;
        thisfninfo = srcthisfninfo;

        if ( wasValAnion  ) { *this = *anistore;     MEMDEL(anistore); }
        if ( wasValVector ) { *this = *vecstore;     MEMDEL(vecstore); }
        if ( wasValMatrix ) { *this = *matstore;     MEMDEL(matstore); }
        if ( wasValSet    ) { *this = *setstore;     MEMDEL(setstore); }
        if ( wasValDict   ) { *this = *dctstore;     MEMDEL(dctstore); }
        if ( wasValDgraph ) { *this = *dgrstore;     MEMDEL(dgrstore); }
        if ( wasValStrErr ) { makeString(*strstore); MEMDEL(strstore); }

        if ( wasValError )
        {
            typeis = 'E';
        }

        if ( wasValEqn )
        {
            MEMNEW(eqnargs,Vector<gentype>);
            NiceAssert( eqnstore );
            *eqnargs = *eqnstore;
            MEMDEL(eqnstore);
        }
    }

    return *this;
}

void gentype::switcheroo(gentype &src)
{
    gentype temp; // will be constructed to zero int, which is really quick
                  // will be deleted on exit like any local variable

    char loc_varid_isscalar = varid_isscalar;
    int  loc_varid_numpts   = varid_numpts;

    Vector<int> *loc_varid_xi = varid_xi;
    Vector<int> *loc_varid_xj = varid_xj;

    if ( src.varid_isscalar )
    {
        loc_varid_isscalar = src.varid_isscalar;
        loc_varid_numpts   = src.varid_numpts;

        loc_varid_xi = src.varid_xi;
        loc_varid_xj = src.varid_xj;
    }

    qswap(src,temp);
    qswap(*this,temp);

    varid_isscalar = loc_varid_isscalar;
    varid_numpts   = loc_varid_numpts;

    grabvarid_xi(loc_varid_xi);
    grabvarid_xj(loc_varid_xj);

    return;
}








// Make equation

int gentype::makeEqn(const std::string &src, int processxyzvw)
{
    deleteVectMatMem();

    // A single character is always interpretted as a string.  This
    // is done to better deal with standard SVM training datasets
    // that by default use single characters to represent categorical
    // data.  We want to read it as such so that we can the apply
    // symbolic multiplication for inner products - that is:
    //
    // "a"*"a" = 1 (the same)
    // "a"*"b" = 0 (different)
    //
    // Exception: the variables x,y,z,v,w,X,Y,Z,V,W are reserved and
    // will not be interpretted as string if !processxyzvw
    //
    // We also treat :, ::, :::, ::::, ~ as strings to emulate sparse
    // vectors

    if ( src.length() == 1 )
    {
        if ( ( src[0] == 'a' ) ||                      ( src[0] == 'o' ) ||
             ( src[0] == 'b' ) || ( src[0] == 'i' ) || ( src[0] == 'p' ) ||
             ( src[0] == 'c' ) || ( src[0] == 'j' ) || ( src[0] == 'q' ) ||
             ( src[0] == 'd' ) || ( src[0] == 'k' ) || ( src[0] == 'r' ) ||
             ( src[0] == 'e' ) || ( src[0] == 'l' ) || ( src[0] == 's' ) ||
             ( src[0] == 'f' ) || ( src[0] == 'm' ) || ( src[0] == 't' ) ||
                                  ( src[0] == 'n' )                      ||
             ( src[0] == 'A' ) ||                      ( src[0] == 'O' ) ||
             ( src[0] == 'B' ) || ( src[0] == 'I' ) || ( src[0] == 'P' ) ||
             ( src[0] == 'C' ) || ( src[0] == 'J' ) || ( src[0] == 'Q' ) ||
             ( src[0] == 'D' ) || ( src[0] == 'K' ) || ( src[0] == 'R' ) ||
             ( src[0] == 'E' ) || ( src[0] == 'L' ) || ( src[0] == 'S' ) ||
             ( src[0] == 'F' ) || ( src[0] == 'M' ) || ( src[0] == 'T' ) ||
                                  ( src[0] == 'N' )                      ||
             ( src[0] == ':' ) || ( src[0] == '~' )                      ||
             ( !processxyzvw && ( ( src[0] == 'g' ) || ( src[0] == 'G' ) ||
                                  ( src[0] == 'h' ) || ( src[0] == 'H' ) ||
                                  ( src[0] == 'u' ) || ( src[0] == 'U' ) ||
                                  ( src[0] == 'v' ) || ( src[0] == 'V' ) ||
                                  ( src[0] == 'w' ) || ( src[0] == 'W' ) ||
                                  ( src[0] == 'x' ) || ( src[0] == 'X' ) ||
                                  ( src[0] == 'y' ) || ( src[0] == 'Y' ) ||
                                  ( src[0] == 'z' ) || ( src[0] == 'Z' )    ) ) )
        {
            makeString(src);

            return 0;
        }
    }

    else if ( src.length() == 1 )
    {
        if ( ( src[0] == ':' ) || ( src[0] == '~' ) )
        {
            makeString(src);

            return 0;
        }
    }

    else if ( src.length() == 2 )
    {
        if ( ( src[0] == ':' ) && ( src[1] == ':' ) )
        {
            makeString(src);

            return 0;
        }
    }

    else if ( src.length() == 3 )
    {
        if ( ( src[0] == ':' ) && ( src[1] == ':' ) && ( src[2] == ':' ) )
        {
            makeString(src);

            return 0;
        }
    }

    else if ( src.length() == 4 )
    {
        if ( ( src[0] == ':' ) && ( src[1] == ':' ) && ( src[2] == ':' ) && ( src[3] == ':' ) )
        {
            makeString(src);

            return 0;
        }
    }

    int res;
    std::string srca;
    std::string srcb;

    // Make string "nice" by fixing +s and -s so that + is a binary operator
    // and - unary

    if ( ( res = makeMathsStringNice(srca,src) ) )
    {
	makeError("Syntax error: ill-formed equation/number.");

        return res;
    }

    // Parse equation to convert operators to purely functional form

    if ( ( res = mathsparse(srcb,srca) ) )
    {
	makeError("Syntax error: unable to parse equation.");

        return res;
    }

    // Construct the equation.

    if ( ( res = makeEqnInternal(srcb) ) )
    {
        return res;
    }

    // Simplify the equation as much as possible.

    evaluate();

    return 0;
}

int gentype::makeEqn(const char *src, int processxyzvw)
{
    std::string srcx(src);

    return makeEqn(srcx,processxyzvw);
}

























// Casting operators

gentype &gentype::toNull(gentype &res) const
{
    if ( !(res.isValNull()) )
    {
        res.deleteVectMatMem('N');
        res.typeis = 'N';
    }

    std::string errstr;

    if ( loctoNull(errstr) )
    {
        res.makeError(errstr);
    }

    return res;
}

gentype &gentype::toInteger(gentype &res) const
{
    if ( !(res.isValInteger()) )
    {
        res.deleteVectMatMem('Z');
        res.typeis = 'Z';
        res.intval = 0;
    }

    std::string errstr;

    if ( loctoInteger(res.intval,errstr) )
    {
        res.makeError(errstr);
    }

    res.doubleval  = res.intval;
    res.isNomConst = isNomConst;

    return res;
}

gentype &gentype::toReal(gentype &res)    const
{
    if ( !(res.isValReal()) )
    {
        res.deleteVectMatMem('R');
        res.typeis = 'R';
        res.intval = 0;
    }

    std::string errstr;

    if ( loctoReal(res.doubleval,errstr) )
    {
        res.makeError(errstr);
    }

    res.intval     = (int) res.doubleval;
    res.isNomConst = isNomConst;

    return res;
}

gentype &gentype::toAnion(gentype &res)   const
{
    if ( !(res.isValAnion()) )
    {
        res.deleteVectMatMem('A');
        *(res.anionval) = 0.0;
    }

    std::string errstr;

    if ( loctoAnion(*(res.anionval),errstr) )
    {
        res.makeError(errstr);
    }

    return res;
}

gentype &gentype::toVector(gentype &res)  const
{
    if ( !(res.isValVector()) )
    {
        res.deleteVectMatMem('V');
    }

    std::string errstr;

    if ( loctoVector(*(res.vectorval),errstr) )
    {
        res.makeError(errstr);
    }

    return res;
}

gentype &gentype::toMatrix(gentype &res)  const
{
    if ( !(res.isValMatrix()) )
    {
        res.deleteVectMatMem('M');
    }

    std::string errstr;

    if ( loctoMatrix(*(res.matrixval),errstr) )
    {
        res.makeError(errstr);
    }

    return res;
}

gentype &gentype::toSet(gentype &res)  const
{
    if ( !(res.isValSet()) )
    {
        res.deleteVectMatMem('X');
        (*(res.setval)).zero();
    }

    std::string errstr;

    if ( loctoSet(*(res.setval),errstr) )
    {
        res.makeError(errstr);
    }

    return res;
}

gentype &gentype::toDict(gentype &res)  const
{
    if ( !(res.isValDict()) )
    {
        res.deleteVectMatMem('D');
        (*(res.dictval)).zero();
    }

    std::string errstr;

    if ( loctoDict(*(res.dictval),errstr) )
    {
        res.makeError(errstr);
    }

    return res;
}

gentype &gentype::toDgraph(gentype &res)  const
{
    if ( !(res.isValDgraph()) )
    {
        res.deleteVectMatMem('G');
        (*(res.dgraphval)).zero();
    }

    std::string errstr;

    if ( loctoDgraph(*(res.dgraphval),errstr) )
    {
        res.makeError(errstr);
    }

    return res;
}

gentype &gentype::toString(gentype &res)  const
{
    if ( !(res.isValString()) )
    {
        res.deleteVectMatMem('S');
        *(res.stringval) = "";
    }

    std::string errstr;

    if ( loctoString(*(res.stringval),errstr) )
    {
        res.makeError(errstr);
    }

    return res;
}

void gentype::cast_null(int finalise) const
{
    if ( !isValNull() )
    {
        std::string errstr;

        if ( finalise && isValEqn() )
        {
            gentype temp(*this);
            SparseVector<SparseVector<gentype> > tempargs;

            // This will throw if finalisation doesn't result in a null
            temp.fastevaluate(tempargs,finalise);
            temp.cast_null(0);
        }

        else if ( loctoNull(errstr) )
        {
            NiceThrow(errstr);
        }

        isNomConst = false;
    }

    return;
}

int gentype::cast_int(int finalise) const
{
    if ( !isValInteger() )
    {
        bool locisNomConst = isNomConst;

        std::string errstr;

        if ( finalise && isValEqn() )
        {
            gentype temp(*this);
            SparseVector<SparseVector<gentype> > tempargs;

            temp.fastevaluate(tempargs,finalise);
            intval = temp.cast_int(0);
        }

        else if ( loctoInteger(intval,errstr) )
        {
            NiceThrow(errstr);
        }

        isNomConst = locisNomConst;
    }

    return intval;
}

double gentype::cast_double(int finalise) const
{
    if ( !isValReal() )
    {
        bool locisNomConst = isNomConst;

        std::string errstr;

        if ( finalise && isValEqn() )
        {
            gentype temp(*this);
            SparseVector<SparseVector<gentype> > tempargs;

            temp.fastevaluate(tempargs,finalise);
            doubleval = temp.cast_double(0);
        }

        else if ( loctoReal(doubleval,errstr) )
        {
            // If this is set then doubleval is a also set nan, so we'll go with that
            //NiceThrow(errstr);
            ;
        }

        isNomConst = locisNomConst;
    }

    return doubleval;
}

const d_anion &gentype::cast_anion(int finalise) const
{
    if ( !isValAnion() )
    {
        isNomConst = false;

        std::string errstr;

        if ( anionval == nullptr )
        {
            MEMNEW(anionval,d_anion);
        }

        if ( finalise && isValEqn() )
        {
            gentype temp(*this);
            SparseVector<SparseVector<gentype> > tempargs;

            temp.fastevaluate(tempargs,finalise);
            *anionval = temp.cast_anion(0);
        }

        else if ( loctoAnion(*anionval,errstr) )
        {
            // If this is set then anionval is a also set nan, so we'll go with that
            //NiceThrow(errstr);
            ;
        }
    }

    return *anionval;
}

const Vector<gentype> &gentype::cast_vector(int finalise) const
{
    if ( !isValVector() )
    {
        isNomConst = false;

        std::string errstr;

        if ( vectorval == nullptr )
        {
            MEMNEW(vectorval,Vector<gentype>);
        }

        if ( finalise && isValEqn() )
        {
            gentype temp(*this);
            SparseVector<SparseVector<gentype> > tempargs;

            temp.fastevaluate(tempargs,finalise);
            *vectorval = temp.cast_vector(0);
        }

        else if ( loctoVector(*vectorval,errstr) )
        {
            // If this is set then vectorval is a vector containing *this, so we'll go with that
            //NiceThrow(errstr);
            ;
        }
    }

    return *vectorval;
}

const Vector<double> &gentype::cast_vector_real(int finalise) const
{
    cast_vector(finalise); // this can't fail by design

    int vsize = (*vectorval).size();

    if ( vectorvalreal == nullptr )
    {
        MEMNEW(vectorvalreal,Vector<double>(vsize));
    }

    else
    {
        (*vectorvalreal).resize(vsize);
    }

    if ( vsize )
    {
        Vector<gentype> &vg = *vectorval;
        Vector<double>  &vr = *vectorvalreal;

        int i;

        for ( i = 0 ; i < vsize ; ++i )
        {
            vr("&",i) = (double) vg(i);
        }
    }

    return *vectorvalreal;
}

const Vector<int> &gentype::cast_vector_int(int finalise) const
{
    cast_vector(finalise); // this can't fail by design

    int vsize = (*vectorval).size();

    if ( vectorvalint == nullptr )
    {
        MEMNEW(vectorvalint,Vector<int>(vsize));
    }

    else
    {
        (*vectorvalint).resize(vsize);
    }

    if ( vsize )
    {
        Vector<gentype> &vg = *vectorval;
        Vector<int>     &vi = *vectorvalint;

        int i;

        for ( i = 0 ; i < vsize ; ++i )
        {
            vi("&",i) = (int) ((double) vg(i)); // *first* cast to double to avoid throw, *then* cast to int
        }
    }

    return *vectorvalint;
}

const SparseVector<gentype> &gentype::cast_sparsevector(int finalise) const
{
    cast_vector(finalise); // this can't fail by design

    int vsize = (*vectorval).size();

    if ( sparsevectorval == nullptr )
    {
        MEMNEW(sparsevectorval,SparseVector<gentype>);
    }

    (*sparsevectorval).zero();

    if ( vsize )
    {
        Vector<gentype>       &vg = *vectorval;
        SparseVector<gentype> &vr = *sparsevectorval;

        int fnum = 0;
        int unum = 0;
        int iv = 0;

        for ( int i = 0 ; i < vsize ; ++i )
        {
            bool issep = false;

            if ( vg(i).isValString() )
            {
                     if ( ((const std::string &) vg(i)) == "~"    ) { unum++;             iv = 0; issep = true; }
                else if ( ((const std::string &) vg(i)) == "::::" ) { unum = 0; fnum = 4; iv = 0; issep = true; }
                else if ( ((const std::string &) vg(i)) == ":::"  ) { unum = 0; fnum = 3; iv = 0; issep = true; }
                else if ( ((const std::string &) vg(i)) == "::"   ) { unum = 0; fnum = 2; iv = 0; issep = true; }
                else if ( ((const std::string &) vg(i)) == ":"    ) { unum = 0; fnum = 1; iv = 0; issep = true; }
            }

            if ( !issep )
            {
                if ( vg(i).isValNull() ) { ; } // null means "there is no element here"
                else if ( fnum == 0 ) { vr.n ("&",iv,unum) = vg(i); }
                else if ( fnum == 1 ) { vr.f1("&",iv,unum) = vg(i); }
                else if ( fnum == 2 ) { vr.f2("&",iv,unum) = vg(i); }
                else if ( fnum == 3 ) { vr.f3("&",iv,unum) = vg(i); }
                else if ( fnum == 4 ) { vr.f4("&",iv,unum) = vg(i); }

                iv++;
            }
        }
    }

    return *sparsevectorval;
}

const SparseVector<double> &gentype::cast_sparsevector_real(int finalise) const
{
    cast_vector(finalise); // this can't fail by design

    int vsize = (*vectorval).size();

    if ( sparsevectorvalreal == nullptr )
    {
        MEMNEW(sparsevectorvalreal,SparseVector<double>);
    }

    (*sparsevectorvalreal).zero(); // empty vector

    if ( vsize )
    {
        Vector<gentype>      &vg = *vectorval;
        SparseVector<double> &vr = *sparsevectorvalreal;

        int fnum = 0;
        int unum = 0;
        int iv = 0;

        for ( int i = 0 ; i < vsize ; ++i )
        {
            bool issep = false;

            if ( vg(i).isValString() )
            {
                     if ( ((const std::string &) vg(i)) == "~"    ) { unum++;             iv = 0; issep = true; }
                else if ( ((const std::string &) vg(i)) == "::::" ) { unum = 0; fnum = 4; iv = 0; issep = true; }
                else if ( ((const std::string &) vg(i)) == ":::"  ) { unum = 0; fnum = 3; iv = 0; issep = true; }
                else if ( ((const std::string &) vg(i)) == "::"   ) { unum = 0; fnum = 2; iv = 0; issep = true; }
                else if ( ((const std::string &) vg(i)) == ":"    ) { unum = 0; fnum = 1; iv = 0; issep = true; }
            }

            if ( !issep )
            {
                if ( vg(i).isValNull() ) { ; } // null means "there is no element here"
                else if ( fnum == 0 ) { vr.n ("&",iv,unum) = (double) vg(i); }
                else if ( fnum == 1 ) { vr.f1("&",iv,unum) = (double) vg(i); }
                else if ( fnum == 2 ) { vr.f2("&",iv,unum) = (double) vg(i); }
                else if ( fnum == 3 ) { vr.f3("&",iv,unum) = (double) vg(i); }
                else if ( fnum == 4 ) { vr.f4("&",iv,unum) = (double) vg(i); }

                iv++;
            }
        }
    }

    return *sparsevectorvalreal;
}

const Matrix<gentype> &gentype::cast_matrix(int finalise) const
{
    if ( !isValMatrix() )
    {
        isNomConst = false;

        if ( matrixval == nullptr )
        {
            MEMNEW(matrixval,Matrix<gentype>);
        }

        std::string errstr;

        if ( finalise && isValEqn() )
        {
            gentype temp(*this);
            SparseVector<SparseVector<gentype> > tempargs;

            temp.fastevaluate(tempargs,finalise);
            *matrixval = temp.cast_matrix(0);
        }

        else if ( loctoMatrix(*matrixval,errstr) )
        {
            // If this is set then matrixval is a matrix containing *this, so we'll go with that
            //NiceThrow(errstr);
            ;
        }
    }

    return *matrixval;
}

const Matrix<double> &gentype::cast_matrix_real(int finalise) const
{
    cast_matrix(finalise);

    int vrows = (*matrixval).numRows();
    int vcols = (*matrixval).numCols();

    if ( matrixvalreal == nullptr )
    {
        MEMNEW(matrixvalreal,Matrix<double>(vrows,vcols));
    }

    else
    {
        (*matrixvalreal).resize(vrows,vcols);
    }

    if ( vrows && vcols )
    {
        Matrix<gentype> &vg = *matrixval;
        Matrix<double>  &vr = *matrixvalreal;

        int i,j;

        for ( i = 0 ; i < vrows ; ++i )
        {
            for ( j = 0 ; j < vcols ; ++j )
            {
                vr("&",i,j) = (double) vg(i,j);
            }
        }
    }

    return *matrixvalreal;
}

const Set<gentype> &gentype::cast_set(int finalise) const
{
    if ( !isValSet() )
    {
        isNomConst = false;

        if ( setval == nullptr )
        {
            MEMNEW(setval,Set<gentype>);
        }

        std::string errstr;

        if ( finalise && isValEqn() )
        {
            gentype temp(*this);
            SparseVector<SparseVector<gentype> > tempargs;

            temp.fastevaluate(tempargs,finalise);
            *setval = temp.cast_set(0);
        }

        else if ( loctoSet(*setval,errstr) )
        {
            // If this is set then setval is a set containing *this, so we'll go with that
            //NiceThrow(errstr);
            ;
        }
    }

    return *setval;
}

const Dict<gentype,dictkey> &gentype::cast_dict(int finalise) const
{
    if ( !isValDict() )
    {
        isNomConst = false;

        if ( dictval == nullptr )
        {
            MEMNEW(dictval,xDict);
        }

        std::string errstr;

        if ( finalise && isValEqn() )
        {
            gentype temp(*this);
            SparseVector<SparseVector<gentype> > tempargs;

            temp.fastevaluate(tempargs,finalise);
            *dictval = temp.cast_dict(0);
        }

        else if ( loctoDict(*dictval,errstr) )
        {
            // If this is set then setval is a set containing *this, so we'll go with that
            //NiceThrow(errstr);
            ;
        }
    }

    return *dictval;
}

const Dgraph<gentype,double> &gentype::cast_dgraph(int finalise) const
{
    if ( !isValDgraph() )
    {
        isNomConst = false;

        if ( dgraphval == nullptr )
        {
            MEMNEW(dgraphval,xDgraph);
        }

        std::string errstr;

        if ( finalise && isValEqn() )
        {
            gentype temp(*this);
            SparseVector<SparseVector<gentype> > tempargs;

            temp.fastevaluate(tempargs,finalise);
            *dgraphval = temp.cast_dgraph(0);
        }

        else if ( loctoDgraph(*dgraphval,errstr) )
        {
            NiceThrow(errstr);
        }
    }

    return *dgraphval;
}

const std::string  &gentype::cast_string(int finalise) const
{
    if ( !isValString() )
    {
        isNomConst = false;

        if ( finalise && isValEqn() )
        {
            gentype temp(*this);
            SparseVector<SparseVector<gentype> > tempargs;

            temp.fastevaluate(tempargs,finalise);

            if ( stringval == nullptr )
            {
                MEMNEW(stringval,std::string);
            }

            *stringval = temp.cast_string(0);
        }

        else
        {
            if ( stringval == nullptr )
            {
                MEMNEW(stringval,std::string);
            }

            std::string errstr;

            if ( loctoString(*stringval,errstr) )
            {
                NiceThrow(errstr);
            }
        }
    }

    return *stringval;
}

gentype &gentype::morph_null(void)
{
    if ( !isValNull() )
    {
        isNomConst = false;

        std::string errstr;

        if ( loctoNull(errstr) )
        {
            makeError(errstr);

            return *this;
        }
    }

    typeis = 'N';

    return *this;
}

gentype &gentype::morph_int(void)
{
    if ( !isValInteger() )
    {
        bool locisNomConst = isNomConst;

        std::string errstr;

        if ( loctoInteger(intval,errstr) )
        {
            makeError(errstr);

            return *this;
        }

        isNomConst = locisNomConst;
    }

    typeis = 'Z';

    return *this;
}

gentype &gentype::morph_double(void)
{
    if ( !isValReal() )
    {
        bool locisNomConst = isNomConst;

        std::string errstr;

        if ( loctoReal(doubleval,errstr) )
        {
            makeError(errstr);

            return *this;
        }

        isNomConst = locisNomConst;
    }

    typeis = 'R';

    return *this;
}

gentype &gentype::morph_anion(void)
{
    if ( !isValAnion() )
    {
        isNomConst = false;

        if ( anionval == nullptr )
        {
            MEMNEW(anionval,d_anion);
        }

        std::string errstr;

        if ( loctoAnion(*anionval,errstr) )
        {
            makeError(errstr);

            return *this;
        }
    }

    typeis = 'A';

    return *this;
}

gentype &gentype::morph_vector(void)
{
    if ( !isValVector() )
    {
        isNomConst = false;

        if ( vectorval == nullptr )
        {
            MEMNEW(vectorval,Vector<gentype>);
        }

        std::string errstr;

        if ( loctoVector(*vectorval,errstr) )
        {
            makeError(errstr);

            return *this;
        }
    }

    typeis = 'V';

    return *this;
}

gentype &gentype::morph_matrix(void)
{
    if ( !isValMatrix() )
    {
        isNomConst = false;

        if ( matrixval == nullptr )
        {
            MEMNEW(matrixval,Matrix<gentype>);
        }

        std::string errstr;

        if ( loctoMatrix(*matrixval,errstr) )
        {
            makeError(errstr);

            return *this;
        }
    }

    typeis = 'M';

    return *this;
}

gentype &gentype::morph_set(void)
{
    if ( !isValSet() )
    {
        isNomConst = false;

        if ( setval == nullptr )
        {
            MEMNEW(setval,Set<gentype>);
        }

        std::string errstr;

        if ( loctoSet(*setval,errstr) )
        {
            makeError(errstr);

            return *this;
        }
    }

    typeis = 'X';

    return *this;
}

gentype &gentype::morph_dict(void)
{
    if ( !isValDict() )
    {
        isNomConst = false;

        if ( dictval == nullptr )
        {
            MEMNEW(dictval,xDict);
        }

        std::string errstr;

        if ( loctoDict(*dictval,errstr) )
        {
            makeError(errstr);

            return *this;
        }
    }

    typeis = 'D';

    return *this;
}

gentype &gentype::morph_dgraph(void)
{
    if ( !isValDgraph() )
    {
        isNomConst = false;

        if ( dgraphval == nullptr )
        {
            MEMNEW(dgraphval,xDgraph);
        }

        std::string errstr;

        if ( loctoDgraph(*dgraphval,errstr) )
        {
            makeError(errstr);

            return *this;
        }
    }

    typeis = 'G';

    return *this;
}

gentype &gentype::morph_string(void)
{
    if ( !isValString() )
    {
        isNomConst = false;

        if ( stringval == nullptr )
        {
            MEMNEW(stringval,std::string);
        }

        std::string errstr;

        if ( loctoString(*stringval,errstr) )
        {
            makeError(errstr);

            return *this;
        }
    }

    typeis = 'S';

    return *this;
}

int gentype::loctoNull(std::string &errstr) const
{
    // Very important: don't overwrite res straight away, as it may actually
    // be a reference to ...val.

    int lociserr = 0;
    errstr = "";

    if ( !isValError() )
    {
        if ( isValNull() )
        {
            ;
        }

        else if ( isValInteger() )
	{
            errstr = "Can't cast integer to null.";
	    lociserr = 1;
	}

	else if ( isValReal() )
	{
            errstr = "Can't cast real to null.";
	    lociserr = 1;
	}

	else if ( isValAnion() )
	{
            errstr = "Can't cast anion to null.";
	    lociserr = 1;
	}

	else if ( isValVector() )
	{
            errstr = "Can't cast vector to null.";
	    lociserr = 1;
	}

	else if ( isValMatrix() )
	{
            errstr = "Can't cast matrix to null.";
	    lociserr = 1;
	}

        else if ( isValSet() )
	{
            errstr = "Can't cast set to null.";
	    lociserr = 1;
	}

        else if ( isValDict() )
	{
            errstr = "Can't cast dictionary to null.";
	    lociserr = 1;
	}

        else if ( isValDgraph() )
	{
            errstr = "Can't cast dgraph to null.";
	    lociserr = 1;
	}

	else if ( isValString() )
	{
            errstr = "Can't cast string to null.";
	    lociserr = 1;
	}

	else if ( isValEqn() )
	{
            errstr = "Can't cast equation to null.";
	    lociserr = 1;
	}
    }

    else
    {
        NiceAssert( stringval );

        errstr = *stringval;
	errstr += "\n";
        errstr += "Can't cast error to null.";

        lociserr = 1;
    }

    return lociserr;
}

int gentype::loctoInteger(int &res, std::string &errstr) const
{
    // Very important: don't overwrite res straight away, as it may actually
    // be a reference to ...val.

    int lociserr = 0;
    double rpart = 0;
    errstr = "";

    if ( !isValError() )
    {
        if ( isValNull() )
	{
            res = 0;
	}

        else if ( isValInteger() )
	{
            res = intval;
	}

	else if ( isValReal() )
	{
            rpart = doubleval;

	    res = (int) rpart;

            if ( ( (((double) res)-rpart) > 2 ) || ( (((double) res)-rpart) < -2 ) )
            {
		errstr = "Integer overflow in cast to integer.";
                lociserr = 1;
            }
	}

	else if ( isValAnion() )
	{
            if ( (*anionval).isreal() )
	    {
                //res = (int) (*anionval).realpart();
                rpart = (*anionval).realpart();

                res = (int) rpart;

                if ( ( (((double) res)-rpart) > 2 ) || ( (((double) res)-rpart) < -2 ) )
                {
                    errstr = "Integer overflow in cast to integer.";
                    lociserr = 1;
                }
	    }

	    else
	    {
		errstr = "Can't cast imaginary number to integer.";
                lociserr = 1;
	    }
	}

	else if ( isValVector() )
	{
            if ( (*vectorval).size() == 1 )
	    {
                res = (*vectorval)(0).cast_int(0);
	    }

	    else
	    {
                errstr = "Can't cast vector to int.";
                lociserr = 1;
	    }
	}

	else if ( isValMatrix() )
	{
            if ( ( (*matrixval).numRows() == 1 ) && ( (*matrixval).numCols() == 1 ) )
	    {
                res = (*matrixval)(0,0).cast_int(0);
	    }

	    else
	    {
                errstr = "Can't cast matrix to int.";
                lociserr = 1;
            }
	}

        else if ( isValSet() )
	{
            errstr = "Can't cast set to integer.";
	    lociserr = 1;
	}

        else if ( isValDict() )
	{
            errstr = "Can't cast dictionary to integer.";
	    lociserr = 1;
	}

        else if ( isValDgraph() )
	{
            errstr = "Can't cast dgraph to integer.";
	    lociserr = 1;
	}

	else if ( isValString() )
	{
	    errstr = "Can't cast string to integer.";
	    lociserr = 1;
	}

	else if ( isValEqn() )
	{
	    errstr = "Can't cast equation to integer.";
	    lociserr = 1;
	}
    }

    else
    {
        NiceAssert( stringval );

        errstr = *stringval;
	errstr += "\n";
        errstr += "Can't cast error to integer.";

        lociserr = 1;
    }

    if ( lociserr )
    {
        res = 0;
    }

    return lociserr;
}

int gentype::loctoReal(double &res, std::string &errstr) const
{
    // Very important: don't overwrite res straight away, as it may actually
    // be a reference to ...val.

    int lociserr = 0;
    errstr = "";

    if ( !isValError() )
    {
        if ( isValNull() )
	{
            res = 0.0;
	}

        else if ( isValInteger() )
	{
	    res = (double) intval;
	}

	else if ( isValReal() )
	{
            res = doubleval;
	}

	else if ( isValAnion() )
	{
            if ( (*anionval).isreal() )
	    {
                res = (*anionval).realpart();
	    }

	    else
	    {
		errstr = "Can't cast imaginary number to real.";
                lociserr = 1;
	    }
	}

	else if ( isValVector() )
	{
            if ( (*vectorval).size() == 1 )
	    {
                res = (*vectorval)(0).cast_double(0);
	    }

	    else
	    {
                errstr = "Can't cast vector to real.";
                lociserr = 1;
	    }
	}

	else if ( isValMatrix() )
	{
            if ( ( (*matrixval).numRows() == 1 ) && ( (*matrixval).numCols() == 1 ) )
	    {
                res = (*matrixval)(0,0).cast_double(0);
	    }

	    else
	    {
                errstr = "Can't cast matrix to real.";
                lociserr = 1;
            }
	}

        else if ( isValSet() )
	{
            errstr = "Can't cast set to real.";
	    lociserr = 1;
	}

        else if ( isValDict() )
	{
            errstr = "Can't cast dictionary to real.";
	    lociserr = 1;
	}

        else if ( isValDgraph() )
	{
            errstr = "Can't cast dgraph to real.";
	    lociserr = 1;
	}

	else if ( isValString() )
	{
	    errstr = "Can't cast string to real.";
	    lociserr = 1;
	}

	else if ( isValEqn() )
	{
	    errstr = "Can't cast equation to real.";
	    lociserr = 1;
	}
    }

    else
    {
        NiceAssert( stringval );

        errstr = *stringval;
        errstr += "\n";
        errstr += "Can't cast error to integer.";

        lociserr = 1;
    }

    if ( lociserr )
    {
        //res = 0.0;

        res = valvnan(errstr.c_str());
    }

    return lociserr;
}

int gentype::loctoAnion(d_anion &res, std::string &errstr) const
{
    // Very important: don't overwrite res straight away, as it may actually
    // be a reference to ...val.

    int lociserr = 0;
    errstr = "";

    if ( !isValError() )
    {
        if ( isValNull() )
	{
            res = 0.0;
	}

        else if ( isValInteger() )
	{
            res = (double) intval;
	}

	else if ( isValReal() )
	{
            res = doubleval;
	}

	else if ( isValAnion() )
	{
            // Overwriting a with a would not be sensible

            if ( &res != anionval )
            {
                res = *anionval;
            }
	}

	else if ( isValVector() )
	{
            if ( (*vectorval).size() == 1 )
	    {
                res = (*vectorval)(0).cast_anion(0);
	    }

	    else
	    {
                errstr = "Can't cast vector to anion.";
                lociserr = 1;
	    }
	}

	else if ( isValMatrix() )
	{
            if ( ( (*matrixval).numRows() == 1 ) && ( (*matrixval).numCols() == 1 ) )
	    {
                res = (*matrixval)(0,0).cast_anion(0);
	    }

	    else
	    {
                errstr = "Can't cast matrix to anion.";
                lociserr = 1;
            }
	}

        else if ( isValSet() )
	{
            errstr = "Can't cast set to anion.";
	    lociserr = 1;
	}

        else if ( isValDict() )
	{
            errstr = "Can't cast dictionary to anion.";
	    lociserr = 1;
	}

        else if ( isValDgraph() )
	{
            errstr = "Can't cast dgraph to anion.";
	    lociserr = 1;
	}

	else if ( isValString() )
	{
	    errstr = "Can't cast string to anion.";
	    lociserr = 1;
	}

	else if ( isValEqn() )
	{
	    errstr = "Can't cast equation to anion.";
	    lociserr = 1;
	}
    }

    else
    {
        NiceAssert( stringval );

        errstr = *stringval;
	errstr += "\n";
        errstr += "Can't cast error to integer.";

        lociserr = 1;
    }

    if ( lociserr )
    {
//        res = 0.0;

        res = valvnan(errstr.c_str());
    }

    return lociserr;
}

int gentype::loctoVector(Vector<gentype> &res, std::string &errstr) const
{
    // Very important: don't overwrite res straight away, as it may actually
    // be a reference to ...val.

    int lociserr = 0;
    errstr = "";

    if ( !isValError() )
    {
        if ( isValNull() )
	{
            res.resize(0);
	}

        else if ( isValInteger() || isValReal() || isValAnion() )
	{
	    res.resize(1);

	    res("&",0) = *this;
	}

	else if ( isValVector() )
	{
            // Overwriting a with a would not be sensible

            if ( &res != vectorval )
            {
                res = (*vectorval);
            }
	}

	else if ( isValMatrix() )
	{
            retVector<gentype> tmpva;
            retVector<gentype> tmpvb;

	    if ( !(*matrixval).numRows() || !(*matrixval).numCols() )
            {
                res.resize(0);
            }

	    else if ( (*matrixval).numRows() == 1 )
	    {
		res = (*matrixval)(0,tmpva,tmpvb);
	    }

	    else if ( (*matrixval).numCols() == 1 )
	    {
		res.resize((*matrixval).numRows());

                for ( int i = 0 ; i < (*matrixval).numRows() ; ++i )
		{
                    res("&",i) = (*matrixval)(i,0);
		}
	    }

	    else
	    {
                // column vector where the rows in the matrix are the elements

		res.resize((*matrixval).numRows());

                for ( int i = 0 ; i < (*matrixval).numRows() ; ++i )
		{
                    res("&",i) = (*matrixval)(i,tmpva,tmpvb);
		}
	    }
	}

        else if ( isValSet() )
	{
            errstr = "Can't cast set to vector.";
	    lociserr = 1;
	}

        else if ( isValDict() )
	{
            errstr = "Can't cast dictionary to vector.";
	    lociserr = 1;
	}

        else if ( isValDgraph() )
	{
            errstr = "Can't cast dgraph to vector.";
	    lociserr = 1;
	}

	else if ( isValString() )
	{
	    errstr = "Can't cast string to vector.";
	    lociserr = 1;
	}

	else if ( isValEqn() )
	{
	    errstr = "Can't cast equation to vector.";
	    lociserr = 1;
	}
    }

    else
    {
        NiceAssert( stringval );

        errstr = *stringval;
	errstr += "\n";
        errstr += "Can't cast error to integer.";

        lociserr = 1;
    }

    if ( lociserr )
    {
        //res.resize(0);

        res.resize(1);
        res("&",0) = *this;
    }

    return lociserr;
}

int gentype::loctoMatrix(Matrix<gentype> &res, std::string &errstr) const
{
    // Very important: don't overwrite res straight away, as it may actually
    // be a reference to ...val.

    int lociserr = 0;
    res.resize(0,0);

    errstr = "";

    if ( !isValError() )
    {
        if ( isValNull() )
        {
            res.resize(0,0);
        }

        else if ( isValInteger() || isValReal() || isValAnion() )
	{
	    res.resize(1,1);

	    res("&",0,0) = *this;
	}

	else if ( isValVector() )
	{
	    res.resize((*vectorval).size(),1);

	    int dessize = (*vectorval).size();

	    for ( int i = 0 ; i < dessize ; ++i )
	    {
                res("&",i,0) = (*vectorval)(i);
	    }
	}

	else if ( isValMatrix() )
	{
            // Overwriting a with a would not be sensible

            if ( &res != matrixval )
            {
                res = (*matrixval);
            }
	}

        else if ( isValSet() )
	{
            errstr = "Can't cast set to matrix.";
	    lociserr = 1;
	}

        else if ( isValDict() )
	{
            errstr = "Can't cast dictionary to matrix.";
	    lociserr = 1;
	}

        else if ( isValDgraph() )
	{
            errstr = "Can't cast dgraph to matrix.";
	    lociserr = 1;
	}

	else if ( isValString() )
	{
	    errstr = "Can't cast string to matrix.";
	    lociserr = 1;
	}

	else if ( isValEqn() )
	{
	    errstr = "Can't cast equation to matrix.";
	    lociserr = 1;
	}
    }

    else
    {
        NiceAssert( stringval );

        errstr = *stringval;
	errstr += "\n";
	errstr += "Can't cast error to matrix.";

        lociserr = 1;
    }

    if ( lociserr )
    {
//        res.resize(0,0);

        res.resize(1,1);
        res("&",0,0) = *this;
    }

    return lociserr;
}

int gentype::loctoSet(Set<gentype> &res, std::string &errstr) const
{
    // Very important: don't overwrite res straight away, as it may actually
    // be a reference to ...val.

    int lociserr = 0;
    errstr = "";

    if ( !isValError() )
    {
        if ( isValNull() )
	{
            res.zero();
	}

        else if ( isValSet() )
	{
            // Overwriting a with a would not be sensible

            if ( &res != setval )
            {
                res = *setval;
            }
	}

        else
        {
            res.zero();
            res.add(*this);
	}
    }

    else
    {
        NiceAssert( stringval );

        errstr = *stringval;
	errstr += "\n";
        errstr += "Can't cast error to set.";

        lociserr = 1;
    }

    if ( lociserr )
    {
//        res.zero();

        res.zero();
        res.add(*this);
    }

    return lociserr;
}

int gentype::loctoDict(Dict<gentype,dictkey> &res, std::string &errstr) const
{
    // Very important: don't overwrite res straight away, as it may actually
    // be a reference to ...val.

    int lociserr = 0;
    errstr = "";

    if ( !isValError() )
    {
        if ( isValNull() )
	{
            res.zero();
	}

        else if ( isValDict() )
	{
            // Overwriting a with a would not be sensible

            if ( &res != dictval )
            {
                res = *dictval;
            }
	}

        else
        {
            res.zero();
            res("&","res") = *this;
	}
    }

    else
    {
        NiceAssert( stringval );

        errstr = *stringval;
	errstr += "\n";
        errstr += "Can't cast error to dictionary.";

        lociserr = 1;
    }

    if ( lociserr )
    {
//        res.zero();

        res.zero();
        res("&","err") = *this;
    }

    return lociserr;
}

int gentype::loctoDgraph(Dgraph<gentype,double> &res, std::string &errstr) const
{
    int lociserr = 0;
    errstr = "";

    if ( !isValError() )
    {
        if ( isValNull() )
	{
            res.zero();
	}

        else if ( isValInteger() )
	{
            errstr = "Can't cast integer to dgraph.";
	    lociserr = 1;
	}

        else if ( isValReal() )
	{
            errstr = "Can't cast real to dgraph.";
	    lociserr = 1;
	}

        else if ( isValAnion() )
	{
            errstr = "Can't cast anion to dgraph.";
	    lociserr = 1;
	}

	else if ( isValVector() )
	{
            errstr = "Can't cast vector to dgraph.";
	    lociserr = 1;
	}

	else if ( isValMatrix() )
	{
            errstr = "Can't cast matrix to dgraph.";
	    lociserr = 1;
	}

        else if ( isValSet() )
	{
            errstr = "Can't cast set to dgraph.";
	    lociserr = 1;
	}

        else if ( isValDict() )
	{
            errstr = "Can't cast set to dictionary.";
	    lociserr = 1;
	}

        else if ( isValDgraph() )
	{
            // Overwriting a with a would not be sensible

            if ( &res != dgraphval )
            {
                res = *dgraphval;
            }
	}

	else if ( isValString() )
	{
            errstr = "Can't cast string to dgraph.";
	    lociserr = 1;
	}

	else if ( isValEqn() )
	{
            errstr = "Can't cast equation to dgraph.";
	    lociserr = 1;
	}
    }

    else
    {
        NiceAssert( stringval );

        errstr = *stringval;
	errstr += "\n";
        errstr += "Can't cast error to set.";

        lociserr = 1;
    }

    if ( lociserr )
    {
        res.zero();
    }

    return lociserr;
}

int gentype::loctoString(std::string &res, std::string &errstr) const
{
    errstr = "";

    std::stringstream resbuffer;

    if ( isValString() )
    {
        // Overwriting a with a would not be sensible

        if ( &res != stringval )
        {
            res = *stringval;
        }
    }

    else if ( isValError() )
    {
        // Overwriting a with a would not be sensible

        if ( ( (*stringval)[0] != 'E' ) || ( (*stringval)[1] != ':' ) )
        {
            if ( &res != stringval )
            {
                res = "E:";
                res += *stringval;
            }

            else
            {
                std::string temp(res);

                res = "E:";
                res += temp;
            }
        }

        else
        {
            res = *stringval;
        }
    }

    else if ( isValEqnDir() )
    {
        // NB: static initialisation occurs the first time the code block
        //     is encountered, and is only done once.  Hence each of these
        //     indices will be looked up once and then remain unchanged.

        const static int factInd          = getfnind("fact");
        const static int dfactInd         = getfnind("dfact");
        const static int tfactInd         = getfnind("tfact");
        const static int psfInd           = getfnind("psf");
        const static int negInd           = getfnind("neg");
        const static int posInd           = getfnind("pos");
        const static int lnotInd          = getfnind("lnot");
        const static int powInd           = getfnind("pow");
        const static int powlInd          = getfnind("powl");
        const static int powrInd          = getfnind("powr");
        const static int epowInd          = getfnind("epow");
        const static int epowlInd         = getfnind("epowl");
        const static int epowrInd         = getfnind("epowr");
        const static int nthrtInd         = getfnind("nthrt");
        const static int PowInd           = getfnind("Pow");
        const static int PowlInd          = getfnind("Powl");
        const static int PowrInd          = getfnind("Powr");
        const static int EpowInd          = getfnind("Epow");
        const static int EpowlInd         = getfnind("Epowl");
        const static int EpowrInd         = getfnind("Epowr");
        const static int NthrtInd         = getfnind("Nthrt");
        const static int mulInd           = getfnind("mul");
        const static int rmulInd          = getfnind("rmul");
        const static int divInd           = getfnind("div");
        const static int idivInd          = getfnind("idiv");
        const static int rdivInd          = getfnind("rdiv");
        const static int modInd           = getfnind("mod");
        const static int emulInd          = getfnind("emul");
        const static int ermulInd         = getfnind("ermul");
        const static int edivInd          = getfnind("ediv");
        const static int eidivInd         = getfnind("eidiv");
        const static int erdivInd         = getfnind("erdiv");
        const static int emodInd          = getfnind("emod");
        const static int addInd           = getfnind("add");
        const static int subInd           = getfnind("sub");
        const static int cayleyDicksonInd = getfnind("cayleyDickson");
        const static int CayleyDicksonInd = getfnind("CayleyDickson");
        const static int eeqInd           = getfnind("eeq");
        const static int eneInd           = getfnind("ene");
        const static int egtInd           = getfnind("egt");
        const static int egeInd           = getfnind("ege");
        const static int eltInd           = getfnind("elt");
        const static int eleInd           = getfnind("ele");
        const static int eqInd            = getfnind("eq");
        const static int neInd            = getfnind("ne");
        const static int gtInd            = getfnind("gt");
        const static int geInd            = getfnind("ge");
        const static int ltInd            = getfnind("lt");
        const static int leInd            = getfnind("le");
        const static int lorInd           = getfnind("lor");
        const static int landInd          = getfnind("land");
        const static int derefvInd        = getfnind("derefv");

        const static int varInd = getfnind("var");
        const static int VarInd = getfnind("Var");

	std::string openbracketis = "(";
	std::string separis = ",";
	std::string closebracketis = ")";

        int qw = fnnameind;
        int fnnameind = qw; // yep, you read that right (deliberate shadow so we can overwrite sans changing)

    // 	            _ left to right                              x_i   -> derefv(x,i)
    // 	            - + ~ left to right                          -a    -> neg(a)
    //                                                           ~a    -> lnot(a)
    //                                                           +a    -> pos(a)       this will never occur and can be ignored as the equation is simplified
    //	            ^ .^ ^/ (right to left)                      a^b   -> pow(a,b)
    //                                                           a^<b  -> powl(a,b)
    //                                                           a^>b  -> powr(a,b)
    //                                                           a.^b  -> epow(a,b)
    //                                                           a.^<b -> epowl(a,b)
    //                                                           a.^>b -> epowr(a,b)
    //                                                           a^/b  -> nthrt(a,b)
    //	            * / // \ % .* ./ .// .\ .% (left to right)   a*b   -> mul(a,b)
    //                                                           a*>b  -> rmul(a,b)
    //                                                           a/b   -> div(a,b)
    //                                                           a//b  -> idiv(a,b)
    //                                                           a\b   -> rdiv(a,b)
    //                                                           a%b   -> mod(a,b)
    //                                                           a.*b  -> emul(a,b)
    //                                                           a.*>b -> ermul(a,b)
    //                                                           a./b  -> ediv(a,b)
    //                                                           a.//b -> eidiv(a,b)
    //                                                           a.\b  -> erdiv(a,b)
    //                                                           a.%b  -> emod(a,b)
    //	            + - (left to right)                          a+b   -> add(a,b)
    //                                                           a-b   -> sub(a,b)     this will never occur and can be ignored as the equation is simplified
    //	            | (cayley-dickson) left to right             a|b   -> cayleyDickson(a,b)
    //                                                           a|@b  -> CayleyDickson(a,b)
    //              == ~= > < >= <= .== .~= .> .< .>= .<= left to right a==b  -> eq(a,b)
    //                                                           a~=b  -> ne(a,b)
    //                                                           a>b   -> gt(a,b)
    //                                                           a>=b  -> ge(a,b)
    //                                                           a<=b  -> le(a,b)
    //                                                           a<b   -> lt(a,b)
    //                                                           a.==b -> eeq(a,b)
    //                                                           a.~=b -> ene(a,b)
    //                                                           a.>b  -> egt(a,b)
    //                                                           a.>=b -> ege(a,b)
    //                                                           a.<=b -> ele(a,b)
    //                                                           a.<b  -> elt(a,b)
    //              && || left to right                          a||b  -> lor(a,b)
    //                                                           a&&b  -> land(a,b)

             if ( fnnameind == factInd          ) { fnnameind = 0; openbracketis = "(";  separis = "";     closebracketis = ")!";   }
        else if ( fnnameind == dfactInd         ) { fnnameind = 0; openbracketis = "(";  separis = "";     closebracketis = ")!!";  }
        else if ( fnnameind == tfactInd         ) { fnnameind = 0; openbracketis = "(";  separis = "";     closebracketis = ")!!!"; }
        else if ( fnnameind == psfInd           ) { fnnameind = 0; openbracketis = "(";  separis = "";     closebracketis = ")$";   }
        else if ( fnnameind == negInd           ) { fnnameind = 0; openbracketis = "-("; separis = "";     closebracketis = ")";    }
        else if ( fnnameind == posInd           ) { fnnameind = 0; openbracketis = "(";  separis = "";     closebracketis = ")";    }
        else if ( fnnameind == lnotInd          ) { fnnameind = 0; openbracketis = "~("; separis = "";     closebracketis = ")";    }
        else if ( fnnameind == powInd           ) { fnnameind = 0; openbracketis = "(";  separis = "^";    closebracketis = ")";    }
        else if ( fnnameind == derefvInd        ) { fnnameind = 0; openbracketis = "";   separis = "_";    closebracketis = "";     }
        else if ( fnnameind == powlInd          ) { fnnameind = 0; openbracketis = "(";  separis = "^<";   closebracketis = ")";    }
        else if ( fnnameind == powrInd          ) { fnnameind = 0; openbracketis = "(";  separis = "^>";   closebracketis = ")";    }
        else if ( fnnameind == epowInd          ) { fnnameind = 0; openbracketis = "(";  separis = ".^";   closebracketis = ")";    }
        else if ( fnnameind == epowlInd         ) { fnnameind = 0; openbracketis = "(";  separis = ".^<";  closebracketis = ")";    }
        else if ( fnnameind == epowrInd         ) { fnnameind = 0; openbracketis = "(";  separis = ".^>";  closebracketis = ")";    }
        else if ( fnnameind == nthrtInd         ) { fnnameind = 0; openbracketis = "(";  separis = "^/";   closebracketis = ")";    }
        else if ( fnnameind == PowInd           ) { fnnameind = 0; openbracketis = "(";  separis = "^^";   closebracketis = ")";    }
        else if ( fnnameind == PowlInd          ) { fnnameind = 0; openbracketis = "(";  separis = "^^<";  closebracketis = ")";    }
        else if ( fnnameind == PowrInd          ) { fnnameind = 0; openbracketis = "(";  separis = "^^>";  closebracketis = ")";    }
        else if ( fnnameind == EpowInd          ) { fnnameind = 0; openbracketis = "(";  separis = ".^^";  closebracketis = ")";    }
        else if ( fnnameind == EpowlInd         ) { fnnameind = 0; openbracketis = "(";  separis = ".^^<"; closebracketis = ")";    }
        else if ( fnnameind == EpowrInd         ) { fnnameind = 0; openbracketis = "(";  separis = ".^^>"; closebracketis = ")";    }
        else if ( fnnameind == NthrtInd         ) { fnnameind = 0; openbracketis = "(";  separis = "^^/";  closebracketis = ")";    }
        else if ( fnnameind == mulInd           ) { fnnameind = 0; openbracketis = "(";  separis = "*";    closebracketis = ")";    }
        else if ( fnnameind == rmulInd          ) { fnnameind = 0; openbracketis = "(";  separis = "*>";   closebracketis = ")";    }
        else if ( fnnameind == divInd           ) { fnnameind = 0; openbracketis = "(";  separis = "/";    closebracketis = ")";    }
        else if ( fnnameind == idivInd          ) { fnnameind = 0; openbracketis = "(";  separis = "//";   closebracketis = ")";    }
        else if ( fnnameind == rdivInd          ) { fnnameind = 0; openbracketis = "(";  separis = "\\";   closebracketis = ")";    }
        else if ( fnnameind == modInd           ) { fnnameind = 0; openbracketis = "(";  separis = "%";    closebracketis = ")";    }
        else if ( fnnameind == emulInd          ) { fnnameind = 0; openbracketis = "(";  separis = ".*";   closebracketis = ")";    }
        else if ( fnnameind == ermulInd         ) { fnnameind = 0; openbracketis = "(";  separis = ".*>";  closebracketis = ")";    }
        else if ( fnnameind == edivInd          ) { fnnameind = 0; openbracketis = "(";  separis = "./";   closebracketis = ")";    }
        else if ( fnnameind == eidivInd         ) { fnnameind = 0; openbracketis = "(";  separis = ".//";  closebracketis = ")";    }
        else if ( fnnameind == erdivInd         ) { fnnameind = 0; openbracketis = "(";  separis = ".\\";  closebracketis = ")";    }
        else if ( fnnameind == emodInd          ) { fnnameind = 0; openbracketis = "(";  separis = ".%";   closebracketis = ")";    }
        else if ( fnnameind == addInd           ) { fnnameind = 0; openbracketis = "(";  separis = "+";    closebracketis = ")";    }
        else if ( fnnameind == subInd           ) { fnnameind = 0; openbracketis = "(";  separis = "-";    closebracketis = ")";    }
        else if ( fnnameind == cayleyDicksonInd ) { fnnameind = 0; openbracketis = "(";  separis = "|";    closebracketis = ")";    }
        else if ( fnnameind == CayleyDicksonInd ) { fnnameind = 0; openbracketis = "(";  separis = "|@";   closebracketis = ")";    }
        else if ( fnnameind == eeqInd           ) { fnnameind = 0; openbracketis = "(";  separis = ".==";  closebracketis = ")";    }
        else if ( fnnameind == eneInd           ) { fnnameind = 0; openbracketis = "(";  separis = ".~=";  closebracketis = ")";    }
        else if ( fnnameind == egtInd           ) { fnnameind = 0; openbracketis = "(";  separis = ".>";   closebracketis = ")";    }
        else if ( fnnameind == egeInd           ) { fnnameind = 0; openbracketis = "(";  separis = ".>=";  closebracketis = ")";    }
        else if ( fnnameind == eltInd           ) { fnnameind = 0; openbracketis = "(";  separis = ".<";   closebracketis = ")";    }
        else if ( fnnameind == eleInd           ) { fnnameind = 0; openbracketis = "(";  separis = ".<=";  closebracketis = ")";    }
        else if ( fnnameind == eqInd            ) { fnnameind = 0; openbracketis = "(";  separis = "==";   closebracketis = ")";    }
        else if ( fnnameind == neInd            ) { fnnameind = 0; openbracketis = "(";  separis = "~=";   closebracketis = ")";    }
        else if ( fnnameind == gtInd            ) { fnnameind = 0; openbracketis = "(";  separis = ">";    closebracketis = ")";    }
        else if ( fnnameind == geInd            ) { fnnameind = 0; openbracketis = "(";  separis = ">=";   closebracketis = ")";    }
        else if ( fnnameind == ltInd            ) { fnnameind = 0; openbracketis = "(";  separis = "<";    closebracketis = ")";    }
        else if ( fnnameind == leInd            ) { fnnameind = 0; openbracketis = "(";  separis = "<=";   closebracketis = ")";    }
        else if ( fnnameind == lorInd           ) { fnnameind = 0; openbracketis = "(";  separis = "||";   closebracketis = ")";    }
        else if ( fnnameind == landInd          ) { fnnameind = 0; openbracketis = "(";  separis = "&&";   closebracketis = ")";    }

        NiceAssert( ( fnnameind != varInd ) || eqnargs );

        if ( ( fnnameind == varInd ) &&
             ( ((*eqnargs)(0)).isValInteger() ) &&
             ( (((*eqnargs)(0)).intval) == 0 ) &&
             ( ((*eqnargs)(1)).isValInteger() ) &&
             ( (((*eqnargs)(1)).intval) == 0 ) )
        {
            resbuffer << "x";
        }

        else if ( ( fnnameind == varInd ) &&
             ( ((*eqnargs)(0)).isValInteger() ) &&
             ( (((*eqnargs)(0)).intval) == 0 ) &&
             ( ((*eqnargs)(1)).isValInteger() ) &&
             ( (((*eqnargs)(1)).intval) == 1 ) )
        {
            resbuffer << "y";
        }

        else if ( ( fnnameind == varInd ) &&
             ( ((*eqnargs)(0)).isValInteger() ) &&
             ( (((*eqnargs)(0)).intval) == 0 ) &&
             ( ((*eqnargs)(1)).isValInteger() ) &&
             ( (((*eqnargs)(1)).intval) == 2 ) )
        {
            resbuffer << "z";
        }

        else if ( ( fnnameind == varInd ) &&
             ( ((*eqnargs)(0)).isValInteger() ) &&
             ( (((*eqnargs)(0)).intval) == 0 ) &&
             ( ((*eqnargs)(1)).isValInteger() ) &&
             ( (((*eqnargs)(1)).intval) == 3 ) )
        {
            resbuffer << "v";
        }

        else if ( ( fnnameind == varInd ) &&
             ( ((*eqnargs)(0)).isValInteger() ) &&
             ( (((*eqnargs)(0)).intval) == 0 ) &&
             ( ((*eqnargs)(1)).isValInteger() ) &&
             ( (((*eqnargs)(1)).intval) == 4 ) )
        {
            resbuffer << "w";
        }

        else if ( ( fnnameind == varInd ) &&
             ( ((*eqnargs)(0)).isValInteger() ) &&
             ( (((*eqnargs)(0)).intval) == 0 ) &&
             ( ((*eqnargs)(1)).isValInteger() ) &&
             ( (((*eqnargs)(1)).intval) == 5 ) )
        {
            resbuffer << "g";
        }

        else if ( ( fnnameind == varInd ) &&
             ( ((*eqnargs)(0)).isValInteger() ) &&
             ( (((*eqnargs)(0)).intval) == 42 ) &&
             ( ((*eqnargs)(1)).isValInteger() ) &&
             ( (((*eqnargs)(1)).intval) == 42 ) )
        {
            resbuffer << "h";
        }

        else if ( ( fnnameind == varInd ) &&
             ( ((*eqnargs)(0)).isValInteger() ) &&
             ( (((*eqnargs)(0)).intval) == 1 ) &&
             ( ((*eqnargs)(1)).isValInteger() ) &&
             ( (((*eqnargs)(1)).intval) == 1 ) )
        {
            resbuffer << "u";
        }

        else if ( ( fnnameind == VarInd ) &&
             ( ((*eqnargs)(0)).isValInteger() ) &&
             ( (((*eqnargs)(0)).intval) == 0 ) &&
             ( ((*eqnargs)(1)).isValInteger() ) &&
             ( (((*eqnargs)(1)).intval) == 0 ) )
        {
            resbuffer << "X";
        }

        else if ( ( fnnameind == VarInd ) &&
             ( ((*eqnargs)(0)).isValInteger() ) &&
             ( (((*eqnargs)(0)).intval) == 0 ) &&
             ( ((*eqnargs)(1)).isValInteger() ) &&
             ( (((*eqnargs)(1)).intval) == 1 ) )
        {
            resbuffer << "Y";
        }

        else if ( ( fnnameind == VarInd ) &&
             ( ((*eqnargs)(0)).isValInteger() ) &&
             ( (((*eqnargs)(0)).intval) == 0 ) &&
             ( ((*eqnargs)(1)).isValInteger() ) &&
             ( (((*eqnargs)(1)).intval) == 2 ) )
        {
            resbuffer << "Z";
        }

        else if ( ( fnnameind == VarInd ) &&
             ( ((*eqnargs)(0)).isValInteger() ) &&
             ( (((*eqnargs)(0)).intval) == 0 ) &&
             ( ((*eqnargs)(1)).isValInteger() ) &&
             ( (((*eqnargs)(1)).intval) == 3 ) )
        {
            resbuffer << "V";
        }

        else if ( ( fnnameind == VarInd ) &&
             ( ((*eqnargs)(0)).isValInteger() ) &&
             ( (((*eqnargs)(0)).intval) == 0 ) &&
             ( ((*eqnargs)(1)).isValInteger() ) &&
             ( (((*eqnargs)(1)).intval) == 4 ) )
        {
            resbuffer << "W";
        }

        else if ( ( fnnameind == VarInd ) &&
             ( ((*eqnargs)(0)).isValInteger() ) &&
             ( (((*eqnargs)(0)).intval) == 0 ) &&
             ( ((*eqnargs)(1)).isValInteger() ) &&
             ( (((*eqnargs)(1)).intval) == 5 ) )
        {
            resbuffer << "G";
        }

        else if ( ( fnnameind == VarInd ) &&
             ( ((*eqnargs)(0)).isValInteger() ) &&
             ( (((*eqnargs)(0)).intval) == 42 ) &&
             ( ((*eqnargs)(1)).isValInteger() ) &&
             ( (((*eqnargs)(1)).intval) == 42 ) )
        {
            resbuffer << "H";
        }

        else if ( ( fnnameind == VarInd ) &&
             ( ((*eqnargs)(0)).isValInteger() ) &&
             ( (((*eqnargs)(0)).intval) == 1 ) &&
             ( ((*eqnargs)(1)).isValInteger() ) &&
             ( (((*eqnargs)(1)).intval) == 1 ) )
        {
            resbuffer << "U";
        }

        else
        {
            resbuffer << getfnname(fnnameind) << openbracketis;

            NiceAssert( eqnargs );

            //if ( (*eqnargs).size() )
            {
                for ( int i = 0 ; i < (*eqnargs).size() ; ++i )
                {
                    if ( !fnnameind && (*eqnargs)(i).isValAnion() && (*eqnargs).size() && ( separis != "+" ) && ( separis != "-" ) )
                    {
                        // eg want (1+1i)^(2+3i), not 1+1i^2+3i

                        resbuffer << "(";
                        resbuffer << (*eqnargs)(i);
                        resbuffer << ")";
                    }

                    else
                    {
                        resbuffer << (*eqnargs)(i);
                    }

                    if ( i < (*eqnargs).size()-1 )
                    {
                        resbuffer << separis;
                    }
                }
            }

            resbuffer << closebracketis;
        }

	res = resbuffer.str();
    }

    else
    {
        resbuffer << *this;
        res = resbuffer.str();
    }

    return 0;
}













SparseVector<SparseVector<int> > &gentype::varsUsed(SparseVector<SparseVector<int> > &res) const
{
    const static int varInd = getfnind("var");
    const static int VarInd = getfnind("Var");
    const static int gvarInd = getfnind("gvar");
    const static int gVarInd = getfnind("gVar");

         if ( isValNull()    ) { ; }
    else if ( isValInteger() ) { ; }
    else if ( isValReal()    ) { ; }
    else if ( isValAnion()   ) { ; }
    else if ( isValString()  ) { ; }
    else if ( isValError()   ) { ; }

    else if ( isValVector()  )
    {
        int i;
        int xsize = size();

        if ( xsize )
        {
            for ( i = 0 ; i < xsize ; ++i )
            {
                ((*vectorval)(i)).varsUsed(res);
            }
        }
    }

    else if ( isValMatrix()  )
    {
        int i,j;
        int xrows = numRows();
        int xcols = numCols();

        NiceAssert( matrixval );

        if ( xrows && xcols )
        {
            for ( i = 0 ; i < xrows ; ++i )
            {
                for ( j = 0 ; j < xcols ; ++j )
                {
                    ((*matrixval)(i,j)).varsUsed(res);
                }
            }
        }
    }

    else if ( isValSet()  )
    {
        int i;
        int xsize = size();

        if ( xsize > 0 )
        {
            for ( i = 0 ; i < xsize ; ++i )
            {
                (((*setval).all())(i)).varsUsed(res);
            }
        }
    }

    else if ( isValDict()  )
    {
        int i;
        int xsize = size();

        if ( xsize )
        {
            for ( i = 0 ; i < xsize ; ++i )
            {
                ((*dictval).val("&",i)).varsUsed(res);
            }
        }
    }

    else if ( isValDgraph()  )
    {
        int i;
        int xsize = size();

        if ( xsize )
        {
            for ( i = 0 ; i < xsize ; ++i )
            {
                (((*dgraphval).all())(i)).varsUsed(res);
            }
        }
    }

    else if ( ( fnnameind == varInd ) || ( fnnameind == VarInd ) )
    {
        NiceAssert( eqnargs );

        if ( ((*eqnargs)(0)).isCastableToIntegerWithoutLoss() && ((*eqnargs)(1)).isCastableToIntegerWithoutLoss() )
        {
            (res("&",((*eqnargs)(0)).cast_int(0)))("&",((*eqnargs)(1)).cast_int(0)) = 1;
        }
    }

    else if ( ( fnnameind == gvarInd ) || ( fnnameind == gVarInd ) )
    {
        NiceAssert( eqnargs );

        if ( ((*eqnargs)(0)).isCastableToIntegerWithoutLoss() && ((*eqnargs)(1)).isCastableToIntegerWithoutLoss() )
        {
            (res("&",((*eqnargs)(0)).cast_int(0)))("&",((*eqnargs)(1)).cast_int(0)) = 1;
        }
    }

    else
    {
        int i;

        NiceAssert( eqnargs );

        for ( i = 0 ; i < (*eqnargs).size() ; ++i )
        {
            (*eqnargs)(i).varsUsed(res);
        }
    }

    return res;
}

SparseVector<int> &gentype::rowsUsed(SparseVector<int> &res) const
{
    const static int varInd = getfnind("var");
    const static int VarInd = getfnind("Var");

         if ( isValNull()    ) { ; }
    else if ( isValInteger() ) { ; }
    else if ( isValReal()    ) { ; }
    else if ( isValAnion()   ) { ; }
    else if ( isValString()  ) { ; }
    else if ( isValError()   ) { ; }

    else if ( isValVector()  )
    {
        int i;
        int xsize = size();

        if ( xsize )
        {
            for ( i = 0 ; i < xsize ; ++i )
            {
                ((*vectorval)(i)).rowsUsed(res);
            }
        }
    }

    else if ( isValSet()  )
    {
        int i;
        int xsize = size();

        if ( xsize > 0 )
        {
            for ( i = 0 ; i < xsize ; ++i )
            {
                (((*setval).all())(i)).rowsUsed(res);
            }
        }
    }

    else if ( isValDict()  )
    {
        int i;
        int xsize = size();

        if ( xsize )
        {
            for ( i = 0 ; i < xsize ; ++i )
            {
                ((*dictval).val(i)).rowsUsed(res);
            }
        }
    }

    else if ( isValDgraph()  )
    {
        int i;
        int xsize = size();

        if ( xsize )
        {
            for ( i = 0 ; i < xsize ; ++i )
            {
                (((*dgraphval).all())(i)).rowsUsed(res);
            }
        }
    }

    else if ( isValMatrix()  )
    {
        int i,j;
        int xrows = numRows();
        int xcols = numCols();

        NiceAssert( matrixval );

        if ( xrows && xcols )
        {
            for ( i = 0 ; i < xrows ; ++i )
            {
                for ( j = 0 ; j < xcols ; ++j )
                {
                    ((*matrixval)(i,j)).rowsUsed(res);
                }
            }
        }
    }

    else
    {
        if ( ( fnnameind == varInd ) || ( fnnameind == VarInd ) )
        {
            NiceAssert( eqnargs );

            if ( ((*eqnargs)(0)).isCastableToIntegerWithoutLoss() )
            {
                res("&",((*eqnargs)(0)).cast_int(0)) = 1;
            }
        }
    }

    return res;
}














// Other stuff

int gentype::realDeriv(const gentype &ix, const gentype &jx)
{
    int res = 0;

    const static int varInd = getfnind("var");
    const static int VarInd = getfnind("Var");
    const static int gvarInd = getfnind("gvar");
    const static int gVarInd = getfnind("gVar");
    const static int realDerivInd = getfnind("realDeriv");

    int i,j;

    if ( ix.isValVector() && jx.isValVector() )
    {
	gentype iy,jy;
	Vector<gentype> ii(ix.cast_vector(0));
	Vector<gentype> jj(jx.cast_vector(0));
        Matrix<gentype> tempres(ix.size(),jx.size());

        tempres = *this;

	for ( i = 0 ; i < ix.size() ; ++i )
	{
	    for ( j = 0 ; j < jx.size() ; ++j )
	    {
		iy = ii(i);
		jy = jj(j);
		tempres("&",i,j).realDeriv(iy,jy);
	    }
	}

        *this = tempres;
        ++res;
    }

    else if ( ix.isValVector() && ( jx.isCastableToIntegerWithoutLoss() || jx.isValEqnDir() ) )
    {
        gentype iy;
	Vector<gentype> ii(ix.cast_vector(0));
	Vector<gentype> tempres(ix.size());

        tempres = *this;

	for ( i = 0 ; i < ix.size() ; ++i )
	{
	    iy = ii(i);
	    tempres("&",i).realDeriv(iy,jx);
	}

        *this = tempres;
        ++res;
    }

    else if ( ( ix.isCastableToIntegerWithoutLoss() || ix.isValEqnDir() ) && jx.isValVector() )
    {
	gentype jy;
	Vector<gentype> jj(jx.cast_vector(0));
        Vector<gentype> tempres(jx.size());

        tempres = *this;

	for ( j = 0 ; j < jx.size() ; ++j )
	{
	    jy = jj(j);
	    tempres("&",j).realDeriv(ix,jy);
	}

        *this = tempres;
        ++res;
    }

    else if ( ix.isCastableToIntegerWithoutLoss() && jx.isCastableToIntegerWithoutLoss() )
    {
             if ( isValNull()    ) { *this = 0; }
        else if ( isValInteger() ) { *this = 0; }
	else if ( isValReal()    ) { *this = 0; }
	else if ( isValAnion()   ) { *this = 0; }
	else if ( isValString()  ) { *this = 0; }
	else if ( isValError()   ) { ; }
        else if ( isValDgraph()  ) { *this = 0; }

        else if ( isValSet() )
        {
            if ( (*setval).size() > 0 )
	    {
                for ( i = 0 ; i < (*setval).size() ; ++i )
		{
                    (((*setval).ncall())("&",i)).realDeriv(ix,jx);
		}
	    }
        }

        else if ( isValDict() )
        {
            if ( (*dictval).size() )
	    {
                for ( i = 0 ; i < (*dictval).size() ; ++i )
		{
                    ((*dictval).val("&",i)).realDeriv(ix,jx);
		}
	    }
        }

	else if ( isValVector()  )
	{
	    //if ( (*vectorval).size() )
	    {
		for ( i = 0 ; i < (*vectorval).size() ; ++i )
		{
                    ((*vectorval)("&",i)).realDeriv(ix,jx);
		}
	    }
	}

	else if ( isValMatrix()  )
	{
	    if ( (*matrixval).numRows() && (*matrixval).numCols() )
	    {
		for ( i = 0 ; i < (*matrixval).numRows() ; ++i )
		{
		    for ( j = 0 ; j < (*matrixval).numCols() ; ++j )
		    {
                        ((*matrixval)("&",i,j)).realDeriv(ix,jx);
		    }
		}
	    }
	}

	else if ( isValEqnDir()  )
	{
            NiceAssert( eqnargs );

            if ( ( fnnameind == varInd ) || ( fnnameind == VarInd ) )
	    {
		// This is a thing
                //
                // Note the assumption that we are dealing with real variables
                // here.  For completeness in terms of hypercomplex variables
                // you would need to follow more complicated rules.  It can
                // be done... put it on the to do list.
                //
                // As for derivatives with respect to vectors, matrices, ...
                // I don't know, too many ambiguities.  It will work for
                // vectors in limited cases (norms and such).

                const static gentype tempres("kronDelta(x,y)*kronDelta(z,v)");
                gentype rres(tempres);

                rres.substitute((*eqnargs)(0),ix,(*eqnargs)(1),jx);
                fastcopy(rres,1);
                //(*this) = res((*eqnargs)(0),ix,(*eqnargs)(1),jx);
	    }

            else if ( ( ( fnnameind == gvarInd ) || ( fnnameind == gVarInd ) ) &&
                      !( ix.isValEqn() ) && !( jx.isValEqn() ) && ix.iseq((*eqnargs)(0)) && jx.iseq((*eqnargs)(1)) )
	    {
                // This is like above but *only* if ix == eqnargs(0) and jx == eqnargs(1).
                // Otherwise undefined, so leave unchange.
                // (that is the difference between var and gvar)

//                fastcopy(oneintgentype(),1);
                fastcopy(1_gent,1);
	    }

            else if ( ( realDerivInd == fnnameind ) || ( fnnameind == gvarInd ) || ( fnnameind == gVarInd ) || ( fnnameind == varInd ) || ( VarInd == fnnameind ) )
            {
                const static gentype tempres("realDeriv(x,y,z)");
                gentype temp(tempres);

                temp.substitute(ix,jx,*this);
                fastcopy(temp,1);
            }

            else if ( realDerivDefinedDir() )
            {
                gentype tempres(*((*thisfninfo).realderiv));
                SparseVector<SparseVector<gentype> > temparg;

                if ( (*thisfninfo).numargs )
                {
                    j = 1;

                    for ( i = 0 ; i < (*thisfninfo).numargs ; ++i )
                    {
                        if ( (*thisfninfo).realargcopy & j )
                        {
                            temparg("&",0)("&",i).fastcopy((*eqnargs)(i),1);
                        }

                        if ( (*thisfninfo).realdrvcopy & j )
                        {
                            temparg("&",1)("&",i).fastcopy((*eqnargs)(i),1);
                            temparg("&",1)("&",i).realDeriv(ix,jx);
                        }

                        temparg("&",2)("&",0).fastcopy(ix,1);
                        temparg("&",2)("&",1).fastcopy(jx,1);

                        j *= 2;
                    }
                }

                tempres.evaluate(temparg);
                fastcopy(tempres,1);
                // *this = tempres(temparg);

            }

            else
            {
                constructError(ix,jx,*this,"Derivative not defined for this function.");

//                const static gentype tempres("realDeriv(x,y,z)");
//                gentype temp(tempres);
//
//                temp.substitute(ix,jx,*this);
//                fastcopy(temp,1);
            }
	}

	else
	{
            constructError(ix,jx,*this,"An impossible error appears to have occured in the realDeriv function.");
	}

        ++res;
    }

    else if ( ( ix.isCastableToIntegerWithoutLoss() && jx.isValEqnDir()                    ) ||
              ( ix.isValEqnDir()                    && jx.isCastableToIntegerWithoutLoss() ) ||
              ( ix.isValEqnDir()                    && jx.isValEqnDir()                    )    )
    {
        const static gentype tempres("realDeriv(x,y,z)");
        gentype temp(tempres);

        temp.substitute(ix,jx,*this);
        fastcopy(temp,1);
        ++res;
    }

    else
    {
        constructError(ix,jx,*this,"realDeriv indices must be real or vector/matrix thereof");
        ++res;
    }

    return res;
}













// Internal version of substitute - function evaluation
//
// finalise: 1 means finalise randoms (indetermin 2)
//           2 means finalise globals (indetermin 1)
//           3 means both
//
// isValEqn: 1 contains indeterminant random or global parts
//           2 contains deterministic parts
//           4 contains indeterminant random parts
//           8 contains indeterminant global parts
//
// isIndeterm: 1 global function indeterminant
//             2 random indeterminant

int gentype::fastevaluate(const SparseVector<SparseVector<gentype> > &evalargs, int finalise)
{
    const static int nullptrInd   = getfnind("");
    const static int varInd       = getfnind("var");
    const static int VarInd       = getfnind("Var");
    const static int gvarInd      = getfnind("gvar");
    const static int gVarInd      = getfnind("gVar");
    const static int posInd       = getfnind("pos");
    const static int negInd       = getfnind("neg");
    const static int conjInd      = getfnind("conj");
    const static int addInd       = getfnind("add");
    const static int subInd       = getfnind("sub");
    const static int mulInd       = getfnind("mul");
    const static int divInd       = getfnind("div");
    const static int rdivInd      = getfnind("rdiv");
    const static int emulInd      = getfnind("emul");
    const static int edivInd      = getfnind("ediv");
    const static int erdivInd     = getfnind("erdiv");
    const static int landInd      = getfnind("land");
    const static int lorInd       = getfnind("lor");
    const static int powInd       = getfnind("pow");
    const static int PowInd       = getfnind("Pow");
    const static int powlInd      = getfnind("powl");
    const static int PowlInd      = getfnind("Powl");
    const static int powrInd      = getfnind("powr");
    const static int PowrInd      = getfnind("Powr");
    const static int epowInd      = getfnind("epow");
    const static int EpowInd      = getfnind("Epow");
    const static int epowlInd     = getfnind("epowl");
    const static int EpowlInd     = getfnind("Epowl");
    const static int epowrInd     = getfnind("epowr");
    const static int EpowrInd     = getfnind("Epowr");
    const static int sizeInd      = getfnind("size");
    const static int numRowsInd   = getfnind("numRows");
    const static int numColsInd   = getfnind("numCols");
    const static int realDerivInd = getfnind("realDeriv");
    const static int abs1Ind      = getfnind("abs1");
    const static int abs2Ind      = getfnind("abs2");
    const static int absinfInd    = getfnind("absinf");
    const static int abs0Ind      = getfnind("abs0");
    const static int abspInd      = getfnind("absp");
    const static int norm1Ind     = getfnind("norm1");
    const static int norm2Ind     = getfnind("norm2");
    const static int normpInd     = getfnind("normp");

    int oldfnnameind = fnnameind;

    int i,j;
    int ccnt = 0; // counts number of changes (in principle)
    int doagain = 0; // set 1 if global function has been evaluated, so repeat required (as global function might itself return a function)
    //const fninfoblock *locthisfninfo = thisfninfo;

    if ( !isValEqn() )
    {
        // Not an equation, so no need to evaluate

        ;
    }

    else if ( isValVector() )
    {
	if ( size() )
	{
	    for ( i = 0 ; i < size() ; ++i )
	    {
                ccnt += ((*vectorval)("&",i)).fastevaluate(evalargs,finalise);
	    }
	}
    }

    else if ( isValMatrix() )
    {
	if ( numRows() && numCols() )
	{
	    for ( i = 0 ; i < numRows() ; ++i )
	    {
		for ( j = 0 ; j < numCols() ; ++j )
		{
                    ccnt += ((*matrixval)("&",i,j)).fastevaluate(evalargs,finalise);
		}
	    }
	}
    }

    else if ( isValSet() )
    {
	if ( size() > 0 )
	{
	    for ( i = 0 ; i < size() ; ++i )
	    {
                ccnt += (((*setval).ncall())("&",i)).fastevaluate(evalargs,finalise);
	    }
	}
    }

    else if ( isValDict() )
    {
	//if ( size() )
	{
	    for ( i = 0 ; i < size() ; ++i )
	    {
                ccnt += ((*dictval).val("&",i)).fastevaluate(evalargs,finalise);
	    }
	}
    }

    else if ( isValDgraph() )
    {
	if ( size() )
	{
	    for ( i = 0 ; i < size() ; ++i )
	    {
                ccnt += (((*dgraphval).ncall())("&",i)).fastevaluate(evalargs,finalise);
	    }
	}
    }

    else
    {
//fnname "pycall"                sin
//numargs      2                 1
//dirchkargs   0                 1
//widechkargs  3                 0
//preEvalArgs  3                 1
//derivDeffed  0                 1
//isInDetermin 0                 0
//fn2arg pycall
//congfnname "~"
//fnconjind -1                   -1
//realargcopy 0                  1
//realdrvcopy 0                  1
//realderiv nullptr              nullprt
//realderivfn "0"
//descript "..."
//phantomqwerty
//bool rundebug = ( evalargs.isindpresent(0) && evalargs(0).isindpresent(0) && evalargs(0)(0).isValVector() );
        int  argsize              = (*thisfninfo).numargs;
        int  isInDetermin         = (*thisfninfo).isInDetermin;
	int  isresfunction        = 0;
        int  argbit               = 1;
        int  isresfullyeval       = 1;
        char res_varid_isscalarfn = 0;
        int  res_varid_numpts     = 0;

        Vector<int> res_varid_xi(1);
        Vector<int> res_varid_xj(1);

        res_varid_xi = 0;
        res_varid_xj = 0;

        if ( argsize )
	{
            for ( i = 0 ; i < argsize ; ++i )
            {
                NiceAssert( eqnargs );

                if ( (*thisfninfo).preEvalArgs & argbit )
                {
                    ccnt += ((*eqnargs)("&",i)).fastevaluate(evalargs,finalise);
                }

                else
                {
                    isresfullyeval = 0;
                }

                if ( ((*eqnargs)(i)).scalarfn_isscalarfn() )
                {
                    if ( res_varid_isscalarfn )
                    {
                        NiceAssert( res_varid_xi == ((*eqnargs)(i)).scalarfn_i() );
                        NiceAssert( res_varid_xj == ((*eqnargs)(i)).scalarfn_j() );

                        res_varid_isscalarfn = ((*eqnargs)(i)).scalarfn_isscalarfn();
                        res_varid_numpts     = ( ((*eqnargs)(i)).scalarfn_numpts() > res_varid_numpts ) ? ((*eqnargs)(i)).scalarfn_numpts() : res_varid_numpts;

                        res_varid_xi = ((*eqnargs)(i)).scalarfn_i();
                        res_varid_xj = ((*eqnargs)(i)).scalarfn_j();
                    }

                    else
                    {
                        res_varid_isscalarfn = ((*eqnargs)(i)).scalarfn_isscalarfn();
                        res_varid_numpts     = ((*eqnargs)(i)).scalarfn_numpts();

                        res_varid_xi = ((*eqnargs)(i)).scalarfn_i();
                        res_varid_xj = ((*eqnargs)(i)).scalarfn_j();
                    }

                    if ( !( ( fnnameind == abs1Ind   ) ||
                            ( fnnameind == abs2Ind   ) ||
                            ( fnnameind == abspInd   ) ||
                            ( fnnameind == absinfInd ) ||
                            ( fnnameind == abs0Ind   ) ||
                            ( fnnameind == norm1Ind  ) ||
                            ( fnnameind == norm2Ind  ) ||
                            ( fnnameind == normpInd  )    ) )
                    {
                        ((*eqnargs)("&",i)).varid_isscalar = 0; // This ensures that the scalar "bit" is strictly on the outer layer - but we must leave it there for the norms to evaluate correctly!
                    }
                }

                int argtemp = 0;

                if ( ( (*thisfninfo).dirchkargs & argbit ) && ((*eqnargs)(i)).isValEqnDir() )
                {
                    isresfunction += argbit;
                }

                else if ( ( (*thisfninfo).widechkargs & argbit ) && ( argtemp = ((*eqnargs)(i)).isValEqn() ) )
                {
// finalise: 1 means finalise randoms (indetermin 2)
//           2 means finalise globals (indetermin 1)
//           3 means both
//
// isValEqn: 1 contains indeterminant random or global parts
//           2 contains deterministic parts
//           4 contains indeterminant random parts
//           8 contains indeterminant global parts
//
// isIndeterm: 1 global function indeterminant
//             2 random indeterminant

//                    if ( ( argtemp & 2 ) || !finalise || ( ( ( argtemp & 4 ) && !( finalise & 1 ) ) || ( ( argtemp & 8 ) && !( finalise & 2 ) ) ) )
//                    if ( ( argtemp & 0x10 ) || !finalise || ( ( ( argtemp & 0x04 ) && !( finalise & 0x01 ) ) || ( ( argtemp & 0x08 ) && !( finalise & 0x02 ) ) ) )

                    // Function if any of
                    //
                    // - we're not finalising
                    // - contains deterministic parts
                    // - it contains globals and we're not finalising globals
                    // - it contains randoms and we're not finalising randoms

//if ( isInDetermin & 1 )
//{
//errstream() << "phantomxaa 0: " << *this << "\n";
//errstream() << "phantomxaa 1: finalise = " << finalise << "\n";
//errstream() << "phantomxaa 2: isValEqn = " << argtemp << "\n";
//errstream() << "phantomxaa 3: isInDetermin = " << isInDetermin << "\n";
//}
                    if ( !finalise || ( argtemp & 2 ) ||
                         ( ( argtemp & 8 ) && !( finalise & 2 ) ) ||
                         ( ( argtemp & 4 ) && !( finalise & 1 ) )    )
                    {
                        // Exception: IF  the current function *is* global
                        //            AND we're finalising globals (finalise & 2)
                        //            AND the argument is random but not global ( argemp & 4 ) && !( argtemp & 8 )
                        //            then this is not a function

                        if ( ( isInDetermin == 1 ) && ( finalise & 2 ) && ( argtemp & 4 ) && !( argtemp & 8 ) )
                        {
                            ;
                        }

                        else
                        {
                            isresfunction += argbit;
                        }
                    }
                }

                argbit *= 2;
            }
	}

        (void) isresfullyeval;

        // Simplify if possible

        int issimple = 0;

        if ( isresfunction )
        {
            if ( fnnameind == negInd )
            {
                NiceAssert( eqnargs );

                if ( ((*eqnargs)(0)).isValEqnDir() )
                {
                    if ( ((*eqnargs)(0)).fnnameind == negInd )
                    {
                        // *this = (*(((*eqnargs)(0)).eqnargs))(0);
                        switcheroo((*((((*eqnargs)("&",0)).eqnargs)))("&",0));

                        issimple = 1;
                        ++ccnt;
                    }
                }
            }

            else if ( fnnameind == addInd )
            {
                NiceAssert( eqnargs );

                if ( ((*eqnargs)(0)).isCastableToIntegerWithoutLoss() )
                {
                    if ( ((*eqnargs)(0)).cast_int(0) == 0 )
                    {
                        // *this = ((*eqnargs)(1));
                        switcheroo((*eqnargs)("&",1));

                        issimple = 1;
                        ++ccnt;
                    }
                }

                else if ( ((*eqnargs)(1)).isCastableToIntegerWithoutLoss() )
                {
                    if ( ((*eqnargs)(1)).cast_int(0) == 0 )
                    {
                        // *this = ((*eqnargs)(0));
                        switcheroo(((*eqnargs)("&",0)));

                        issimple = 1;
                        ++ccnt;
                    }
                }
            }

            else if ( fnnameind == subInd )
            {
                NiceAssert( eqnargs );

                if ( ((*eqnargs)(0)).isCastableToIntegerWithoutLoss() )
                {
                    if ( ((*eqnargs)(0)).cast_int(0) == 0 )
                    {
                        // *this = ((*eqnargs)(1));
                        switcheroo((*eqnargs)("&",1));
                        OP_neg(*this);

                        issimple = 1;
                        ++ccnt;
                    }
                }

                else if ( ((*eqnargs)(1)).isCastableToIntegerWithoutLoss() )
                {
                    if ( ((*eqnargs)(1)).cast_int(0) == 0 )
                    {
                        // *this = ((*eqnargs)(0));
                        switcheroo(((*eqnargs)("&",0)));

                        issimple = 1;
                        ++ccnt;
                    }
                }
            }

            else if ( ( fnnameind == mulInd ) || ( fnnameind == emulInd ) )
            {
                NiceAssert( eqnargs );

                if ( ((*eqnargs)(0)).isCastableToIntegerWithoutLoss() )
                {
                    if ( ((*eqnargs)(0)).cast_int(0) == 0 )
                    {
                        *this = 0;

                        issimple = 1;
                        ++ccnt;
                    }

                    else if ( ((*eqnargs)(0)).cast_int(0) == 1 )
                    {
                        // *this = ((*eqnargs)(1));
                        switcheroo(((*eqnargs)("&",1)));

                        issimple = 1;
                        ++ccnt;
                    }
                }

                else if ( ((*eqnargs)(1)).isCastableToIntegerWithoutLoss() )
                {
                    if ( ((*eqnargs)(1)).cast_int(0) == 0 )
                    {
                        *this = 0;

                        issimple = 1;
                        ++ccnt;
                    }

                    else if ( ((*eqnargs)(1)).cast_int(0) == 1 )
                    {
                        // *this = ((*eqnargs)(0));
                        switcheroo(((*eqnargs)("&",0)));

                        issimple = 1;
                        ++ccnt;
                    }
                }
            }

            else if ( ( fnnameind == divInd ) || ( fnnameind == edivInd ) )
            {
                NiceAssert( eqnargs );

                if ( ((*eqnargs)(0)).isCastableToIntegerWithoutLoss() )
                {
                    if ( ((*eqnargs)(0)).cast_int(0) == 0 )
                    {
                        *this = 0;

                        issimple = 1;
                        ++ccnt;
                    }
                }
            }

            else if ( ( fnnameind == rdivInd ) || ( fnnameind == erdivInd ) )
            {
                NiceAssert( eqnargs );

                if ( ((*eqnargs)(1)).isCastableToIntegerWithoutLoss() )
                {
                    if ( ((*eqnargs)(1)).cast_int(0) == 0 )
                    {
                        *this = 0;

                        issimple = 1;
                        ++ccnt;
                    }
                }
            }

            else if ( fnnameind == landInd )
            {
                NiceAssert( eqnargs );

                if ( ((*eqnargs)(0)).isCastableToIntegerWithoutLoss() )
                {
                    if ( ((*eqnargs)(0)).cast_int(0) == 0 )
                    {
                        *this = 0;

                        issimple = 1;
                        ++ccnt;
                    }
                }

                else if ( ((*eqnargs)(1)).isCastableToIntegerWithoutLoss() )
                {
                    if ( ((*eqnargs)(1)).cast_int(0) == 0 )
                    {
                        *this = 0;

                        issimple = 1;
                        ++ccnt;
                    }
                }
            }

            else if ( fnnameind == lorInd )
            {
                NiceAssert( eqnargs );

                if ( ((*eqnargs)(0)).isCastableToIntegerWithoutLoss() )
                {
                    if ( ((*eqnargs)(0)).cast_int(0) == 1 )
                    {
                        *this = 1;

                        issimple = 1;
                        ++ccnt;
                    }
                }

                else if ( ((*eqnargs)(1)).isCastableToIntegerWithoutLoss() )
                {
                    if ( ((*eqnargs)(1)).cast_int(0) == 1 )
                    {
                        *this = 1;

                        issimple = 1;
                        ++ccnt;
                    }
                }
            }

            else if ( ( fnnameind == powInd   ) || ( fnnameind == PowInd   ) ||
                      ( fnnameind == powlInd  ) || ( fnnameind == PowlInd  ) ||
                      ( fnnameind == powrInd  ) || ( fnnameind == PowrInd  ) ||
                      ( fnnameind == epowInd  ) || ( fnnameind == EpowInd  ) ||
                      ( fnnameind == epowlInd ) || ( fnnameind == EpowlInd ) ||
                      ( fnnameind == epowrInd ) || ( fnnameind == EpowrInd )    )
            {
                NiceAssert( eqnargs );

                if ( ((*eqnargs)(1)).isCastableToIntegerWithoutLoss() )
                {
                    if ( ((*eqnargs)(1)).cast_int(0) == 0 )
                    {
                        *this = 1;

                        issimple = 1;
                        ++ccnt;
                    }

                    else if ( ((*eqnargs)(1)).cast_int(0) == 1 )
                    {
                        // *this = ((*eqnargs)(0));
                        switcheroo(((*eqnargs)("&",0)));

                        issimple = 1;
                        ++ccnt;
                    }
                }
            }

            else if ( ( ( fnnameind == abs2Ind   ) ||
                        ( fnnameind == abs1Ind   ) ||
                        ( fnnameind == absinfInd ) ||
                        ( fnnameind == abs0Ind   ) ||
                        ( fnnameind == norm2Ind  ) ||
                        ( fnnameind == norm1Ind  )    ) && (*eqnargs)(0).scalarfn_isscalarfn() )
            {
                NiceAssert( eqnargs );

                *this = ((*thisfninfo).fn1arg)((*eqnargs)(0));

                if ( fnnameind != oldfnnameind )
                {
                    return fastevaluate(evalargs,finalise);
                }
            }

            else if ( ( ( fnnameind == abspInd   ) ||
                        ( fnnameind == normpInd  )    ) && (*eqnargs)(0).scalarfn_isscalarfn() && (*eqnargs)(1).isCastableToRealWithoutLoss() )
            {
                NiceAssert( eqnargs );

                *this = ((*thisfninfo).fn2arg)((*eqnargs)(0),(*eqnargs)(1));

                if ( fnnameind != oldfnnameind )
                {
                    return fastevaluate(evalargs,finalise);
                }
            }
        }

//        if ( issimple || isresfunction || ( isInDetermin && !finalise ) )
//errstream() << "phantomx 3fgfg: " << isInDetermin << "\n";
//errstream() << "phantomx 4fgfg: " << finalise << "\n";

// finalise: 1 means finalise randoms (indetermin 2)
//           2 means finalise globals (indetermin 1)
//           3 means both
//
// isValEqn: 1 contains indeterminant random or global parts
//           2 contains deterministic parts
//           4 contains indeterminant random parts
//           8 contains indeterminant global parts
//
// isIndeterm: 1 global function indeterminant
//             2 random indeterminant

//        if ( issimple || isresfunction || ( ( ( isInDetermin & 2 ) && !( finalise & 1 ) ) || ( ( isInDetermin & 1 ) && !( finalise & 2 ) ) ) )

//if ( isInDetermin & 1 ) 
//{ 
//errstream() << "phantomxaa 7: uissimple = " << issimple << "\n"; 
//errstream() << "phantomxaa 7: isfunction = " << isresfunction << "\n"; 
//errstream() << "phantomxaa 7: isInDetermin = " << isInDetermin << "\n"; 
//errstream() << "phantomxaa 7: finalise = " << finalise << "\n"; 
//}
        if ( issimple || isresfunction || ( ( isInDetermin & 2 ) && !( finalise & 1 ) ) || ( ( isInDetermin & 1 ) && !( finalise & 2 ) ) )
        {
            ;
        }

        else if ( fnnameind == nullptrInd ) { NiceAssert( eqnargs ); switcheroo((*eqnargs)("&",0));           ++ccnt; }
        else if ( fnnameind == posInd     ) { NiceAssert( eqnargs ); switcheroo((*eqnargs)("&",0));           ++ccnt; }
        else if ( fnnameind == conjInd    ) { NiceAssert( eqnargs ); switcheroo((*eqnargs)("&",0)); conj();   ++ccnt; }
        else if ( fnnameind == sizeInd    ) { NiceAssert( eqnargs ); *this = (*eqnargs)(0).size();            ++ccnt; }
        else if ( fnnameind == numRowsInd ) { NiceAssert( eqnargs ); *this = (*eqnargs)(0).numRows();         ++ccnt; }
        else if ( fnnameind == numColsInd ) { NiceAssert( eqnargs ); *this = (*eqnargs)(0).numCols();         ++ccnt; }

        else if ( fnnameind == varInd     ) { ccnt += OP_var(evalargs);         }
        else if ( fnnameind == VarInd     ) { ccnt += OP_var(evalargs); conj(); }
        else if ( fnnameind == gvarInd    ) { ccnt += OP_var(evalargs);         }
        else if ( fnnameind == gVarInd    ) { ccnt += OP_var(evalargs); conj(); }

        else if ( fnnameind == realDerivInd )
        {
            NiceAssert( eqnargs );

            if ( ((*eqnargs)(2)).realDerivDefinedDir() )
            {
                gentype ti,tj;

                ti.fastcopy((*eqnargs)(0),1);
                tj.fastcopy((*eqnargs)(1),1);

                switcheroo((*eqnargs)("&",2));
                ccnt += realDeriv(ti,tj);
            }

            else
            {
                ;
            }
//FIXME phantomxy: if evalargs is nonempty then need to subst at this point
//FIXME: need fast copy below
        }

        else if ( argsize == 0 ) { ++ccnt; doagain = (*thisfninfo).isInDetermin & 1; oldfnnameind = fnnameind;                        *this = ((*thisfninfo).fn0arg)();                                                                                            }
        else if ( argsize == 1 ) { ++ccnt; doagain = (*thisfninfo).isInDetermin & 1; oldfnnameind = fnnameind; NiceAssert( eqnargs ); *this = ((*thisfninfo).fn1arg)((*eqnargs)(0));                                                                       }
        else if ( argsize == 2 ) { ++ccnt; doagain = (*thisfninfo).isInDetermin & 1; oldfnnameind = fnnameind; NiceAssert( eqnargs ); *this = ((*thisfninfo).fn2arg)((*eqnargs)(0),(*eqnargs)(1));                                                         }
        else if ( argsize == 3 ) { ++ccnt; doagain = (*thisfninfo).isInDetermin & 1; oldfnnameind = fnnameind; NiceAssert( eqnargs ); *this = ((*thisfninfo).fn3arg)((*eqnargs)(0),(*eqnargs)(1),(*eqnargs)(2));                                           }
        else if ( argsize == 4 ) { ++ccnt; doagain = (*thisfninfo).isInDetermin & 1; oldfnnameind = fnnameind; NiceAssert( eqnargs ); *this = ((*thisfninfo).fn4arg)((*eqnargs)(0),(*eqnargs)(1),(*eqnargs)(2),(*eqnargs)(3));                             }
        else if ( argsize == 5 ) { ++ccnt; doagain = (*thisfninfo).isInDetermin & 1; oldfnnameind = fnnameind; NiceAssert( eqnargs ); *this = ((*thisfninfo).fn5arg)((*eqnargs)(0),(*eqnargs)(1),(*eqnargs)(2),(*eqnargs)(3),(*eqnargs)(4));               }
        else if ( argsize == 6 ) { ++ccnt; doagain = (*thisfninfo).isInDetermin & 1; oldfnnameind = fnnameind; NiceAssert( eqnargs ); *this = ((*thisfninfo).fn6arg)((*eqnargs)(0),(*eqnargs)(1),(*eqnargs)(2),(*eqnargs)(3),(*eqnargs)(4),(*eqnargs)(5)); }

        else
        {
            std::string locfnname(getfnname(fnnameind));

            constructError(*this,locfnname+" is not a recognised function name");
        }

        //else if ( ( argsize == 1 ) && ( (*thisfninfo).OP_fn1arg != nullptr ) ) { *this = (*eqnargs)(0); ((*locthisfninfo).OP_fn1arg)(*this);                                                                       }
        //else if ( ( argsize == 2 ) && ( (*thisfninfo).OP_fn2arg != nullptr ) ) { *this = (*eqnargs)(0); ((*locthisfninfo).OP_fn2arg)(*this,(*eqnargs)(1));                                                         }
        //else if ( ( argsize == 3 ) && ( (*thisfninfo).OP_fn3arg != nullptr ) ) { *this = (*eqnargs)(0); ((*locthisfninfo).OP_fn3arg)(*this,(*eqnargs)(1),(*eqnargs)(2));                                           }
        //else if ( ( argsize == 4 ) && ( (*thisfninfo).OP_fn4arg != nullptr ) ) { *this = (*eqnargs)(0); ((*locthisfninfo).OP_fn4arg)(*this,(*eqnargs)(1),(*eqnargs)(2),(*eqnargs)(3));                             }
        //else if ( ( argsize == 5 ) && ( (*thisfninfo).OP_fn5arg != nullptr ) ) { *this = (*eqnargs)(0); ((*locthisfninfo).OP_fn5arg)(*this,(*eqnargs)(1),(*eqnargs)(2),(*eqnargs)(3),(*eqnargs)(4));               }
        //else if ( ( argsize == 6 ) && ( (*thisfninfo).OP_fn5arg != nullptr ) ) { *this = (*eqnargs)(0); ((*locthisfninfo).OP_fn5arg)(*this,(*eqnargs)(1),(*eqnargs)(2),(*eqnargs)(3),(*eqnargs)(4),(*eqnargs)(5)); }

        if ( res_varid_isscalarfn )
        {
            scalarfn_setisscalarfn(1);
            scalarfn_setnumpts(res_varid_numpts);

            scalarfn_seti(res_varid_xi);
            scalarfn_setj(res_varid_xj);
        }
    }

    if ( doagain && ( finalise & 2 ) && isValEqnDir() && ( ((*thisfninfo).isInDetermin) & 1 ) && ( oldfnnameind != fnnameind ) )
    {
        ccnt += fastevaluate(evalargs,finalise);
    }

    if ( scalarfn_isscalarfn() && !isValEqn() )
    {
        scalarfn_setisscalarfn(0);
    }

    return ccnt;
}




















// Helper functions:

/*
gentype &gentype::ident(void)
{
    *this = 1; return *this;

    //     if ( isValNull()    ) { ;                      }
    //else if ( isValInteger() ) { intval = 1;            }
    //else if ( isValReal()    ) { doubleval = 1;         }
    //else if ( isValAnion()   ) { (*anionval) = 1.0;     }
    //else if ( isValVector()  ) { (*vectorval).ident();  }
    //else if ( isValMatrix()  ) { (*matrixval).ident();  }
    //else if ( isValSet()     ) { (*setval).ident();     }
    //else if ( isValDgraph()  ) { (*dgraphval).ident();  }
    //else if ( isValString()  ) { (*stringval) = "";     }
    //else if ( isValError()   ) { ;                      }
    //else                       { *this = 1;             }
    //
    //return *this;
}

gentype &gentype::zero(void)
{
    *this = 0; return *this;

    //     if ( isValNull()    ) { ;                      }
    //else if ( isValInteger() ) { intval = 0;            }
    //else if ( isValReal()    ) { doubleval = 0;         }
    //else if ( isValAnion()   ) { (*anionval) = 0.0;     }
    //else if ( isValVector()  ) { (*vectorval).zero();   }
    //else if ( isValMatrix()  ) { (*matrixval).zero();   }
    //else if ( isValSet()     ) { (*setval).zero();      }
    //else if ( isValDgraph()  ) { (*dgraphval).zero();   }
    //else if ( isValString()  ) { (*stringval) = "";     }
    //else if ( isValError()   ) { ;                      }
    //else                       { *this = 0;     }
    //
    //return *this;
}
*/

void gentype::reversestring(void)
{
    int i;

    NiceAssert( stringval );

    if ( (*stringval).length() )
    {
        std::string temp = *stringval;
        *stringval = "";

	for ( i = (int) temp.length()-1 ; i >= 0 ; --i )
	{
            *stringval += temp[i];
	}
    }

    return;
}

void gentype::invertstringcase(void)
{
    int i;

    NiceAssert( stringval );

    if ( (*stringval).length() )
    {
        for ( i = 0 ; i < (int) (*stringval).length() ; ++i )
        {
            switch ( (*stringval)[i] )
	    {
            case 'a': { (*stringval)[i] = 'A'; break; }
            case 'b': { (*stringval)[i] = 'B'; break; }
            case 'c': { (*stringval)[i] = 'C'; break; }
            case 'd': { (*stringval)[i] = 'D'; break; }
            case 'e': { (*stringval)[i] = 'E'; break; }
            case 'f': { (*stringval)[i] = 'F'; break; }
            case 'g': { (*stringval)[i] = 'G'; break; }
            case 'h': { (*stringval)[i] = 'H'; break; }
            case 'i': { (*stringval)[i] = 'I'; break; }
            case 'j': { (*stringval)[i] = 'J'; break; }
            case 'k': { (*stringval)[i] = 'K'; break; }
            case 'l': { (*stringval)[i] = 'L'; break; }
            case 'm': { (*stringval)[i] = 'M'; break; }
            case 'n': { (*stringval)[i] = 'N'; break; }
            case 'o': { (*stringval)[i] = 'O'; break; }
            case 'p': { (*stringval)[i] = 'P'; break; }
            case 'q': { (*stringval)[i] = 'Q'; break; }
            case 'r': { (*stringval)[i] = 'R'; break; }
            case 's': { (*stringval)[i] = 'S'; break; }
            case 't': { (*stringval)[i] = 'T'; break; }
            case 'u': { (*stringval)[i] = 'U'; break; }
            case 'v': { (*stringval)[i] = 'V'; break; }
            case 'w': { (*stringval)[i] = 'W'; break; }
            case 'x': { (*stringval)[i] = 'X'; break; }
            case 'y': { (*stringval)[i] = 'Y'; break; }
            case 'z': { (*stringval)[i] = 'Z'; break; }
            case 'A': { (*stringval)[i] = 'a'; break; }
            case 'B': { (*stringval)[i] = 'b'; break; }
            case 'C': { (*stringval)[i] = 'c'; break; }
            case 'D': { (*stringval)[i] = 'd'; break; }
            case 'E': { (*stringval)[i] = 'e'; break; }
            case 'F': { (*stringval)[i] = 'f'; break; }
            case 'G': { (*stringval)[i] = 'g'; break; }
            case 'H': { (*stringval)[i] = 'h'; break; }
            case 'I': { (*stringval)[i] = 'i'; break; }
            case 'J': { (*stringval)[i] = 'j'; break; }
            case 'K': { (*stringval)[i] = 'k'; break; }
            case 'L': { (*stringval)[i] = 'l'; break; }
            case 'M': { (*stringval)[i] = 'm'; break; }
            case 'N': { (*stringval)[i] = 'n'; break; }
            case 'O': { (*stringval)[i] = 'o'; break; }
            case 'P': { (*stringval)[i] = 'p'; break; }
            case 'Q': { (*stringval)[i] = 'q'; break; }
            case 'R': { (*stringval)[i] = 'r'; break; }
            case 'S': { (*stringval)[i] = 's'; break; }
            case 'T': { (*stringval)[i] = 't'; break; }
            case 'U': { (*stringval)[i] = 'u'; break; }
            case 'V': { (*stringval)[i] = 'v'; break; }
            case 'W': { (*stringval)[i] = 'w'; break; }
            case 'X': { (*stringval)[i] = 'x'; break; }
            case 'Y': { (*stringval)[i] = 'y'; break; }
            case 'Z': { (*stringval)[i] = 'z'; break; }
	    default: { break; }
	    }
	}
    }

    return;
}






















// Maths parsing

// Go through string left to right
// Break into a vector of chunk strings - each is either a number, an
// expression or an operator group

int gentype::mathsparse(std::string &srcx, const std::string &src)
{
    int res = 0;
    int AShilton = 0;

    srcx = src;

    // Break src into blocks.  Basically takes srcx and
    // divides it into sequential blocks.  Each block i is described
    // by element i in the vectors:
    //
    // srcxblock(i):     relevant part of srcx
    // srcxblocktype(i): type, where 0 means opcode block, 1 means number,
    //                   2 means expression
    // srcxblockres(i):  for numbers 1 = int, 2 = real, 3 = anion, 4 = vector,
    //                   5 = matrix, 6 = string, 7 = error, 8 = set, 9 = dgraph,
    //                   10 = dict, for expressions this is the number of arguments in
    //                   the expression
    // srcxblockname(i): for expressions this is the function name of the block

    std::string exprname = "";
    std::string opblock  = "";
    Vector<int> commapos;
    int i,j,k;

    Vector<eqninfoblock> srcxblock;

    i = 0;
    j = 0;
    k = 0;

    while ( i < (int) srcx.length() )
    {
        bool isconst = false;
        res = processNumLtoR(i,j,srcx,isconst);

	if ( res == -1 )
	{
//errstream() << "phantomxy 0\n";
            return -1;
	}

	else if ( res )
	{
	    if ( opblock.length() )
	    {
		srcxblock.add(k);

		srcxblock("&",k).text = opblock;
		srcxblock("&",k).type = 0;

		++k;
                opblock = "";
	    }

	    srcxblock.add(k);

	    srcxblock("&",k).text = srcx.substr(i,j-i+1);
	    srcxblock("&",k).type = 1;
	    srcxblock("&",k).res  = res;

	    ++k;
            i = j+1;
	}

	else
	{
            res = processExprLtoR(i,j,AShilton,srcx,exprname,commapos);

	    if ( res == -1 )
	    {
//errstream() << "phantomxy 1\n";
		return -1;
	    }

	    else if ( res )
	    {
		if ( opblock.length() )
		{
		    srcxblock.add(k);

		    srcxblock("&",k).text = opblock;
		    srcxblock("&",k).type = 0;

		    ++k;
		    opblock = "";
		}

                commapos -= i;

		srcxblock.add(k);

		srcxblock("&",k).text   = srcx.substr(i,j-i+1);
		srcxblock("&",k).type   = 2;
		srcxblock("&",k).res    = res-1;
		srcxblock("&",k).fnname = exprname;
		srcxblock("&",k).commas = commapos;
                srcxblock("&",k).isstr  = AShilton;

		++k;
		i = j+1;
	    }

	    else
	    {
		opblock += srcx[i];
                ++i;
	    }
	}
    }

    if ( opblock.length() )
    {
	srcxblock.add(k);

	srcxblock("&",k).text = opblock;
	srcxblock("&",k).type = 0;

	++k;
	opblock = "";
    }

    // Quick sanity check - operators and numbers/expressions should alternate

    if ( srcxblock.size() > 1 )
    {
	int prevblocktype = srcxblock(0).type;

	for ( i = 1 ; i < srcxblock.size() ; ++i )
	{
	    if ( ( prevblocktype && srcxblock(i).type ) || ( !prevblocktype && !srcxblock(i).type ) )
	    {
//errstream() << "phantomxy 2\n";
                return -1;
	    }

            prevblocktype = srcxblock(i).type;
	}
    }

    else if ( srcxblock.size() == 1 )
    {
	if ( !srcxblock(0).type )
	{
	    // If there is a single block then it must be a number or an expression, not an operator block

//errstream() << "phantomxy 3\n";
	    return -1;
	}
    }

    else
    {
        // Empty is meaningless

//errstream() << "phantomxy 4\n";
        return -1;
    }

    // Run through all strings and convert to expressions
    //
    // null,Null,none,None -> null()
    // nan,NaN,... -> vnan()
    // inf -> pinf()
    // pinf -> pinf()
    // pi -> pi()
    // euler -> euler()
    // tnow -> tnow()
    // clkyear
    // clkmon
    // clkday
    // clkhour
    // clkmin
    // clksec
    // x -> var(0,0)
    // y -> var(0,1)
    // z -> var(0,2)
    // v -> var(0,3)
    // w -> var(0,4)
    // g -> var(0,5)
    // h -> var(42,42)
    // u -> var(1,1)

    for ( i = 0 ; i < srcxblock.size() ; ++i )
    {
	if ( srcxblock(i).isstr )
	{
            if ( ( srcxblock(i).fnname == "null" ) || ( srcxblock(i).fnname == "Null" ) || ( srcxblock(i).fnname == "none" ) || ( srcxblock(i).fnname == "None" ) )
	    {
                srcxblock("&",i).text  = "null()";
		srcxblock("&",i).isstr = 0;
	    }

            else if ( ( srcxblock(i).fnname == "nan" ) || ( srcxblock(i).fnname == "NAN" ) ||
                      ( srcxblock(i).fnname == "Nan" ) || ( srcxblock(i).fnname == "nAn" ) || ( srcxblock(i).fnname == "naN" ) ||
                      ( srcxblock(i).fnname == "nAN" ) || ( srcxblock(i).fnname == "Nan" ) || ( srcxblock(i).fnname == "NAn" )    )
	    {
		srcxblock("&",i).text  = "vnan()";
		srcxblock("&",i).isstr = 0;
	    }

            else if ( ( srcxblock(i).fnname == "inf" ) || ( srcxblock(i).fnname == "INF" ) ||
                      ( srcxblock(i).fnname == "Inf" ) || ( srcxblock(i).fnname == "iNf" ) || ( srcxblock(i).fnname == "inF" ) ||
                      ( srcxblock(i).fnname == "iNF" ) || ( srcxblock(i).fnname == "InF" ) || ( srcxblock(i).fnname == "INf" )    )
	    {
		srcxblock("&",i).text  = "pinf()";
		srcxblock("&",i).isstr = 0;
	    }

            else if ( srcxblock(i).fnname == "pinf" )
	    {
		srcxblock("&",i).text  = "pinf()";
		srcxblock("&",i).isstr = 0;
	    }

            else if ( srcxblock(i).fnname == "ninf" )
	    {
		srcxblock("&",i).text  = "pinf()";
		srcxblock("&",i).isstr = 0;
	    }

            else if ( srcxblock(i).fnname == "pi" )
	    {
		srcxblock("&",i).text  = "pi()";
		srcxblock("&",i).isstr = 0;
	    }

	    else if ( srcxblock(i).fnname == "euler" )
	    {
		srcxblock("&",i).text  = "euler()";
                srcxblock("&",i).isstr = 0;
	    }

	    else if ( srcxblock(i).fnname == "tnow" )
	    {
		srcxblock("&",i).text  = "tnow()";
                srcxblock("&",i).isstr = 0;
	    }

	    else if ( srcxblock(i).fnname == "clkyear" )
	    {
		srcxblock("&",i).text  = "clkyear()";
                srcxblock("&",i).isstr = 0;
	    }

	    else if ( srcxblock(i).fnname == "clkmon" )
	    {
		srcxblock("&",i).text  = "clkmon()";
                srcxblock("&",i).isstr = 0;
	    }

	    else if ( srcxblock(i).fnname == "clkday" )
	    {
		srcxblock("&",i).text  = "clkday()";
                srcxblock("&",i).isstr = 0;
	    }

	    else if ( srcxblock(i).fnname == "clkhour" )
	    {
		srcxblock("&",i).text  = "clkhour()";
                srcxblock("&",i).isstr = 0;
	    }

	    else if ( srcxblock(i).fnname == "clkmin" )
	    {
		srcxblock("&",i).text  = "clkmin()";
                srcxblock("&",i).isstr = 0;
	    }

	    else if ( srcxblock(i).fnname == "clksec" )
	    {
		srcxblock("&",i).text  = "clksec()";
                srcxblock("&",i).isstr = 0;
	    }

	    else if ( srcxblock(i).fnname == "x" )
	    {
		srcxblock("&",i).text   = "var(0,0)";
		srcxblock("&",i).fnname = "var";
		srcxblock("&",i).isstr  = 0;

		(srcxblock("&",i).commas).resize(1);
                (srcxblock("&",i).commas)("&",0) = 5;
	    }

	    else if ( srcxblock(i).fnname == "y" )
	    {
		srcxblock("&",i).text   = "var(0,1)";
		srcxblock("&",i).fnname = "var";
		srcxblock("&",i).isstr  = 0;

		(srcxblock("&",i).commas).resize(1);
                (srcxblock("&",i).commas)("&",0) = 5;
	    }

	    else if ( srcxblock(i).fnname == "z" )
	    {
		srcxblock("&",i).text   = "var(0,2)";
		srcxblock("&",i).fnname = "var";
		srcxblock("&",i).isstr  = 0;

		(srcxblock("&",i).commas).resize(1);
                (srcxblock("&",i).commas)("&",0) = 5;
	    }

	    else if ( srcxblock(i).fnname == "v" )
	    {
		srcxblock("&",i).text   = "var(0,3)";
		srcxblock("&",i).fnname = "var";
		srcxblock("&",i).isstr  = 0;

		(srcxblock("&",i).commas).resize(1);
                (srcxblock("&",i).commas)("&",0) = 5;
	    }

	    else if ( srcxblock(i).fnname == "w" )
	    {
		srcxblock("&",i).text   = "var(0,4)";
		srcxblock("&",i).fnname = "var";
		srcxblock("&",i).isstr  = 0;

		(srcxblock("&",i).commas).resize(1);
                (srcxblock("&",i).commas)("&",0) = 5;
	    }

	    else if ( srcxblock(i).fnname == "g" )
	    {
		srcxblock("&",i).text   = "var(0,5)";
		srcxblock("&",i).fnname = "var";
		srcxblock("&",i).isstr  = 0;

		(srcxblock("&",i).commas).resize(1);
                (srcxblock("&",i).commas)("&",0) = 5;
	    }

	    else if ( srcxblock(i).fnname == "h" )
	    {
		srcxblock("&",i).text   = "var(42,42)";
		srcxblock("&",i).fnname = "var";
		srcxblock("&",i).isstr  = 0;

		(srcxblock("&",i).commas).resize(1);
                (srcxblock("&",i).commas)("&",0) = 5;
	    }

	    else if ( srcxblock(i).fnname == "u" )
	    {
		srcxblock("&",i).text   = "var(1,1)";
		srcxblock("&",i).fnname = "var";
		srcxblock("&",i).isstr  = 0;

		(srcxblock("&",i).commas).resize(1);
                (srcxblock("&",i).commas)("&",0) = 5;
	    }

            else if ( srcxblock(i).fnname == "X" )
	    {
                srcxblock("&",i).text   = "Var(0,0)";
                srcxblock("&",i).fnname = "Var";
		srcxblock("&",i).isstr  = 0;

		(srcxblock("&",i).commas).resize(1);
                (srcxblock("&",i).commas)("&",0) = 5;
	    }

            else if ( srcxblock(i).fnname == "Y" )
	    {
                srcxblock("&",i).text   = "Var(0,1)";
                srcxblock("&",i).fnname = "Var";
		srcxblock("&",i).isstr  = 0;

		(srcxblock("&",i).commas).resize(1);
                (srcxblock("&",i).commas)("&",0) = 5;
	    }

            else if ( srcxblock(i).fnname == "Z" )
	    {
                srcxblock("&",i).text   = "Var(0,2)";
                srcxblock("&",i).fnname = "Var";
		srcxblock("&",i).isstr  = 0;

		(srcxblock("&",i).commas).resize(1);
                (srcxblock("&",i).commas)("&",0) = 5;
	    }

            else if ( srcxblock(i).fnname == "V" )
	    {
                srcxblock("&",i).text   = "Var(0,3)";
                srcxblock("&",i).fnname = "Var";
		srcxblock("&",i).isstr  = 0;

		(srcxblock("&",i).commas).resize(1);
                (srcxblock("&",i).commas)("&",0) = 5;
	    }

            else if ( srcxblock(i).fnname == "W" )
	    {
                srcxblock("&",i).text   = "Var(0,4)";
                srcxblock("&",i).fnname = "Var";
		srcxblock("&",i).isstr  = 0;

		(srcxblock("&",i).commas).resize(1);
                (srcxblock("&",i).commas)("&",0) = 5;
	    }

            else if ( srcxblock(i).fnname == "G" )
	    {
                srcxblock("&",i).text   = "Var(0,5)";
                srcxblock("&",i).fnname = "Var";
		srcxblock("&",i).isstr  = 0;

		(srcxblock("&",i).commas).resize(1);
                (srcxblock("&",i).commas)("&",0) = 5;
	    }

            else if ( srcxblock(i).fnname == "H" )
	    {
                srcxblock("&",i).text   = "Var(42,42)";
                srcxblock("&",i).fnname = "Var";
		srcxblock("&",i).isstr  = 0;

		(srcxblock("&",i).commas).resize(1);
                (srcxblock("&",i).commas)("&",0) = 5;
	    }

            else if ( srcxblock(i).fnname == "U" )
	    {
                srcxblock("&",i).text   = "Var(1,1)";
                srcxblock("&",i).fnname = "Var";
		srcxblock("&",i).isstr  = 0;

		(srcxblock("&",i).commas).resize(1);
                (srcxblock("&",i).commas)("&",0) = 5;
	    }
	}
    }

    // Now that the srcx has been broken down into blocks we can start
    // processing the operators according to the usual rules of precedence.

    // But first, we need to process any expressions

    std::string subblock;
    int m,n;

    for ( i = 0 ; i < (srcxblock.size()) ; ++i )
    {
	if ( ( srcxblock(i).type == 2 ) && ( srcxblock(i).res > 0 ) )
	{
	    for ( j = (srcxblock(i).res)-1 ; j >= 0 ; --j )
	    {
		if ( j == 0 )
		{
		    if ( srcxblock(i).res == 1 )
		    {
			m = (int) ((srcxblock(i).fnname).length())+1;
			n = (int) ((srcxblock(i).text).length())-2;
		    }

		    else
		    {
			m = (int) ((srcxblock(i).fnname).length())+1;
			n = ((srcxblock(i).commas)(j))-1;
		    }
		}

		else if ( j == (srcxblock(i).res)-1 )
		{
                    m = ((srcxblock(i).commas)(j-1))+1;
                    n = (int) ((srcxblock(i).text).length())-2;
		}

		else
		{
                    m = ((srcxblock(i).commas)(j-1))+1;
                    n = ((srcxblock(i).commas)(j))-1;
		}

		if ( ( res = mathsparse(subblock,(srcxblock(i).text).substr(m,n-m+1)) ) )
		{
//errstream() << "phantomxy 5\n";
                    return res;
		}

		(srcxblock("&",i).text).erase(m,n-m+1);
                (srcxblock("&",i).text).insert(m,subblock);
	    }
	}
    }

    // Finally up to operators.  Order is as follows
    //
    //              _ left to right                              a_i    -> derefv(a,i)
    //              ! right to left                              a!     -> fact(a)
    //                                                           a!!    -> dfact(a)
    //                                                           a!!!   -> tfact(a)
    //                                                           a$     -> psf(a)
    // 	            - + ~ left to right                          -a     -> neg(a)
    //                                                           ~a     -> lnot(a)
    //                                                           +a     -> pos(a)       this will never occur and can be ignored as the equation is simplified
    //	            ^ .^ ^/ (right to left)                      a^b    -> pow(a,b)
    //                                                           a^<b   -> powl(a,b)
    //                                                           a^>b   -> powr(a,b)
    //                                                           a.^b   -> epow(a,b)
    //                                                           a.^<b  -> epowl(a,b)
    //                                                           a.^>b  -> epowr(a,b)
    //                                                           a^/b   -> nthrt(a,b)
    //	                                                         a^^b   -> Pow(a,b)
    //                                                           a^^<b  -> Powl(a,b)
    //                                                           a^^>b  -> Powr(a,b)
    //                                                           a.^^b  -> Epow(a,b)
    //                                                           a.^^<b -> Epowl(a,b)
    //                                                           a.^^>b -> Epowr(a,b)
    //                                                           a^^/b  -> Nthrt(a,b)
    //	            * / // \ % .* ./ .// .\ .% (left to right)   a*b    -> mul(a,b)
    //                                                           a*>b   -> rmul(a,b)
    //                                                           a/b    -> div(a,b)
    //                                                           a//b   -> idiv(a,b)
    //                                                           a\b    -> rdiv(a,b)
    //                                                           a%b    -> mod(a,b)
    //                                                           a.*b   -> emul(a,b)
    //                                                           a.*>b  -> ermul(a,b)
    //                                                           a./b   -> ediv(a,b)
    //                                                           a.//b  -> eidiv(a,b)
    //                                                           a.\b   -> erdiv(a,b)
    //                                                           a.%b   -> emod(a,b)
    //	            + - (left to right)                          a+b    -> add(a,b)
    //                                                           a-b    -> sub(a,b)     this will never occur and can be ignored as the equation is simplified
    //	            | (cayley-dickson) left to right             a|b    -> cayleyDickson(a,b)
    //                                                           a|@b   -> CayleyDickson(a,b)
    //              Logical comparison left to right             a==b   -> eq(a,b)
    //                                                           a~=b   -> ne(a,b)
    //                                                           a>b    -> gt(a,b)
    //                                                           a>=b   -> ge(a,b)
    //                                                           a<=b   -> le(a,b)
    //                                                           a<b    -> lt(a,b)
    //                                                           a.==b  -> eeq(a,b)
    //                                                           a.~=b  -> ene(a,b)
    //                                                           a.>b   -> egt(a,b)
    //                                                           a.>=b  -> ege(a,b)
    //                                                           a.<=b  -> ele(a,b)
    //                                                           a.<b   -> elt(a,b)
    //              && || left to right                          a||b   -> lor(a,b)
    //                                                           a&&b   -> land(a,b)

    Vector<std::string> opSymb;
    Vector<std::string> opFuncEquiv;
    Vector<int> opRevBinOrder;

    opSymb.resize(1);         opSymb("&",0)        = "_";
    opFuncEquiv.resize(1);    opFuncEquiv("&",0)   = "derefv";
    opRevBinOrder.resize(1);  opRevBinOrder("&",0) = 0;

    if ( ( res = operatorToFunction(1,1,opSymb,opFuncEquiv,opRevBinOrder,srcxblock) ) ) { return res; }

    opSymb.resize(4);         opSymb("&",0)        = "!!!";           opSymb("&",1)        = "!!";    opSymb("&",2)        = "!";     opSymb("&",3)        = "$";
    opFuncEquiv.resize(4);    opFuncEquiv("&",0)   = "tfact";         opFuncEquiv("&",1)   = "dfact"; opFuncEquiv("&",2)   = "fact";  opFuncEquiv("&",3)   = "psf";
    opRevBinOrder.resize(4);  opRevBinOrder("&",0) = 0;               opRevBinOrder("&",1) = 0;       opRevBinOrder("&",2) = 0;       opRevBinOrder("&",3) = 0;

    if ( ( res = operatorToFunction(1,0,opSymb,opFuncEquiv,opRevBinOrder,srcxblock) ) ) { return res; }

    opSymb.resize(2);         opSymb("&",0)        = "~";             opSymb("&",1)        = "-";
    opFuncEquiv.resize(2);    opFuncEquiv("&",0)   = "lnot";          opFuncEquiv("&",1)   = "neg";
    opRevBinOrder.resize(2);  opRevBinOrder("&",0) = 0;               opRevBinOrder("&",1) = 0;

    if ( ( res = operatorToFunction(0,0,opSymb,opFuncEquiv,opRevBinOrder,srcxblock) ) ) { return res; }

    opSymb.resize(14);        opSymb("&",0)        = ".^^>";          opSymb("&",1)        = ".^^<";  opSymb("&",2)        = ".^^";   opSymb("&",3)        = "^^>";  opSymb("&",4)        = "^^<";  opSymb("&",5)        = "^^/";   opSymb("&",6)        = "^^";    opSymb("&",7)        = ".^>";   opSymb("&",8)        = ".^<";   opSymb("&",9)        = ".^";    opSymb("&",10)        = "^>";    opSymb("&",11)        = "^<";    opSymb("&",12)        = "^/";    opSymb("&",13)        = "^";
    opFuncEquiv.resize(14);   opFuncEquiv("&",0)   = "Epowr";         opFuncEquiv("&",1)   = "Epowl"; opFuncEquiv("&",2)   = "Epow";  opFuncEquiv("&",3)   = "Powr"; opFuncEquiv("&",4)   = "Powl"; opFuncEquiv("&",5)   = "Nthrt"; opFuncEquiv("&",6)   = "Pow";   opFuncEquiv("&",7)   = "epowr"; opFuncEquiv("&",8)   = "epowl"; opFuncEquiv("&",9)   = "epow";  opFuncEquiv("&",10)   = "powr";  opFuncEquiv("&",11)   = "powl";  opFuncEquiv("&",12)   = "nthrt"; opFuncEquiv("&",13)   = "pow";
    opRevBinOrder.resize(14); opRevBinOrder("&",0) = 0;               opRevBinOrder("&",1) = 0;       opRevBinOrder("&",2) = 0;       opRevBinOrder("&",3) = 0;      opRevBinOrder("&",4) = 0;      opRevBinOrder("&",5) = 0;       opRevBinOrder("&",6) = 0;       opRevBinOrder("&",7) = 0;       opRevBinOrder("&",8) = 0;       opRevBinOrder("&",9) = 0;       opRevBinOrder("&",10) = 0;       opRevBinOrder("&",11) = 0;       opRevBinOrder("&",12) = 0;       opRevBinOrder("&",13) = 0;

    if ( ( res = operatorToFunction(1,1,opSymb,opFuncEquiv,opRevBinOrder,srcxblock) ) ) { return res; }

    opSymb.resize(12);        opSymb("&",0)        = ".*>";           opSymb("&",1)        = ".*";    opSymb("&",2)        = "./";    opSymb("&",3)        = ".\\";   opSymb("&",4)        = ".%";   opSymb("&",5)        = "*>";   opSymb("&",6)        = "*";   opSymb("&",7)        = "/";   opSymb("&",8)        = "\\";   opSymb("&",9)        = "%";   opSymb("&",10)        = "//";   opSymb("&",11)        = ".//";
    opFuncEquiv.resize(12);   opFuncEquiv("&",0)   = "ermul";         opFuncEquiv("&",1)   = "emul";  opFuncEquiv("&",2)   = "ediv";  opFuncEquiv("&",3)   = "erdiv"; opFuncEquiv("&",4)   = "emod"; opFuncEquiv("&",5)   = "rmul"; opFuncEquiv("&",6)   = "mul"; opFuncEquiv("&",7)   = "div"; opFuncEquiv("&",8)   = "rdiv"; opFuncEquiv("&",9)   = "mod"; opFuncEquiv("&",10)   = "idiv"; opFuncEquiv("&",11)   = "eidiv";
    opRevBinOrder.resize(12); opRevBinOrder("&",0) = 0;               opRevBinOrder("&",1) = 0;       opRevBinOrder("&",2) = 0;       opRevBinOrder("&",3) = 0;       opRevBinOrder("&",4) = 0;      opRevBinOrder("&",5) = 0;      opRevBinOrder("&",6) = 0;     opRevBinOrder("&",7) = 0;     opRevBinOrder("&",8) = 0;      opRevBinOrder("&",9) = 0;     opRevBinOrder("&",10) = 0;      opRevBinOrder("&",11) = 0;

    if ( ( res = operatorToFunction(0,1,opSymb,opFuncEquiv,opRevBinOrder,srcxblock) ) ) { return res; }

    opSymb.resize(1);         opSymb("&",0)        = "+";
    opFuncEquiv.resize(1);    opFuncEquiv("&",0)   = "add";
    opRevBinOrder.resize(1);  opRevBinOrder("&",0) = 0;

    if ( ( res = operatorToFunction(0,1,opSymb,opFuncEquiv,opRevBinOrder,srcxblock) ) ) { return res; }

    opSymb.resize(2);         opSymb("&",0)        = "|@";            opSymb("&",1)        = "|";
    opFuncEquiv.resize(2);    opFuncEquiv("&",0)   = "CayleyDickson"; opFuncEquiv("&",1)   = "cayleyDickson";
    opRevBinOrder.resize(2);  opRevBinOrder("&",0) = 0;               opRevBinOrder("&",1) = 0;

    if ( ( res = operatorToFunction(0,1,opSymb,opFuncEquiv,opRevBinOrder,srcxblock) ) ) { return res; }

    opSymb.resize(12);        opSymb("&",0)        = ".==";           opSymb("&",1)        = ".~=";   opSymb("&",2)        = ".>=";   opSymb("&",3)        = ".<=";  opSymb("&",4)        = ".>";   opSymb("&",5)        = ".<";    opSymb("&",6)        = "==";    opSymb("&",7)        = "~=";    opSymb("&",8)        = ">=";    opSymb("&",9)        = "<=";    opSymb("&",10)        = ">";     opSymb("&",11)        = "<";
    opFuncEquiv.resize(12);   opFuncEquiv("&",0)   = "eeq";           opFuncEquiv("&",1)   = "ene";   opFuncEquiv("&",2)   = "ege";   opFuncEquiv("&",3)   = "ele";  opFuncEquiv("&",4)   = "egt";  opFuncEquiv("&",5)   = "elt";   opFuncEquiv("&",6)   = "eq";    opFuncEquiv("&",7)   = "ne";    opFuncEquiv("&",8)   = "ge";    opFuncEquiv("&",9)   = "le";    opFuncEquiv("&",10)   = "gt";    opFuncEquiv("&",11)   = "lt";
    opRevBinOrder.resize(12); opRevBinOrder("&",0) = 0;               opRevBinOrder("&",1) = 0;       opRevBinOrder("&",2) = 0;       opRevBinOrder("&",3) = 0;      opRevBinOrder("&",4) = 0;      opRevBinOrder("&",5) = 0;       opRevBinOrder("&",6) = 0;       opRevBinOrder("&",7) = 0;       opRevBinOrder("&",8) = 0;       opRevBinOrder("&",9) = 0;       opRevBinOrder("&",10) = 0;       opRevBinOrder("&",11) = 0;

    if ( ( res = operatorToFunction(0,1,opSymb,opFuncEquiv,opRevBinOrder,srcxblock) ) ) { return res; }

    opSymb.resize(2);         opSymb("&",0)        = "||";            opSymb("&",1)        = "&&";
    opFuncEquiv.resize(2);    opFuncEquiv("&",0)   = "lor";           opFuncEquiv("&",1)   = "land";
    opRevBinOrder.resize(2);  opRevBinOrder("&",0) = 0;               opRevBinOrder("&",1) = 0;

    if ( ( res = operatorToFunction(0,1,opSymb,opFuncEquiv,opRevBinOrder,srcxblock) ) ) { return res; }

    // Sanity check - should only have one block left

    if ( srcxblock.size() != 1 )
    {
//errstream() << "phantomxy 6\n";
	return -1;
    }

    // Finally, we need to reconstruct srcx from the blocks

    srcx = srcxblock(0).text;

//errstream() << "phantomxy 7\n";
    return res;
}

// NB: matrices and vectors (and in fact numbers in general) are
// parsed back to operator>>, which then calls down for individual
// function elements to get back to here.


void subeforE(std::string &src)
{
    if ( src.length() )
    {
        size_t i;

        for ( i = 0 ; i < src.length() ; ++i )
        {
            if ( src[i] == 'E' )
            {
                src[i] = 'e';
            }
        }
    }

    return;
}


// This is a very naive function parser that assumes that the
// function is either a number or in the form
//
// fnname(a,b,...)
//
// where fnname is purely alphanumeric starting with alpha, and
// a,b,... are in the same format.  It does check that each function
// gets the correct number of arguments.  It is simple because it
// is purely recursive and can "hang off" the input stream operator
// if it finds a number.  It assumes brackets are correctly paired.
// The only real complexities is that it needs to check if the string
// is simply "i", "I", "J", .. etc for anions, and [ for vectors, and
// M: for matricies

int gentype::makeEqnInternal(const std::string &src)
{
    deleteVectMatMem();

    int res;
    int i,m,n;
    int AShilton = 0;

    typeis = 'F';

    bool isconst = false;
    isNomConst = false;

    res = processNumLtoR(0,i,src,isconst);

    if ( res == -1 )
    {
	makeError("Syntax error: illformed number.");

	return -1;
    }

    else if ( res == 1 )
    {
        // Type: int

/*
        int zres;
	std::stringstream resbuffer;

	resbuffer << src;
	resbuffer >> zres;

        *this = zres;
*/
        *this = std::stoi(src);
        isNomConst = isconst;
    }

    else if ( res == 2 )
    {
        // Type: real

        // Must deal with E to e substitution first

        std::string locsrc(src);
        subeforE(locsrc);

/*
        double rres;
	std::stringstream resbuffer;

        resbuffer << locsrc;
	resbuffer >> rres;

        *this = rres;
*/
        *this = std::stod(src);
        isNomConst = isconst;
    }

    else if ( res == 3 )
    {
        // Type: anion

        // Must deal with E to e substitution first

        std::string locsrc(src);
        subeforE(locsrc);

        d_anion ares;
	std::stringstream resbuffer;

        resbuffer << locsrc;
	resbuffer >> ares;

        *this = ares;
    }

    else if ( res == 6 )
    {
        // Type: string

        makeString(src.substr(1,src.length()-2));
    }

    else if ( res == 7 )
    {
        // Type: error

	i = 0;

	while ( src[i] != '\"' )
	{
	    ++i;

            NiceAssert( i < (int) src.length() );
	}

	makeError(src.substr(i+1,src.length()-i-2));
    }

    else if ( res == 4 )
    {
        // Type: vector

        Vector<gentype> vres;
	std::stringstream resbuffer;

        NiceAssert( src.length() >= 2 );

        if ( src.length() == 2 )
        {
            ; // []
        }

        else if ( std::isspace(src[1]) && std::isspace(src[src.length()-2]) )
        {
            resbuffer << src;
            resbuffer >> vres;
        }

        else
        {
            // Need to put in spaces

            std::string altsrc;

            altsrc = "[ ";
            altsrc += src.substr(1,(src.length())-2);
            altsrc += " ]";

            resbuffer << altsrc;
            resbuffer >> vres;
        }

        *this = vres;
    }

    else if ( res == 5 )
    {
        // Type: matrix

        Matrix<gentype> mres;
	std::stringstream resbuffer;

	i = 0;

	while ( src[i] != '[' )
	{
	    ++i;

            NiceAssert( i < (int) src.length() );
	}

        NiceAssert( src.length()-i >= 2 );

        if ( src.length()-i == 2 )
        {
            ; // []
        }

        else if ( std::isspace(src[i+1]) && std::isspace(src[src.length()-2]) )
        {
            resbuffer << src.substr(i,(src.length())-i);
            resbuffer >> mres;
        }

        else
        {
            // Need to put in spaces

            std::string altsrc;

            altsrc = "[ ";
            altsrc += src.substr(i+1,(src.length())-2);
            altsrc += " ]";

            resbuffer << altsrc;
            resbuffer >> mres;
        }

        *this = mres;
    }

    else if ( res == 8 )
    {
        // Type: set

        Set<gentype> sres;
	std::stringstream resbuffer;

        NiceAssert( src.length() >= 2 );

        if ( src.length() == 2 )
        {
            ; // {}
        }

        else if ( std::isspace(src[1]) && std::isspace(src[src.length()-2]) )
        {
            resbuffer << src;
            resbuffer >> sres;
        }

        else if ( src[1] != '*' )
        {
            // Need to put in spaces

            std::string altsrc;

            altsrc = "{ ";
            altsrc += src.substr(1,(src.length())-2);
            altsrc += " }";

            resbuffer << altsrc;
            resbuffer >> sres;
        }

        else
        {
            // Infinite sets are {*} - DON'T PUT IN SPACES!

            std::string altsrc;

            altsrc = "{";
            altsrc += src.substr(1,(src.length())-2);
            altsrc += "}";

            resbuffer << altsrc;
            resbuffer >> sres;
        }

        *this = sres;
    }

    else if ( res == 9 )
    {
        // Type: dgraph

        Dgraph<gentype,double> dgres;
	std::stringstream resbuffer;

	i = 0;

        while ( src[i] != '{' )
	{
	    ++i;

            NiceAssert( i < (int) src.length() );
	}

        NiceAssert( src.length()-i >= 2 );

        if ( src.length()-i == 2 )
        {
            ; // {}
        }

        else if ( std::isspace(src[i+1]) && std::isspace(src[src.length()-2]) )
        {
            resbuffer << src.substr(i,(src.length())-i);
            resbuffer >> dgres;
        }

        else
        {
            // Need to put in spaces

            std::string altsrc;

            altsrc = "{ ";
            altsrc += src.substr(i+1,(src.length())-2);
            altsrc += " }";

            resbuffer << altsrc;
            resbuffer >> dgres;
        }

        *this = dgres;
    }

    else if ( res == 10 )
    {
        // Type: dict

        Dict<gentype,dictkey> sres;
	std::stringstream resbuffer;

        NiceAssert( src.length() >= 2 );

        if ( src.length() == 2 )
        {
            ; // {}
        }

        else if ( std::isspace(src[1]) && std::isspace(src[src.length()-2]) )
        {
            resbuffer << src;
            resbuffer >> sres;
        }

        else
        {
            // Need to put in spaces

            std::string altsrc;

            altsrc = "{{ ";
            altsrc += src.substr(2,(src.length())-3);
            altsrc += " }}";

            resbuffer << altsrc;
            resbuffer >> sres;
        }

        *this = sres;
    }

    else
    {
        // Syntax error

	Vector<int> commapos;
        std::string locfnname;

        res = processExprLtoR(0,i,AShilton,src,locfnname,commapos);

        if ( ( res == -1 ) || !res || AShilton )
	{
	    makeError("Syntax error: illformed expression.");

	    return -1;
	}

        fnnameind = getfnind(locfnname);

        if ( -1 == fnnameind )
        {
            makeError("Syntax error: no function "+locfnname+" found.");

            return -1;
        }

        thisfninfo = getfninfo(fnnameind);

        if ( thisfninfo == nullptr )
        {
            makeError("Syntax error: no function information found (bug).");

            return -1;
        }

	// Check number of arguments is correct

        --res;

        if ( res != (*thisfninfo).numargs )
        {
            std::string llocfnname(getfnname(fnnameind));

            makeError("Syntax error: wrong number of arguments for "+llocfnname+".");

            return -1;
        }

	// Process arguments

	MEMNEW(eqnargs,Vector<gentype>(res));

        NiceAssert( eqnargs );

	if ( res )
	{
	    int resb;

	    for ( i = 0 ; i < res ; ++i )
	    {
		if ( i == 0 )
		{
		    if ( res == 1 )
		    {
                        m = (int) (locfnname.length())+1;
			n = (int) (src.length())-2;
		    }

		    else
		    {
                        m = (int) (locfnname.length())+1;
			n = (commapos(i))-1;
		    }
		}

		else if ( i == res-1 )
		{
		    m = (commapos(i-1))+1;
		    n = (int) (src.length())-2;
		}

		else
		{
		    m = (commapos(i-1))+1;
		    n = (commapos(i))-1;
		}

                NiceAssert( eqnargs );

                resb = ((*eqnargs)("&",i)).makeEqnInternal(src.substr(m,n-m+1));

		if ( resb )
		{
		    std::string errstris = ((*eqnargs)(i)).cast_string(0);

                    makeError(errstris);

                    return resb;
		}
	    }
	}
    }

    return 0;
}






















// Global functions.  This function table is access by fnB(i,arg) in
// gentype and allows gentype to build on top of pretty much anything

void defaultfnaddrE(int i, int j, gentype &res, const gentype &xa, int ia, const gentype &xb, int ib);
void defaultfnaddrE(int i, int j, gentype &res, const gentype &xa, int ia, const gentype &xb, int ib)
{
    (void) i;
    (void) j;
    (void) xa;
    (void) ia;
    (void) xb;
    (void) ib;

    res.force_null();

    return;
}

void edefaultfnaddrE(int i, int j, Vector<gentype> &eres, const Vector<gentype> &exa, int ia, const Vector<gentype> &exb, int ib);
void edefaultfnaddrE(int i, int j, Vector<gentype> &eres, const Vector<gentype> &exa, int ia, const Vector<gentype> &exb, int ib)
{
    (void) i;
    (void) j;
    (void) exa;
    (void) ia;
    (void) exb;
    (void) ib;

    eres.resize(0);

    return;
}

GenFunc &setzero(GenFunc &x);
GenFunc &setzero(GenFunc &x)
{
    x = defaultfnaddrE;

    return x;
}

void qswap(GenFunc &a, GenFunc &b);
void qswap(GenFunc &a, GenFunc &b)
{
    GenFunc c(a);

    a = b;
    b = c;

    return;
}

eGenFunc &setzero(eGenFunc &x);
eGenFunc &setzero(eGenFunc &x)
{
    x = edefaultfnaddrE;

    return x;
}

void qswap(eGenFunc &a, eGenFunc &b);
void qswap(eGenFunc &a, eGenFunc &b)
{
    eGenFunc c(a);

    a = b;
    b = c;

    return;
}

void getsetunsetgenFunc (int i, int j, int mode, const  GenFunc fnaddr, const gentype &xa, int ia, const gentype &xb, int ib, gentype &res, int &ires);
void getsetunsetegenFunc(int i, int j, int mode, const eGenFunc fnaddr, const Vector<gentype> &exa, int ia, const Vector<gentype> &exb, int ib, Vector<gentype> &eres, int &ires);

void setGenFunc(const GenFunc fnaddr)
{
    gentype res;
    int ires = 0;

    const gentype xa;
    int ia = 0;
    const gentype xb;
    int ib = 0;

    getsetunsetgenFunc(0,0,0,fnaddr,xa,ia,xb,ib,res,ires);

    return;
}

static void evalgenFunc(int i, int j, const gentype &xa, int ia, const gentype &xb, int ib, gentype &res)
{
    int ires = 0;

    getsetunsetgenFunc(i,j,1,defaultfnaddrE,xa,ia,xb,ib,res,ires);

    return;
}

void getsetunsetgenFunc(int i, int j, int mode, const GenFunc fnaddr, const gentype &xa, int ia, const gentype &xb, int ib, gentype &res, int &ires)
{
    res.force_null();

    ires = 0;

    static GenFunc funcTable = defaultfnaddrE;

    switch ( mode )
    {
        case 0:
        {
            funcTable = fnaddr;

            break;
        }

        default:
        {
            NiceAssert( mode == 1 );

            (*funcTable)(i,j,res,xa,ia,xb,ib);

            break;
        }
    }

    return;
}

void seteGenFunc(const eGenFunc fnaddr)
{
    Vector<gentype> res;
    int ires = 0;

    const Vector<gentype> xa;
    int ia = 0;
    const Vector<gentype> xb;
    int ib = 0;

    getsetunsetegenFunc(0,0,0,fnaddr,xa,ia,xb,ib,res,ires);

    return;
}

void evalegenFunc(int i, int j, const Vector<gentype> &exa, int ia, const Vector<gentype> &exb, int ib, Vector<gentype> &eres)
{
    int ires = 0;

    getsetunsetegenFunc(i,j,1,edefaultfnaddrE,exa,ia,exb,ib,eres,ires);

    return;
}

void getsetunsetegenFunc(int i, int j, int mode, const eGenFunc fnaddr, const Vector<gentype> &exa, int ia, const Vector<gentype> &exb, int ib, Vector<gentype> &eres, int &ires)
{
    NiceAssert( exa.size() == exb.size() );

    eres.resize(exa.size());

    int k;

    for ( k = 0 ; k < exa.size() ; ++k )
    {
        eres("&",k).force_null();
    }

    ires = 0;

    static eGenFunc funcTable = edefaultfnaddrE;

    switch ( mode )
    {
        case 0:
        {
            funcTable = fnaddr;

            break;
        }

        default:
        {
            NiceAssert( mode == 1 );

            (*funcTable)(i,j,eres,exa,ia,exb,ib);

            break;
        }
    }

    return;
}










gentype gentype::var(const SparseVector<SparseVector<gentype> > &evalargs, const Vector<gentype> &argres) const
{
    int i,j;
    gentype res;

    if ( argres(0).isValVector() && argres(1).isValVector() )
    {
	Vector<gentype> locargres(argres);
        Vector<gentype> ii(argres(0).cast_vector(0));
	Vector<gentype> jj(argres(1).cast_vector(0));
        Matrix<gentype> tempres(argres(0).size(),argres(1).size());

        for ( i = 0 ; i < argres(0).size() ; ++i )
	{
	    for ( j = 0 ; j < argres(1).size() ; ++j )
	    {
		locargres("&",0) = ii(i);
		locargres("&",1) = jj(j);
		tempres("&",i,j) = var(evalargs,locargres);
	    }
	}

        res = tempres;
    }

    else if ( argres(0).isValVector() )
    {
	Vector<gentype> locargres(argres);
        Vector<gentype> ii(argres(0).cast_vector(0));
        Vector<gentype> tempres(argres(0).size());

        locargres("&",1) = argres(1);

        for ( i = 0 ; i < argres(0).size() ; ++i )
	{
	    locargres("&",0) = ii(i);
	    tempres("&",i) = var(evalargs,locargres);
	}

        res = tempres;
    }

    else if ( argres(1).isValVector() )
    {
	Vector<gentype> locargres(argres);
	Vector<gentype> jj(argres(1).cast_vector(0));
        Vector<gentype> tempres(argres(1).size());

        locargres("&",0) = argres(0);

	for ( j = 0 ; j < argres(1).size() ; ++j )
	{
	    locargres("&",1) = jj(j);
            tempres("&",j) = var(evalargs,locargres);
	}

        res = tempres;
    }

    else if ( argres(0).isCastableToIntegerWithoutLoss() && argres(1).isCastableToIntegerWithoutLoss() )
    {
	i = argres(0).cast_int(0);
	j = argres(1).cast_int(0);

	if ( (evalargs.isindpresent(i)) )
	{
            // We don't want to touch (evalargs)(i) unless we know that
            // it is present, as touching this will automatically cause
            // it's creation otherwise, which we do not want.

            if ( ((evalargs)(i).isindpresent(j)) )
	    {
		res = evalargs(i)(j);
	    }

	    else
	    {
                nearcopy(res,argres);
	    }
	}

	else
	{
	    nearcopy(res,argres);
	}
    }

    else if ( argres(0).isValEqn() || argres(1).isValEqn() )
    {
        std::string locfnname(getfnname(fnnameind));

        res = locfnname+"(x,y)"; // could be var or Var
        res = res(argres(0),argres(1));
    }

    else
    {
	constructError(argres(0),argres(1),res,"Variable indices must be integer (or matrix/vector thereof).");
    }

    return res;
}

int gentype::OP_var(const SparseVector<SparseVector<gentype> > &evalargs)
{
    int res = 0;
    int i,j;

    // Assumption here: this function == var

    NiceAssert( eqnargs );

    if ( (*eqnargs)(0).isValVector() && (*eqnargs)(1).isValVector() )
    {
        Vector<gentype> locargres((*eqnargs));
        Vector<gentype> ii((*eqnargs)(0).cast_vector(0));
        Vector<gentype> jj((*eqnargs)(1).cast_vector(0));
        Matrix<gentype> tempres((*eqnargs)(0).size(),(*eqnargs)(1).size());

        for ( i = 0 ; i < (*eqnargs)(0).size() ; ++i )
	{
            for ( j = 0 ; j < (*eqnargs)(1).size() ; ++j )
	    {
		locargres("&",0) = ii(i);
		locargres("&",1) = jj(j);
		tempres("&",i,j) = var(evalargs,locargres);
	    }
	}

        res = 1;
        *this = tempres;
    }

    else if ( (*eqnargs)(0).isValVector() )
    {
        Vector<gentype> locargres((*eqnargs));
        Vector<gentype> ii((*eqnargs)(0).cast_vector(0));
        Vector<gentype> tempres((*eqnargs)(0).size());

        locargres("&",1) = (*eqnargs)(1);

        for ( i = 0 ; i < (*eqnargs)(0).size() ; ++i )
	{
	    locargres("&",0) = ii(i);
	    tempres("&",i) = var(evalargs,locargres);
	}

        res = 1;
        *this = tempres;
    }

    else if ( (*eqnargs)(1).isValVector() )
    {
        Vector<gentype> locargres((*eqnargs));
        Vector<gentype> jj((*eqnargs)(1).cast_vector(0));
        Vector<gentype> tempres((*eqnargs)(1).size());

        locargres("&",0) = (*eqnargs)(0);

        for ( j = 0 ; j < (*eqnargs)(1).size() ; ++j )
	{
	    locargres("&",1) = jj(j);
            tempres("&",j) = var(evalargs,locargres);
	}

        res = 1;
        *this = tempres;
    }

    else if ( (*eqnargs)(0).isCastableToIntegerWithoutLoss() && (*eqnargs)(1).isCastableToIntegerWithoutLoss() )
    {
        i = (*eqnargs)(0).cast_int(0);
        j = (*eqnargs)(1).cast_int(0);

	if ( (evalargs.isindpresent(i)) )
	{
            // We don't want to touch (evalargs)(i) unless we know that
            // it is present, as touching this will automatically cause
            // it's creation otherwise, which we do not want.

            if ( ((evalargs)(i).isindpresent(j)) )
	    {
                res = 1;
                fastcopy(evalargs(i)(j),1);
	    }
	}
    }

    else if ( (*eqnargs)(0).isValEqn() || (*eqnargs)(1).isValEqn() )
    {
        ;
    }

    else
    {
        constructError((*eqnargs)(0),(*eqnargs)(1),*this,"Variable indices must be integer (or matrix/vector thereof).");
    }

    return res;
}

// Given a string and a starting brace, find matching end brace
// and set end to relevant position.  LRorRL is 0 for left to right,
// 1 for right to left.  Returns 0 on success, 1 on failure.

static int pairBrackets(int start, int &end, const std::string &src, int LRorRL)
{
    NiceAssert( start >= 0 );
    NiceAssert( start < (int) src.length() );

//errstream() << "phantomxyza 0\n";
    if ( !LRorRL && !( ( src[start] == '(' ) || ( src[start] == '[' ) || ( src[start] == '{' ) || ( src[start] == '\"' ) ) )
    {
        end = start;
//errstream() << "phantomxyza 1\n";
        return 1;
    }

    if (  LRorRL && !( ( src[start] == ')' ) || ( src[start] == ']' ) || ( src[start] == '}' ) || ( src[start] == '\"' ) ) )
    {
        end = start;
//errstream() << "phantomxyza 2\n";
        return 1;
    }

    int curvecount = 0;
    int squarecount = 0;
    int curlycount = 0;
    int quotecount = 0;
    int justgo = 1;
    char charlast = ' ';

    end = start;

//errstream() << "phantomxyza 3\n";
    while ( justgo || curvecount || squarecount || curlycount || quotecount )
    {
	justgo = 0;
//errstream() << "phantomxyza 4\n";

	if ( ( end < 0 ) || ( end >= (int) src.length() ) )
	{
	    end = start;
//errstream() << "phantomxyza 4b\n";
            return 1;
	}

	if ( src[end] == '(' && !quotecount ) { ++curvecount; }
	if ( src[end] == ')' && !quotecount ) { --curvecount; }

	if ( src[end] == '[' && !quotecount ) { ++squarecount; }
	if ( src[end] == ']' && !quotecount ) { --squarecount; }

	if ( src[end] == '{' && !quotecount ) { ++curlycount; }
	if ( src[end] == '}' && !quotecount ) { --curlycount; }

//errstream() << "phantomxyza 5: " << src[end] << "," << charlast << "\n";
	if ( ( src[end] == '\"' ) && ( charlast != '\\' ) ) { quotecount = quotecount ? 0 : 1; }

	if ( !LRorRL && ( ( curvecount < 0 ) || ( squarecount < 0 ) || ( curlycount < 0 ) ) )
	{
	    end = start;
//errstream() << "phantomxyza 6\n";
            return 1;
	}

	if (  LRorRL && ( ( curvecount > 0 ) || ( squarecount > 0 ) || ( curlycount > 0 ) ) )
	{
	    end = start;
//errstream() << "phantomxyza 7\n";
            return 1;
	}

	charlast = src[end];
//errstream() << "phantomxyza 8: " << src[end] << "," << charlast << "\n";

	if ( !LRorRL ) { ++end; }
	else           { --end; }
    }

    if ( !LRorRL ) { --end; }
    else           { ++end; }

//errstream() << "phantomxyza 9\n";
    return 0;
}

// Given a string src and a starting point start, working from left
// to right, return NZ if a number is located at this point and 0
// otherwise (-1 for error).  A number can be any gentype that isn't
// an equation - that is: an integer, real, anion, vector, matrix of
// string:
//
// Integers: a                      a is a sequence of {0123456789}
// Reals:    a{.b}{[e or E]{-}c}    a is a sequence of {0123456789}
//                                  b is a sequence of {0123456789}
//                                  c is a sequence of {0123456789}
//           .b{[e or E]{-}c}       b is a sequence of {0123456789}
//                                  c is a sequence of {0123456789}
// Anions:   {r}s                   r is a real number
//                                  s is one of {iIJKlmnopqr}
// Vectors:  [ ... ]                the relevant end ] can be detected by pairing of brackets
// Matrices: M:[ ... ]              the relevant end ] can be detected by pairing of brackets
// Sets:     { ... }                the relevant end } can be detected by pairing of brackets
// Dgraph:   G:{ ... }              the relevant end } can be detected by pairing of brackets
// String:   "..."                  the second quote not preceeded by \ is the end quote
//
// return:
//
// 0 if not a number
// 1 if integer
// 2 if real
// 3 if anion
// 4 if vector
// 5 if matrix
// 6 if string
// 7 if an error
// 8 if set
// 9 if dgraph
// 10 if dict
// -1 if a syntax error occurs.
//
// Note that we don't include any preceeding -, as this unary operator
// must be dealt with in correct order, for example to ensure that -3! = -6

static int processNumLtoR(int start, int &end, const std::string &src, bool &isconst)
{
    isconst = false;

    int res = 0;

    NiceAssert( start >= 0 );
    NiceAssert( start < (int) src.length() );

    end = start;

    // Intentionally not using else statements here to allow fall-through

//errstream() << "phantomxyz 0\n";
    if ( !res && ( ( src[start] == 'i' ) || ( src[start] == 'I' ) || ( src[start] == 'J' ) ||
                   ( src[start] == 'K' ) || ( src[start] == 'l' ) || ( src[start] == 'm' ) ||
		   ( src[start] == 'n' ) || ( src[start] == 'o' ) || ( src[start] == 'p' ) ||
		   ( src[start] == 'q' ) || ( src[start] == 'r' )                             ) )
    {
	if ( end == ((int) src.length())-1 )
	{
            res = 3;
	}

	else
	{
            if ( !(  ( src[end+1] == 'a' ) || ( src[end+1] == 'b' ) || ( src[end+1] == 'c' ) || ( src[end+1] == 'd' ) || ( src[end+1] == 'e' ) || ( src[end+1] == 'f' ) || ( src[end+1] == 'g' ) ||
                     ( src[end+1] == 'h' ) || ( src[end+1] == 'i' ) || ( src[end+1] == 'j' ) || ( src[end+1] == 'k' ) || ( src[end+1] == 'l' ) || ( src[end+1] == 'm' ) || ( src[end+1] == 'n' ) ||
                     ( src[end+1] == 'o' ) || ( src[end+1] == 'p' ) || ( src[end+1] == 'q' ) || ( src[end+1] == 'r' ) || ( src[end+1] == 's' ) || ( src[end+1] == 't' ) || ( src[end+1] == 'u' ) ||
                     ( src[end+1] == 'v' ) || ( src[end+1] == 'w' ) || ( src[end+1] == 'x' ) || ( src[end+1] == 'y' ) || ( src[end+1] == 'z' ) || //( src[end+1] == '_' ) ||
                     ( src[end+1] == 'A' ) || ( src[end+1] == 'B' ) || ( src[end+1] == 'C' ) || ( src[end+1] == 'D' ) || ( src[end+1] == 'E' ) || ( src[end+1] == 'F' ) || ( src[end+1] == 'G' ) ||
                     ( src[end+1] == 'H' ) || ( src[end+1] == 'I' ) || ( src[end+1] == 'J' ) || ( src[end+1] == 'K' ) || ( src[end+1] == 'L' ) || ( src[end+1] == 'M' ) || ( src[end+1] == 'N' ) ||
                     ( src[end+1] == 'O' ) || ( src[end+1] == 'P' ) || ( src[end+1] == 'Q' ) || ( src[end+1] == 'R' ) || ( src[end+1] == 'S' ) || ( src[end+1] == 'T' ) || ( src[end+1] == 'U' ) ||
	             ( src[end+1] == 'V' ) || ( src[end+1] == 'W' ) || ( src[end+1] == 'X' ) || ( src[end+1] == 'Y' ) || ( src[end+1] == 'Z' ) || ( src[end+1] == '(' ) ||
	              ( ( end != start ) && ( ( src[end+1] == '0' ) || ( src[end+1] == '1' ) || ( src[end+1] == '2' ) || ( src[end+1] == '3' ) || ( src[end+1] == '4' ) || ( src[end+1] == '5' ) ||
		           		      ( src[end+1] == '6' ) || ( src[end+1] == '7' ) || ( src[end+1] == '8' ) || ( src[end+1] == '9' ) ) ) ) )
	    {
		res = 3;
	    }
	}
    }

    if ( !res && ( ( src[start] == '0' ) || ( src[start] == '1' ) || ( src[start] == '2' ) ||
                   ( src[start] == '3' ) || ( src[start] == '4' ) || ( src[start] == '5' ) ||
		   ( src[start] == '6' ) || ( src[start] == '7' ) || ( src[start] == '8' ) ||
		   ( src[start] == '9' )                                                      ) )
    {
	// This might be an integer.  Begin by finding end of numeric block

	res = 1;

	while ( ( src[end] == '0' ) || ( src[end] == '1' ) || ( src[end] == '2' ) ||
	      	( src[end] == '3' ) || ( src[end] == '4' ) || ( src[end] == '5' ) ||
		( src[end] == '6' ) || ( src[end] == '7' ) || ( src[end] == '8' ) ||
		( src[end] == '9' )                                                  )
	{
	    ++end;

	    if ( end >= (int) src.length() )
	    {
                break;
	    }
	}

	--end;

        // c at end could indicate a constant integer

        bool iscend = false;

        if ( ( end+1 < (int) src.length() ) && ( src[end+1] == 'c' ) )
        {
            iscend = true;
            ++end;
        }

        // If numeric block is followed by . e E i I J K l m n o p q r then
        // this is not a numeric block

	if ( end+1 < (int) src.length() )
	{
	    if ( src[end+1] == '.' )
	    {
                // Need to know if this is an operator (eg .*) or part of a
                // real (eg .0)
		++end;
                ++end;

	        if ( end >= (int) src.length() )
		{
                    //. should never occur at the end of an equation

		    end = start-1;
		    return -1;
		}

		else if ( ( src[end] == '0' ) || ( src[end] == '1' ) || ( src[end] == '2' ) ||
		          ( src[end] == '3' ) || ( src[end] == '4' ) || ( src[end] == '5' ) ||
		          ( src[end] == '6' ) || ( src[end] == '7' ) || ( src[end] == '8' ) ||
		          ( src[end] == '9' )                                                  )
		{
                    if ( iscend )
                    {
                        // Makes no sense

                        end = start-1;
                        return -1;
                    }

                    else
                    {
                        // Not an integer, might be a real

                        res = 0;
                        end = start;
                    }
		}

		else
		{
		    // . operator after an integer

                    if ( iscend )
                    {
                        isconst = true;
                    }

		    --end;
		    --end;
		}
	    }

            else if ( ( src[end+1] == 'e' ) || ( src[end+1] == 'E' ) || ( src[end+1] == 'i' ) ||
                      ( src[end+1] == 'I' ) || ( src[end+1] == 'J' ) || ( src[end+1] == 'K' ) ||
                      ( src[end+1] == 'l' ) || ( src[end+1] == 'm' ) || ( src[end+1] == 'n' ) ||
                      ( src[end+1] == 'o' ) || ( src[end+1] == 'p' ) || ( src[end+1] == 'q' ) ||
                      ( src[end+1] == 'r' )    )
	    {
                if ( iscend )
                {
                    // Makes no sense

                    end = start-1;
                    return -1;
                }

                else
                {
                    // could be an anion, could be a real

                    res = 0;
                    end = start;
                }
	    }

            else if ( iscend )
            {
                isconst = true;
            }
	}

        else if ( iscend )
        {
            isconst = true;
        }
    }

    if ( !res && ( ( src[start] == '0' ) || ( src[start] == '1' ) || ( src[start] == '2' ) ||
                   ( src[start] == '3' ) || ( src[start] == '4' ) || ( src[start] == '5' ) ||
		   ( src[start] == '6' ) || ( src[start] == '7' ) || ( src[start] == '8' ) ||
		   ( src[start] == '9' ) || ( src[start] == '.' )                             ) )
    {
	// This might be a real or an anion.  Begin by finding end of the first numeric block

	res = 2;

	if ( src[end] != '.' )
	{
	    while ( ( src[end] == '0' ) || ( src[end] == '1' ) || ( src[end] == '2' ) ||
		    ( src[end] == '3' ) || ( src[end] == '4' ) || ( src[end] == '5' ) ||
		    ( src[end] == '6' ) || ( src[end] == '7' ) || ( src[end] == '8' ) ||
		    ( src[end] == '9' )                                                  )
	    {
		++end;

		if ( end >= (int) src.length() )
		{
		    break;
		}
	    }
	}

        // Must be outside of loop to correctly catch reals starting with a .

	--end;

	// Next we might get a decimal point, which must be followed by a numeric block.
	// Note that we can't have an operator like .* here as this would have been caught
        // by the integer case.

	if ( end+1 < (int) src.length() )
	{
	    if ( src[end+1] == '.' )
	    {
	        ++end;
	        ++end;

	        if ( end >= (int) src.length() )
	        {
	            // Can't have a . at the end of a string

	            end = start-1;
	            return -1;
	        }

	        int tempend = end-1;

		while ( ( src[end] == '0' ) || ( src[end] == '1' ) || ( src[end] == '2' ) ||
		        ( src[end] == '3' ) || ( src[end] == '4' ) || ( src[end] == '5' ) ||
		        ( src[end] == '6' ) || ( src[end] == '7' ) || ( src[end] == '8' ) ||
		        ( src[end] == '9' )                                                  )
		{
		    ++end;

		    if ( end >= (int) src.length() )
		    {
			break;
		    }
		}

		--end;

		if ( end <= tempend )
		{
		    if ( end <= start )
		    {
			// Must be an operator starting with .

			end = start-1;
			return 0;
		    }

		    else
		    {
			// Case can't happen as it would have been caught by the integer code above

			end = start-1;
			return -1;
		    }
	        }
	    }
	}

	// After that we might get an e, possibly followed by -, then must be followed by a numeric block

	if ( end+1 < (int) src.length() )
	{
            if ( ( src[end+1] == 'e' ) || ( src[end+1] == 'E' ) )
	    {
	        ++end;
                ++end;

	        if ( end >= (int) src.length() )
	        {
	            end = start-1;
	            return -1;
	        }

	        if ( src[end] == '-' )
	        {
	            ++end;
	        }

	        if ( end >= (int) src.length() )
	        {
	            end = start-1;
	            return -1;
	        }

	        int tempend = end-1;

	        while ( ( src[end] == '0' ) || ( src[end] == '1' ) || ( src[end] == '2' ) ||
	                ( src[end] == '3' ) || ( src[end] == '4' ) || ( src[end] == '5' ) ||
	                ( src[end] == '6' ) || ( src[end] == '7' ) || ( src[end] == '8' ) ||
	                ( src[end] == '9' )                                                  )
	        {
	            ++end;

	            if ( end >= (int) src.length() )
	            {
	                break;
	            }
	        }

	        --end;

	        if ( end <= tempend )
	        {
	            end = start-1;
	            return -1;
	        }
	    }
	}

        // c at end could indicate a constant real

        bool iscend = false;

        if ( ( end+1 < (int) src.length() ) && ( src[end+1] == 'c' ) )
        {
            iscend = true;
            ++end;
        }

        // Finally, if this is a quaternion, there may be an i I J K l m n o p q r at the end

	if ( end+1 < (int) src.length() )
	{
	    if ( ( src[end+1] == 'i' ) || ( src[end+1] == 'I' ) || ( src[end+1] == 'J' ) ||
		 ( src[end+1] == 'K' ) || ( src[end+1] == 'l' ) || ( src[end+1] == 'm' ) ||
		 ( src[end+1] == 'n' ) || ( src[end+1] == 'o' ) || ( src[end+1] == 'p' ) ||
		 ( src[end+1] == 'q' ) || ( src[end+1] == 'r' )                             )
	    {
                if ( iscend )
                {
                    // Makes no sense

                    end = start-1;
                    return -1;
                }

                else
                {
		    res = 3;
                    ++end;
                }
	    }
	}

        else if ( iscend )
        {
            isconst = true;
        }
    }

    if ( !res && ( src[start] == '[' ) )
    {
	res = 4;

	if ( pairBrackets(start,end,src,0) )
	{
	    end = start-1;
            return -1;
	}
    }

    if ( !res && ( src[start] == 'M' ) )
    {
	++end;

	if ( end >= (int) src.length() )
	{
	    end = start-1;
	    return -1;
	}

	if ( src[end] == ':' )
	{
	    res = 5;

	    ++end;

	    if ( end >= (int) src.length() )
	    {
		end = start-1;
		return -1;
	    }

	    while ( isspace(src[end]) )
	    {
		++end;

		if ( end >= (int) src.length() )
		{
		    end = start-1;
		    return -1;
		}
	    }

	    if ( src[end] != '[' )
	    {
		end = start-1;
		return -1;
	    }

	    // Note: first instance of start passed as value, second instance by reference

	    if ( pairBrackets(end,end,src,0) )
	    {
		end = start-1;
		return -1;
	    }
	}
    }

    if ( !res && ( src[start] == '{' ) && ( src[start+1] != '{' ) )
    {
        res = 8;

	if ( pairBrackets(start,end,src,0) )
	{
	    end = start-1;
            return -1;
	}
    }

    if ( !res && ( src[start] == '{' ) && ( src[start+1] == '{' ) )
    {
        res = 10;

	if ( pairBrackets(start,end,src,0) )
	{
	    end = start-1;
            return -1;
	}
    }

    if ( !res && ( src[start] == 'G' ) )
    {
	++end;

	if ( end >= (int) src.length() )
	{
	    end = start-1;
	    return -1;
	}

	if ( src[end] == ':' )
	{
            res = 9;

	    ++end;

	    if ( end >= (int) src.length() )
	    {
		end = start-1;
		return -1;
	    }

	    while ( isspace(src[end]) )
	    {
		++end;

		if ( end >= (int) src.length() )
		{
		    end = start-1;
		    return -1;
		}
	    }

            if ( src[end] != '{' )
	    {
		end = start-1;
		return -1;
	    }

	    // Note: first instance of start passed as value, second instance by reference

	    if ( pairBrackets(end,end,src,0) )
	    {
		end = start-1;
		return -1;
	    }
	}
    }

    if ( !res && ( src[start] == '\"' ) )
    {
//errstream() << "phantomxyz 1\n";
	res = 6;

	if ( pairBrackets(start,end,src,0) )
	{
	    end = start-1;
            return -1;
	}
    }

    if ( !res && ( ( src[start] == 'E' ) && ( start < (int) src.length()-1 ) ) )
    {
	++end;

	if ( end >= (int) src.length() )
	{
	    end = start-1;
	    return -1;
	}

	if ( src[end] == ':' )
	{
	    res = 7;

	    ++end;

	    if ( end >= (int) src.length() )
	    {
		end = start-1;
		return -1;
	    }

	    while ( isspace(src[end]) )
	    {
		++end;

		if ( end >= (int) src.length() )
		{
		    end = start-1;
		    return -1;
		}
	    }

	    if ( src[end] != '\"' )
	    {
		end = start-1;
		return -1;
	    }

	    // Note: first instance of start passed as value, second instance by reference

	    if ( pairBrackets(end,end,src,0) )
	    {
		end = start-1;
		return -1;
	    }
	}
    }

    return res;
}

// Given a string src and a starting point start, working from left
// to right, return numargs+1 if an expression number is located at
// this point and 0 otherwise (-1 for error).  exprname is a below.
// An expression is:
//
// {a}(b1,b2,...,bn)              a is an alphanumeric sequence starting with an alpha and possibly including _
//                                b. is something with paired brackets
//                                n is numargs
//
// Exceptions:
//
// - i,I,J,K,l,m,n,o,p,q,r, when not followed by a (, are numbers
//   and not syntax errors

static int processExprLtoR(int start, int &end, int &isitastring, const std::string &src, std::string &exprname, Vector<int> &commapos)
{
    int res = 0;
    int isexpr = 0;

    NiceAssert( start >= 0 );
    NiceAssert( start < (int) src.length() );

    commapos.resize(0);

    end = start;
    exprname = "";
    isitastring = 0;

    while (  ( src[end] == 'a' ) || ( src[end] == 'b' ) || ( src[end] == 'c' ) || ( src[end] == 'd' ) || ( src[end] == 'e' ) || ( src[end] == 'f' ) || ( src[end] == 'g' ) ||
             ( src[end] == 'h' ) || ( src[end] == 'i' ) || ( src[end] == 'j' ) || ( src[end] == 'k' ) || ( src[end] == 'l' ) || ( src[end] == 'm' ) || ( src[end] == 'n' ) ||
             ( src[end] == 'o' ) || ( src[end] == 'p' ) || ( src[end] == 'q' ) || ( src[end] == 'r' ) || ( src[end] == 's' ) || ( src[end] == 't' ) || ( src[end] == 'u' ) ||
             ( src[end] == 'v' ) || ( src[end] == 'w' ) || ( src[end] == 'x' ) || ( src[end] == 'y' ) || ( src[end] == 'z' ) || //( src[end] == '_' ) ||
             ( src[end] == 'A' ) || ( src[end] == 'B' ) || ( src[end] == 'C' ) || ( src[end] == 'D' ) || ( src[end] == 'E' ) || ( src[end] == 'F' ) || ( src[end] == 'G' ) ||
             ( src[end] == 'H' ) || ( src[end] == 'I' ) || ( src[end] == 'J' ) || ( src[end] == 'K' ) || ( src[end] == 'L' ) || ( src[end] == 'M' ) || ( src[end] == 'N' ) ||
             ( src[end] == 'O' ) || ( src[end] == 'P' ) || ( src[end] == 'Q' ) || ( src[end] == 'R' ) || ( src[end] == 'S' ) || ( src[end] == 'T' ) || ( src[end] == 'U' ) ||
	     ( src[end] == 'V' ) || ( src[end] == 'W' ) || ( src[end] == 'X' ) || ( src[end] == 'Y' ) || ( src[end] == 'Z' ) ||
	    ( ( end != start ) && ( ( src[end] == '0' ) || ( src[end] == '1' ) || ( src[end] == '2' ) || ( src[end] == '3' ) || ( src[end] == '4' ) || ( src[end] == '5' ) ||
				    ( src[end] == '6' ) || ( src[end] == '7' ) || ( src[end] == '8' ) || ( src[end] == '9' ) ) ) )
    {
	exprname += src[end];
	++end;

	if ( end >= (int) src.length() )
	{
            break;
	}
    }

    if ( ( end == start ) && ( src[end] != '(' ) )
    {
	// Definitely not an expression

	end = start-1;
        return 0;
    }

    if ( end < (int) src.length() )
    {
	// An expression is a string (possibly empty) followed by an expression
	// in brackets, so something(blah)

	if ( src[end] == '(' )
	{
	    isexpr = 1;

	    if ( end == ((int) src.length())-1 )
	    {
		// Unpaired brackets error

		exprname = "";
		end = start-1;
		return -1;
	    }
	}
    }

    // Allow for the possible strings that aren't expressions

    if ( !isexpr && ( ( exprname == "i" ) || ( exprname == "I" ) || ( exprname == "J" ) || ( exprname == "K" ) ||
		      ( exprname == "l" ) || ( exprname == "m" ) || ( exprname == "n" ) || ( exprname == "o" ) ||
		      ( exprname == "p" ) || ( exprname == "q" ) || ( exprname == "r" )                           ) )
    {
	exprname = "";
	end = start-1;
	return 0;
    }

    if ( isexpr )
    {
	int tempend = end;

	if ( pairBrackets(end,end,src,0) )
	{
	    // Unpaired brackets error

	    end = start-1;
            return -1;
	}

	if ( end == tempend+1 )
	{
	    // Brackets are (), so no arguments

            res = 1;
	}

	else
	{
	    // Brackets contain arguments - need to count the arguments and record where the commas are

	    res = 2;

            int i;
	    int curvecount = 0;
	    int squarecount = 0;
	    int curlycount = 0;
	    int quotecount = 0;
	    char charlast = ' ';

	    for ( i = tempend+1 ; i <= end-1 ; ++i )
	    {
		if ( src[i] == '(' ) { ++curvecount; }
		if ( src[i] == ')' ) { --curvecount; }

		if ( src[i] == '[' ) { ++squarecount; }
		if ( src[i] == ']' ) { --squarecount; }

		if ( src[i] == '{' ) { ++curlycount; }
		if ( src[i] == '}' ) { --curlycount; }

		if ( ( src[i] == '\"' ) && ( charlast != '\\' ) ) { quotecount = quotecount ? 0 : 1; }

		if ( ( src[i] == ',' ) && !curvecount && !squarecount && !curlycount && !quotecount ) { ++res; commapos.add(res-3); commapos("&",res-3) = i; }

		charlast = src[i];
	    }
	}
    }

    else
    {
	// This isn't an expression, but it is a string

	--end;
	isitastring = 1;
        res = 1;
    }

    return res;
}


std::ostream &operator<<(std::ostream &output, const eqninfoblock &src )
{
    output << "------------------------------------------\n";
    output << src.text   << "\n";
    output << src.type   << "\n";
    output << src.res    << "\n";
    output << src.fnname << "\n";
    output << src.commas << "\n";
    output << src.isstr  << "\n";
    output << "------------------------------------------\n";

    return output;
}

void qswap(eqninfoblock &a, eqninfoblock &b)
{
    qswap(a.text  ,b.text  );
    qswap(a.type  ,b.type  );
    qswap(a.res   ,b.res   );
    qswap(a.commas,b.commas);
    qswap(a.fnname,b.fnname);
    qswap(a.isstr ,b.isstr );

    return;
}

// Function to remove operators and replace them with equivalent functions
//
// Assumptions: unary operators right to left cleave to the right (eg a!+b is fine, but a+!b is not)
//              unary operators left to right cleave to the left (eg a||~b is fine, but a~||b is not)
//
// LtoRRtoL: 0 for LtoR, 1 for RtoL
// UnaryBinary: 0 for unary, 1 for binary
// opSymb: operator symbols
// opFuncEquiv: name of replacement function
// opRevBinOrder: 0 normal, 1 to reverse order of binary operators

int operatorToFunction(int LtoRRtoL, int UnaryBinary, const Vector<std::string> &opSymb, const Vector<std::string> &opFuncEquiv, const Vector<int> &opRevBinOrder, Vector<eqninfoblock> &srcxblock)
{
    // Big assumption enforced by the caller: the blocks alternate .../opblock/other/opblock/other/...

    NiceAssert( opSymb.size() == opFuncEquiv.size() );

    int i,j;

    if ( opSymb.size() && ( srcxblock.size() > 1 ) )
    {
	for ( i = ( LtoRRtoL ? srcxblock.size()-1 : 0 ) ; ( i >= 0 ) && ( i < srcxblock.size() ) ; i += ( LtoRRtoL ? -1 : +1 ) )
	{
	    if ( !(srcxblock(i).type) )
	    {
		// This is a block of operators

		if ( i == srcxblock.size()-1 )
		{
		    // Rightmost operator block

		    if ( LtoRRtoL && !UnaryBinary )
		    {
			for ( j = 0 ; j < opSymb.size() ; ++j )
			{
			    if ( opSymb(j) == (srcxblock(i).text).substr(0,opSymb(j).length()) )
			    {
				// Remove operator from operator block

				(srcxblock("&",i).text).erase(0,opSymb(j).length());

				// Insert functional equivalent around previous operator

				(srcxblock("&",i-1).text) = opFuncEquiv(j) + "(" + (srcxblock(i-1).text) + ")";

				// if block empty then remove and break

				if ( !((srcxblock(i).text).length()) )
				{
				    srcxblock.remove(i);
                                    break;
				}
			    }
			}
		    }
		}

		else if ( i == 0 )
		{
		    if ( !LtoRRtoL && !UnaryBinary )
		    {
			for ( j = 0 ; j < opSymb.size() ; ++j )
			{
			    if ( opSymb(j) == (srcxblock(i).text).substr(((srcxblock(i).text).length())-(opSymb(j).length()),opSymb(j).length()) )
			    {
				// Remove operator from operator block

				(srcxblock("&",i).text).erase(((srcxblock(i).text).length())-(opSymb(j).length()),opSymb(j).length());

				// Insert functional equivalent around next operator

				(srcxblock("&",i+1).text) = opFuncEquiv(j) + "(" + (srcxblock(i+1).text) + ")";

				// if block empty then remove and break

				if ( !((srcxblock(i).text).length()) )
				{
				    srcxblock.remove(i);
                                    --i;
                                    break;
				}
			    }
			}
		    }
		}

		else
		{
		    if ( LtoRRtoL && !UnaryBinary )
		    {
			for ( j = 0 ; j < opSymb.size() ; ++j )
			{
			    if ( opSymb(j) == (srcxblock(i).text).substr(0,opSymb(j).length()) )
			    {
				// Remove operator from operator block

				(srcxblock("&",i).text).erase(0,opSymb(j).length());

				// Insert functional equivalent around previous operator

				(srcxblock("&",i-1).text) = opFuncEquiv(j) + "(" + (srcxblock(i-1).text) + ")";

				// if block empty then remove and break

				if ( !((srcxblock(i).text).length()) )
				{
                                    return -1;
				}
			    }
			}
		    }

		    else if ( !LtoRRtoL && !UnaryBinary )
		    {
			for ( j = 0 ; j < opSymb.size() ; ++j )
			{
			    if ( opSymb(j) == (srcxblock(i).text).substr(((srcxblock(i).text).length())-(opSymb(j).length()),opSymb(j).length()) )
			    {
				// Remove operator from operator block

				(srcxblock("&",i).text).erase(((srcxblock(i).text).length())-(opSymb(j).length()),opSymb(j).length());

				// Insert functional equivalent around next operator

				(srcxblock("&",i+1).text) = opFuncEquiv(j) + "(" + (srcxblock(i+1).text) + ")";

				// if block empty then remove and break

				if ( !((srcxblock(i).text).length()) )
				{
                                    return -1;
				}
			    }
			}
		    }

		    else if ( LtoRRtoL && UnaryBinary )
		    {
			for ( j = 0 ; j < opSymb.size() ; ++j )
			{
			    if ( opSymb(j) == srcxblock(i).text )
			    {
				// Insert functional equivalent around previous operator

                                if ( !opRevBinOrder(j) )
                                {
                                    (srcxblock("&",i-1).text) = opFuncEquiv(j) + "(" + (srcxblock(i-1).text) + "," + (srcxblock(i+1).text) + ")";
                                }

                                else
                                {
                                    (srcxblock("&",i-1).text) = opFuncEquiv(j) + "(" + (srcxblock(i+1).text) + "," + (srcxblock(i-1).text) + ")";
                                }

				// Remove operator from operator block and right expression/number

				srcxblock.remove(i+1);
				srcxblock.remove(i);
				--i;
                                break;
			    }
			}
		    }

		    else if ( !LtoRRtoL && UnaryBinary )
		    {
			for ( j = 0 ; j < opSymb.size() ; ++j )
			{
			    if ( opSymb(j) == srcxblock(i).text )
			    {
				// Insert functional equivalent around previous operator

                                if ( !opRevBinOrder(j) )
                                {
                                    (srcxblock("&",i+1).text) = opFuncEquiv(j) + "(" + (srcxblock(i-1).text) + "," + (srcxblock(i+1).text) + ")";
                                }

                                else
                                {
                                    (srcxblock("&",i+1).text) = opFuncEquiv(j) + "(" + (srcxblock(i+1).text) + "," + (srcxblock(i-1).text) + ")";
                                }

				// Remove operator from operator block and right expression/number

				srcxblock.remove(i);
				srcxblock.remove(i-1);
				--i;
				--i;
                                break;
			    }
			}
		    }
		}
	    }
	}
    }

    return 0;
}



static fninfoblock qqqfninfo[NUMFNDEF] = {
        { ""                ,1,0  ,0,1 ,1,0,nullptr ,nullptr            ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"~"             ,-1,0 ,1 ,nullptr ,"var(1,0)", 
          "" },
        { "var"             ,2,3  ,0,3 ,1,0,nullptr ,nullptr            ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"Var"           ,-1,0 ,0 ,nullptr ,"0", 
          "Variable i,j" },
        { "Var"             ,2,3  ,0,3 ,1,0,nullptr ,nullptr            ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"var"           ,-1,0 ,0 ,nullptr ,"0", 
          "Conjugate variable i,j" },
        { "gvar"            ,2,3  ,0,3 ,0,0,nullptr ,nullptr            ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"gVar"          ,-1,0 ,0 ,nullptr ,"0", 
          "Global variable i,j" },
        { "gVar"            ,2,3  ,0,3 ,0,0,nullptr ,nullptr            ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"gvar"          ,-1,0 ,0 ,nullptr ,"0", 
          "Conjugate global variable i,j" },
        { "pos"             ,1,1  ,0,1 ,1,0,nullptr ,pos                ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_pos         ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"~"             ,-1,0 ,1 ,nullptr ,"var(1,0)", 
          "Posation" },
        { "neg"             ,1,1  ,0,1 ,1,0,nullptr ,neg                ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_neg         ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"~"             ,-1,0 ,1 ,nullptr ,"-var(1,0)", 
          "Negation" },
        { "add"             ,2,3  ,0,3 ,1,0,nullptr ,nullptr            ,add          ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,OP_add    ,nullptr,nullptr,nullptr,nullptr,3 ,"~"             ,-1,0 ,3 ,nullptr ,"var(1,0)+var(1,1)", 
          "Addition" },
        { "sub"             ,2,3  ,0,3 ,1,0,nullptr ,nullptr            ,sub          ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,OP_sub    ,nullptr,nullptr,nullptr,nullptr,3 ,"~"             ,-1,0 ,3 ,nullptr ,"var(1,0)-var(1,1)", 
          "Subtraction" },
        { "mul"             ,2,3  ,0,3 ,1,0,nullptr ,nullptr            ,mul          ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,OP_mul    ,nullptr,nullptr,nullptr,nullptr,-3,"~"             ,-1,3 ,3 ,nullptr ,"(var(1,0)*y)+(x*var(1,1))", 
          "(Left/normal) multiplication" },
        { "rmul"            ,2,3  ,0,3 ,1,0,nullptr ,nullptr            ,rmul         ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,-3,"~"             ,-1,3 ,3 ,nullptr ,"rmul(var(1,0),y)+rmul(x,var(1,1))", 
          "Right multiplication" },
        { "div"             ,2,3  ,0,3 ,1,0,nullptr ,nullptr            ,div          ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,OP_div    ,nullptr,nullptr,nullptr,nullptr,-3,"rdiv"          ,-1,3 ,3 ,nullptr ,"(var(1,0)/y)-((x/(y^2))*var(1,1))", 
          "(Left/normal) division" },
        { "idiv"            ,2,3  ,0,3 ,1,0,nullptr ,nullptr            ,idiv         ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,OP_idiv   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,0 ,0 ,nullptr ,"0", 
          "Integer division" },
        { "rdiv"            ,2,3  ,0,3 ,1,0,nullptr ,nullptr            ,rdiv         ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,OP_rdiv   ,nullptr,nullptr,nullptr,nullptr,-3,"div"           ,-1,3 ,3 ,nullptr ,"-(var(1,0)*((x^2)\\y))+(x\\var(1,1))", 
          "Right division" },
        { "mod"             ,2,3  ,0,3 ,1,0,nullptr ,nullptr            ,mod          ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,OP_mod    ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,0 ,0 ,nullptr ,"0", 
          "Modulus" },
//        { "pow"             ,2,3  ,0,3 ,1,0,nullptr ,nullptr            ,pow          ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,3 ,"Pow"           ,-1,3 ,3 ,nullptr ,"(y*pow(x,y-1)*var(1,0))+(log(x)*pow(x,y)*var(1,1))", 
//          "Raise a to power b.  For anions this is (powl(a,b)+powr(a,b))/2." },
//        { "Pow"             ,2,3  ,0,3 ,1,0,nullptr ,nullptr            ,Pow          ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,3 ,"pow"           ,-1,3 ,3 ,nullptr ,"(y*Pow(x,y-1)*var(1,0))+(Log(x)*Pow(x,y)*var(1,1))", 
//          "Raise a to power b (alternative hand).  For anions this is (Powl(a,b)+Powr(a,b))/2." },
        { "pow"             ,2,3  ,0,3 ,1,0,nullptr ,nullptr            ,pow          ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,3 ,"Powl"          ,-1,3 ,3 ,nullptr ,"(y*powr(x,y-1)*var(1,0))+(log(x)*powr(x,y)*var(1,1))", 
          "Raise a to power b as \"right\" power.  For anions this is exp(log(a)*b)" },
        { "Pow"             ,2,3  ,0,3 ,1,0,nullptr ,nullptr            ,Pow          ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,3 ,"powl"          ,-1,3 ,3 ,nullptr ,"(y*Powr(x,y-1)*var(1,0))+(Log(x)*Powr(x,y)*var(1,1))", 
          "Raise a to power b as \"right\" power (alternative hand).  For anions this is exp(Log(a)*b)" },
        { "powl"            ,2,3  ,0,3 ,1,0,nullptr ,nullptr            ,powl         ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,3 ,"Powr"          ,-1,3 ,3 ,nullptr ,"(y*powl(x,y-1)*var(1,0))+(log(x)*powl(x,y)*var(1,1))", 
          "Raise a to power b as \"left\" power.  For anions this is exp(b*log(a))" },
        { "Powl"            ,2,3  ,0,3 ,1,0,nullptr ,nullptr            ,Powl         ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,3 ,"powr"          ,-1,3 ,3 ,nullptr ,"(y*Powl(x,y-1)*var(1,0))+(Log(x)*Powl(x,y)*var(1,1))", 
          "Raise a to power b as \"left\" power (alternative hand).  For anions this is exp(b*Log(a))" },
        { "powr"            ,2,3  ,0,3 ,1,0,nullptr ,nullptr            ,powr         ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,3 ,"Powl"          ,-1,3 ,3 ,nullptr ,"(y*powr(x,y-1)*var(1,0))+(log(x)*powr(x,y)*var(1,1))", 
          "Raise a to power b as \"right\" power.  For anions this is exp(log(a)*b)" },
        { "Powr"            ,2,3  ,0,3 ,1,0,nullptr ,nullptr            ,Powr         ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,3 ,"powl"          ,-1,3 ,3 ,nullptr ,"(y*Powr(x,y-1)*var(1,0))+(Log(x)*Powr(x,y)*var(1,1))", 
          "Raise a to power b as \"right\" power (altnerative hand).  For anions this is exp(Log(a)*b)" },
        { "emul"            ,2,3  ,0,3 ,1,0,nullptr ,nullptr            ,emul         ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,-3,"~"             ,-1,3 ,3 ,nullptr ,"(var(1,0).*y)+(x.*var(1,1))", 
          "Elementwise (left/normal) multiplication" },
        { "ermul"           ,2,3  ,0,3 ,1,0,nullptr ,nullptr            ,ermul        ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,-3,"~"             ,-1,3 ,3 ,nullptr ,"ermul(var(1,0),y)+ermul(x,var(1,1))", 
          "Elementwise right multiplication" },
        { "ediv"            ,2,3  ,0,3 ,1,0,nullptr ,nullptr            ,ediv         ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,-3,"erdiv"         ,-1,3 ,3 ,nullptr ,"(var(1,0)./y)-((x./(y.^2)).*var(1,1))", 
          "Elementwise (left/normal) division" },
        { "eidiv"           ,2,3  ,0,3 ,1,0,nullptr ,nullptr            ,eidiv        ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,0 ,0 ,nullptr ,"0", 
          "Elementwise integer division" },
        { "erdiv"           ,2,3  ,0,3 ,1,0,nullptr ,nullptr            ,erdiv        ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,-3,"ediv"          ,-1,3 ,3 ,nullptr ,"-(var(1,0).*((x.^2).\\y))+(x.\\var(1,1))", 
          "Elementwise right division" },
        { "emod"            ,2,3  ,0,3 ,1,0,nullptr ,nullptr            ,emod         ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,0 ,0 ,nullptr ,"0", 
          "Elementwise modulus" },
//        { "epow"            ,2,3  ,0,3 ,1,0,nullptr ,nullptr            ,epow         ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,3 ,"Epow"          ,-1,3 ,3 ,nullptr ,"((y.*epow(x,y-1)).*var(1,0))+((log(x).*epow(x,y)).*var(1,1))", 
//          "Elementwise power." },
//        { "Epow"            ,2,3  ,0,3 ,1,0,nullptr ,nullptr            ,Epow         ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,3 ,"epow"          ,-1,3 ,3 ,nullptr ,"((y.*Epow(x,y-1)).*var(1,0))+((Log(x).*Epow(x,y)).*var(1,1))", 
//          "Elementwise power (alterntaive hand)." },
        { "epow"            ,2,3  ,0,3 ,1,0,nullptr ,nullptr            ,epow         ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,3 ,"Epowl"         ,-1,3 ,3 ,nullptr ,"((y.*epowr(x,y-1)).*var(1,0))+((log(x).*epowr(x,y)).*var(1,1))", 
          "Elementwise right power" },
        { "Epow"            ,2,3  ,0,3 ,1,0,nullptr ,nullptr            ,Epow         ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,3 ,"epowl"         ,-1,3 ,3 ,nullptr ,"((y.*Epowr(x,y-1)).*var(1,0))+((Log(x).*Epowr(x,y)).*var(1,1))", 
          "Elementwise right power (alternative hand)" },
        { "epowl"           ,2,3  ,0,3 ,1,0,nullptr ,nullptr            ,epowl        ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,3 ,"Epowr"         ,-1,3 ,3 ,nullptr ,"((y.*epowl(x,y-1)).*var(1,0))+((log(x).*epowl(x,y)).*var(1,1))", 
          "Elementwise left power" },
        { "Epowl"           ,2,3  ,0,3 ,1,0,nullptr ,nullptr            ,Epowl        ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,3 ,"epowr"         ,-1,3 ,3 ,nullptr ,"((y.*Epowl(x,y-1)).*var(1,0))+((Log(x).*Epowl(x,y)).*var(1,1))", 
          "Elementwise left power (alternative hand)" },
        { "epowr"           ,2,3  ,0,3 ,1,0,nullptr ,nullptr            ,epowr        ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,3 ,"Epowl"         ,-1,3 ,3 ,nullptr ,"((y.*epowr(x,y-1)).*var(1,0))+((log(x).*epowr(x,y)).*var(1,1))", 
          "Elementwise right power" },
        { "Epowr"           ,2,3  ,0,3 ,1,0,nullptr ,nullptr            ,Epowr        ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,3 ,"epowl"         ,-1,3 ,3 ,nullptr ,"((y.*Epowr(x,y-1)).*var(1,0))+((Log(x).*Epowr(x,y)).*var(1,1))", 
          "Elementwise right power (alternative hand)" },
        { "eq"              ,2,3  ,0,3 ,1,0,nullptr ,nullptr            ,eq           ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,0 ,0 ,nullptr ,"0", 
          "Logical equals" },
        { "ne"              ,2,3  ,0,3 ,1,0,nullptr ,nullptr            ,ne           ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,0 ,0 ,nullptr ,"0", 
          "Logical not equals" },
        { "gt"              ,2,3  ,0,3 ,1,0,nullptr ,nullptr            ,gt           ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,0 ,0 ,nullptr ,"0", 
          "Logical greater than" },
        { "ge"              ,2,3  ,0,3 ,1,0,nullptr ,nullptr            ,ge           ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,0 ,0 ,nullptr ,"0", 
          "Logical greater than or equal to" },
        { "le"              ,2,3  ,0,3 ,1,0,nullptr ,nullptr            ,le           ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,0 ,0 ,nullptr ,"0", 
          "Logical less than or equal to" },
        { "lt"              ,2,3  ,0,3 ,1,0,nullptr ,nullptr            ,lt           ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,0 ,0 ,nullptr ,"0", 
          "Logical less than" },
        { "eeq"             ,2,3  ,0,3 ,1,0,nullptr ,nullptr            ,eeq          ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,0 ,0 ,nullptr ,"0", 
          "Elementwise logical equals" },
        { "ene"             ,2,3  ,0,3 ,1,0,nullptr ,nullptr            ,ene          ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,0 ,0 ,nullptr ,"0", 
          "Elementwise logical not equals" },
        { "egt"             ,2,3  ,0,3 ,1,0,nullptr ,nullptr            ,egt          ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,0 ,0 ,nullptr ,"0", 
          "Elementwise logical greater than" },
        { "ege"             ,2,3  ,0,3 ,1,0,nullptr ,nullptr            ,ege          ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,0 ,0 ,nullptr ,"0", 
          "Elementwise logical greater than or equals to" },
        { "ele"             ,2,3  ,0,3 ,1,0,nullptr ,nullptr            ,ele          ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,0 ,0 ,nullptr ,"0", 
          "Elementwise logical less than or equal to" },
        { "elt"             ,2,3  ,0,3 ,1,0,nullptr ,nullptr            ,elt          ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,0 ,0 ,nullptr ,"0", 
          "Elementwise logical less than" },
        { "lnot"            ,1,1  ,0,1 ,1,0,nullptr ,lnot               ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_lnot        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,0 ,0 ,nullptr ,"0", 
          "Logical not" },
        { "lis"             ,1,1  ,0,1 ,1,0,nullptr ,lis                ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_lis         ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,0 ,0 ,nullptr ,"0", 
          "Logical is (not not)" },
        { "lor"             ,2,3  ,0,3 ,1,0,nullptr ,nullptr            ,lor          ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,0 ,0 ,nullptr ,"0", 
          "Logical or" },
        { "lnor"            ,2,3  ,0,3 ,1,0,nullptr ,nullptr            ,lnor         ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,0 ,0 ,nullptr ,"0", 
          "Logical nor" },
        { "land"            ,2,3  ,0,3 ,1,0,nullptr ,nullptr            ,land         ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,0 ,0 ,nullptr ,"0", 
          "Logical and" },
        { "lnand"           ,2,3  ,0,3 ,1,0,nullptr ,nullptr            ,lnand        ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,0 ,0 ,nullptr ,"0", 
          "Logical nand" },
        { "lxor"            ,2,3  ,0,3 ,1,0,nullptr ,nullptr            ,lxor         ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,0 ,0 ,nullptr ,"0", 
          "Logical xor" },
        { "lxand"           ,2,3  ,0,3 ,1,0,nullptr ,nullptr            ,lxand        ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,0 ,0 ,nullptr ,"0", 
          "Logical xand" },
        { "ifthenelse"      ,3,1  ,0,7 ,1,0,nullptr ,nullptr            ,nullptr      ,ifthenelse      ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,6 ,"~"             ,-1,6 ,1 ,nullptr ,"ifthenelse(var(1,0),y,z)", 
          "If a true then b, otherwise c" },
        { "isnull"          ,1,1  ,0,1 ,1,0,nullptr ,isnull             ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_isnull      ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,0 ,0 ,nullptr ,"0", 
          "Returns 1 if x == null, 0 otherwise" },
        { "isint"           ,1,1  ,0,1 ,1,0,nullptr ,isint              ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_isint       ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,0 ,0 ,nullptr ,"0", 
          "Returns 1 if x is integral, 0 otherwise" },
        { "isreal"          ,1,1  ,0,1 ,1,0,nullptr ,isreal             ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_isreal      ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,0 ,0 ,nullptr ,"0", 
          "Returns 1 if x is real, 0 otherwise" },
        { "isanion"         ,1,1  ,0,1 ,1,0,nullptr ,isanion            ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_isanion     ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,0 ,0 ,nullptr ,"0", 
          "Returns 1 if x is an anion, 0 otherwise" },
        { "isvector"        ,1,1  ,0,1 ,1,0,nullptr ,isvector           ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_isvector    ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,0 ,0 ,nullptr ,"0", 
          "Returns 1 if x is a vector, 0 otherwise" },
        { "ismatrix"        ,1,1  ,0,1 ,1,0,nullptr ,ismatrix           ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_ismatrix    ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,0 ,0 ,nullptr ,"0", 
          "Returns 1 if x is a matrix, 0 otherwise" },
        { "isset"           ,1,1  ,0,1 ,1,0,nullptr ,isset              ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_isset       ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,0 ,0 ,nullptr ,"0", 
          "Returns 1 if x is a set, 0 otherwise" },
        { "isdgraph"        ,1,1  ,0,1 ,1,0,nullptr ,isdgraph           ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_isdgraph    ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,0 ,0 ,nullptr ,"0", 
          "Returns 1 if x is a directed graph, 0 otherwise" },
        { "isstring"        ,1,1  ,0,1 ,1,0,nullptr ,isstring           ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_isstring    ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,0 ,0 ,nullptr ,"0", 
          "Returns 1 if x is a string, 0 otherwise" },
        { "iserror"         ,1,1  ,0,1 ,1,0,nullptr ,iserror            ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_iserror     ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,0 ,0 ,nullptr ,"0", 
          "Returns 1 if x is aa error, 0 otherwise" },
        { "size"            ,1,1  ,0,1 ,1,0,nullptr ,size               ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_size        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,0 ,0 ,nullptr ,"0", 
          "Size of vector/matrix, 1 otherwise" },
        { "numRows"         ,1,1  ,0,1 ,1,0,nullptr ,numRows            ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_numRows     ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,0 ,0 ,nullptr ,"0", 
          "Number of rows in matrix, 1 otherwise" },
        { "numCols"         ,1,1  ,0,1 ,1,0,nullptr ,numCols            ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_numCols     ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,0 ,0 ,nullptr ,"0", 
          "Number of columns in matrix, 1 otherwise" },
        { "null"            ,0,0  ,0,0 ,1,0,null    ,nullptr            ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,0 ,0 ,nullptr ,"0", 
          "Null" },
        { "pi"              ,0,0  ,0,0 ,1,0,pi      ,nullptr            ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,0 ,0 ,nullptr ,"0", 
          "pi" },
        { "euler"           ,0,0  ,0,0 ,1,0,euler   ,nullptr            ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,0 ,0 ,nullptr ,"0", 
          "Eulers constant" },
        { "pinf"            ,0,0  ,0,0 ,1,0,pinf    ,nullptr            ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,0 ,0 ,nullptr ,"0", 
          "Positive infinity" },
        { "ninf"            ,0,0  ,0,0 ,1,0,ninf    ,nullptr            ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,0 ,0 ,nullptr ,"0", 
          "Negative infinity" },
        { "vnan"            ,0,0  ,0,0 ,1,0,vnan    ,nullptr            ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,0 ,0 ,nullptr ,"0", 
          "Not-a-number" },
        { "eye"             ,2,0  ,3,3 ,1,0,nullptr ,nullptr            ,eye          ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,0 ,0 ,nullptr ,"0", 
          "Identity matrix (size i,j, need to be square)" },
        { "conj"            ,1,0  ,0,1 ,1,0,nullptr ,conj               ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,""              ,-1,0 ,1 ,nullptr ,"conj(var(1,0))", 
          "Returns the elementwise conjugate of a" },
        { "realDeriv"       ,3,3  ,0,7 ,0,0,nullptr ,nullptr            ,nullptr      ,realDeriv       ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,4 ,"~"             ,-1,0 ,0 ,nullptr ,"0", 
          "Real derivative: realDeriv(f,i,j) = df/dvar(i,j)" },
        { "eps_comm"        ,4,15 ,0,15,1,0,nullptr ,nullptr            ,nullptr      ,nullptr         ,eps_comm   ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,0 ,0 ,nullptr ,"0", 
          "Commutator pseudo-tensor" },
        { "eps_assoc"       ,5,31 ,0,31,1,0,nullptr ,nullptr            ,nullptr      ,nullptr         ,nullptr    ,eps_assoc    ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,0 ,0 ,nullptr ,"0", 
          "Associator pseudo-tensor" },
        { "im_complex"      ,1,1  ,0,1 ,1,0,nullptr ,im_complex         ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"Im_complex"    ,-1,0 ,0 ,nullptr ,"0", 
          "Complex unit (im_complex(0) = 1, im_complex(1) = i)" },
        { "im_quat"         ,1,1  ,0,1 ,1,0,nullptr ,im_quat            ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"Im_quat"       ,-1,0 ,0 ,nullptr ,"0", 
          "Quaternion unit (im_quat(0) = 1, im_quat(1) = I, im_quat(2) = J, im_quat(3) = K" },
        { "im_octo"         ,1,1  ,0,1 ,1,0,nullptr ,im_octo            ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"Im_octo"       ,-1,0 ,0 ,nullptr ,"0", 
          "Octonion unit (im_octo(0) = 1, im_octo(1) = l, im_octo(2) = m, im_octo(3) = n, im_octo(4) = o, im_octo(5) = p, im_octo(6) = q, im_octo(7) = r" },
        { "im_anion"        ,2,3  ,0,3 ,1,0,nullptr ,nullptr            ,im_anion     ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"Im_anion"      ,-1,0 ,0 ,nullptr ,"0", 
          "Anionic unit (im_anion(0) = 1, im_anion(a) = imag)" },
        { "Im_complex"      ,1,1  ,0,1 ,1,0,nullptr ,Im_complex         ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"im_complex"    ,-1,0 ,0 ,nullptr ,"0", 
          "Complex unit (alternative hand) (Im_complex(0) = 1, Im_complex(1) = -i)" },
        { "Im_quat"         ,1,1  ,0,1 ,1,0,nullptr ,Im_quat            ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"im_quat"       ,-1,0 ,0 ,nullptr ,"0", 
          "Quaternion unit (alternative hand) (Im_quat(0) = 1, Im_quat(1) = -I, Im_quat(2) = -J, Im_quat(3) = -K" },
        { "Im_octo"         ,1,1  ,0,1 ,1,0,nullptr ,Im_octo            ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"im_octo"       ,-1,0 ,0 ,nullptr ,"0", 
          "Octonion unit (alternative hand) (Im_octo(0) = 1, Im_octo(1) = l, Im_octo(2) = m, Im_octo(3) = n, Im_octo(4) = o, Im_octo(5) = p, Im_octo(6) = q, Im_octo(7) = r" },
        { "Im_anion"        ,2,3  ,0,3 ,1,0,nullptr ,nullptr            ,Im_anion     ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"im_anion"      ,-1,0 ,0 ,nullptr ,"0", 
          "Anionic unit (alternative hand) (Im_anion(0) = 1, Im_anion(a) = -im_anion(a))" },
        { "vect_const"      ,2,3  ,0,3 ,1,0,nullptr ,nullptr            ,vect_const   ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,2 ,"~"             ,-1,1 ,2 ,nullptr ,"vect_const(x,var(1,1))", 
          "vect_const(n,x) = vector of size n, all values x" },
        { "vect_unit"       ,2,3  ,0,3 ,1,0,nullptr ,nullptr            ,vect_unit    ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,0 ,0 ,nullptr ,"0", 
          "vect_unit(n,i) = vector of size n, all 0 except element i being 1" },
        { "ivect"           ,3,7  ,0,3 ,1,0,nullptr ,nullptr            ,nullptr      ,ivect           ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,7 ,"~"             ,-1,0 ,0 ,nullptr ,"0", 
          "ivect(a,b,c) = copy of Matlab's a:b:c notation" },
        { "commutate"       ,2,3  ,0,3 ,1,0,nullptr ,nullptr            ,commutate    ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,-3,"~"             ,-1,3 ,3 ,nullptr ,"commutate(var(1,0),y)+commutate(x,var(1,1))", 
          "Commutator [x,y] = (xy - yx)/2" },
        { "associate"       ,3,7  ,0,7 ,1,0,nullptr ,nullptr            ,nullptr      ,associate       ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,-7,"~"             ,-1,7 ,7 ,nullptr ,"associate(var(1,0),y,z)+associate(x,var(1,1),z)+associate(x,y,var(1,2))", 
          "Associator [x,y,z] = (x(yz) - (xy)z)/2" },
        { "anticommutate"   ,2,3  ,0,3 ,1,0,nullptr ,nullptr            ,anticommutate,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,3 ,"~"             ,-1,3 ,3 ,nullptr ,"anticommutate(var(1,0),y)+anticommutate(x,var(1,1))", 
          "Anti-commutator {x,y} = (xy + yx)/2" },
        { "antiassociate"   ,3,7  ,0,7 ,1,0,nullptr ,nullptr            ,nullptr      ,antiassociate   ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,7 ,"~"             ,-1,7 ,7 ,nullptr ,"antiassociate(var(1,0),y,z)+antiassociate(x,var(1,1),z)+antiassociate(x,y,var(1,2))", 
          "Anti-associator {x,y,z} = (x(yz) + (xy)z)/2" },
        { "cayleyDickson"   ,2,3  ,0,3 ,1,0,nullptr ,nullptr            ,cayleyDickson,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"CayleyDickson" ,-1,0 ,3 ,nullptr ,"cayleyDickson(var(1,0),var(1,1))", 
          "Returns the Cayley-Dickson construct x|y" },
        { "CayleyDickson"   ,2,3  ,0,3 ,1,0,nullptr ,nullptr            ,CayleyDickson,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"cayleyDickson" ,-1,0 ,3 ,nullptr ,"CayleyDickson(var(1,0),var(1,1))", 
          "Returns the Cayley-Dickson construct x|y (alternative hand)" },
        { "kronDelta"       ,2,0  ,3,3 ,1,0,nullptr ,nullptr            ,kronDelta    ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,0 ,0 ,nullptr ,"0", 
          "Kronecker-Delta function delta_{i.j} = 1 if i == j, 0 otherwise (even if i,j are vectors)" },
        { "diracDelta"      ,1,0  ,1,1 ,1,0,nullptr ,diracDelta         ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,0 ,0 ,nullptr ,"0", 
          "Dirac-Delta function delta_{i.j} = inf if i == j, 0 otherwise" },
        { "ekronDelta"      ,2,3  ,0,3 ,1,0,nullptr ,nullptr            ,ekronDelta   ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,0 ,0 ,nullptr ,"0", 
          "Elementwise Kronecker-Delta function delta_{i.j} = 1 if i == j, 0 otherwise (but go elementwise if i,j are vectors or matrices)" },
        { "ediracDelta"     ,1,1  ,0,1 ,1,0,nullptr ,ediracDelta        ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,0 ,0 ,nullptr ,"0", 
          "Elementwise Dirac-Delta function delta_{i.j} = inf if i == j, 0 otherwise (but go elementwise if i,j are vectors or matrices)" },
        { "perm"            ,2,3  ,0,3 ,1,0,nullptr ,nullptr            ,perm         ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,0 ,0 ,nullptr ,"0", 
          "Number of permutations of j objects selectable from i total objects (elementwise for vectors/matrices)" },
        { "comb"            ,2,3  ,0,3 ,1,0,nullptr ,nullptr            ,comb         ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,0 ,0 ,nullptr ,"0", 
          "Number of combinations of j objects selectable from i total objects (elementwise for vectors/matrices" },
        { "fact"            ,1,1  ,0,1 ,1,0,nullptr ,fact               ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,1 ,1 ,nullptr ,"realDeriv(0,0,gamma(x+1))*var(1,0)", 
          "Factorial i!.  Operates elementwise for vectors/matrices, returns gamma(i+1) if i non-integer, negative of causes integer overflow." },
        { "abs2"            ,1,1  ,0,1 ,1,0,nullptr ,abs2               ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,1 ,1 ,nullptr ,"angle(x)*var(1,0)", 
          "2-norm ||a||_2 of a (absolute value for scalar, Frobenius for matrix, sqrt of num elements for set)" },
        { "abs1"            ,1,1  ,0,1 ,1,0,nullptr ,abs1               ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,1 ,1 ,nullptr ,"sgn(x)*var(1,0)", 
          "1-norm ||a||_1 of a (absolute value for scalar, elementwise 1-norm for matrices, num elements for set)" },
        { "absp"            ,2,3  ,0,3 ,1,0,nullptr ,nullptr            ,absp         ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,3 ,3 ,nullptr ,"realDeriv(0,0,sum(eabs2(x).^y)^inv(y))*var(1,0)+realDeriv(0,1,sum(eabs2(x).^y)^inv(y))*var(1,1)", 
          "p-norm ||a||_p of a (absolute value for scalar, elementwise p-norm for matrices, ||a||_2^1/p for set)" },
        { "absinf"          ,1,1  ,0,1 ,1,0,nullptr ,absinf             ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,1 ,1 ,nullptr ,"deref(var(1,0),argmaxabs(x))", 
          "inf-norm ||a||_inf of a (absolute value for scalar, elementwise inf-norm for matrices, for set 0 if empty, 1 otherwise)" },
        { "abs0"            ,1,1  ,0,1 ,1,0,nullptr ,abs0               ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,1 ,1 ,nullptr ,"deref(var(1,0),argminabs(x))", 
          "0-norm ||a||_0 = min_i { ||a_i||_0 } (absolute value for scalar, elementwise 0-norm for matrices, for set 0 if empty, 1 otherwise)}" },
        { "norm1"           ,1,1  ,0,1 ,1,0,nullptr ,norm1              ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,1 ,1 ,nullptr ,"sgn(x)*var(1,0)", 
          "||a||_1 of a (absolute value for scalar, elementwise 1-norm for matrices, num elements for set)" },
        { "norm2"           ,1,1  ,0,1 ,1,0,nullptr ,norm2              ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,1 ,1 ,nullptr ,"2*x*var(1,0)", 
          "||a||_2^2 of a (squared absolute value for scalar, squared Frobenius for matrix, num elements for set)" },
        { "normp"           ,2,3  ,0,3 ,1,0,nullptr ,nullptr            ,normp        ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,3 ,3 ,nullptr ,"realDeriv(0,0,sum(eabs2(x).^y))*var(1,0)+realDeriv(0,1,sum(eabs2(x).^y))*var(1,1)", 
          "||a||_p^p of a (absolute value for scalar to p, elementwise p-norm to p for matrices, num elements for set)" },
        { "angle"           ,1,1  ,0,1 ,1,0,nullptr ,angle              ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"~"             ,-1,1 ,1 ,nullptr ,"inv(abs2(x))*(var(1,0)-angle(x)*(angle(x)*var(1,0)))", 
          "Direction a/||a||_2 of a (0 of a = 0)" },
        { "inv"             ,1,1  ,0,1 ,1,0,nullptr ,inv                ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"~"             ,-1,1 ,1 ,nullptr ,"-(x^(-2))*var(1,0)", 
          "Inverse conj(a)/||a||_2 of a" },
        { "eabs2"           ,1,1  ,0,1 ,1,0,nullptr ,eabs2              ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_eabs2       ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,1 ,1 ,nullptr ,"sgn(x).*var(1,0)", 
          "Elementwise 2-norm ||a||_2 of a (absolute value for scalar, Frobenius for matrix, sqrt of num elements for set)" },
        { "eabs1"           ,1,1  ,0,1 ,1,0,nullptr ,eabs1              ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_eabs1       ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,1 ,1 ,nullptr ,"sgn(x).*var(1,0)", 
          "Elementwise 1-norm ||a||_1 of a (absolute value for scalar, elementwise 1-norm for matrices, num elements for set)" },
        { "eabsp"           ,2,3  ,0,3 ,1,0,nullptr ,nullptr            ,eabsp        ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,3 ,3 ,nullptr ,"realDeriv(0,0,enormp(x,y).^inv(y)).*var(1,0)+realDeriv(0,1,enormp(x,y).^inv(y)).*var(1,1)", 
          "Elementwise p-norm ||a||_p of a (absolute value for scalar, elementwise p-norm for matrices, ||a||_2^1/p for set)" },
        { "eabsinf"         ,1,1  ,0,1 ,1,0,nullptr ,eabsinf            ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_eabsinf     ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,1 ,1 ,nullptr ,"sgn(x).*var(1,0)", 
          "Elementwise inf-norm ||a||_inf of a (absolute value for scalar, elementwise inf-norm for matrices, for set 0 if empty, 1 otherwise)" },
        { "eabs0"           ,1,1  ,0,1 ,1,0,nullptr ,eabs0              ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_eabs0       ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,1 ,1 ,nullptr ,"sgn(x).*var(1,0)", 
          "Elementwise 0-norm ||a||_0 = min_i { ||a_i||_0 } (absolute value for scalar, elementwise 0-norm for matrices, for set 0 if empty, 1 otherwise)}" },
        { "enorm1"          ,1,1  ,0,1 ,1,0,nullptr ,enorm1             ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_enorm1      ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,1 ,1 ,nullptr ,"sgn(x).*var(1,0)", 
          "Elementwise ||a||_1 of a (absolute value for scalar, elementwise 1-norm for matrices, num elements for set)" },
        { "enorm2"          ,1,1  ,0,1 ,1,0,nullptr ,enorm2             ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_enorm2      ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,1 ,1 ,nullptr ,"x.*var(1,0)", 
          "Elementwise ||a||_2^2 of a (squared absolute value for scalar, squared Frobenius for matrix, num elements for set)" },
        { "enormp"          ,2,3  ,0,3 ,1,0,nullptr ,nullptr            ,enormp       ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,3 ,3 ,nullptr ,"((y.*(eabs2(x).^(y-1)).*sgn(x)).*var(1,0))+((log(x).*(eabs2(x).^y)).*var(1,0))", 
          "Elementwise ||a||_p^p of a (absolute value for scalar to p, elementwise p-norm to p for matrices, num elements for set)" },
        { "eangle"          ,1,1  ,0,1 ,1,0,nullptr ,eangle             ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_eangle      ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"~"             ,-1,1 ,1 ,nullptr ,"einv(eabs2(x)).*(var(1,0)-eangle(x).*eangle(x).*var(1,0))", 
          "Elementwise direction a/||a||_2 of a (0 of a = 0)" },
        { "einv"            ,1,1  ,0,1 ,1,0,nullptr ,einv               ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_einv        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"~"             ,-1,1 ,1 ,nullptr ,"-(x.^(-2)).*var(1,0)", 
          "Elementwise inverse conj(a)/||a||_2 of a" },
        { "real"            ,1,1  ,0,1 ,1,0,nullptr ,real               ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_real        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,0 ,1 ,nullptr ,"real(var(1,0))", 
          "Elementwise real part Re(a) of a." },
        { "imag"            ,1,1  ,0,1 ,1,0,nullptr ,imag               ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_imag        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"~"             ,-1,1 ,1 ,nullptr ,"realDeriv(0,0,eabs2(imagx(x)).*sgn(derefa(x,1))).*var(1,0)", 
          "Elementwise imaginary sign-corrected magnitude |Im(a)|*sgn(a(1)) (or |Im(a)| if sgn(a(1)) = 0) of a" },
        { "imagd"           ,1,1  ,0,1 ,1,0,nullptr ,imagd              ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_imagd       ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"Imagd"         ,-1,1 ,1 ,nullptr ,"realDeriv(0,0,imagx(x)./imag(x)).*var(1,0)", 
          "Elementwise unit imaginary Im(a)/|Im(a)|*sgn(a(1)) (or (0,1) if Im(a) = 0) of a" },
        { "Imagd"           ,1,1  ,0,1 ,1,0,nullptr ,Imagd              ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_Imagd       ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"imagd"         ,-1,1 ,1 ,nullptr ,"realDeriv(0,0,imagx(x)./imag(x)).*var(1,0)", 
          "Elementwise alternative hand unit imaginary Im(a)/|Im(a)|*sgn(a(1)) (or (0,-1) if Im(a) = 0) of a" },
        { "imagx"           ,1,1  ,0,1 ,1,0,nullptr ,imagx              ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_imagx       ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"imagx"         ,-1,0 ,1 ,nullptr ,"imagx(var(1,0))", 
          "Elementwise imaginary part Im(a) of a." },
        { "arg"             ,1,1  ,0,1 ,1,0,nullptr ,arg                ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_arg         ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"~"             ,-1,1 ,1 ,nullptr ,"realDeriv(0,0,eabs2(imagx(log(x))).*sgn(derefa(x,1))).*var(1,0)", 
          "Elementwise argument |Im(log(a))|*sgn(a(1)) (or |Im(log(a))| if sgn(a(1)) = 0) of a." },
        { "argd"            ,1,1  ,0,1 ,1,0,nullptr ,argd               ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_argd        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"Argd"          ,-1,1 ,1 ,nullptr ,"realDeriv(0,0,imagx(log(x))./arg(x)).*var(1,0)", 
          "Elementwise unit imaginary Im(log(a))/|Im(log(a))|*sgn(a(1)) (or (0,1) if arg(a) = 0) of a" },
        { "Argd"            ,1,1  ,0,1 ,1,0,nullptr ,Argd               ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_Argd        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"argd"          ,-1,1 ,1 ,nullptr ,"realDeriv(0,0,imagx(Log(x))./arg(x)).*var(1,0)", 
          "Elementwise unit alternative hand imaginary Im(Log(a))/|Im(log(a))|*sgn(a(1)) (or (0,-1) if arg(a) = 0) of a" },
        { "argx"            ,1,1  ,0,1 ,1,0,nullptr ,argx               ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_argx        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"Argx"          ,-1,1 ,1 ,nullptr ,"realDeriv(0,0,imagx(log(x))).*var(1,0)", 
          "Elementwise complete argument Im(log(a)) of a." },
        { "Argx"            ,1,1  ,0,1 ,1,0,nullptr ,Argx               ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_Argx        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"argx"          ,-1,1 ,1 ,nullptr ,"realDeriv(0,0,imagx(Log(x))).*var(1,0)", 
          "Elementwise complete alternative hand argument Im(Log(a)) of a." },
        { "polar"           ,3,7  ,0,7 ,1,0,nullptr ,nullptr            ,nullptr      ,polar           ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,7 ,"~"             ,-1,7 ,7 ,nullptr ,"(realDeriv(0,0,(x.*exp(y.*z)+exp(z.*y).*x)/2).*var(1,0))+(realDeriv(0,1,(x.*exp(y.*z)+exp(z.*y).*x)/2).*var(1,1))+(realDeriv(0,2,(x.*exp(y.*z)+exp(z.*y).*x)/2).*var(1,2))", 
          "Elementwise polar form: polar(x,y,q) = x*exp(y*q) defined by the polar form (x,y*q)." },
        { "polard"          ,3,7  ,0,7 ,1,0,nullptr ,nullptr            ,nullptr      ,polard          ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,7 ,"~"             ,-1,7 ,7 ,nullptr ,"(realDeriv(0,0,(x.*exp(y.*z)+exp(z.*y).*x)/2).*var(1,0))+(realDeriv(0,1,(x.*exp(y.*z)+exp(z.*y).*x)/2).*var(1,1))+(realDeriv(0,2,(x.*exp(y.*z)+exp(z.*y).*x)/2).*var(1,2))", 
          "Elementwise polar form: polard(x,y,q) = x*exp(y*q) defined by the polar form (x,y*q)." },
        { "polarx"          ,2,3  ,0,3 ,1,0,nullptr ,nullptr            ,polarx       ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,3 ,"~"             ,-1,3 ,3 ,nullptr ,"realDeriv(0,0,(x.*exp(y)+exp(y).*x)/2).*var(1,0)+realDeriv(0,1,(x.*exp(y)+exp(y).*x)/2).*var(1,1)", 
          "Elementwise polar form: polarx(x,y) = x*exp(a) defined by the polar form (x,a)." },
        { "sgn"             ,1,1  ,0,1 ,1,0,nullptr ,sgn                ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_sgn         ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"~"             ,-1,1 ,1 ,nullptr ,"ediracDelta(x).*var(1,0)", 
          "Elementwise sign of a (also elementwise for anions)." },
        { "sqrt"            ,1,1  ,0,1 ,1,0,nullptr ,sqrt               ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_sqrt        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"Sqrt"          ,-1,1 ,1 ,nullptr ,"einv(2*sqrt(x)).*var(1,0)", 
          "Square root pow(a,0.5)." },
        { "Sqrt"            ,1,1  ,0,1 ,1,0,nullptr ,Sqrt               ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_Sqrt        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"sqrt"          ,-1,1 ,1 ,nullptr ,"einv(2*Sqrt(x)).*var(1,0)", 
          "Square root (alternative hand, Pow(a,0.5))." },
        { "cbrt"            ,1,1  ,0,1 ,1,0,nullptr ,cbrt               ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_cbrt        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"cbrt"          ,-1,1 ,1 ,nullptr ,"einv(3*cbrt(x)*cbrt(x)).*var(1,0)", 
          "Cube root (pow(a,1/3))." },
        { "Cbrt"            ,1,1  ,0,1 ,1,0,nullptr ,Cbrt               ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_Cbrt        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"Cbrt"          ,-1,1 ,1 ,nullptr ,"einv(3*Cbrt(x)*Cbrt(x)).*var(1,0)", 
          "Cube root (alternative hand, Pow(a,1/3))." },
        { "nthrt"           ,2,3  ,0,3 ,1,0,nullptr ,nullptr            ,nthrt        ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,3 ,"nthrt"         ,-1,3 ,3 ,nullptr ,"(einv(y*epow(nthrt(x,y),y-1)).*var(1,0))-((nthrt(x,y).*log(x)./(x.^2)).*var(1,1))", 
          "nth root (nthrt(a,b) is the exact root of a real, b integer, otherwise nthrt(a,b) = pow(a,inv(b)))." },
        { "Nthrt"           ,2,3  ,0,3 ,1,0,nullptr ,nullptr            ,Nthrt        ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,3 ,"Nthrt"         ,-1,3 ,3 ,nullptr ,"(einv(3*epow(Nthrt(x,y),y-1)).*var(1,0))-((Nthrt(x,y).*Log(x)./(x.^2)).*var(1,1))", 
          "nth root (alternative hand - exact root of a real, b integer, otherwise Nthrt(a,b) = Pow(a,inv(b)))." },
        { "exp"             ,1,1  ,0,1 ,1,0,nullptr ,exp                ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_exp         ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"exp"           ,-1,1 ,1 ,nullptr ,"exp(x).*var(1,0)", 
          "Exponential." },
        { "tenup"           ,1,1  ,0,1 ,1,0,nullptr ,tenup              ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_tenup       ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"~"             ,-1,1 ,1 ,nullptr ,"realDeriv(0,0,exp(log(10)*x)).*var(1,0)", 
          "Ten to the power (10^a)." },
        { "log"             ,1,1  ,0,1 ,1,0,nullptr ,log                ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_log         ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"Log"           ,-1,1 ,1 ,nullptr ,"einv(x).*var(1,0)", 
          "Natural logarithm (log(a) = log(abs2(a)) + q*atan2(a_I,a_R))." },
        { "Log"             ,1,1  ,0,1 ,1,0,nullptr ,Log                ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_Log         ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"log"           ,-1,1 ,1 ,nullptr ,"einv(x).*var(1,0)", 
          "Natural logarithm (alternative hand, Log(a) = Log(abs2(a)) + q*atan2(a_I,a_R))." },
        { "log10"           ,1,1  ,0,1 ,1,0,nullptr ,log10              ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_log10       ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"Log10"         ,-1,1 ,1 ,nullptr ,"einv(log(10)*x).*var(1,0)", 
          "Base 10 logarithm (log10(a) = log(a)/2.3025851)." },
        { "Log10"           ,1,1  ,0,1 ,1,0,nullptr ,Log10              ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_Log10       ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"log10"         ,-1,1 ,1 ,nullptr ,"einv(log(10)*x).*var(1,0)", 
          "Base 10 logarithm (alternative hand, Log10(a) = Log(a)/2.3025851)." },
        { "logb"            ,2,3  ,0,3 ,1,0,nullptr ,nullptr            ,logb         ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,3 ,"Logbl"         ,-1,3 ,3 ,nullptr ,"realDeriv(0,0,log(y).\\log(x)).*var(1,0)+realDeriv(0,1,log(y).\\log(x)).*var(1,1)", 
          "Base b right logarithm (logb(a,b) = inv(log(b))*log(a))." },
        { "Logb"            ,2,3  ,0,3 ,1,0,nullptr ,nullptr            ,Logb         ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,3 ,"logbl"         ,-1,3 ,3 ,nullptr ,"realDeriv(0,0,Log(y).\\Log(x)).*var(1,0)+realDeriv(0,1,Log(y).\\Log(x)).*var(1,1)", 
          "Base b right logarithm (alternative hand, Logb(a,b) = inv(Log(b))*Log(a))." },
//        { "logb"            ,2,3  ,0,3 ,1,0,nullptr ,nullptr            ,logb         ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,3 ,"Logb"          ,-1,3 ,3 ,nullptr ,"realDeriv(0,0,(logbl(x,y)+logbr(x,y))/2).*var(1,0)+realDeriv(0,1,(logbl(x,y)+logbr(x,y))/2).*var(1,1)", 
//          "Base b logarithm (logb(a,b) = 1/2 (logbl(a,b) + logbr(a,b)))." },
//        { "Logb"            ,2,3  ,0,3 ,1,0,nullptr ,nullptr            ,Logb         ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,3 ,"logb"          ,-1,3 ,3 ,nullptr ,"realDeriv(0,0,(Logbl(x,y)+Logbr(x,y))/2).*var(1,0)+realDeriv(0,1,(Logbl(x,y)+Logbr(x,y))/2).*var(1,1)", 
//          "Base b logarithm (alternative hand, Logb(a,b) = 1/2 (Logbl(a,b) + Logbr(a,b)))." },
        { "logbl"           ,2,3  ,0,3 ,1,0,nullptr ,nullptr            ,logbl        ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,3 ,"Logbr"         ,-1,3 ,3 ,nullptr ,"realDeriv(0,0,log(x)./log(y)).*var(1,0)+realDeriv(0,1,log(x)./log(y)).*var(1,1)", 
          "Base b left logarithm (logbl(a,b) = log(a)*inv(log(b)))." },
        { "Logbl"           ,2,3  ,0,3 ,1,0,nullptr ,nullptr            ,Logbl        ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,3 ,"logbr"         ,-1,3 ,3 ,nullptr ,"realDeriv(0,0,Log(x)./Log(y)).*var(1,0)+realDeriv(0,1,Log(x)./Log(y)).*var(1,1)", 
          "Base b left logarithm (alternative hand, Logbl(a,b) = Log(a)*inv(Log(b)))." },
        { "logbr"           ,2,3  ,0,3 ,1,0,nullptr ,nullptr            ,logbr        ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,3 ,"Logbl"         ,-1,3 ,3 ,nullptr ,"realDeriv(0,0,log(y).\\log(x)).*var(1,0)+realDeriv(0,1,log(y).\\log(x)).*var(1,1)", 
          "Base b right logarithm (logbr(a,b) = inv(log(b))*log(a))." },
        { "Logbr"           ,2,3  ,0,3 ,1,0,nullptr ,nullptr            ,Logbr        ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,3 ,"logbl"         ,-1,3 ,3 ,nullptr ,"realDeriv(0,0,Log(y).\\Log(x)).*var(1,0)+realDeriv(0,1,Log(y).\\Log(x)).*var(1,1)", 
          "Base b right logarithm (alternative hand, Logbr(a,b) = inv(Log(b))*Log(a))." },
        { "sin"             ,1,1  ,0,1 ,1,0,nullptr ,sin                ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_sin         ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"~"             ,-1,1 ,1 ,nullptr ,"cos(x).*var(1,0)", 
          "Sine (sin(a) = sin(a_R)*cosh(a_I) + q*cos(a_R)*sinh(a_I))" },
        { "cos"             ,1,1  ,0,1 ,1,0,nullptr ,cos                ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_cos         ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"~"             ,-1,1 ,1 ,nullptr ,"-sin(x).*var(1,0)", 
          "Cosine (cos(a) = cos(a_R)*cosh(a_I) - q*sin(a_R)*sinh(a_I))" },
        { "tan"             ,1,1  ,0,1 ,1,0,nullptr ,tan                ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_tan         ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"~"             ,-1,1 ,1 ,nullptr ,"(sec(x).^2).*var(1,0)", 
          "Tangent (tan(a) = sin(a)*inv(cos(a)))" },
        { "cosec"           ,1,1  ,0,1 ,1,0,nullptr ,cosec              ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_cosec       ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"~"             ,-1,1 ,1 ,nullptr ,"-cosec(x).*cot(x).*var(1,0)", 
          "Cosecant (cosec(a) = inv(sin(a)))" },
        { "sec"             ,1,1  ,0,1 ,1,0,nullptr ,sec                ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_sec         ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"~"             ,-1,1 ,1 ,nullptr ,"sec(x).*tan(x).*var(1,0)", 
          "Secant (sec(a) = inv(cos(a)))" },
        { "cot"             ,1,1  ,0,1 ,1,0,nullptr ,cot                ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_cot         ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"~"             ,-1,1 ,1 ,nullptr ,"-(cosec(x).^2).*var(1,0)", 
          "Cotangent (cot(a) = inv(tan(a)))" },
        { "asin"            ,1,1  ,0,1 ,1,0,nullptr ,asin               ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_asin        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"Asin"          ,-1,1 ,1 ,nullptr ,"einv(sqrt(1-(x.^2))).*var(1,0)", 
          "Inverse sine (see Abramowitz and Stegun)" },
        { "Asin"            ,1,1  ,0,1 ,1,0,nullptr ,Asin               ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_Asin        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"asin"          ,-1,1 ,1 ,nullptr ,"einv(Sqrt(1-(x.^2))).*var(1,0)", 
          "Inverse sine (alternate hand, see Abramowitz and Stegun)" },
        { "acos"            ,1,1  ,0,1 ,1,0,nullptr ,acos               ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_acos        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"Acos"          ,-1,1 ,1 ,nullptr ,"-einv(sqrt(1-(x.^2))).*var(1,0)", 
          "Inverse cosine (see Abramowitz and Stegun)" },
        { "Acos"            ,1,1  ,0,1 ,1,0,nullptr ,Acos               ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_Acos        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"acos"          ,-1,1 ,1 ,nullptr ,"-einv(Sqrt(1-(x.^2))).*var(1,0)", 
          "Inverse cosine (alternative hand, see Abramowitz and Stegun)" },
        { "atan"            ,1,1  ,0,1 ,1,0,nullptr ,atan               ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_atan        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"~"             ,-1,1 ,1 ,nullptr ,"einv(1+(x.^2)).*var(1,0)", 
          "Inverse tangent (see Abramowitz and Stegun)" },
        { "acosec"          ,1,1  ,0,1 ,1,0,nullptr ,acosec             ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_acosec      ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"Acosec"        ,-1,1 ,1 ,nullptr ,"-einv(x.*sqrt((x.^2)-1)).*var(1,0)", 
          "Inverse cosecant (acosec(a) = asin(inv(a)))" },
        { "Acosec"          ,1,1  ,0,1 ,1,0,nullptr ,Acosec             ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_Acosec      ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"acosec"        ,-1,1 ,1 ,nullptr ,"-einv(x.*Sqrt((x.^2)-1)).*var(1,0)", 
          "Inverse cosecant (alternative hand, Acosec(a) = Asin(inv(a)))" },
        { "asec"            ,1,1  ,0,1 ,1,0,nullptr ,asec               ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_asec        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"Asec"          ,-1,1 ,1 ,nullptr ,"einv(x.*sqrt((x.^2)-1)).*var(1,0)", 
          "Inverse secant (asec(a) = acos(inv(a)))" },
        { "Asec"            ,1,1  ,0,1 ,1,0,nullptr ,Asec               ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_Asec        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"asec"          ,-1,1 ,1 ,nullptr ,"einv(x.*Sqrt((x.^2)-1)).*var(1,0)", 
          "Inverse secant (alternative hand, Asec(a) = Acos(inv(a)))" },
        { "acot"            ,1,1  ,0,1 ,1,0,nullptr ,acot               ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_acot        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"~"             ,-1,1 ,1 ,nullptr ,"-einv(1+(x.^2)).*var(1,0)", 
          "Inverse cotangent (acot(a) = atan(inv(a)))" },
        { "sinc"            ,1,1  ,0,1 ,1,0,nullptr ,sinc               ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_sinc        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"~"             ,-1,1 ,1 ,nullptr ,"((cos(x)-sinc(x))./x).*var(1,0)", 
          "Sinc (unnormalised sin(x)/x)" },
        { "cosc"            ,1,1  ,0,1 ,1,0,nullptr ,cosc               ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_cosc        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"~"             ,-1,1 ,1 ,nullptr ,"((-sin(x)-cosc(x))./x).*var(1,0)", 
          "Cosc (unnormalised cos(x)/x)" },
        { "tanc"            ,1,1  ,0,1 ,1,0,nullptr ,tanc               ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_tanc        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"~"             ,-1,1 ,1 ,nullptr ,"(((sec(x).^2)-tanc(x))./x).*var(1,0)", 
          "Tanc (unnormalised tan(x)/x)" },
        { "vers"            ,1,1  ,0,1 ,1,0,nullptr ,vers               ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_vers        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"~"             ,-1,1 ,1 ,nullptr ,"realDeriv(0,0,1-cos(x)).*var(1,0)", 
          "Versed sine (1-cos(x))" },
        { "covers"          ,1,1  ,0,1 ,1,0,nullptr ,covers             ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_covers      ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"~"             ,-1,1 ,1 ,nullptr ,"realDeriv(0,0,1-sin(x)).*var(1,0)", 
          "Coversed sine (1-sin(x))" },
        { "hav"             ,1,1  ,0,1 ,1,0,nullptr ,hav                ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_hav         ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"~"             ,-1,1 ,1 ,nullptr ,"realDeriv(0,0,vers(x)/2).*var(1,0)", 
          "Half versed sine (vers(x)/2)" },
        { "excosec"         ,1,1  ,0,1 ,1,0,nullptr ,excosec            ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_excosec     ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"~"             ,-1,1 ,1 ,nullptr ,"realDeriv(0,0,cosec(x)-1).*var(1,0)", 
          "External cosecant (cosec(x)-1)" },
        { "exsec"           ,1,1  ,0,1 ,1,0,nullptr ,exsec              ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_exsec       ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"~"             ,-1,1 ,1 ,nullptr ,"realDeriv(0,0,sec(x)-1).*var(1,0)", 
          "Exterior secant (sec(x)-1)" },
        { "avers"           ,1,1  ,0,1 ,1,0,nullptr ,avers              ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_avers       ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"Avers"         ,-1,1 ,1 ,nullptr ,"realDeriv(0,0,acos(x+1)).*var(1,0)", 
          "Inverse versed sine (acos(x+1))" },
        { "Avers"           ,1,1  ,0,1 ,1,0,nullptr ,Avers              ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_Avers       ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"avers"         ,-1,1 ,1 ,nullptr ,"realDeriv(0,0,Acos(x+1)).*var(1,0)", 
          "Inverse versed sine (alternative hand, Acos(x+1))" },
        { "acovers"         ,1,1  ,0,1 ,1,0,nullptr ,acovers            ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_acovers     ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"Acovers"       ,-1,1 ,1 ,nullptr ,"realDeriv(0,0,asin(x+1)).*var(1,0)", 
          "Inverse coversed sine (asin(x+1))" },
        { "Acovers"         ,1,1  ,0,1 ,1,0,nullptr ,Acovers            ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_Acovers     ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"acovers"       ,-1,1 ,1 ,nullptr ,"realDeriv(0,0,Asin(x+1)).*var(1,0)", 
          "Inverse coversed sine (alternative hand, Asin(x+1))" },
        { "ahav"            ,1,1  ,0,1 ,1,0,nullptr ,ahav               ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_ahav        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"Ahav"          ,-1,1 ,1 ,nullptr ,"realDeriv(0,0,avers(2*x)).*var(1,0)", 
          "Inverse half versed sine (avers(2*x))" },
        { "Ahav"            ,1,1  ,0,1 ,1,0,nullptr ,Ahav               ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_Ahav        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"ahav"          ,-1,1 ,1 ,nullptr ,"realDeriv(0,0,Avers(2*x)).*var(1,0)", 
          "Inverse half versed sine (alternative hand Avers(2*x))" },
        { "aexcosec"        ,1,1  ,0,1 ,1,0,nullptr ,aexcosec           ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_aexcosec    ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"Aexcosec"      ,-1,1 ,1 ,nullptr ,"realDeriv(0,0,acosec(x+1)).*var(1,0)", 
          "Inverse external cosecant (acosec(x+1))" },
        { "Aexcosec"        ,1,1  ,0,1 ,1,0,nullptr ,Aexcosec           ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_Aexcosec    ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"aexcosec"      ,-1,1 ,1 ,nullptr ,"realDeriv(0,0,Acosec(x+1)).*var(1,0)", 
          "Inverse external cosecant (alternative hand, Acosec(x+1))" },
        { "aexsec"          ,1,1  ,0,1 ,1,0,nullptr ,aexsec             ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_aexsec      ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"Aexsec"        ,-1,1 ,1 ,nullptr ,"realDeriv(0,0,asec(x+1)).*var(1,0)", 
          "Inverse external secant (asec(x+1))" },
        { "Aexsec"          ,1,1  ,0,1 ,1,0,nullptr ,Aexsec             ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_Aexsec      ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"aexsec"        ,-1,1 ,1 ,nullptr ,"realDeriv(0,0,Asec(x+1)).*var(1,0)", 
          "Inverse external secant (alternative hand, Asec(x+1))" },
        { "castrg"          ,1,1  ,0,1 ,1,0,nullptr ,castrg             ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_castrg      ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"castrg"        ,-1,1 ,1 ,nullptr ,"casctrg(x).*var(1,0)", 
          "Cosine and sine cos(x)+sin(x)" },
        { "acastrg"         ,1,1  ,0,1 ,1,0,nullptr ,acastrg            ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_acastrg     ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"acastrg"       ,-1,1 ,1 ,nullptr ,"realDeriv(0,0,acos(x/sqrt(2))).*var(1,0)", 
          "Inverse cosine and sine (acos(x/sqrt(2))+pi/4)" },
        { "Acastrg"         ,1,1  ,0,1 ,1,0,nullptr ,Acastrg            ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_Acastrg     ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"Acastrg"       ,-1,1 ,1 ,nullptr ,"realDeriv(0,0,Acos(2/sqrt(2))).*var(1,0)", 
          "Inverse cosine and sine (alternative hand Acos(x/sqrt(2))+pi/4)" },
        { "casctrg"         ,1,1  ,0,1 ,1,0,nullptr ,casctrg            ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_casctrg     ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"casctrg"       ,-1,1 ,1 ,nullptr ,"-castrg(x).*var(1,0)", 
          "Complementary cosine and sine (cos(x)-sin(x))" },
        { "acasctrg"        ,1,1  ,0,1 ,1,0,nullptr ,acasctrg           ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_acasctrg    ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"acasctrg"      ,-1,1 ,1 ,nullptr ,"realDeriv(0,0,acos(x/sqrt(2))).*var(1,0)", 
          "Inverse complementary cosine and sine (acos(x/sqrt(2))-pi/4)" },
        { "Acasctrg"        ,1,1  ,0,1 ,1,0,nullptr ,Acasctrg           ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_Acasctrg    ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"Acasctrg"      ,-1,1 ,1 ,nullptr ,"realDeriv(0,0,Acos(2/sqrt(2))).*var(1,0)", 
          "Inverse complementary cosine and sine (alternative hand, Acos(x/sqrt(2))-pi/4)" },
        { "sinh"            ,1,1  ,0,1 ,1,0,nullptr ,sinh               ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_sinh        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"~"             ,-1,1 ,1 ,nullptr ,"cosh(x).*var(1,0)", 
          "Hyperbolic Sine (sinh(R)*cos(I) + q*cosh(R)*sin(I))" },
        { "cosh"            ,1,1  ,0,1 ,1,0,nullptr ,cosh               ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_cosh        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"~"             ,-1,1 ,1 ,nullptr ,"sinh(x).*var(1,0)", 
          "Hyperbolic Cosine (cosh(R)*cos(I) + q*sinh(R)*sin(I))" },
        { "tanh"            ,1,1  ,0,1 ,1,0,nullptr ,tanh               ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_tanh        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"~"             ,-1,1 ,1 ,nullptr ,"(sech(x).^2).*var(1,0)", 
          "Hyperbolic Tangent (sinh(a)*inv(cosh(a)))" },
        { "cosech"          ,1,1  ,0,1 ,1,0,nullptr ,cosech             ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_cosech      ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"~"             ,-1,1 ,1 ,nullptr ,"-cosech(x).*coth(x).*var(1,0)", 
          "Hyperbolic Cosecant (inv(sinh(a)))" },
        { "sech"            ,1,1  ,0,1 ,1,0,nullptr ,sech               ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_sech        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"~"             ,-1,1 ,1 ,nullptr ,"-sech(x).*tanh(x).*var(1,0)", 
          "Hyperbolic Secant (inv(cosh(a)))" },
        { "coth"            ,1,1  ,0,1 ,1,0,nullptr ,coth               ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_coth        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"~"             ,-1,1 ,1 ,nullptr ,"-(cosech(x).^2).*var(1,0)", 
          "Hyperbolic Cotangent (inv(tanh(a)))" },
        { "asinh"           ,1,1  ,0,1 ,1,0,nullptr ,asinh              ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_asinh       ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"~"             ,-1,1 ,1 ,nullptr ,"einv(sqrt((x.^2)+1)).*var(1,0)", 
          "Inverse Hyperbolic Sine (see Abramowitz and Stegun)" },
        { "acosh"           ,1,1  ,0,1 ,1,0,nullptr ,acosh              ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_acosh       ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"Acosh"         ,-1,1 ,1 ,nullptr ,"einv(sqrt((x.^2)-1)).*var(1,0)", 
          "Inverse Hyperbolic Cosine (see Abramowitz and Stegun)" },
        { "Acosh"           ,1,1  ,0,1 ,1,0,nullptr ,Acosh              ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_Acosh       ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"acosh"         ,-1,1 ,1 ,nullptr ,"einv(Sqrt((x.^2)-1)).*var(1,0)", 
          "Inverse Hyperbolic Cosine (alternative hand, see Abramowitz and Stegun)" },
        { "atanh"           ,1,1  ,0,1 ,1,0,nullptr ,atanh              ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_atanh       ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"Atanh"         ,-1,1 ,1 ,nullptr ,"einv(1-(x.^2)).*var(1,0)", 
          "Inverse Hyperbolic Tangent (see Abramowitz and Stegun)" },
        { "Atanh"           ,1,1  ,0,1 ,1,0,nullptr ,Atanh              ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_Atanh       ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"atanh"         ,-1,1 ,1 ,nullptr ,"einv(1-(x.^2)).*var(1,0)", 
          "Inverse Hyperbolic Tangent (alternative hand, Abramowitz and Stegun)" },
        { "acosech"         ,1,1  ,0,1 ,1,0,nullptr ,acosech            ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_acosech     ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"~"             ,-1,1 ,1 ,nullptr ,"-sgn(real(x)).*einv(x.*sqrt(1+(x.^2))).*var(1,0)", 
          "Inverse Hyperbolic Cosecant (Abramowitz and Stegun)" },
        { "asech"           ,1,1  ,0,1 ,1,0,nullptr ,asech              ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_asech       ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"Asech"         ,-1,1 ,1 ,nullptr ,"-sgn(real(x)).*einv(x.*sqrt(1-(x.^2))).*var(1,0)", 
          "Inverse Hyperbolic Secant (acosh(inv(a)))" },
        { "Asech"           ,1,1  ,0,1 ,1,0,nullptr ,Asech              ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_Asech       ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"asech"         ,-1,1 ,1 ,nullptr ,"-sgn(real(x)).*einv(x.*Sqrt(1-(x.^2))).*var(1,0)", 
          "Inverse Hyperbolic Secant (alternative hand, Acosh(inv(a)))" },
        { "acoth"           ,1,1  ,0,1 ,1,0,nullptr ,acoth              ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_acoth       ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"Acoth"         ,-1,1 ,1 ,nullptr ,"einv(1-(x.^2)).*var(1,0)", 
          "Inverse Hyperbolic Cotangent (atanh(inv(a)))" },
        { "Acoth"           ,1,1  ,0,1 ,1,0,nullptr ,Acoth              ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_Acoth       ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"acoth"         ,-1,1 ,1 ,nullptr ,"einv(1-(x.^2)).*var(1,0)", 
          "Inverse Hyperbolic Cotangent (alterntaive hand, Atanh(inv(a)))" },
        { "sinhc"           ,1,1  ,0,1 ,1,0,nullptr ,sinhc              ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_sinhc       ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"~"             ,-1,1 ,1 ,nullptr ,"((cosh(x)-sinhc(x))./x).*var(1,0)", 
          "Hyperbolic Sinc (unnormalised sinh(x)/x)" },
        { "coshc"           ,1,1  ,0,1 ,1,0,nullptr ,coshc              ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_coshc       ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"~"             ,-1,1 ,1 ,nullptr ,"((sinh(x)-coshc(x))./x).*var(1,0)", 
          "Hyperbolic Cosc (unnormalised cosh(x)/x)" },
        { "tanhc"           ,1,1  ,0,1 ,1,0,nullptr ,tanhc              ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_tanhc       ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"~"             ,-1,1 ,1 ,nullptr ,"(((sech(x).^2)-tanhc(x))./x).*var(1,0)", 
          "Hyperbolic Tanc (unnormalised tanh(x)/x)" },
        { "versh"           ,1,1  ,0,1 ,1,0,nullptr ,versh              ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_versh       ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"~"             ,-1,1 ,1 ,nullptr ,"realDeriv(0,0,1-cosh(x)).*var(1,0)", 
          "Hyperbolic Versed sine (1-cosh(x))" },
        { "coversh"         ,1,1  ,0,1 ,1,0,nullptr ,coversh            ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_coversh     ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"~"             ,-1,1 ,1 ,nullptr ,"realDeriv(0,0,1-sinh(x)).*var(1,0)", 
          "Hyperbolic Coversed sine (1-sinh(x))" },
        { "havh"            ,1,1  ,0,1 ,1,0,nullptr ,havh               ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_havh        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"~"             ,-1,1 ,1 ,nullptr ,"realDeriv(0,0,versh(x)/2).*var(1,0)", 
          "Hyperbolic Half versed sine (versh(x)/2)" },
        { "excosech"        ,1,1  ,0,1 ,1,0,nullptr ,excosech           ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_excosech    ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"~"             ,-1,1 ,1 ,nullptr ,"realDeriv(0,0,cosech(x)-1).*var(1,0)", 
          "Hyperbolic External cosecant (cosech(x)-1)" },
        { "exsech"          ,1,1  ,0,1 ,1,0,nullptr ,exsech             ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_exsech      ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"~"             ,-1,1 ,1 ,nullptr ,"realDeriv(0,0,sech(x)-1).*var(1,0)", 
          "Hyperbolic Exterior secant (sech(x)-1)" },
        { "aversh"          ,1,1  ,0,1 ,1,0,nullptr ,aversh             ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_aversh      ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"Aversh"        ,-1,1 ,1 ,nullptr ,"realDeriv(0,0,acosh(x+1)).*var(1,0)", 
          "Inverse Hypebolic versed sine (acosh(x+1))" },
        { "Aversh"          ,1,1  ,0,1 ,1,0,nullptr ,Aversh             ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_Aversh      ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"aversh"        ,-1,1 ,1 ,nullptr ,"realDeriv(0,0,Acosh(x+1)).*var(1,0)", 
          "Inverse Hyperbolic versed sine (alternative hand, Acosh(x+1))" },
        { "acovrsh"         ,1,1  ,0,1 ,1,0,nullptr ,acovrsh            ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_acovrsh     ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"~"             ,-1,1 ,1 ,nullptr ,"realDeriv(0,0,asinh(x+1)).*var(1,0)", 
          "Inverse Hyperbolic coversed sine (asinh(x+1))" },
        { "ahavh"           ,1,1  ,0,1 ,1,0,nullptr ,ahavh              ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_ahavh       ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"Ahavh"         ,-1,1 ,1 ,nullptr ,"realDeriv(0,0,aversh(2*x)).*var(1,0)", 
          "Inverse hyperbolic half versed sine (aversh(2*x))" },
        { "Ahavh"           ,1,1  ,0,1 ,1,0,nullptr ,Ahavh              ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_Ahavh       ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"ahavh"         ,-1,1 ,1 ,nullptr ,"realDeriv(0,0,Aversh(2*x)).*var(1,0)", 
          "Inverse hyperbolic half versed sine (alterative hand, Aversh(2*x))" },
        { "aexcosech"       ,1,1  ,0,1 ,1,0,nullptr ,aexcosech          ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_aexcosech   ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"~"             ,-1,1 ,1 ,nullptr ,"realDeriv(0,0,acosech(x+1)).*var(1,0)", 
          "Inverse hyperbolic external cosecant (acosech(x+1))" },
        { "aexsech"         ,1,1  ,0,1 ,1,0,nullptr ,aexsech            ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_aexsech     ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"Aexsech"       ,-1,1 ,1 ,nullptr ,"realDeriv(0,0,asech(x+1)).*var(1,0)", 
          "Inverse hyperbolic external secant (asech(x+1))" },
        { "Aexsech"         ,1,1  ,0,1 ,1,0,nullptr ,Aexsech            ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_Aexsech     ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"aexsech"       ,-1,1 ,1 ,nullptr ,"realDeriv(0,0,Asech(x+1)).*var(1,0)", 
          "Inverse hyperbolic external secant (alternative hand, Asech(x+1))" },
        { "cashyp"          ,1,1  ,0,1 ,1,0,nullptr ,cashyp             ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_cashyp      ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"cashyp"        ,-1,1 ,1 ,nullptr ,"exp(x).*var(1,0)", 
          "Hyperbolic cas (cosine and sine) (cash(a) = cosh(a)+sinh(a) = exp(a))" },
        { "acashyp"         ,1,1  ,0,1 ,1,0,nullptr ,acashyp            ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_acashyp     ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"acashyp"       ,-1,1 ,1 ,nullptr ,"realDeriv(0,0,log(x)).*var(1,0)", 
          "Hyperbolic Inverse cas (log(a))" },
        { "Acashyp"         ,1,1  ,0,1 ,1,0,nullptr ,Acashyp            ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_Acashyp     ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"Acashyp"       ,-1,1 ,1 ,nullptr ,"realDeriv(0,0,Log(x)).*var(1,0)", 
          "Hyperbolic Inverse cas (alternative hand, Log(a))" },
        { "caschyp"         ,1,1  ,0,1 ,1,0,nullptr ,caschyp            ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_caschyp     ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"caschyp"       ,-1,1 ,1 ,nullptr ,"exp(-x).*var(1,0)", 
          "Hyperbolic Complementary cas (cosine and sine) (cash(a) = cosh(a)-sinh(a) = exp(-a))" },
        { "acaschyp"        ,1,1  ,0,1 ,1,0,nullptr ,acaschyp           ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_acaschyp    ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"acaschyp"      ,-1,1 ,1 ,nullptr ,"realDeriv(0,0,-log(x)).*var(1,0)", 
          "Hyperbolic Inverse Complementary cas (-log(a))" },
        { "Acaschyp"        ,1,1  ,0,1 ,1,0,nullptr ,Acaschyp           ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_Acaschyp    ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"Acaschyp"      ,-1,1 ,1 ,nullptr ,"realDeriv(0,0,-Log(x)).*var(1,0)", 
          "Hyperbolic Inverse Complementary cas (alternative hand, -Log(a))" },
        { "sigm"            ,1,1  ,0,1 ,1,0,nullptr ,sigm               ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_sigm        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"~"             ,-1,1 ,1 ,nullptr ,"realDeriv(0,0,einv(1+exp(x))).*var(1,0)", 
          "Sigmoid function (inv(1+exp(a)))" },
        { "gd"              ,1,1  ,0,1 ,1,0,nullptr ,gd                 ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_gd          ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"~"             ,-1,1 ,1 ,nullptr ,"realDeriv(0,0,2*atan(tanh(x/2))).*var(1,0)", 
          "Gudermannian function (2*atan(tanh(a/2)))" },
        { "asigm"           ,1,1  ,0,1 ,1,0,nullptr ,asigm              ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_asigm       ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"Asigm"         ,-1,1 ,1 ,nullptr ,"realDeriv(0,0,log(einv(x)-1)).*var(1,0)", 
          "Inverse sigmoid function (log(inv(a)-1))" },
        { "Asigm"           ,1,1  ,0,1 ,1,0,nullptr ,Asigm              ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_Asigm       ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"asigm"         ,-1,1 ,1 ,nullptr ,"realDeriv(0,0,Log(einv(x)-1)).*var(1,0)", 
          "Inverse sigmoid function (alternative hand, Log(inv(a)-1))" },
        { "agd"             ,1,1  ,0,1 ,1,0,nullptr ,agd                ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_agd         ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"Agd"           ,-1,1 ,1 ,nullptr ,"realDeriv(0,0,2*atanh(tan(x/2))).*var(1,0)", 
          "Inverse Gudermannian function (2*atanh(tan(a/2)))" },
        { "Agd"             ,1,1  ,0,1 ,1,0,nullptr ,Agd                ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_Agd         ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"agd"           ,-1,1 ,1 ,nullptr ,"realDeriv(0,0,2*Atanh(tan(x/2))).*var(1,0)", 
          "Inverse Gudermannian function (alternative hand, 2*Atanh(tan(a/2)))" },
        { "bern"            ,2,3  ,0,3 ,1,0,nullptr ,nullptr            ,bern         ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"~"             ,-1,3 ,3 ,nullptr ,"((size(x)-1)*bern(derefv(x,ivect(1,1,size(x)-1))-derefv(x,ivect(0,1,size(x)-2)),y)).*var(1,1)", 
          "bern(w,x) returns the Bernstein polynomial of order size(w) (w is a weight vector) evaluated at x" },
        { "funcv"           ,1,0  ,0,0 ,1,0,nullptr ,bernv              ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"~"             ,-1,0 ,0 ,nullptr ,"0", 
          "Return functional vector for function f(x)" },
        { "rkhsv"           ,3,7  ,0,7 ,1,0,nullptr ,bernv              ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"~"             ,-1,0 ,0 ,nullptr ,"0", 
          "return RKHS vector with kernel K (string - see mercer.h for format), centres (vectors) x and weights a" },
        { "bernv"           ,1,1  ,0,1 ,1,0,nullptr ,bernv              ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"~"             ,-1,0 ,0 ,nullptr ,"0", 
          "bernv(w) return the Bernstein polynomial *vector* of order size(w) (w is a weight vector)" },
        { "normDistr"       ,1,1  ,0,1 ,1,0,nullptr ,normDistr          ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"~"             ,-1,1 ,1 ,nullptr ,"realDeriv(0,0,0.398942280401*exp((-(x^2))/2)).*var(1,0)", 
          "Normal distribution density function." },
        { "polyDistr"       ,2,3  ,0,3 ,1,0,nullptr ,nullptr            ,polyDistr    ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,3 ,"PolyDistr"     ,-1,3 ,3 ,nullptr ,"realDeriv(0,0,(x*sqrt(gamma(3/x)/gamma(1/x))/(2*gamma(1/x)))*exp(-(sqrt(gamma(3/x)/gamma(1/x))^x)*(y^x)))*var(1,0)+realDeriv(0,1,(x*sqrt(gamma(3/x)/gamma(1/x))/(2*gamma(1/x)))*exp(-(sqrt(gamma(3/x)/gamma(1/x))^x)*(y^x)))*var(1,1)", 
          "Polynomial distribution density function." },
        { "PolyDistr"       ,2,3  ,0,3 ,1,0,nullptr ,nullptr            ,PolyDistr    ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,3 ,"polyDistr"     ,-1,3 ,3 ,nullptr ,"realDeriv(0,0,(x*Sqrt(gamma(3/x)/gamma(1/x))/(2*gamma(1/x)))*exp(-(Sqrt(gamma(3/x)/gamma(1/x))^x)*(y^x)))*var(1,0)+realDeriv(0,1,(x*Sqrt(gamma(3/x)/gamma(1/x))/(2*gamma(1/x)))*exp(-(Sqrt(gamma(3/x)/gamma(1/x))^x)*(y^x)))*var(1,1)", 
          "Polynomial distribution density function (alternative hand)." },
        { "gamma"           ,1,1  ,0,1 ,1,0,nullptr ,gamma              ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"~"             ,-1,1 ,1 ,nullptr ,"(gamma(x).*psi(x)).*var(1,0)", 
          "Gamma function" },
        { "lngamma"         ,1,1  ,0,1 ,1,0,nullptr ,lngamma            ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"~"             ,-1,1 ,1 ,nullptr ,"psi(x).*var(1,0)", 
          "Log gamma function" },
        { "psi"             ,1,1  ,0,1 ,1,0,nullptr ,psi                ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"~"             ,-1,1 ,1 ,nullptr ,"psi_n(1,x).*var(1,0)", 
          "Digamma function" },
        { "psi_n"           ,2,3  ,0,3 ,1,0,nullptr ,nullptr            ,psi_n        ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,2 ,"~"             ,-1,3 ,2 ,nullptr ,"psi_n(x-1,y).*var(1,1)", 
          "Polygamma function" },
        { "gami"            ,2,3  ,0,3 ,1,0,nullptr ,nullptr            ,gami         ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,0 ,0 ,nullptr ,"E: \"Gradient of gami not defined\"", 
          "Incomplete gamma function" },
        { "gamic"           ,2,3  ,0,3 ,1,0,nullptr ,nullptr            ,gamic        ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,0 ,0 ,nullptr ,"E: \"Gradient of gamic not defined\"", 
          "Inverse incomplete gamma function" },
        { "erf"             ,1,1  ,0,1 ,1,0,nullptr ,erf                ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_erf         ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"~"             ,-1,1 ,1 ,nullptr ,"((2/sqrt(pi()))*exp(-(x.^2))).*var(1,0)", 
          "Error function" },
        { "erfc"            ,1,1 ,0 ,1 ,1,0,nullptr ,erfc               ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_erfc        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"~"             ,-1,1 ,1 ,nullptr ,"(-(2/sqrt(pi()))*exp(-(x.^2))).*var(1,0)", 
          "Complementary error function" },
        { "dawson"          ,1,1 ,0 ,1 ,1,0,nullptr ,dawson             ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"~"             ,-1,1 ,1 ,nullptr ,"(1-(2*(x.*dawson(x)))).*var(1,0)", 
          "Dawson's function" },
        { "rint"            ,1,1 ,0 ,1 ,1,0,nullptr ,rint               ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,0 ,0 ,nullptr ,"0", 
          "Round to nearest integer" },
        { "ceil"            ,1,1 ,0 ,1 ,1,0,nullptr ,ceil               ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,0 ,0 ,nullptr ,"0", 
          "Round up to integer" },
        { "floor"           ,1,1 ,0 ,1 ,1,0,nullptr ,floor              ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,0 ,0 ,nullptr ,"0", 
          "Round down to integer" },
        { "outerProd"       ,2,3 ,0 ,3 ,1,0,nullptr ,nullptr            ,outerProd    ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,-3,"OuterProd"     ,-1,3 ,3 ,nullptr ,"outerProd(var(1,0),y)+outerProd(x,var(1,1))", 
          "Outer product." },
        { "OuterProd"       ,2,3 ,0 ,3 ,1,0,nullptr ,nullptr            ,OuterProd    ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,-3,"outerprod"     ,-1,3 ,3 ,nullptr ,"OuterProd(var(1,0),y)+OuterProd(x,var(1,1))", 
          "Transpose of outer product." },
        { "fourProd"        ,4,15,0 ,15,1,0,nullptr ,nullptr            ,nullptr      ,nullptr         ,fourProd   ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,15,"~"             ,-1,15,15,nullptr ,"fourProd(var(1,0),y,z,v)+fourProd(x,var(1,1),z,v)+fourProd(x,y,var(1,2),v)+fourProd(x,y,z,var(1,3))", 
          "Four product." },
        { "trans"           ,1,1 ,0 ,1 ,1,0,nullptr ,trans              ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"~"             ,-1,0 ,1 ,nullptr ,"trans(var(1,0))", 
          "Transpose." },
        { "det"             ,1,1 ,0 ,1 ,1,0,nullptr ,det                ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"~"             ,-1,0 ,0 ,nullptr ,"E: \"Gradient of det not defined\"", 
          "Determinant." },
        { "trace"           ,1,1 ,0 ,1 ,1,0,nullptr ,trace              ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"~"             ,-1,0 ,1 ,nullptr ,"trace(var(1,0))", 
          "Trace." },
        { "miner"           ,3,7 ,0 ,7 ,1,0,nullptr ,nullptr            ,nullptr      ,miner           ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,0 ,0 ,nullptr ,"E: \"Gradient of miner not defined\"" , 
          "Matrix minor." },
        { "cofactor"        ,3,7 ,0 ,7 ,1,0,nullptr ,nullptr            ,nullptr      ,cofactor        ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,0 ,0 ,nullptr ,"E: \"Gradient of cofactor not defined\"" , 
          "Matrix cofactor." },
        { "adj"             ,1,1 ,0 ,1 ,1,0,nullptr ,adj                ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"~"             ,-1,0 ,0 ,nullptr ,"E: \"Gradient of adj not defined\"", 
          "Matrix adjoint." },
        { "max"             ,1,0 ,1 ,1 ,1,0,nullptr ,max                ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"~"             ,-1,1 ,1 ,nullptr ,"deref(var(1,0),argmax(x))", 
          "Maximum." },
        { "min"             ,1,0 ,1 ,1 ,1,0,nullptr ,min                ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"~"             ,-1,1 ,1 ,nullptr ,"deref(var(1,0),argmin(x))", 
          "Minimum" },
        { "maxdiag"         ,1,0 ,1 ,1 ,1,0,nullptr ,maxdiag            ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"~"             ,-1,1 ,1 ,nullptr ,"deref(var(1,0),argmaxdiag(x))", 
          "Maximum diagonal element." },
        { "mindiag"         ,1,0 ,1 ,1 ,1,0,nullptr ,mindiag            ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"~"             ,-1,1 ,1 ,nullptr ,"deref(var(1,0),argmindiag(x))", 
          "Minimum diagonal element." },
        { "argmax"          ,1,0 ,1 ,1 ,1,0,nullptr ,argmax             ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,0 ,0 ,nullptr ,"0", 
          "Maximum element index." },
        { "argmin"          ,1,0 ,1 ,1 ,1,0,nullptr ,argmin             ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,0 ,0 ,nullptr ,"0", 
          "Minimum element index." },
        { "argmaxdiag"      ,1,0 ,1 ,1 ,1,0,nullptr ,argmaxdiag         ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,0 ,0 ,nullptr ,"0", 
          "Maximum diagonal element index." },
        { "argmindiag"      ,1,0 ,1 ,1 ,1,0,nullptr ,argmindiag         ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,0 ,0 ,nullptr ,"0", 
          "Minimum diagonal element index." },
        { "allargmax"       ,1,0 ,1 ,1 ,1,0,nullptr ,allargmax          ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,0 ,0 ,nullptr ,"0", 
          "Vector of all maximum element indices." },
        { "allargmin"       ,1,0 ,1 ,1 ,1,0,nullptr ,allargmin          ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,0 ,0 ,nullptr ,"0", 
          "Vector of all minimum element indices." },
        { "allargmaxdiag"   ,1,0 ,1 ,1 ,1,0,nullptr ,allargmaxdiag      ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,0 ,0 ,nullptr ,"0", 
          "Vector of all maximum diagonal element indices." },
        { "allargmindiag"   ,1,0 ,1 ,1 ,1,0,nullptr ,allargmindiag      ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,0 ,0 ,nullptr ,"0", 
          "Vector of all minimum diagonal element indices." },
        { "maxabs"          ,1,0 ,1 ,1 ,1,0,nullptr ,maxabs             ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,1 ,1 ,nullptr ,"deref(var(1,0),argmaxabs(x))", 
          "maximum absolute element of a" },
        { "minabs"          ,1,0 ,1 ,1 ,1,0,nullptr ,minabs             ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,1 ,1 ,nullptr ,"deref(var(1,0),argminabs(x))", 
          "minimum absolute element of a" },
        { "maxabsdiag"      ,1,0 ,1 ,1 ,1,0,nullptr ,maxabsdiag         ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,1 ,1 ,nullptr ,"deref(var(1,0),argmaxabsdiag(x))", 
          "maximum absolute element of a" },
        { "minabsdiag"      ,1,0 ,1 ,1 ,1,0,nullptr ,minabsdiag         ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,1 ,1 ,nullptr ,"deref(var(1,0),argminabsdiag(x))", 
          "minimum absolute element of a" },
        { "argmaxabs"       ,1,0 ,1 ,1 ,1,0,nullptr ,argmaxabs          ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,0 ,0 ,nullptr ,"0", 
          "first index maximum absolute element of a" },
        { "argminabs"       ,1,0 ,1 ,1 ,1,0,nullptr ,argminabs          ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,0 ,0 ,nullptr ,"0", 
          "first index minimum absolute element of a" },
        { "argmaxabsdiag"   ,1,0 ,1 ,1 ,1,0,nullptr ,argmaxabsdiag      ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,0 ,0 ,nullptr ,"0", 
          "first index maximum absolute element of a" },
        { "argminabsdiag"   ,1,0 ,1 ,1 ,1,0,nullptr ,argminabsdiag      ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,0 ,0 ,nullptr ,"0", 
          "first index minimum absolute element of a" },
        { "allargmaxabs"    ,1,0 ,1 ,1 ,1,0,nullptr ,allargmaxabs       ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,0 ,0 ,nullptr ,"0", 
          "all maximum absolute elements of a" },
        { "allargminabs"    ,1,0 ,1 ,1 ,1,0,nullptr ,allargminabs       ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,0 ,0 ,nullptr ,"0", 
          "all minimum absolute elements of a" },
        { "allargmaxabsdiag",1,0 ,1 ,1 ,1,0,nullptr ,allargmaxabsdiag   ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,0 ,0 ,nullptr ,"0", 
          "all maximum absolute elements of a" },
        { "allargminabsdiag",1,0 ,1 ,1 ,1,0,nullptr ,allargminabsdiag   ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,0 ,0 ,nullptr ,"0", 
          "all minimum absolute elements of a" },
        { "sum"             ,1,1 ,0 ,1 ,1,0,nullptr ,sum                ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"~"             ,-1,0 ,1 ,nullptr ,"sum(var(1,0))", 
          "Summation of all elements." },
        { "prod"            ,1,1 ,0 ,1 ,1,0,nullptr ,prod               ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"Prod"          ,-1,1 ,0 ,nullptr ,"realDeriv(0,0,prod(sgn(var(0,0)))*exp(sum(log(eabs2(var(0,0))))))*var(1,0)", 
          "Prodoct of all elements (evaluated left-right)." },
        { "Prod"            ,1,1 ,0 ,1 ,1,0,nullptr ,Prod               ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"prod"          ,-1,1 ,0 ,nullptr ,"realDeriv(0,0,prod(sgn(var(0,0)))*exp(sum(log(eabs2(conj(var(0,0)))))))*var(1,0)", 
          "Product of all elements (evaluated right-left)." },
        { "mean"            ,1,1 ,0 ,1 ,1,0,nullptr ,mean               ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"~"             ,-1,0 ,1 ,nullptr ,"mean(var(1,0))", 
          "Mean of elements." },
        { "median"          ,1,0 ,1 ,1 ,1,0,nullptr ,median             ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"~"             ,-1,1 ,1 ,nullptr ,"deref(var(1,0),argmedian(x))", 
          "Median of elements." },
        { "argmedian"       ,1,0 ,1 ,1 ,1,0,nullptr ,argmedian          ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,0 ,0 ,nullptr ,"0", 
          "index of median element." },
        { "deref"           ,2,3 ,0 ,3 ,1,0,nullptr ,nullptr            ,deref        ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"~"             ,-1,2 ,1 ,nullptr ,"deref(var(1,0),y)", 
          "deref(a,x) returns element x in a. scalar: x = [ ] -> a, x = [ i ] -> derefv(a,i), x = [ i j ] -> derefm(a,i,j)" },
        { "derefv"          ,2,3 ,0 ,3 ,1,0,nullptr ,nullptr            ,derefv       ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"~"             ,-1,2 ,1 ,nullptr ,"derefv(var(1,0),y)", 
          "derefv(a,i) returns element i in vector a" },
        { "derefm"          ,3,7 ,0 ,7 ,1,0,nullptr ,nullptr            ,nullptr      ,derefm          ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"~"             ,-1,2 ,1 ,nullptr ,"derefm(var(1,0),y,z)", 
          "derefm(a,i,j) returns element i,j in matrix a" },
        { "derefa"          ,2,3 ,0 ,3 ,1,0,nullptr ,nullptr            ,derefa       ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"~"             ,-1,2 ,1 ,nullptr ,"derefa(var(1,0),y)" , 
          "derefa(a,i) return a(i) for anion a" },
        { "collapse"        ,1,1 ,0 ,1 ,1,0,nullptr ,collapse           ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"~"             ,-1,0 ,1 ,nullptr ,"collapse(var(1,0))", 
          "" },
        { "zeta"            ,1,1 ,0 ,1 ,1,0,nullptr ,zeta               ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"~"             ,-1,1 ,1 ,nullptr ,"E: \"Gradient of zeta not defined\"", 
          "Reimann zeta function" },
        { "lambertW"        ,1,1 ,0 ,1 ,1,0,nullptr ,lambertW           ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"~"             ,-1,1 ,1 ,nullptr ,"(lambertW(x)./(x.*(1+lambertW(x)))).*var(1,0)", 
          "Lambert W function main branch W0 (W>-1)" },
        { "lambertWx"       ,1,1 ,0 ,1 ,1,0,nullptr ,lambertWx          ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,1 ,"~"             ,-1,1 ,1 ,nullptr ,"(lambertWx(x)./(x.*(1+lambertWx(x)))).*var(1,0)", 
          "Lambert W function lower branch W1 (W<-1)" },
        { "fnA"             ,2,3 ,0 ,3 ,1,1,nullptr ,nullptr            ,fnA          ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,0 ,0 ,nullptr ,"0", 
          "" },
        { "fnB"             ,3,3 ,4 ,7 ,1,1,nullptr ,nullptr            ,nullptr      ,fnB             ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,7 ,4 ,nullptr ,"dfnB(x,y,z,1).*var(1,2)", 
          "" },
        { "fnC"             ,4,3 ,12,15,1,1,nullptr ,nullptr            ,nullptr      ,nullptr         ,fnC        ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,15,12,nullptr ,"(dfnC(x,y,z,1,var(0,3),0).*var(1,2))+(dfnC(x,y,z,0,var(0,3),1).*var(1,3))", 
          "" },
        { "dfnB"            ,4,11,4 ,15,1,1,nullptr ,nullptr            ,nullptr      ,nullptr         ,dfnB       ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,15,4 ,nullptr ,"dfnB(x,y,z,var(0,3)+1).*var(1,2)", 
          "" },
        { "dfnC"            ,6,43,20,63,1,1,nullptr ,nullptr            ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,dfnC   ,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,63,20,nullptr ,"(dfnC(x,y,z,var(0,3)+1,var(0,4),var(0,5)).*var(1,2))+(dfnC(x,y,z,var(0,3),var(0,4),var(0,5)+1).*var(1,4))", 
          "" },
        { "efnB"            ,3,3 ,4 ,7 ,1,1,nullptr ,nullptr            ,nullptr      ,efnB            ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,7 ,4 ,nullptr ,"edfnB(x,y,z,1).*var(1,2)", 
          "" },
        { "efnC"            ,4,3 ,12,15,1,1,nullptr ,nullptr            ,nullptr      ,nullptr         ,efnC       ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,15,12,nullptr ,"(edfnC(x,y,z,1,var(0,3),0).*var(1,2))+(edfnC(x,y,z,0,var(0,3),1).*var(1,3))", 
          "" },
        { "edfnB"           ,4,11,4 ,15,1,1,nullptr ,nullptr            ,nullptr      ,nullptr         ,edfnB      ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,15,4 ,nullptr ,"edfnB(x,y,z,var(0,3)+1).*var(1,2)", 
          "" },
        { "edfnC"           ,6,43,20,63,1,1,nullptr ,nullptr            ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,edfnC  ,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,63,20,nullptr ,"(edfnC(x,y,z,var(0,3)+1,var(0,4),var(0,5)).*var(1,2))+(edfnC(x,y,z,var(0,3),var(0,4),var(0,5)+1).*var(1,4))", 
          "" },
        { "irand"           ,1,1 ,0 ,1 ,1,2,nullptr ,irand              ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,0 ,0 ,nullptr ,"0", 
          "uniform positive random integer [0,i-1]" },
        { "urand"           ,2,3 ,0 ,3 ,1,2,nullptr ,nullptr            ,urand        ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,0 ,0 ,nullptr ,"urand(var(1,0),var(1,1))", 
          "uniform random double [x,y]" },
        { "grand"           ,2,0 ,3 ,3 ,1,2,nullptr ,nullptr            ,grand        ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,0 ,0 ,nullptr ,"grand(var(1,0),var(1,1))", 
          "gaussian random double from N(m,c)" },
        { "testfn"          ,2,2 ,3 ,3 ,1,0,nullptr ,nullptr            ,testfn       ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,0 ,0 ,nullptr ,"0", 
          "" },
        { "testfnA"         ,3,2 ,7 ,7 ,1,0,nullptr ,nullptr            ,nullptr      ,testfnA         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,0 ,0 ,nullptr ,"0", 
          "" },
        { "partestfn"       ,3,4 ,7 ,7 ,1,0,nullptr ,nullptr            ,nullptr      ,partestfn       ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,0 ,0 ,nullptr ,"0", 
          "" },
        { "partestfnA"      ,4,4 ,15,15,1,0,nullptr ,nullptr            ,nullptr      ,nullptr         ,partestfnA ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,0 ,0 ,nullptr ,"0", 
          "" },
        { "isvnan"          ,1,1 ,0 ,1 ,1,0,nullptr ,isvnan             ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_isvnan      ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,0 ,0 ,nullptr ,"0", 
          "True of NaN." },
        { "isinf"           ,1,1 ,0 ,1 ,1,0,nullptr ,isinf              ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_isinf       ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,0 ,0 ,nullptr ,"0", 
          "True if infinite." },
        { "ispinf"          ,1,1 ,0 ,1 ,1,0,nullptr ,ispinf             ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_ispinf      ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,0 ,0 ,nullptr ,"0", 
          "True if positive infinite." },
        { "isninf"          ,1,1 ,0 ,1 ,1,0,nullptr ,isninf             ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,OP_isninf      ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,0 ,0 ,nullptr ,"0", 
          "True of negative infinite." },
        { "tnow"            ,0,0 ,0 ,0 ,1,2,tnow    ,nullptr            ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,0 ,0 ,nullptr ,"0", 
          "Elapsed time since arbitrary point." },
        { "clkyear"         ,0,0 ,0 ,0 ,1,2,clkyear ,nullptr            ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,0 ,0 ,nullptr ,"0", 
          "Current time year (local time)." },
        { "clkmon"          ,0,0 ,0 ,0 ,1,2,clkmon  ,nullptr            ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,0 ,0 ,nullptr ,"0", 
          "Current time month (local time)." },
        { "clkday"          ,0,0 ,0 ,0 ,1,2,clkday  ,nullptr            ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,0 ,0 ,nullptr ,"0", 
          "Current time day (local time)." },
        { "clkhour"         ,0,0 ,0 ,0 ,1,2,clkhour ,nullptr            ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,0 ,0 ,nullptr ,"0", 
          "Current time hour (local time)." },
        { "clkmin"          ,0,0 ,0 ,0 ,1,2,clkmin  ,nullptr            ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,0 ,0 ,nullptr ,"0", 
          "Current time min (local time)." },
        { "clksec"          ,0,0 ,0 ,0 ,1,2,clksec  ,nullptr            ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,0 ,0 ,nullptr ,"0", 
          "Current time sec (local time)." },
        { "dfact"           ,1,1 ,0 ,1 ,1,0,nullptr ,dfact              ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,1 ,1 ,nullptr ,"realDeriv(0,0,(2^((1+(2*x)-cos(pi()*x))/4))*(pi()^((cos(pi()*x)-1)/4))*gamma(1+(x/2)))*var(1,0)", 
          "Double factorial a!!" },
        { "tfact"           ,1,1 ,0 ,1 ,1,0,nullptr ,tfact              ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,0 ,0 ,nullptr ,"0", 
          "Triple factorial a!!!" },
        { "multifact"       ,2,0 ,3 ,3 ,1,0,nullptr ,nullptr            ,multifact    ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,0 ,0 ,nullptr ,"0", 
          "Multifactorial a!!...m...!" },
        { "sf"              ,1,1 ,0 ,1 ,1,0,nullptr ,sf                 ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,0 ,0 ,nullptr ,"0", 
          "Sloane's superfactorial" },
        { "psf"             ,1,1 ,0 ,1 ,1,0,nullptr ,psf                ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,0 ,0 ,nullptr ,"0", 
          "Pickover's superfactorial " },
        { "subfact"         ,1,1 ,0 ,1 ,1,0,nullptr ,subfact            ,nullptr      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,1 ,1 ,nullptr ,"realDeriv(0,0,gami(-1,x+1)/exp(1))*var(1,0)", 
          "Subfactorial !a" },
        { "syscall"         ,2,0 ,3 ,3 ,0,1,nullptr ,nullptr            ,syscall      ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,0 ,0 ,nullptr ,"0", 
          "System call to evaluate, eg syscall(\"command\",x)" },
#ifndef PYLOCAL
        { "pycall"          ,2,0 ,3 ,3 ,0,1,nullptr ,nullptr            ,pycall       ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,0 ,0 ,nullptr ,"0", 
          "System (python3) call to evaluate, eg pycall(\"math.sin\",x)" }
#endif
#ifdef PYLOCAL
        { "pycall"          ,2,0 ,3 ,3 ,0,0,nullptr ,nullptr            ,pycall       ,nullptr         ,nullptr    ,nullptr      ,nullptr,nullptr    ,nullptr        ,nullptr   ,nullptr,nullptr,nullptr,nullptr,0 ,"~"             ,-1,0 ,0 ,nullptr ,"0", 
          "System (python3) call to evaluate, eg pycall(\"math.sin\",x)" }
#endif
};



// prod(x) = prod(sgn(x))*prod(eabs2(x))
//         = prod(sgn(x))*exp(sum(log(eabs2(x))))
// Prod(x) = prod(sgn(x))*prod(eabs2(conj(x)))
//         = prod(sgn(x))*exp(sum(log(eabs2(conj(x)))))
//
// Derivatives:
//
// realDeriv(prod(...)) = realDeriv(prod(sgn(var(0,0)))*exp(sum(log(eabs2(var(0,0)))))
// realDeriv(Prod(...)) = realDeriv(prod(sgn(var(0,0)))*exp(sum(log(eabs2(conj(var(0,0))))))

fninfoblock *getfninfo(void);
fninfoblock *getfninfo(void)
{
    return qqqfninfo;
}

const char *getfnname(int fnnameind)
{
    return getfninfo()[fnnameind].fnname;
}

int getfnind(const std::string &fnname)
{
    int i,ires = -1;

    for ( i = 0 ; i < NUMFNDEF ; ++i )
    {
        if ( fnname == getfnname(i) )
        {
            ires = i;
            break;
        }
    }

    return ires;
}

const char *getfndescrip(const std::string &fnname)
{
    const static char unknownfn[] = "Function not found";
    int i;
    const char *res = unknownfn;

    for ( i = 0 ; i < NUMFNDEF ; ++i )
    {
        if ( fnname == getfnname(i) )
        {
            res = (*getfninfo(i)).descript;
            break;
        }
    }

    return res;
}

int getfnindConj(int fnInd)
{
    int res = getfninfo()[fnInd].fnconjind;

    if ( res == -1 )
    {
        getfninfo()[fnInd].fnconjind = getfnind(getfninfo()[fnInd].conjfnname);
        res = getfninfo()[fnInd].fnconjind;
    }

    return res;
}

const fninfoblock *getfninfo(int ires)
{
    initgentype(); // not ready to JIT yet

    static thread_local gentype blind(0);
    fninfoblock *res = nullptr;

    if ( ires != -1 )
    {
        if ( getfninfo()[ires].realderiv == nullptr )
        {
            getfninfo()[ires].realderiv = &blind;
            // The above line is needed to stop getfninfo entering an
            // infinite loop.  For example, if the derivative of add is
            // being generated here then the derivative itself includes an
            // instance of add, which will result in a call back to
            // getfninfo, and if realderiv is still nullptr at this point the
            // process will repeat in an infinite loop. Including the above
            // line means that this can only be called once for each
            // function.
            //
            // ASIDE: it is important to only include basic functions (ie.
            // those which have a derivative defined that doesn't include
            // the realDeriv function) in non-basic function derivative
            // strings (is within the realDeriv function).

            gentype *temp;

            MEMNEW(temp,gentype(getfninfo()[ires].realderivfn));

            getfninfo()[ires].realderiv = temp;
        }

        res = &(getfninfo()[ires]);
    }

    return res;
}

void exitgentype(void);
void exitgentype(void)
{
    int i;

    static thread_local gentype blind(0); // never modified, so no need for this to be volatile

    for ( i = 0 ; i < NUMFNDEF ; ++i )
    {
        if ( getfninfo()[i].realderiv )
        {
            MEMDEL(getfninfo()[i].realderiv);
            getfninfo()[i].realderiv = &blind; // Not null or it just gets created again!
        }
    }

    for ( i = 0 ; i < NUMFNDEF ; ++i )
    {
        getfninfo()[i].realderiv = nullptr; // nullptr is safe here.
    }

    return;
}


//Singleton-like thingie to call exitgentype when the only static example is destructed.
//Only used in initgentype function to trigger call to exitgentype
class deltrigger
{
public:

    ~deltrigger()
    {
        exitgentype();
    }
};

#ifdef INSVMCONTEXT
void setintercalc(void (*intercalccall)(std::ostream &, std::istream &));
#endif

void initgentype(void)
{
    bool doit = false; // the lambda once will set this true one time only.  The static nature of once ensures
                       // thread-safe operation (static initialisation is thread-safe)
    static bool once [[maybe_unused]] =
    [&doit](){
        doit = true;

        return true;
    } ();

    if ( doit )
    {
#ifdef INSVMCONTEXT
        setintercalc(&intercalc);
#endif

//        svm_atexit(exitgentype,"gentype",2); - old version using atexit call.  No longer used

        int i;

        for ( i = 0 ; i < NUMFNDEF ; ++i )
        {
            getfninfo(i);
        }

        static deltrigger dummy; // when destructed after code has run, this will trigger a call to exitgentype
    }
}
/*
    static int isinited = 0;

    if ( isinited )
    {
        return;
    }

    else
    {
#ifdef ENABLE_THREADS
    static svm_recursive_mutex eyelock;
    eyelock.lock();
#endif

    static int beinginited = 0;

    if ( !isinited && !beinginited )
    {
        setintercalc(&intercalc);

        beinginited = 1;

        svm_atexit(exitgentype,"gentype",2);

//        errstream() << "Constructing gentype derivatives\n";

        int i;

        for ( i = 0 ; i < NUMFNDEF ; ++i )
        {
            getfninfo(i);
        }

//        for ( i = 0 ; i < NUMFNDEF ; ++i )
//        {
//            errstream() << i << " (" << getfninfo()[i].fnname << "): " << *(getfninfo()[i].realderiv) << " done.\n";
//        }

        isinited = 1;
        beinginited = 0;
    }

#ifdef ENABLE_THREADS
    eyelock.unlock();
#endif
    }
}
*/












































// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
//
// Helper functions for operators start here
//
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================




// Check if arguments are compatible for addition/subtraction.  Returns:
//
// 0 = no
// 1 = yes, result integer
// 2 = yes, result real
// 3 = yes, result anion
// 4 = yes, result vector
// 5 = yes, result matrix
// 6 = yes, result string
// 8 = yes, result set
// 9 = yes, result dgraph
//10 = yes, result null
//11 = yes, result dict
//
// Notes: adding a string to anything gives a string
//        7 means leave as gentype
//        isstrict: set for logical operations

static int checkAddCompat(const gentype &a, const gentype &b, int &acast, int &bcast, int isstrict = 0);
static int checkAddCompat(const gentype &a, const gentype &b, int &acast, int &bcast, int isstrict)
{
    if ( a.isValNull() )
    {
             if ( b.isValNull()                ) { acast = 10; bcast = 10; return 10; }
        else if ( b.isValInteger()             ) { acast = 1;  bcast = 1;  return 1;  }
        else if ( b.isValReal()                ) { acast = 2;  bcast = 2;  return 2;  }
        else if ( b.isValAnion()               ) { acast = 3;  bcast = 3;  return 3;  }
        else if ( b.isValVector() && !isstrict ) { acast = 7;  bcast = 4;  return 4;  }
        else if ( b.isValMatrix() && !isstrict ) { acast = 7;  bcast = 5;  return 5;  }
        else if ( b.isValSet()    && !isstrict ) { acast = 7;  bcast = 8;  return 8;  }
        else if ( b.isValString()              ) { acast = 6;  bcast = 6;  return 6;  }
        else                                     { acast = 0;  bcast = 0;  return 0;  }
    }

    else if ( a.isValInteger() )
    {
             if ( b.isValNull()                ) { acast = 1; bcast = 1;  return 1;  }
        else if ( b.isValInteger()             ) { acast = 1; bcast = 1;  return 1;  }
        else if ( b.isValReal()                ) { acast = 2; bcast = 2;  return 2;  }
        else if ( b.isValAnion()               ) { acast = 3; bcast = 3;  return 3;  }
        else if ( b.isValVector() && !isstrict ) { acast = 7; bcast = 4;  return 4;  }
        else if ( b.isValMatrix() && !isstrict ) { acast = 7; bcast = 5;  return 5;  }
        else if ( b.isValSet()    && !isstrict ) { acast = 7; bcast = 8;  return 8;  }
        else if ( b.isValString()              ) { acast = 6; bcast = 6;  return 6;  }
        else                                     { acast = 0; bcast = 0;  return 0;  }
    }

    else if ( a.isValReal() )
    {
             if ( b.isValNull()                ) { acast = 2; bcast = 2;  return 2;  }
        else if ( b.isValInteger()             ) { acast = 2; bcast = 2;  return 2;  }
        else if ( b.isValReal()                ) { acast = 2; bcast = 2;  return 2;  }
        else if ( b.isValAnion()               ) { acast = 3; bcast = 3;  return 3;  }
        else if ( b.isValVector() && !isstrict ) { acast = 7; bcast = 4;  return 4;  }
        else if ( b.isValMatrix() && !isstrict ) { acast = 7; bcast = 5;  return 5;  }
        else if ( b.isValSet()    && !isstrict ) { acast = 7; bcast = 8;  return 8;  }
        else if ( b.isValString()              ) { acast = 6; bcast = 6;  return 6;  }
        else                                     { acast = 0; bcast = 0;  return 0;  }
    }

    else if ( a.isValAnion() )
    {
             if ( b.isValNull()                ) { acast = 3; bcast = 3;  return 3;  }
        else if ( b.isValInteger()             ) { acast = 3; bcast = 3;  return 3;  }
        else if ( b.isValReal()                ) { acast = 3; bcast = 3;  return 3;  }
        else if ( b.isValAnion()               ) { acast = 3; bcast = 3;  return 3;  }
        else if ( b.isValVector() && !isstrict ) { acast = 7; bcast = 4;  return 4;  }
        else if ( b.isValMatrix() && !isstrict ) { acast = 7; bcast = 5;  return 5;  }
        else if ( b.isValSet()    && !isstrict ) { acast = 7; bcast = 8;  return 8;  }
        else if ( b.isValString()              ) { acast = 6; bcast = 6;  return 6;  }
        else                                     { acast = 0; bcast = 0;  return 0;  }
    }

    else if ( a.isValVector() )
    {
             if ( b.isValNull()    && !isstrict                                               ) { acast = 4; bcast = 7; return 4; }
        else if ( b.isValInteger() && !isstrict                                               ) { acast = 4; bcast = 7; return 4; }
        else if ( b.isValReal()    && !isstrict                                               ) { acast = 4; bcast = 7; return 4; }
        else if ( b.isValAnion()   && !isstrict                                               ) { acast = 4; bcast = 7; return 4; }
        else if ( b.isValVector()  && ( a.size() == b.size() )                                ) { acast = 4; bcast = 4; return 4; }
	else if ( b.isValMatrix()  && ( ( b.numRows() == a.size() ) && ( b.numCols() == 1 ) ) ) { acast = 5; bcast = 5; return 5; }
        else if ( b.isValSet()     && !isstrict                                               ) { acast = 7; bcast = 8; return 8;  }
        else if ( b.isValString()                                                             ) { acast = 6; bcast = 6; return 6;  }
        else                                                                                    { acast = 0; bcast = 0; return 0;  }
    }

    else if ( a.isValMatrix() )
    {
             if ( b.isValNull()    && !isstrict                                                            ) { acast = 5; bcast = 7; return 5; }
        else if ( b.isValInteger() && !isstrict                                                            ) { acast = 5; bcast = 7; return 5; }
        else if ( b.isValReal()    && !isstrict                                                            ) { acast = 5; bcast = 7; return 5; }
        else if ( b.isValAnion()   && !isstrict                                                            ) { acast = 5; bcast = 7; return 5; }
        else if ( b.isValVector()  && ( ( a.numRows() == b.size() ) && ( a.numCols() == 1 ) )              ) { acast = 5; bcast = 5; return 5; }
	else if ( b.isValMatrix()  && ( ( a.numRows() == b.numRows() ) && ( a.numCols() == b.numCols() ) ) ) { acast = 5; bcast = 5; return 5; }
        else if ( b.isValSet()     && !isstrict                                                            ) { acast = 7; bcast = 8; return 8;  }
        else if ( b.isValString()                                                                          ) { acast = 6; bcast = 6; return 6;  }
        else                                                                                                 { acast = 0; bcast = 0; return 0;  }
    }

    else if ( a.isValSet() )
    {
             if ( b.isValNull()    && !isstrict ) { acast = 8; bcast = 7; return 8; }
        else if ( b.isValInteger() && !isstrict ) { acast = 8; bcast = 7; return 8; }
        else if ( b.isValReal()    && !isstrict ) { acast = 8; bcast = 7; return 8; }
        else if ( b.isValAnion()   && !isstrict ) { acast = 8; bcast = 7; return 8; }
        else if ( b.isValVector()  && !isstrict ) { acast = 8; bcast = 7; return 8; }
        else if ( b.isValMatrix()  && !isstrict ) { acast = 8; bcast = 7; return 8; }
        else if ( b.isValSet()                  ) { acast = 8; bcast = 8; return 8; }
        else if ( b.isValString()  && !isstrict ) { acast = 8; bcast = 7; return 8; }
        else                                      { acast = 0; bcast = 0; return 0; }
    }

    else if ( a.isValDgraph() )
    {
        // In this case, we can only "add" in the logical comparison sense,
        // not in the mathematical sense.  Hence isstrict, not !isstrict.

        if ( b.isValDgraph() && isstrict ) { acast = 9; bcast = 9; return 9; }
        else                               { acast = 0; bcast = 0; return 0; }
    }

    else if ( a.isValDict() )
    {
        // In this case, we can only "add" in the logical comparison sense,
        // not in the mathematical sense.  Hence isstrict, not !isstrict.

        if ( b.isValDict() && isstrict ) { acast = 11; bcast = 11; return 11; }
        else                             { acast = 0;  bcast = 0;  return 0;  }
    }

    else if ( a.isValString() )
    {
             if ( b.isValNull()    ) { acast = 6; bcast = 6; return 6; }
        else if ( b.isValInteger() ) { acast = 6; bcast = 6; return 6; }
        else if ( b.isValReal()    ) { acast = 6; bcast = 6; return 6; }
        else if ( b.isValAnion()   ) { acast = 6; bcast = 6; return 6; }
        else if ( b.isValVector()  ) { acast = 6; bcast = 6; return 6; }
        else if ( b.isValMatrix()  ) { acast = 6; bcast = 6; return 6; }
        else if ( b.isValSet()     ) { acast = 7; bcast = 8; return 8; }
        else if ( b.isValString()  ) { acast = 6; bcast = 6; return 6; }
        else                         { acast = 0; bcast = 0; return 0; }
    }

    return 0;
}

void constructError(gentype &res, const std::string &errstrval)
{
    res.makeError(errstrval);

    return;
}

void constructError(const gentype &a, gentype &res, const std::string &errstrval)
{
    std::string errstr = errstrval;

    if ( a.isValError() ) { errstr += ",("; errstr += a.cast_string(0); errstr += ")"; }

    res.makeError(errstr);

    return;
}

void constructError(const gentype &a, const gentype &b, gentype &res, const std::string &errstrval)
{
    std::string errstr = errstrval;

    if ( a.isValError() ) { errstr += ",("; errstr += a.cast_string(0); errstr += ")"; }
    if ( b.isValError() ) { errstr += ",("; errstr += b.cast_string(0); errstr += ")"; }

    res.makeError(errstr);

    return;
}

void constructError(const gentype &a, const gentype &b, const gentype &c, gentype &res, const std::string &errstrval)
{
    std::string errstr = errstrval;

    if ( a.isValError() ) { errstr += ",("; errstr += a.cast_string(0); errstr += ")"; }
    if ( b.isValError() ) { errstr += ",("; errstr += b.cast_string(0); errstr += ")"; }
    if ( c.isValError() ) { errstr += ",("; errstr += c.cast_string(0); errstr += ")"; }

    res.makeError(errstr);

    return;
}

void constructError(const gentype &a, const gentype &b, const gentype &c, const gentype &d, gentype &res, const std::string &errstrval)
{
    std::string errstr = errstrval;

    if ( a.isValError() ) { errstr += ",("; errstr += a.cast_string(0); errstr += ")"; }
    if ( b.isValError() ) { errstr += ",("; errstr += b.cast_string(0); errstr += ")"; }
    if ( c.isValError() ) { errstr += ",("; errstr += c.cast_string(0); errstr += ")"; }
    if ( d.isValError() ) { errstr += ",("; errstr += d.cast_string(0); errstr += ")"; }

    res.makeError(errstr);

    return;
}

void constructError(const gentype &a, const gentype &b, const gentype &c, const gentype &d, const gentype &e, gentype &res, const std::string &errstrval)
{
    std::string errstr = errstrval;

    if ( a.isValError() ) { errstr += ",("; errstr += a.cast_string(0); errstr += ")"; }
    if ( b.isValError() ) { errstr += ",("; errstr += b.cast_string(0); errstr += ")"; }
    if ( c.isValError() ) { errstr += ",("; errstr += c.cast_string(0); errstr += ")"; }
    if ( d.isValError() ) { errstr += ",("; errstr += d.cast_string(0); errstr += ")"; }
    if ( e.isValError() ) { errstr += ",("; errstr += e.cast_string(0); errstr += ")"; }

    res.makeError(errstr);

    return;
}

void constructError(const gentype &a, const gentype &b, const gentype &c, const gentype &d, const gentype &e, const gentype &f, gentype &res, const std::string &errstrval)
{
    std::string errstr = errstrval;

    if ( a.isValError() ) { errstr += ",("; errstr += a.cast_string(0); errstr += ")"; }
    if ( b.isValError() ) { errstr += ",("; errstr += b.cast_string(0); errstr += ")"; }
    if ( c.isValError() ) { errstr += ",("; errstr += c.cast_string(0); errstr += ")"; }
    if ( d.isValError() ) { errstr += ",("; errstr += d.cast_string(0); errstr += ")"; }
    if ( e.isValError() ) { errstr += ",("; errstr += e.cast_string(0); errstr += ")"; }
    if ( f.isValError() ) { errstr += ",("; errstr += f.cast_string(0); errstr += ")"; }

    res.makeError(errstr);

    return;
}

void constructError(gentype &res, const char *errstr)
{
    std::string errstralt = errstr;

    constructError(res,errstralt);

    return;
}

void constructError(const gentype &a, gentype &res, const char *errstr)
{
    std::string errstralt = errstr;

    constructError(a,res,errstralt);

    return;
}

void constructError(const gentype &a, const gentype &b, gentype &res, const char *errstr)
{
    std::string errstralt = errstr;

    constructError(a,b,res,errstralt);

    return;
}

void constructError(const gentype &a, const gentype &b, const gentype &c, gentype &res, const char *errstr)
{
    std::string errstralt = errstr;

    constructError(a,b,c,res,errstralt);

    return;
}

void constructError(const gentype &a, const gentype &b, const gentype &c, const gentype &d, gentype &res, const char *errstr)
{
    std::string errstralt = errstr;

    constructError(a,b,c,d,res,errstralt);

    return;
}

void constructError(const gentype &a, const gentype &b, const gentype &c, const gentype &d, const gentype &e, gentype &res, const char *errstr)
{
    std::string errstralt = errstr;

    constructError(a,b,c,d,e,res,errstralt);

    return;
}

void constructError(const gentype &a, const gentype &b, const gentype &c, const gentype &d, const gentype &e, const gentype &f, gentype &res, const char *errstr)
{
    std::string errstralt = errstr;

    constructError(a,b,c,d,e,f,res,errstralt);

    return;
}




















































// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
//
// Operators start here
//
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================


// Logical operators

bool gentype::iseq(const gentype &b) const
{
    if ( isValEqnDir() || b.isValEqnDir() )
    {
        // NB: this is not accurate.  It can report a != b when in fact
        //     a == b.  For example x+y != y+x according to this code.  At
        //     some point this logic needs to be corrected, but it is highly
        //     nontrivial and the benefit is marginal.

        if ( isValEqnDir() && b.isValEqnDir() )
        {
            if ( fnnameind == b.fnnameind )
            {
                NiceAssert( eqnargs );
                NiceAssert( b.eqnargs );

                return *eqnargs == *(b.eqnargs);
            }
        }

        return false;
    }

    bool res = false;
    int acast = 0;
    int bcast = 0;

    if ( ( res = checkAddCompat(*this,b,acast,bcast,1) ) )
    {
             if ( ( acast == 1  ) && ( bcast == 1  ) ) { res = ( cast_int(0)       == b.cast_int(0)       ); }
        else if ( ( acast == 2  ) && ( bcast == 2  ) ) { res = ( cast_double(0)    == b.cast_double(0)    ); }
        else if ( ( acast == 3  ) && ( bcast == 3  ) ) { res = ( cast_anion(0)     == b.cast_anion(0)     ); }
        else if ( ( acast == 4  ) && ( bcast == 4  ) ) { res = ( cast_vector(0)    == b.cast_vector(0)    ); }
        else if ( ( acast == 5  ) && ( bcast == 5  ) ) { res = ( cast_matrix(0)    == b.cast_matrix(0)    ); }
        else if ( ( acast == 8  ) && ( bcast == 8  ) ) { res = ( cast_set(0)       == b.cast_set(0)       ); }
        else if ( ( acast == 11 ) && ( bcast == 11 ) ) { res = ( cast_dict(0)      == b.cast_dict(0)      ); }
        else if ( ( acast == 9  ) && ( bcast == 9  ) ) { res = ( cast_dgraph(0)    == b.cast_dgraph(0)    ); }
        else if ( ( acast == 10 ) && ( bcast == 10 ) ) { res = true;                                         }
        else                                           { res = ( cast_string(0)    == b.cast_string(0)    ); }
    }

    return res;
}

int operator!=(const gentype &a, const gentype &b)
{
    if ( a.isValEqnDir() || b.isValEqnDir() )
    {
        return !(a==b);
    }

    int res = 0;
    int acast = 0;
    int bcast = 0;

    if ( ( res = checkAddCompat(a,b,acast,bcast,1) ) )
    {
             if ( ( acast == 1  ) && ( bcast == 1  ) ) { res = ( a.cast_int(0)     != b.cast_int(0)       ); }
        else if ( ( acast == 2  ) && ( bcast == 2  ) ) { res = ( a.cast_double(0)  != b.cast_double(0)    ); }
        else if ( ( acast == 3  ) && ( bcast == 3  ) ) { res = ( a.cast_anion(0)   != b.cast_anion(0)     ); }
        else if ( ( acast == 4  ) && ( bcast == 4  ) ) { res = ( a.cast_vector(0)  != b.cast_vector(0)    ); }
        else if ( ( acast == 5  ) && ( bcast == 5  ) ) { res = ( a.cast_matrix(0)  != b.cast_matrix(0)    ); }
        else if ( ( acast == 8  ) && ( bcast == 8  ) ) { res = ( a.cast_set(0)     != b.cast_set(0)       ); }
        else if ( ( acast == 11 ) && ( bcast == 11 ) ) { res = ( a.cast_dict(0)    != b.cast_dict(0)      ); }
        else if ( ( acast == 9  ) && ( bcast == 9  ) ) { res = ( a.cast_dgraph(0)  != b.cast_dgraph(0)    ); }
        else if ( ( acast == 10 ) && ( bcast == 10 ) ) { res = 0;                                            }
        else                                           { res = ( a.cast_string(0)  != b.cast_string(0)    ); }
    }

    return res;
}

int operator<(const gentype &a, const gentype &b)
{
    if ( a.isValEqnDir() || b.isValEqnDir() )
    {
        return 0;
    }

    int res = 0;
    int acast = 0;
    int bcast = 0;

    if ( ( res = checkAddCompat(a,b,acast,bcast,1) ) )
    {
             if ( ( acast == 1  ) && ( bcast == 1  ) ) { res = (  a.cast_int(0)       <  b.cast_int(0)       ); }
        else if ( ( acast == 2  ) && ( bcast == 2  ) ) { res = (  a.cast_double(0)    <  b.cast_double(0)    ); }
        else if ( ( acast == 3  ) && ( bcast == 3  ) ) { res = 0;                                             }
        else if ( ( acast == 4  ) && ( bcast == 4  ) ) { res = (  a.cast_vector(0)    <  b.cast_vector(0)    ); }
        else if ( ( acast == 5  ) && ( bcast == 5  ) ) { res = (  a.cast_matrix(0)    <  b.cast_matrix(0)    ); }
        else if ( ( acast == 8  ) && ( bcast == 8  ) ) { res = (  a.cast_set(0)       <  b.cast_set(0)       ); }
        else if ( ( acast == 9  ) && ( bcast == 9  ) ) { res = 0;                                             }
        else if ( ( acast == 10 ) && ( bcast == 10 ) ) { res = 0;                                             }
        else                                           { res = 0;                                             }
    }

    return res;
}

int operator>(const gentype &a, const gentype &b)
{
    if ( a.isValEqnDir() || b.isValEqnDir() )
    {
        return 0;
    }

    int res = 0;
    int acast = 0;
    int bcast = 0;

    if ( ( res = checkAddCompat(a,b,acast,bcast,1) ) )
    {
             if ( ( acast == 1  ) && ( bcast == 1  ) ) { res = (  a.cast_int(0)       >  b.cast_int(0)       ); }
        else if ( ( acast == 2  ) && ( bcast == 2  ) ) { res = (  a.cast_double(0)    >  b.cast_double(0)    ); }
        else if ( ( acast == 3  ) && ( bcast == 3  ) ) { res = 0;                                             }
        else if ( ( acast == 4  ) && ( bcast == 4  ) ) { res = (  a.cast_vector(0)    >  b.cast_vector(0)    ); }
        else if ( ( acast == 5  ) && ( bcast == 5  ) ) { res = (  a.cast_matrix(0)    >  b.cast_matrix(0)    ); }
        else if ( ( acast == 8  ) && ( bcast == 8  ) ) { res = (  a.cast_set(0)       >  b.cast_set(0)       ); }
        else if ( ( acast == 9  ) && ( bcast == 9  ) ) { res = 0;                                             }
        else if ( ( acast == 10 ) && ( bcast == 10 ) ) { res = 0;                                             }
        else                                           { res = 0;                                             }
    }

    return res;
}

int operator<=(const gentype &a, const gentype &b)
{
    if ( a.isValEqnDir() || b.isValEqnDir() )
    {
        return 0;
    }

    int res = 0;
    int acast = 0;
    int bcast = 0;

    if ( ( res = checkAddCompat(a,b,acast,bcast,1) ) )
    {
             if ( ( acast == 1  ) && ( bcast == 1  ) ) { res = (  a.cast_int(0)       <= b.cast_int(0)       ); }
        else if ( ( acast == 2  ) && ( bcast == 2  ) ) { res = (  a.cast_double(0)    <= b.cast_double(0)    ); }
        else if ( ( acast == 3  ) && ( bcast == 3  ) ) { res = 1;                                             }
        else if ( ( acast == 4  ) && ( bcast == 4  ) ) { res = (  a.cast_vector(0)    <= b.cast_vector(0)    ); }
        else if ( ( acast == 5  ) && ( bcast == 5  ) ) { res = (  a.cast_matrix(0)    <= b.cast_matrix(0)    ); }
        else if ( ( acast == 8  ) && ( bcast == 8  ) ) { res = (  a.cast_set(0)       <= b.cast_set(0)       ); }
        else if ( ( acast == 9  ) && ( bcast == 9  ) ) { res = 1;                                             }
        else if ( ( acast == 10 ) && ( bcast == 10 ) ) { res = 1;                                             }
        else                                           { res = 1;                                             }
    }

    return res;
}

int operator>=(const gentype &a, const gentype &b)
{
    if ( a.isValEqnDir() || b.isValEqnDir() )
    {
        return 0;
    }

    int res = 0;
    int acast = 0;
    int bcast = 0;

    if ( ( res = checkAddCompat(a,b,acast,bcast,1) ) )
    {
             if ( ( acast == 1  ) && ( bcast == 1  ) ) { res = (  a.cast_int(0)       >= b.cast_int(0)       ); }
        else if ( ( acast == 2  ) && ( bcast == 2  ) ) { res = (  a.cast_double(0)    >= b.cast_double(0)    ); }
        else if ( ( acast == 3  ) && ( bcast == 3  ) ) { res = 1;                                             }
        else if ( ( acast == 4  ) && ( bcast == 4  ) ) { res = (  a.cast_vector(0)    >= b.cast_vector(0)    ); }
        else if ( ( acast == 5  ) && ( bcast == 5  ) ) { res = (  a.cast_matrix(0)    >= b.cast_matrix(0)    ); }
        else if ( ( acast == 8  ) && ( bcast == 8  ) ) { res = (  a.cast_set(0)       >= b.cast_set(0)       ); }
        else if ( ( acast == 9  ) && ( bcast == 9  ) ) { res = 1;                                             }
        else if ( ( acast == 10 ) && ( bcast == 10 ) ) { res = 1;                                             }
        else                                           { res = 1;                                             }
    }

    return res;
}

// + posation - unary, return rvalue
// - negation - unary, return rvalue

gentype  operator+(const gentype &a)
{
    if ( a.isValEqnDir() )
    {
        const static gentype res("+x");

        return res(a);
    }

    gentype res = a;

    return setposate(res);
}

gentype  operator-(const gentype &a)
{
    if ( a.isValEqnDir() )
    {
        const static gentype res("-x");

        return res(a);
    }

    gentype res = a;

    return setnegate(res);
}

// + addition       - binary, return rvalue
// - subtraction    - binary, return rvalue
// * multiplication - binary, return rvalue

/*
gentype  operator/(const gentype &a, const gentype &b)
{
    // NB: the old version (commented out) does integer division for
    // integers.  This is more trouble than it is worth, as it makes
    // equations like sin(var(1,1)/2) act in unexpected ways.  If you
    // need integer division, use idiv, eg sin(idiv(var(1,1),2)).
    // Other major problem: the code tends to seek the simplest representation
    // for any given number, so 1.0 is demoted to 1, and 1.0/2.0 will
    // be demoted to 1/2, which is 0 and not 0.5 when integer division
    // is implemented
    //
    //    gentype res;
    //
    //    if ( a.isValInteger() && b.isValInteger() )
    //    {
    //	Special case of integer division
    //
    //	res = a.cast_int(0) / b.cast_int(0);
    //    }
    //
    //    else if ( !(a.isValString()) && !(b.isValString()) )
    //    {
    //        res = a*inv(b);
    //    }
    //
    //    else
    //    {
    //	constructError(a,b,res,"Error: incompatible types in division.");
    //    }

    gentype res(a);

    return res /= b;
}
*/

gentype  operator%(const gentype &a, const gentype &b)
{
    if ( a.isValEqnDir() || b.isValEqnDir() )
    {
        const static gentype res("x%y");

        return res(a,b);
    }

    gentype res;

    if ( a.isCastableToIntegerWithoutLoss() && b.isCastableToIntegerWithoutLoss() )
    {
        res = ( a.cast_int(0) ) % ( b.cast_int(0) );
    }

    else
    {
	constructError(a,b,res,"Error: incompatible (non-integer) types in mod.");
    }

    return res;
}

















gentype &gentype::leftmult(const gentype &b)
{
    if ( isCastableToIntegerWithoutLoss() && !b.isValSet() )
    {
        if      ( cast_int(0) ==  0 ) {                          return *this; }
        else if ( cast_int(0) ==  1 ) { fastcopy(b,1);           return *this; }
        else if ( cast_int(0) == -1 ) { fastcopy(b,1); negate(); return *this; }
    }

    if ( !isValSet() && b.isCastableToIntegerWithoutLoss() )
    {
        //NB:  need to keep structure of result, even if it is zero
        //     if ( b.cast_int(0) ==  0 ) { *this = 0; return *this; }
        if      ( b.cast_int(0) ==  1 ) {           return *this; }
        else if ( b.cast_int(0) == -1 ) { negate(); return *this; }
    }

    if ( isValEqnDir() || b.isValEqnDir() )
    {
        const static gentype tempres("x*y");
        gentype res(tempres);

        // Method:
        //
        // - switch contents of a and res quickly (so a is now x*y)
        // - switch contents of lefthand operand in a (multiplication)
        //   with res (which is what a was originally).
        // - operation is now half done.
        // - do fastcopy to overwrite righthand operand in a with b

        if ( varid_isscalar )
        {
            res.varid_isscalar = varid_isscalar;
            res.varid_numpts   = varid_numpts;

            res.grabvarid_xi(varid_xi);
            res.grabvarid_xj(varid_xj);
        }

        if ( b.varid_isscalar )
        {
            res.varid_isscalar = b.varid_isscalar;
            res.varid_numpts   = b.varid_numpts;

            res.grabvarid_xi(b.varid_xi);
            res.grabvarid_xj(b.varid_xj);
        }

        qswap(*this,res);
        NiceAssert( eqnargs );
        qswap((*(eqnargs))("&",0),res);
        (*(eqnargs))("&",1).fastcopy(b,1);

        if ( (*(eqnargs))(0).varid_isscalar )
        {
            varid_isscalar = (*(eqnargs))(0).varid_isscalar;
            varid_numpts   = (*(eqnargs))(0).varid_numpts;

            grabvarid_xi((*(eqnargs))(0).varid_xi);
            grabvarid_xj((*(eqnargs))(0).varid_xj);

            (*(eqnargs))("&",0).varid_isscalar = 0;
        }

        if ( (*(eqnargs))(1).varid_isscalar )
        {
            varid_isscalar = (*(eqnargs))(1).varid_isscalar;
            varid_numpts   = (*(eqnargs))(1).varid_numpts;

            grabvarid_xi((*(eqnargs))(1).varid_xi);
            grabvarid_xj((*(eqnargs))(1).varid_xj);

            (*(eqnargs))("&",1).varid_isscalar = 0;
        }

        return *this;
    }

    // Design decision: vector*vector is the inner product.  That way,
    // the derivative of abs2(x) works correctly for vectorial x
    //
    // Design decision: string*string is 1 if same, -1 otherwise.  That
    // way, inner product can be used for categorical features in the SVM

    if (( isValVector() && b.isValVector() && ( size()    != b.size()    ) )||
        ( isValVector() && b.isValMatrix() && ( size()    != b.numRows() ) )||
        ( isValMatrix() && b.isValVector() && ( numCols() != b.size()    ) )||
        ( isValMatrix() && b.isValMatrix() && ( numCols() == b.numRows() ) ))
    {
        goto errcase;
    }

    if ( isValInteger() && b.isValInteger() )
    {
        // Need to allow for potential overflow!

        int vala = cast_int(0);
        int valb = b.cast_int(0);

        int resa = vala*valb;

        if ( ( vala != 0 ) && ( resa/vala != valb ) )
        {
            force_double() = ((double) vala)*((double) valb);
        }

        else
        {
            dir_int() = resa;
        }
    }

    else if ( isValInteger() && b.isValReal()    ) { ::leftmult(dir_double(),b.cast_double(0)); }
    else if ( isValInteger() && b.isValAnion()   ) { ::leftmult(dir_anion(), b.cast_anion(0) ); }
    else if ( isValReal()    && b.isValInteger() ) { ::leftmult(dir_double(),b.cast_int(0)   ); }
    else if ( isValReal()    && b.isValReal()    ) { ::leftmult(dir_double(),b.cast_double(0)); }
    else if ( isValReal()    && b.isValAnion()   ) { ::leftmult(dir_anion(), b.cast_anion(0) ); }
    else if ( isValAnion()   && b.isValInteger() ) { ::leftmult(dir_anion(), b.cast_double(0)); }
    else if ( isValAnion()   && b.isValReal()    ) { ::leftmult(dir_anion(), b.cast_double(0)); }
    else if ( isValAnion()   && b.isValAnion()   ) { ::leftmult(dir_anion(), b.cast_anion(0) ); }
    else if ( isValVector()  && b.isValInteger() ) { ::leftmult(dir_vector(),b               ); }
    else if ( isValVector()  && b.isValReal()    ) { ::leftmult(dir_vector(),b               ); }
    else if ( isValVector()  && b.isValAnion()   ) { ::leftmult(dir_vector(),b               ); }
    else if ( isValVector()  && b.isValMatrix()  ) { ::leftmult(dir_vector(),b.cast_matrix(0)); }
    else if ( isValVector()  && b.isValString()  ) { ::leftmult(dir_vector(),b               ); }
    else if ( isValMatrix()  && b.isValInteger() ) { ::leftmult(dir_matrix(),b               ); }
    else if ( isValMatrix()  && b.isValReal()    ) { ::leftmult(dir_matrix(),b               ); }
    else if ( isValMatrix()  && b.isValAnion()   ) { ::leftmult(dir_matrix(),b               ); }
    else if ( isValMatrix()  && b.isValMatrix()  ) { ::leftmult(dir_matrix(),b.cast_matrix(0)); }
    else if ( isValMatrix()  && b.isValString()  ) { ::leftmult(dir_matrix(),b               ); }
    else if ( isValSet()     && b.isValInteger() ) { Set<gentype> bb(b); double temp; innerProduct(temp,cast_set(0),bb); *this = temp; }
    else if ( isValSet()     && b.isValReal()    ) { Set<gentype> bb(b); double temp; innerProduct(temp,cast_set(0),bb); *this = temp; }
    else if ( isValSet()     && b.isValAnion()   ) { Set<gentype> bb(b); double temp; innerProduct(temp,cast_set(0),bb); *this = temp; }
    else if ( isValSet()     && b.isValString()  ) { Set<gentype> bb(b); double temp; innerProduct(temp,cast_set(0),bb); *this = temp; }

    else if ( isValNull()    && b.isValNull()    ) { ;          }
    else if ( isValInteger() && b.isValNull()    ) { *this = 0; }
    else if ( isValReal()    && b.isValNull()    ) { *this = 0; }
    else if ( isValAnion()   && b.isValNull()    ) { *this = 0; }
    else if ( isValVector()  && b.isValNull()    ) { *this = 0; }
    else if ( isValMatrix()  && b.isValNull()    ) { *this = 0; }
    else if ( isValSet()     && b.isValNull()    ) { *this = 0; }
    else if ( isValDict()    && b.isValNull()    ) { *this = 0; }
    else if ( isValString()  && b.isValNull()    ) { *this = 0; }
    else if ( isValDgraph()  && b.isValNull()    ) { *this = 0; }
    else if ( isValNull()    && b.isValInteger() ) { *this = 0; }
    else if ( isValNull()    && b.isValReal()    ) { *this = 0; }
    else if ( isValNull()    && b.isValAnion()   ) { *this = 0; }
    else if ( isValNull()    && b.isValVector()  ) { *this = 0; }
    else if ( isValNull()    && b.isValMatrix()  ) { *this = 0; }
    else if ( isValNull()    && b.isValSet()     ) { *this = 0; }
    else if ( isValNull()    && b.isValDict()    ) { *this = 0; }
    else if ( isValNull()    && b.isValString()  ) { *this = 0; }
    else if ( isValNull()    && b.isValDgraph()  ) { *this = 0; }

    else if ( isValInteger() && b.isValVector()  ) { int     x = cast_int(0);       *this = b; *this *= x; }
    else if ( isValInteger() && b.isValMatrix()  ) { int     x = cast_int(0);       *this = b; *this *= x; }
    else if ( isValInteger() && b.isValSet()     ) { Set<gentype> aa(*this); double temp; innerProduct(temp,aa,b.cast_set(0)); *this = temp; }
    else if ( isValReal()    && b.isValVector()  ) { double  x = cast_double(0);    *this = b; *this *= x; }
    else if ( isValReal()    && b.isValMatrix()  ) { double  x = cast_double(0);    *this = b; *this *= x; }
    else if ( isValReal()    && b.isValSet()     ) { Set<gentype> aa(*this); double temp; innerProduct(temp,aa,b.cast_set(0)); *this = temp; }
    else if ( isValString()  && b.isValVector()  ) { std::string x(cast_string(0)); *this = b; *this *= x; }
    else if ( isValString()  && b.isValMatrix()  ) { std::string x(cast_string(0)); *this = b; *this *= x; }
    else if ( isValString()  && b.isValSet()     ) { Set<gentype> aa(*this); double temp; innerProduct(temp,aa,b.cast_set(0)); *this = temp; }

    else if ( isValAnion()   && b.isValVector()  ) { gentype x(*this); *this = b; rightmult(x); }
    else if ( isValAnion()   && b.isValMatrix()  ) { gentype x(*this); *this = b; rightmult(x); }
    else if ( isValAnion()   && b.isValSet()     ) { Set<gentype> aa(*this); double temp; innerProduct(temp,aa,b.cast_set(0)); *this = temp; }

    else if ( isValVector()  && b.isValVector()  ) { gentype temp; twoProduct  (temp,cast_vector(0),b.cast_vector(0)); *this = temp; }
    else if ( isValSet()     && b.isValSet()     ) { double  temp; innerProduct(temp,cast_set(0),   b.cast_set(0)   ); *this = temp; }
    else if ( isValDgraph()  && b.isValDgraph()  ) { double  temp; innerProduct(temp,cast_dgraph(0),b.cast_dgraph(0)); *this = temp; }

    else if ( isValMatrix()  && b.isValVector()  ) { *this = ( cast_matrix(0) * b.cast_vector(0) ); }
    else if ( isValString()  && b.isValString()  ) { *this = ( ( *this == b ) ? 1 : -1 );           }

    else if ( isValInteger() && b.isValString()  ) { goto errcase; }
    else if ( isValInteger() && b.isValDgraph()  ) { goto errcase; }
    else if ( isValReal()    && b.isValString()  ) { goto errcase; }
    else if ( isValReal()    && b.isValDgraph()  ) { goto errcase; }
    else if ( isValAnion()   && b.isValString()  ) { goto errcase; }
    else if ( isValAnion()   && b.isValDgraph()  ) { goto errcase; }
    else if ( isValVector()  && b.isValSet()     ) { goto errcase; }
    else if ( isValVector()  && b.isValDgraph()  ) { goto errcase; }
    else if ( isValMatrix()  && b.isValSet()     ) { goto errcase; }
    else if ( isValMatrix()  && b.isValDgraph()  ) { goto errcase; }
    else if ( isValString()  && b.isValInteger() ) { goto errcase; }
    else if ( isValString()  && b.isValReal()    ) { goto errcase; }
    else if ( isValString()  && b.isValAnion()   ) { goto errcase; }
    else if ( isValString()  && b.isValDgraph()  ) { goto errcase; }
    else if ( isValSet()     && b.isValVector()  ) { goto errcase; }
    else if ( isValSet()     && b.isValMatrix()  ) { goto errcase; }
    else if ( isValSet()     && b.isValDgraph()  ) { goto errcase; }
    else if ( isValDgraph()  && b.isValInteger() ) { goto errcase; }
    else if ( isValDgraph()  && b.isValReal()    ) { goto errcase; }
    else if ( isValDgraph()  && b.isValAnion()   ) { goto errcase; }
    else if ( isValDgraph()  && b.isValVector()  ) { goto errcase; }
    else if ( isValDgraph()  && b.isValMatrix()  ) { goto errcase; }
    else if ( isValDgraph()  && b.isValString()  ) { goto errcase; }
    else if ( isValDgraph()  && b.isValSet()     ) { goto errcase; }

    else
    {
    errcase:
        std::string errstr("Error: incompatible types in multiplication leftmult(");
        errstr += cast_string(0);
        errstr += ",";
        errstr += b.cast_string(0);
        errstr += ")";

        constructError(*this,b,*this,errstr.c_str());
    }

    return *this;
}

gentype &gentype::leftmult(double b)
{
         if ( isValReal()    ) {                 doubleval *= b;        }
    else if ( isValInteger() ) { typeis = 'R';   doubleval  = intval*b; }
    else if ( isValNull()    ) { typeis = 'Z';   intval     = 0;        }
    else if ( isValAnion()   ) {                *anionval  *= b;        }
    else                       { gentype bg(b);  leftmult(bg);          }

    return *this;
}

gentype &gentype::rightmult(const gentype &a)
{
    if ( isCastableToIntegerWithoutLoss() && !a.isValSet() )
    {
             if ( cast_int(0) ==  0 ) { return *this; }
        else if ( cast_int(0) ==  1 ) { fastcopy(a,1); return *this; }
        else if ( cast_int(0) == -1 ) { fastcopy(a,1); negate(); return *this; }
    }

    if ( !isValSet() && a.isCastableToIntegerWithoutLoss() )
    {
        //NB:  need to keep structure of result, even if it is zero
        //     if ( a.cast_int(0) ==  0 ) { *this = 0; return *this; }
        if ( a.cast_int(0) ==  1 ) { return *this; }
        else if ( a.cast_int(0) == -1 ) { negate(); return *this; }
    }

    if ( a.isValEqnDir() || isValEqnDir() )
    {
        const static gentype tempres("x*y");
        gentype res(tempres);

        if ( a.varid_isscalar )
        {
            res.varid_isscalar = a.varid_isscalar;
            res.varid_numpts   = a.varid_numpts;

            res.grabvarid_xi(a.varid_xi);
            res.grabvarid_xj(a.varid_xj);
        }

        if ( varid_isscalar )
        {
            res.varid_isscalar = varid_isscalar;
            res.varid_numpts   = varid_numpts;

            res.grabvarid_xi(varid_xi);
            res.grabvarid_xj(varid_xj);
        }

        qswap(*this,res);
        NiceAssert( eqnargs );
        qswap((*(eqnargs))("&",1),res);
        (*(eqnargs))("&",0).fastcopy(a,1);

        if ( (*(eqnargs))(0).varid_isscalar )
        {
            varid_isscalar = (*(eqnargs))(0).varid_isscalar;
            varid_numpts   = (*(eqnargs))(0).varid_numpts;

            grabvarid_xi((*(eqnargs))(0).varid_xi);
            grabvarid_xj((*(eqnargs))(0).varid_xj);

            (*(eqnargs))("&",0).varid_isscalar = 0;
        }

        if ( (*(eqnargs))(1).varid_isscalar )
        {
            varid_isscalar = (*(eqnargs))(1).varid_isscalar;
            varid_numpts   = (*(eqnargs))(1).varid_numpts;

            grabvarid_xi((*(eqnargs))(1).varid_xi);
            grabvarid_xj((*(eqnargs))(1).varid_xj);

            (*(eqnargs))("&",1).varid_isscalar = 0;
        }

        return *this;
    }

    // Design decision: vector*vector is the inner product.  That way,
    // the derivative of abs2(x) works correctly for vectorial x
    //
    // Design decision: string*string is 1 if same, -1 otherwise.  That
    // way, inner product can be used for categorical features in the SVM

    if (( a.isValVector() && isValVector() && ( a.size()    != size()    ) )||
        ( a.isValVector() && isValMatrix() && ( a.size()    != numRows() ) )||
        ( a.isValMatrix() && isValVector() && ( a.numCols() != size()    ) )||
        ( a.isValMatrix() && isValMatrix() && ( a.numCols() == numRows() ) ))
    {
        goto errcase;
    }

    if ( a.isValInteger() && isValInteger() )
    {
        // Need to allow for potential overflow!

        int vala = a.cast_int(0);
        int valb = cast_int(0);

        int resb = vala*valb;

        if ( ( valb != 0 ) && ( resb/valb != vala ) )
        {
            force_double() = ((double) vala)*((double) valb);
        }

        else
        {
            dir_int() = resb;
        }

        //if ( a.isValInteger() && isValInteger() ) { ::rightmult(a.cast_int(0)   ,dir_int()   ); }
    }

    else if ( a.isValInteger() && isValReal()    ) { ::rightmult(a.cast_double(0),dir_double()); }
    else if ( a.isValInteger() && isValAnion()   ) { ::rightmult(a.cast_double(0),dir_anion() ); }
    else if ( a.isValInteger() && isValVector()  ) { ::rightmult(a               ,dir_vector()); }
    else if ( a.isValInteger() && isValMatrix()  ) { ::rightmult(a               ,dir_matrix()); }
    else if ( a.isValInteger() && isValSet()     ) { *this = dir_set()*a;                        }
    else if ( a.isValReal()    && isValInteger() ) { ::rightmult(a.cast_double(0),dir_double()); }
    else if ( a.isValReal()    && isValReal()    ) { ::rightmult(a.cast_double(0),dir_double()); }
    else if ( a.isValReal()    && isValAnion()   ) { ::rightmult(a.cast_double(0),dir_anion() ); }
    else if ( a.isValReal()    && isValVector()  ) { ::rightmult(a               ,dir_vector()); }
    else if ( a.isValReal()    && isValMatrix()  ) { ::rightmult(a               ,dir_matrix()); }
    else if ( a.isValReal()    && isValSet()     ) { *this = dir_set()*a;                        }
    else if ( a.isValAnion()   && isValInteger() ) { ::rightmult(a.cast_anion(0) ,dir_anion() ); }
    else if ( a.isValAnion()   && isValReal()    ) { ::rightmult(a.cast_anion(0) ,dir_anion() ); }
    else if ( a.isValAnion()   && isValAnion()   ) { ::rightmult(a.cast_anion(0) ,dir_anion() ); }
    else if ( a.isValAnion()   && isValVector()  ) { ::rightmult(a               ,dir_vector()); }
    else if ( a.isValAnion()   && isValMatrix()  ) { ::rightmult(a               ,dir_matrix()); }
    else if ( a.isValAnion()   && isValSet()     ) { *this = dir_set()*a;                        }
    else if ( a.isValMatrix()  && isValVector()  ) { ::rightmult(a.cast_matrix(0),dir_vector()); }
    else if ( a.isValMatrix()  && isValMatrix()  ) { ::rightmult(a.cast_matrix(0),dir_matrix()); }
    else if ( a.isValString()  && isValVector()  ) { ::rightmult(a               ,dir_vector()); }
    else if ( a.isValString()  && isValMatrix()  ) { ::rightmult(a               ,dir_matrix()); }
    else if ( a.isValString()  && isValSet()     ) { *this = dir_set()*a;                        }

    else if ( a.isValNull()    && isValNull()    ) { ;          }
    else if ( a.isValInteger() && isValNull()    ) { *this = 0; }
    else if ( a.isValReal()    && isValNull()    ) { *this = 0; }
    else if ( a.isValAnion()   && isValNull()    ) { *this = 0; }
    else if ( a.isValVector()  && isValNull()    ) { *this = 0; }
    else if ( a.isValMatrix()  && isValNull()    ) { *this = 0; }
    else if ( a.isValSet()     && isValNull()    ) { *this = 0; }
    else if ( a.isValDict()    && isValNull()    ) { *this = 0; }
    else if ( a.isValString()  && isValNull()    ) { *this = 0; }
    else if ( a.isValDgraph()  && isValNull()    ) { *this = 0; }
    else if ( a.isValNull()    && isValInteger() ) { *this = 0; }
    else if ( a.isValNull()    && isValReal()    ) { *this = 0; }
    else if ( a.isValNull()    && isValAnion()   ) { *this = 0; }
    else if ( a.isValNull()    && isValVector()  ) { *this = 0; }
    else if ( a.isValNull()    && isValMatrix()  ) { *this = 0; }
    else if ( a.isValNull()    && isValSet()     ) { *this = 0; }
    else if ( a.isValNull()    && isValDict()    ) { *this = 0; }
    else if ( a.isValNull()    && isValString()  ) { *this = 0; }
    else if ( a.isValNull()    && isValDgraph()  ) { *this = 0; }

    else if ( a.isValVector()  && isValInteger() ) { int     x = cast_int(0);       *this = a; *this *= x; }
    else if ( a.isValMatrix()  && isValInteger() ) { int     x = cast_int(0);       *this = a; *this *= x; }
    else if ( a.isValSet()     && isValInteger() ) { int     x = cast_int(0);       *this = a; *this *= x; }
    else if ( a.isValVector()  && isValReal()    ) { double  x = cast_double(0);    *this = a; *this *= x; }
    else if ( a.isValMatrix()  && isValReal()    ) { double  x = cast_double(0);    *this = a; *this *= x; }
    else if ( a.isValSet()     && isValReal()    ) { double  x = cast_double(0);    *this = a; *this *= x; }
    else if ( a.isValVector()  && isValString()  ) { std::string x(cast_string(0)); *this = a; *this *= x; }
    else if ( a.isValMatrix()  && isValString()  ) { std::string x(cast_string(0)); *this = a; *this *= x; }
    else if ( a.isValSet()     && isValString()  ) { std::string x(cast_string(0)); *this = a; *this *= x; }

    else if ( a.isValVector()  && isValAnion()   ) { gentype x(*this); *this = a; leftmult(x); }
    else if ( a.isValMatrix()  && isValAnion()   ) { gentype x(*this); *this = a; leftmult(x); }
    else if ( a.isValSet()     && isValAnion()   ) { gentype x(*this); *this = a; leftmult(x); }

    else if ( a.isValVector()  && isValVector()  ) { gentype temp; twoProduct  (temp,a.cast_vector(0),cast_vector(0)); *this = temp; }
    else if ( a.isValSet()     && isValSet()     ) { double  temp; innerProduct(temp,a.cast_set(0)   ,cast_set(0)   ); *this = temp; }
    else if ( a.isValDgraph()  && isValDgraph()  ) { double  temp; innerProduct(temp,a.cast_dgraph(0),cast_dgraph(0)); *this = temp; }

    else if ( a.isValVector()  && isValMatrix()  ) { *this = ( a.cast_vector(0) * cast_matrix(0) ); }
    else if ( a.isValString()  && isValString()  ) { *this = ( ( a == *this ) ? 1 : -1 );           }

    else if ( a.isValInteger() && isValString()  ) { goto errcase; }
    else if ( a.isValInteger() && isValDgraph()  ) { goto errcase; }
    else if ( a.isValReal()    && isValString()  ) { goto errcase; }
    else if ( a.isValReal()    && isValDgraph()  ) { goto errcase; }
    else if ( a.isValAnion()   && isValString()  ) { goto errcase; }
    else if ( a.isValAnion()   && isValDgraph()  ) { goto errcase; }
    else if ( a.isValVector()  && isValSet()     ) { goto errcase; }
    else if ( a.isValVector()  && isValDgraph()  ) { goto errcase; }
    else if ( a.isValMatrix()  && isValSet()     ) { goto errcase; }
    else if ( a.isValMatrix()  && isValDgraph()  ) { goto errcase; }
    else if ( a.isValString()  && isValNull()    ) { goto errcase; }
    else if ( a.isValString()  && isValInteger() ) { goto errcase; }
    else if ( a.isValString()  && isValReal()    ) { goto errcase; }
    else if ( a.isValString()  && isValAnion()   ) { goto errcase; }
    else if ( a.isValString()  && isValDgraph()  ) { goto errcase; }
    else if ( a.isValSet()     && isValVector()  ) { goto errcase; }
    else if ( a.isValSet()     && isValMatrix()  ) { goto errcase; }
    else if ( a.isValSet()     && isValDgraph()  ) { goto errcase; }
    else if ( a.isValDgraph()  && isValNull()    ) { goto errcase; }
    else if ( a.isValDgraph()  && isValInteger() ) { goto errcase; }
    else if ( a.isValDgraph()  && isValReal()    ) { goto errcase; }
    else if ( a.isValDgraph()  && isValAnion()   ) { goto errcase; }
    else if ( a.isValDgraph()  && isValVector()  ) { goto errcase; }
    else if ( a.isValDgraph()  && isValMatrix()  ) { goto errcase; }
    else if ( a.isValDgraph()  && isValString()  ) { goto errcase; }
    else if ( a.isValDgraph()  && isValSet()     ) { goto errcase; }

    else
    {
    errcase:
        std::string errstr("Error: incompatible types in multiplication rightmult(");
        errstr += a.cast_string(0);
        errstr += ",";
        errstr += cast_string(0);
        errstr += ")";

        constructError(a,*this,*this,errstr.c_str());
    }

    return *this;
}

gentype &gentype::rightmult(double a)
{
         if ( isValReal()    ) {                 doubleval *= a;        }
    else if ( isValInteger() ) { typeis = 'R';   doubleval  = a*intval; }
    else if ( isValNull()    ) { typeis = 'Z';   intval     = 0;        }
    else if ( isValAnion()   ) {                *anionval  *= a;        }
    else                       { gentype ag(a);  rightmult(ag);         }

    return *this;
}

gentype &gentype::leftdiv(const gentype &b)
{
    if ( isValEqnDir() || b.isValEqnDir() )
    {
        const static gentype tempres("x/y");
        gentype res(tempres);

        // Method: see leftmult

        if ( varid_isscalar )
        {
            res.varid_isscalar = varid_isscalar;
            res.varid_numpts   = varid_numpts;

            res.grabvarid_xi(varid_xi);
            res.grabvarid_xj(varid_xj);
        }

        if ( b.varid_isscalar )
        {
            res.varid_isscalar = b.varid_isscalar;
            res.varid_numpts   = b.varid_numpts;

            res.grabvarid_xi(b.varid_xi);
            res.grabvarid_xj(b.varid_xj);
        }

        qswap(*this,res);
        NiceAssert( eqnargs );
        qswap((*(eqnargs))("&",0),res);
        (*(eqnargs))("&",1).fastcopy(b,1);

        if ( (*(eqnargs))(0).varid_isscalar )
        {
            varid_isscalar = (*(eqnargs))(0).varid_isscalar;
            varid_numpts   = (*(eqnargs))(0).varid_numpts;

            grabvarid_xi((*(eqnargs))(0).varid_xi);
            grabvarid_xj((*(eqnargs))(0).varid_xj);

            (*(eqnargs))("&",0).varid_isscalar = 0;
        }

        if ( (*(eqnargs))(1).varid_isscalar )
        {
            varid_isscalar = (*(eqnargs))(1).varid_isscalar;
            varid_numpts   = (*(eqnargs))(1).varid_numpts;

            grabvarid_xi((*(eqnargs))(1).varid_xi);
            grabvarid_xj((*(eqnargs))(1).varid_xj);

            (*(eqnargs))("&",1).varid_isscalar = 0;
        }

        return *this;
    }

    // Note that pseudo-inverse of matrix of size i*j is of size j*i

    if (( isValVector() && b.isValMatrix() && ( size()    != b.numCols() ) )||
        ( isValMatrix() && b.isValMatrix() && ( numCols() == b.numCols() ) ))
    {
        goto errcase;
    }

         if ( isValNull() && b.isValNull()    ) { ;                                                               }
    else if ( isValNull() && b.isValInteger() ) { dir_double() /= b.cast_double(0);                               }
    else if ( isValNull() && b.isValReal()    ) { dir_double() /= b.cast_double(0);                               }
    else if ( isValNull() && b.isValAnion()   ) { dir_anion()  *= inv(b.cast_anion(0));                           }
    else if ( isValNull() && b.isValVector()  ) { goto errcase;                                                   }
    else if ( isValNull() && b.isValMatrix()  ) { double temp = cast_int(0); *this = b; inverse(); *this *= temp; }
    else if ( isValNull() && b.isValString()  ) { goto errcase;                                                   }
    else if ( isValNull() && b.isValSet()     ) { goto errcase;                                                   }
    else if ( isValNull() && b.isValDict()    ) { goto errcase;                                                   }
    else if ( isValNull() && b.isValDgraph()  ) { goto errcase;                                                   }

    else if ( isValInteger() && b.isValNull()    ) { dir_double() /= b.cast_int(0);                                  }
    else if ( isValInteger() && b.isValInteger() ) { dir_double() /= b.cast_double(0);                               }
    else if ( isValInteger() && b.isValReal()    ) { dir_double() /= b.cast_double(0);                               }
    else if ( isValInteger() && b.isValAnion()   ) { dir_anion()  *= inv(b.cast_anion(0));                           }
    else if ( isValInteger() && b.isValVector()  ) { goto errcase;                                                   }
    else if ( isValInteger() && b.isValMatrix()  ) { double temp = cast_int(0); *this = b; inverse(); *this *= temp; }
    else if ( isValInteger() && b.isValString()  ) { goto errcase;                                                   }
    else if ( isValInteger() && b.isValSet()     ) { goto errcase;                                                   }
    else if ( isValInteger() && b.isValDict()    ) { goto errcase;                                                   }
    else if ( isValInteger() && b.isValDgraph()  ) { goto errcase;                                                   }

    else if ( isValReal() && b.isValNull()    ) { dir_double() /= b.cast_double(0);                                   }
    else if ( isValReal() && b.isValInteger() ) { dir_double() /= b.cast_double(0);                                   }
    else if ( isValReal() && b.isValReal()    ) { dir_double() /= b.cast_double(0);                                   }
    else if ( isValReal() && b.isValAnion()   ) { dir_anion()  *= inv(b.cast_anion(0));                               }
    else if ( isValReal() && b.isValVector()  ) { goto errcase;                                                       }
    else if ( isValReal() && b.isValMatrix()  ) { double temp = cast_double(0);  *this = b; inverse(); *this *= temp; }
    else if ( isValReal() && b.isValString()  ) { goto errcase;                                                       }
    else if ( isValReal() && b.isValSet()     ) { goto errcase;                                                       }
    else if ( isValReal() && b.isValDict()    ) { goto errcase;                                                       }
    else if ( isValReal() && b.isValDgraph()  ) { goto errcase;                                                       }

    else if ( isValAnion() && b.isValNull()    ) { dir_anion()  /= b.cast_double(0);                                   }
    else if ( isValAnion() && b.isValInteger() ) { dir_anion()  /= b.cast_double(0);                                   }
    else if ( isValAnion() && b.isValReal()    ) { dir_anion()  /= b.cast_double(0);                                   }
    else if ( isValAnion() && b.isValAnion()   ) { dir_anion()  *= inv(b.cast_anion(0));                               }
    else if ( isValAnion() && b.isValVector()  ) { goto errcase;                                                       }
    else if ( isValAnion() && b.isValMatrix()  ) { gentype temp(cast_anion(0)); *this = b; inverse(); rightmult(temp); }
    else if ( isValAnion() && b.isValString()  ) { goto errcase;                                                       }
    else if ( isValAnion() && b.isValSet()     ) { goto errcase;                                                       }
    else if ( isValAnion() && b.isValDict()    ) { goto errcase;                                                       }
    else if ( isValAnion() && b.isValDgraph()  ) { goto errcase;                                                       }

    else if ( isValVector() && b.isValNull()    ) { dir_vector() *= inv(b);                }
    else if ( isValVector() && b.isValInteger() ) { dir_vector() *= inv(b);                }
    else if ( isValVector() && b.isValReal()    ) { dir_vector() *= inv(b);                }
    else if ( isValVector() && b.isValAnion()   ) { dir_vector() *= inv(b);                }
    else if ( isValVector() && b.isValVector()  ) { goto errcase;                          }
    else if ( isValVector() && b.isValMatrix()  ) { dir_vector() *= inv(b.cast_matrix(0)); }
    else if ( isValVector() && b.isValString()  ) { goto errcase;                          }
    else if ( isValVector() && b.isValSet()     ) { goto errcase;                          }
    else if ( isValVector() && b.isValDict()    ) { goto errcase;                          }
    else if ( isValVector() && b.isValDgraph()  ) { goto errcase;                          }

    else if ( isValMatrix() && b.isValNull()    ) { dir_matrix() *= inv(b);                }
    else if ( isValMatrix() && b.isValInteger() ) { dir_matrix() *= inv(b);                }
    else if ( isValMatrix() && b.isValReal()    ) { dir_matrix() *= inv(b);                }
    else if ( isValMatrix() && b.isValAnion()   ) { dir_matrix() *= inv(b);                }
    else if ( isValMatrix() && b.isValVector()  ) { goto errcase;                          }
    else if ( isValMatrix() && b.isValMatrix()  ) { dir_matrix() *= inv(b.cast_matrix(0)); }
    else if ( isValMatrix() && b.isValString()  ) { goto errcase;                          }
    else if ( isValMatrix() && b.isValSet()     ) { goto errcase;                          }
    else if ( isValMatrix() && b.isValDict()    ) { goto errcase;                          }
    else if ( isValMatrix() && b.isValDgraph()  ) { goto errcase;                          }

    else if ( isValString() && b.isValNull()    ) { goto errcase; }
    else if ( isValString() && b.isValInteger() ) { goto errcase; }
    else if ( isValString() && b.isValReal()    ) { goto errcase; }
    else if ( isValString() && b.isValAnion()   ) { goto errcase; }
    else if ( isValString() && b.isValVector()  ) { goto errcase; }
    else if ( isValString() && b.isValMatrix()  ) { goto errcase; }
    else if ( isValString() && b.isValString()  ) { goto errcase; }
    else if ( isValString() && b.isValSet()     ) { goto errcase; }
    else if ( isValString() && b.isValDict()    ) { goto errcase; }
    else if ( isValString() && b.isValDgraph()  ) { goto errcase; }

    else if ( isValSet() && b.isValNull()    ) { goto errcase; }
    else if ( isValSet() && b.isValInteger() ) { goto errcase; }
    else if ( isValSet() && b.isValReal()    ) { goto errcase; }
    else if ( isValSet() && b.isValAnion()   ) { goto errcase; }
    else if ( isValSet() && b.isValVector()  ) { goto errcase; }
    else if ( isValSet() && b.isValMatrix()  ) { goto errcase; }
    else if ( isValSet() && b.isValString()  ) { goto errcase; }
    else if ( isValSet() && b.isValSet()     ) { goto errcase; }
    else if ( isValSet() && b.isValDict()    ) { goto errcase; }
    else if ( isValSet() && b.isValDgraph()  ) { goto errcase; }

    else if ( isValDgraph()  && b.isValNull()    ) { goto errcase; }
    else if ( isValDgraph()  && b.isValInteger() ) { goto errcase; }
    else if ( isValDgraph()  && b.isValReal()    ) { goto errcase; }
    else if ( isValDgraph()  && b.isValAnion()   ) { goto errcase; }
    else if ( isValDgraph()  && b.isValVector()  ) { goto errcase; }
    else if ( isValDgraph()  && b.isValMatrix()  ) { goto errcase; }
    else if ( isValDgraph()  && b.isValString()  ) { goto errcase; }
    else if ( isValDgraph()  && b.isValSet()     ) { goto errcase; }
    else if ( isValDgraph()  && b.isValDict()    ) { goto errcase; }
    else if ( isValDgraph()  && b.isValDgraph()  ) { goto errcase; }

    else
    {
    errcase:
        std::string errstr("Error: incompatible types in division leftdiv(");
        errstr += cast_string(0);
        errstr += ",";
        errstr += b.cast_string(0);
        errstr += ")";

        constructError(*this,b,*this,errstr.c_str());
    }

    return *this;
}

gentype &gentype::leftdiv(double b)
{
         if ( isValReal()    ) {                 doubleval /= b;        }
    else if ( isValInteger() ) { typeis = 'R';   doubleval  = intval/b; }
    else if ( isValNull()    ) { typeis = 'Z';   intval     = 0;        }
    else if ( isValAnion()   ) {                *anionval  /= b;        }
    else                       { gentype bg(b);  leftdiv(bg);           }

    return *this;
}

gentype &gentype::rightdiv(const gentype &b)
{
    // Based on a leftdiv with appropriate modifications.
    // (note reversal of b and a in the function definition)

    if ( isCastableToIntegerWithoutLoss() && !b.isValSet() )
    {
             if ( cast_int(0) ==  0 ) {                                   return *this; }
        else if ( cast_int(0) ==  1 ) { fastcopy(b); inverse();           return *this; }
        else if ( cast_int(0) == -1 ) { fastcopy(b); inverse(); negate(); return *this; }
    }

    if ( !isValSet() && b.isCastableToIntegerWithoutLoss() )
    {
             if ( b.cast_int(0) ==  1 ) {           return *this; }
        else if ( b.cast_int(0) == -1 ) { negate(); return *this; }
    }

    if ( isValEqnDir() || b.isValEqnDir() )
    {
        const static gentype tempres("x\\y"); // Note right division
        gentype res(tempres);

        // Method: see leftmult

        if ( b.varid_isscalar )
        {
            res.varid_isscalar = b.varid_isscalar;
            res.varid_numpts   = b.varid_numpts;

            res.grabvarid_xi(b.varid_xi);
            res.grabvarid_xj(b.varid_xj);
        }

        if ( varid_isscalar )
        {
            res.varid_isscalar = varid_isscalar;
            res.varid_numpts   = varid_numpts;

            res.grabvarid_xi(varid_xi);
            res.grabvarid_xj(varid_xj);
        }

        qswap(*this,res);
        NiceAssert( eqnargs );
        qswap((*(eqnargs))("&",1),res);
        (*(eqnargs))("&",0).fastcopy(b,1);

        if ( (*(eqnargs))(0).varid_isscalar )
        {
            varid_isscalar = (*(eqnargs))(0).varid_isscalar;
            varid_numpts   = (*(eqnargs))(0).varid_numpts;

            grabvarid_xi((*(eqnargs))(0).varid_xi);
            grabvarid_xj((*(eqnargs))(0).varid_xj);

            (*(eqnargs))("&",0).varid_isscalar = 0;
        }

        if ( (*(eqnargs))(1).varid_isscalar )
        {
            varid_isscalar = (*(eqnargs))(1).varid_isscalar;
            varid_numpts   = (*(eqnargs))(1).varid_numpts;

            grabvarid_xi((*(eqnargs))(1).varid_xi);
            grabvarid_xj((*(eqnargs))(1).varid_xj);

            (*(eqnargs))("&",1).varid_isscalar = 0;
        }

        return *this;
    }

    // Note that pseudo-inverse of matrix of size i*j is of size j*i

    if (( isValVector() && b.isValMatrix() && ( size()    != b.numRows() ) )||
        ( isValMatrix() && b.isValMatrix() && ( numRows() == b.numRows() ) ))
    {
        goto errcase;
    }

    // Note that the code only differs from leftdiv when dealing with
    // non-commutative fields

         if ( isValNull() && b.isValNull()    ) { ;                                                               }
    else if ( isValNull() && b.isValInteger() ) { dir_double() /= b.cast_double(0);                               }
    else if ( isValNull() && b.isValReal()    ) { dir_double() /= b.cast_double(0);                               }
    else if ( isValNull() && b.isValAnion()   ) { ::rightmult(inv(b.cast_anion(0)),dir_anion());                  }
    else if ( isValNull() && b.isValVector()  ) { goto errcase;                                                   }
    else if ( isValNull() && b.isValMatrix()  ) { double temp = cast_int(0); *this = b; inverse(); *this *= temp; }
    else if ( isValNull() && b.isValString()  ) { goto errcase;                                                   }
    else if ( isValNull() && b.isValSet()     ) { goto errcase;                                                   }
    else if ( isValNull() && b.isValDgraph()  ) { goto errcase;                                                   }

    else if ( isValInteger() && b.isValNull()    ) { dir_double() /= b.cast_double(0);                               }
    else if ( isValInteger() && b.isValInteger() ) { dir_double() /= b.cast_double(0);                               }
    else if ( isValInteger() && b.isValReal()    ) { dir_double() /= b.cast_double(0);                               }
    else if ( isValInteger() && b.isValAnion()   ) { ::rightmult(inv(b.cast_anion(0)),dir_anion());                  }
    else if ( isValInteger() && b.isValVector()  ) { goto errcase;                                                   }
    else if ( isValInteger() && b.isValMatrix()  ) { double temp = cast_int(0); *this = b; inverse(); *this *= temp; }
    else if ( isValInteger() && b.isValString()  ) { goto errcase;                                                   }
    else if ( isValInteger() && b.isValSet()     ) { goto errcase;                                                   }
    else if ( isValInteger() && b.isValDgraph()  ) { goto errcase;                                                   }

    else if ( isValReal() && b.isValNull()    ) { dir_double() /= b.cast_double(0);                                  }
    else if ( isValReal() && b.isValInteger() ) { dir_double() /= b.cast_double(0);                                  }
    else if ( isValReal() && b.isValReal()    ) { dir_double() /= b.cast_double(0);                                  }
    else if ( isValReal() && b.isValAnion()   ) { ::rightmult(inv(b.cast_anion(0)),dir_anion());                     }
    else if ( isValReal() && b.isValVector()  ) { goto errcase;                                                      }
    else if ( isValReal() && b.isValMatrix()  ) { double temp = cast_double(0); *this = b; inverse(); *this *= temp; }
    else if ( isValReal() && b.isValString()  ) { goto errcase;                                                      }
    else if ( isValReal() && b.isValSet()     ) { goto errcase;                                                      }
    else if ( isValReal() && b.isValDgraph()  ) { goto errcase;                                                      }

    else if ( isValAnion() && b.isValNull()    ) { dir_anion()  /= (double) b.cast_double(0);                         }
    else if ( isValAnion() && b.isValInteger() ) { dir_anion()  /= (double) b.cast_double(0);                         }
    else if ( isValAnion() && b.isValReal()    ) { dir_anion()  /=          b.cast_double(0);                         }
    else if ( isValAnion() && b.isValAnion()   ) { ::rightmult(inv(b.cast_anion(0)),dir_anion());                     }
    else if ( isValAnion() && b.isValVector()  ) { goto errcase;                                                      }
    else if ( isValAnion() && b.isValMatrix()  ) { gentype temp(cast_anion(0)); *this = b; inverse(); leftmult(temp); }
    else if ( isValAnion() && b.isValString()  ) { goto errcase;                                                      }
    else if ( isValAnion() && b.isValSet()     ) { goto errcase;                                                      }
    else if ( isValAnion() && b.isValDgraph()  ) { goto errcase;                                                      }

    else if ( isValVector() && b.isValNull()    ) { dir_vector() *= inv(b);                          }
    else if ( isValVector() && b.isValInteger() ) { dir_vector() *= inv(b);                          }
    else if ( isValVector() && b.isValReal()    ) { dir_vector() *= inv(b);                          }
    else if ( isValVector() && b.isValAnion()   ) { ::rightmult(inv(b),dir_vector());                }
    else if ( isValVector() && b.isValVector()  ) { goto errcase;                                    }
    else if ( isValVector() && b.isValMatrix()  ) { ::rightmult(inv(b.cast_matrix(0)),dir_vector()); }
    else if ( isValVector() && b.isValString()  ) { goto errcase;                                    }
    else if ( isValVector() && b.isValSet()     ) { goto errcase;                                    }
    else if ( isValVector() && b.isValDgraph()  ) { goto errcase;                                    }

    else if ( isValMatrix() && b.isValNull()    ) { dir_matrix() *= inv(b);                          }
    else if ( isValMatrix() && b.isValInteger() ) { dir_matrix() *= inv(b);                          }
    else if ( isValMatrix() && b.isValReal()    ) { dir_matrix() *= inv(b);                          }
    else if ( isValMatrix() && b.isValAnion()   ) { ::rightmult(inv(b),dir_matrix());                }
    else if ( isValMatrix() && b.isValVector()  ) { goto errcase;                                    }
    else if ( isValMatrix() && b.isValMatrix()  ) { ::rightmult(inv(b.cast_matrix(0)),dir_matrix()); }
    else if ( isValMatrix() && b.isValString()  ) { goto errcase;                                    }
    else if ( isValMatrix() && b.isValSet()     ) { goto errcase;                                    }
    else if ( isValMatrix() && b.isValDgraph()  ) { goto errcase;                                    }

    else if ( isValString() && b.isValNull()    ) { goto errcase; }
    else if ( isValString() && b.isValInteger() ) { goto errcase; }
    else if ( isValString() && b.isValReal()    ) { goto errcase; }
    else if ( isValString() && b.isValAnion()   ) { goto errcase; }
    else if ( isValString() && b.isValVector()  ) { goto errcase; }
    else if ( isValString() && b.isValMatrix()  ) { goto errcase; }
    else if ( isValString() && b.isValString()  ) { goto errcase; }
    else if ( isValString() && b.isValSet()     ) { goto errcase; }
    else if ( isValString() && b.isValDgraph()  ) { goto errcase; }

    else if ( isValSet() && b.isValNull()    ) { goto errcase; }
    else if ( isValSet() && b.isValInteger() ) { goto errcase; }
    else if ( isValSet() && b.isValReal()    ) { goto errcase; }
    else if ( isValSet() && b.isValAnion()   ) { goto errcase; }
    else if ( isValSet() && b.isValVector()  ) { goto errcase; }
    else if ( isValSet() && b.isValMatrix()  ) { goto errcase; }
    else if ( isValSet() && b.isValString()  ) { goto errcase; }
    else if ( isValSet() && b.isValSet()     ) { goto errcase; }
    else if ( isValSet() && b.isValDgraph()  ) { goto errcase; }

    else if ( isValDgraph() && b.isValNull()    ) { goto errcase; }
    else if ( isValDgraph() && b.isValInteger() ) { goto errcase; }
    else if ( isValDgraph() && b.isValReal()    ) { goto errcase; }
    else if ( isValDgraph() && b.isValAnion()   ) { goto errcase; }
    else if ( isValDgraph() && b.isValVector()  ) { goto errcase; }
    else if ( isValDgraph() && b.isValMatrix()  ) { goto errcase; }
    else if ( isValDgraph() && b.isValString()  ) { goto errcase; }
    else if ( isValDgraph() && b.isValSet()     ) { goto errcase; }
    else if ( isValDgraph() && b.isValDgraph()  ) { goto errcase; }

    else
    {
    errcase:
        // Note reversal of a and b here

        std::string errstr("Error: incompatible types in division rightdiv(");
        errstr += b.cast_string(0);
        errstr += ",";
        errstr += cast_string(0);
        errstr += ")";

        constructError(*this,b,*this,errstr.c_str());
    }

    return *this;
}

gentype &gentype::rightdiv(double a)
{
         if ( isValReal()    ) {                 doubleval /= a;        }
    else if ( isValInteger() ) { typeis = 'R';   doubleval  = intval/a; }
    else if ( isValNull()    ) { typeis = 'Z';   intval     = 0;        }
    else if ( isValAnion()   ) {                *anionval  /= a;        }
    else                       { gentype ag(a);  rightdiv(ag);          }

    return *this;
}

gentype &gentype::leftadd(const gentype &b)
{
    if ( isCastableToIntegerWithoutLoss() && ( cast_int(0) == 0 ) && !b.isValSet() )
    {
        fastcopy(b);
    }

    else if ( !isValSet() && b.isCastableToIntegerWithoutLoss() && ( b.cast_int(0) == 0 ) )
    {
        ;
    }

    else if ( isValEqnDir() || b.isValEqnDir() )
    {
        const static gentype tempres("x+y");
        gentype res(tempres);

        // Method: see leftmult

        if ( varid_isscalar )
        {
            res.varid_isscalar = varid_isscalar;
            res.varid_numpts   = varid_numpts;

            res.grabvarid_xi(varid_xi);
            res.grabvarid_xj(varid_xj);
        }

        if ( b.varid_isscalar )
        {
            res.varid_isscalar = b.varid_isscalar;
            res.varid_numpts   = b.varid_numpts;

            res.grabvarid_xi(b.varid_xi);
            res.grabvarid_xj(b.varid_xj);
        }

        qswap(*this,res);
        NiceAssert( eqnargs );
        qswap((*(eqnargs))("&",0),res);
        (*(eqnargs))("&",1).fastcopy(b,1);

        if ( (*(eqnargs))(0).varid_isscalar )
        {
            varid_isscalar = (*(eqnargs))(0).varid_isscalar;
            varid_numpts   = (*(eqnargs))(0).varid_numpts;

            grabvarid_xi((*(eqnargs))(0).varid_xi);
            grabvarid_xj((*(eqnargs))(0).varid_xj);

            (*(eqnargs))("&",0).varid_isscalar = 0;
        }

        if ( (*(eqnargs))(1).varid_isscalar )
        {
            varid_isscalar = (*(eqnargs))(1).varid_isscalar;
            varid_numpts   = (*(eqnargs))(1).varid_numpts;

            grabvarid_xi((*(eqnargs))(1).varid_xi);
            grabvarid_xj((*(eqnargs))(1).varid_xj);

            (*(eqnargs))("&",1).varid_isscalar = 0;
        }
    }

    else if ( isfasttype() && b.isfasttype() )
    {
             if ( isValNull()    && b.isValNull()    ) { ; }
        else if ( isValNull()    && b.isValReal()    ) { dir_double() += b.cast_double(0); }
        else if ( isValNull()    && b.isValAnion()   ) { dir_anion()  += b.cast_anion(0);  }
        else if ( isValInteger() && b.isValReal()    ) { dir_double() += b.cast_double(0); }
        else if ( isValInteger() && b.isValAnion()   ) { dir_anion()  += b.cast_anion(0);  }
        else if ( isValReal()    && b.isValNull()    ) { dir_double() += b.cast_int(0);    }
        else if ( isValReal()    && b.isValInteger() ) { dir_double() += b.cast_int(0);    }
        else if ( isValReal()    && b.isValReal()    ) { dir_double() += b.cast_double(0); }
        else if ( isValReal()    && b.isValAnion()   ) { dir_anion()  += b.cast_anion(0);  }
        else if ( isValAnion()   && b.isValNull()    ) { dir_anion()  += b.cast_double(0); }
        else if ( isValAnion()   && b.isValInteger() ) { dir_anion()  += b.cast_double(0); }
        else if ( isValAnion()   && b.isValReal()    ) { dir_anion()  += b.cast_double(0); }
        else if ( isValAnion()   && b.isValAnion()   ) { dir_anion()  += b.cast_anion(0);  }
        //else if ( isValNull()    && b.isValInteger() ) { dir_int()    += b.cast_int(0);    }
        //else if ( isValInteger() && b.isValNull()    ) { dir_int()    += b.cast_int(0);    }
        //else if ( isValInteger() && b.isValInteger() ) { dir_int()    += b.cast_int(0);    }

        else
        {
            // Need to allow for potential overflow!

            int aa = cast_int(0);
            int bb = b.cast_int(0);

            if ( ( ( aa >= 0 ) && ( (INT_MAX-aa) < bb ) ) || ( ( aa <= 0 ) && ( bb < (INT_MIN-aa) ) ) )
            {
                force_double() = ((double) aa)+((double) bb);
            }

            else
            {
                dir_int() = aa+bb;
            }
        }
    }

    else
    {
        int acast = 0;
        int bcast = 0;
        int rescast = checkAddCompat(*this,b,acast,bcast);

        if ( rescast && ( rescast != 6 ) )
        {
            if ( ( acast == 1 ) && ( bcast == 1 ) )
            {
                // Need to allow for potential overflow!

                int aa = cast_int(0);
                int bb = b.cast_int(0);

                if ( ( ( aa >= 0 ) && ( (INT_MAX-aa) < bb ) ) || ( ( aa <= 0 ) && ( bb < (INT_MIN-aa) ) ) )
                {
                    force_double() = ((double) aa)+((double) bb);
                }

                else
                {
                    dir_int() = aa+bb;
                }
            }

            else if ( ( acast == 2  ) && ( bcast == 2  ) ) { dir_double() += b.cast_double(0);     }
            else if ( ( acast == 3  ) && ( bcast == 3  ) ) { dir_anion()  += b.cast_anion(0);      }
            else if ( ( acast == 4  ) && ( bcast == 4  ) ) { dir_vector() += b.cast_vector(0);     }
            else if ( ( acast == 4  ) && ( bcast == 7  ) ) { dir_vector() += b;                    }
            else if ( ( acast == 5  ) && ( bcast == 5  ) ) { dir_matrix() += b.cast_matrix(0);     }
            else if ( ( acast == 5  ) && ( bcast == 7  ) ) { dir_matrix() += b;                    }
            else if ( ( acast == 8  ) && ( bcast == 7  ) ) { dir_set()    += b;                    }
            else if ( ( acast == 8  ) && ( bcast == 8  ) ) { dir_set()    += b.cast_set(0);        }
            else if ( ( acast == 7  ) && ( bcast == 10 ) ) { *this = b;                            }
            else if ( ( acast == 10 ) && ( bcast == 7  ) ) { ;                                     }
            else if ( ( acast == 10 ) && ( bcast == 10 ) ) { ;                                     }
            else if ( ( acast == 7  ) && ( bcast == 4  ) ) { *this = ( *this + b.cast_vector(0) ); }
            else if ( ( acast == 7  ) && ( bcast == 8  ) ) { *this = ( *this + b.cast_set(0)    ); }
            else                                           { *this = ( *this + b.cast_matrix(0) ); }
        }

        else if ( rescast == 6 )
        {
            std::string leftpart  = cast_string(0);
            std::string rightpart = b.cast_string(0);

            leftpart += rightpart;
            makeString(leftpart);
        }

        else
        {
            constructError(*this,b,*this,"Error: incompatible types in addition.");
        }
    }

    return *this;
}

gentype &gentype::leftadd(double b)
{
         if ( isValReal()    ) {                 doubleval += b;        }
    else if ( isValInteger() ) { typeis = 'R';   doubleval  = intval+b; }
    else if ( isValNull()    ) { typeis = 'R';   doubleval  = b;        }
    else if ( isValAnion()   ) {                *anionval  += b;        }
    else                       { gentype bg(b);  rightdiv(bg);          }

    return *this;
}

gentype &gentype::leftsub(const gentype &b)
{
    if ( isCastableToIntegerWithoutLoss() && ( cast_int(0) == 0 ) && !b.isValSet() )
    {
        fastcopy(b);
        negate();
    }

    else if ( !isValSet() && b.isCastableToIntegerWithoutLoss() && ( b.cast_int(0) == 0 ) )
    {
        ;
    }

    else if ( isValEqnDir() || b.isValEqnDir() )
    {
        const static gentype tempres("x-y");
        gentype res(tempres);
        // Method: see leftmult

        if ( varid_isscalar )
        {
            res.varid_isscalar = varid_isscalar;
            res.varid_numpts   = varid_numpts;

            res.grabvarid_xi(varid_xi);
            res.grabvarid_xj(varid_xj);
        }

        if ( b.varid_isscalar )
        {
            res.varid_isscalar = b.varid_isscalar;
            res.varid_numpts   = b.varid_numpts;

            res.grabvarid_xi(b.varid_xi);
            res.grabvarid_xj(b.varid_xj);
        }

        qswap(*this,res);
        NiceAssert( eqnargs );
        qswap((*(eqnargs))("&",0),res);
        (*(((*(eqnargs))("&",1).eqnargs)))("&",0).fastcopy(b,1);

        if ( (*(eqnargs))(0).varid_isscalar )
        {
            varid_isscalar = (*(eqnargs))(0).varid_isscalar;
            varid_numpts   = (*(eqnargs))(0).varid_numpts;

            grabvarid_xi((*(eqnargs))(0).varid_xi);
            grabvarid_xj((*(eqnargs))(0).varid_xj);

            (*(eqnargs))("&",0).varid_isscalar = 0;
        }

        if ( (*(eqnargs))(1).varid_isscalar )
        {
            varid_isscalar = (*(eqnargs))(1).varid_isscalar;
            varid_numpts   = (*(eqnargs))(1).varid_numpts;

            grabvarid_xi((*(eqnargs))(1).varid_xi);
            grabvarid_xj((*(eqnargs))(1).varid_xj);

            (*(eqnargs))("&",1).varid_isscalar = 0;
        }
    }

    else if ( isfasttype() && b.isfasttype() )
    {
             if ( isValNull()    && b.isValNull()    ) { ; }
        else if ( isValNull()    && b.isValReal()    ) { dir_double() -= b.cast_double(0); }
        else if ( isValNull()    && b.isValAnion()   ) { dir_anion()  -= b.cast_anion(0);  }
        else if ( isValInteger() && b.isValReal()    ) { dir_double() -= b.cast_double(0); }
        else if ( isValInteger() && b.isValAnion()   ) { dir_anion()  -= b.cast_anion(0);  }
        else if ( isValReal()    && b.isValNull()    ) { dir_double() -= b.cast_int(0);    }
        else if ( isValReal()    && b.isValInteger() ) { dir_double() -= b.cast_int(0);    }
        else if ( isValReal()    && b.isValReal()    ) { dir_double() -= b.cast_double(0); }
        else if ( isValReal()    && b.isValAnion()   ) { dir_anion()  -= b.cast_anion(0);  }
        else if ( isValAnion()   && b.isValNull()    ) { dir_anion()  -= b.cast_double(0); }
        else if ( isValAnion()   && b.isValInteger() ) { dir_anion()  -= b.cast_double(0); }
        else if ( isValAnion()   && b.isValReal()    ) { dir_anion()  -= b.cast_double(0); }
        else if ( isValAnion()   && b.isValAnion()   ) { dir_anion()  -= b.cast_anion(0);  }
        //else if ( isValNull()    && b.isValInteger() ) { dir_int()    -= b.cast_int(0);    }
        //else if ( isValInteger() && b.isValNull()    ) { dir_int()    -= b.cast_int(0);    }
        //else if ( isValInteger() && b.isValInteger() ) { dir_int()    -= b.cast_int(0);    }

        else
        {
            // Need to allow for potential overflow!

            int aa = cast_int(0);
            int bb = b.cast_int(0);

            if ( ( bb == INT_MIN ) || ( ( aa >= 0 ) && ( (INT_MAX-aa) < -bb ) ) || ( ( aa <= 0 ) && ( -bb < (INT_MIN-aa) ) ) )
            {
                force_double() = ((double) aa)-((double) bb);
            }

            else
            {
                dir_int() = aa-bb;
            }
        }
    }

    else
    {
        int acast = 0;
        int bcast = 0;
        int rescast = checkAddCompat(*this,b,acast,bcast);

        if ( rescast && ( rescast != 6 ) )
        {
            if ( ( acast == 1 ) && ( bcast == 1 ) )
            {
                // Need to allow for potential overflow!

                int aa = cast_int(0);
                int bb = b.cast_int(0);

                if ( ( bb == INT_MIN ) || ( ( aa >= 0 ) && ( (INT_MAX-aa) < -bb ) ) || ( ( aa <= 0 ) && ( -bb < (INT_MIN-aa) ) ) )
                {
                    force_double() = ((double) aa)-((double) bb);
                }

                else
                {
                    dir_int() = aa-bb;
                }
            }

            else if ( ( acast == 2  ) && ( bcast == 2  ) ) { dir_double() -= b.cast_double(0);     }
            else if ( ( acast == 3  ) && ( bcast == 3  ) ) { dir_anion()  -= b.cast_anion(0);      }
            else if ( ( acast == 4  ) && ( bcast == 4  ) ) { dir_vector() -= b.cast_vector(0);     }
            else if ( ( acast == 4  ) && ( bcast == 7  ) ) { dir_vector() -= b;                    }
            else if ( ( acast == 5  ) && ( bcast == 5  ) ) { dir_matrix() -= b.cast_matrix(0);     }
            else if ( ( acast == 5  ) && ( bcast == 7  ) ) { dir_matrix() -= b;                    }
            else if ( ( acast == 8  ) && ( bcast == 7  ) ) { dir_set()    -= b;                    }
            else if ( ( acast == 8  ) && ( bcast == 8  ) ) { dir_set()    -= b.cast_set(0);        }
            else if ( ( acast == 7  ) && ( bcast == 10 ) ) { *this = b; negate();                  }
            else if ( ( acast == 10 ) && ( bcast == 7  ) ) { ;                                     }
            else if ( ( acast == 10 ) && ( bcast == 10 ) ) { ;                                     }
            else if ( ( acast == 7  ) && ( bcast == 4  ) ) { *this = ( *this - b.cast_vector(0) ); }
            //else if ( ( acast == 7  ) && ( bcast == 8  ) ) { *this = ( *this - b.cast_set(0)    ); }
            else                                           { *this = ( *this - b.cast_matrix(0) ); }
        }

        else
        {
            constructError(*this,b,*this,"Error: incompatible types in subtraction.");
        }
    }

    return *this;
}

gentype &gentype::leftsub(double b)
{
         if ( isValReal()    ) {                 doubleval -= b;        }
    else if ( isValInteger() ) { typeis = 'R';   doubleval  = intval-b; }
    else if ( isValNull()    ) { typeis = 'R';   doubleval  = -b;       }
    else if ( isValAnion()   ) {                *anionval  -= b;        }
    else                       { gentype bg(b);  rightdiv(bg);          }

    return *this;
}





















gentype &operator+=(gentype &a, int bb)
{
    if ( ( bb == 0 ) && !a.isValSet() )
    {
        ;
    }

    else if ( a.isValEqnDir() )
    {
	if ( a.isCastableToIntegerWithoutLoss() )
	{
	    if ( !(a.cast_int(0)) )
	    {
                a = bb;
	    }

	    else
	    {
		goto basecase;
	    }
	}

	else
	{
	basecase:
            gentype b(bb);

            a += b;
	}
    }

    else if ( a.isValInteger() )
    {
        // Need to allow for potential overflow!

        int aa = a.cast_int(0);

        if ( ( ( aa >= 0 ) && ( (INT_MAX-aa) < bb ) ) || ( ( aa <= 0 ) && ( bb < (INT_MIN-aa) ) ) )
        {
            a.force_double() = ((double) aa)+((double) bb);
        }

        else
        {
            a.dir_int() = aa+bb;
        }
    }

    else if ( a.isValNull()    ) { ;                                                            }
    else if ( a.isValReal()    ) {                a.dir_double() += bb;                         }
    else if ( a.isValAnion()   ) {                a.dir_anion()  += (double) bb;                }
    else if ( a.isValVector()  ) { gentype b(bb); a.dir_vector() += b;                          }
    else if ( a.isValMatrix()  ) { gentype b(bb); a.dir_matrix() += b;                          }
    else if ( a.isValSet()     ) { gentype b(bb); a.dir_set()    += b;                          }
    else if ( a.isValDgraph()  ) { constructError(a,a,"Error: cannot add a graph and an int."); }

    else
    {
        constructError(a,a,"Error: incompatible types in addition.");
    }

    return a;
}

gentype &operator-=(gentype &a, int bb)
{
    if ( ( bb == 0 ) && !a.isValSet() )
    {
        ;
    }

    else if ( a.isValEqnDir() )
    {
	if ( a.isCastableToIntegerWithoutLoss() )
	{
	    if ( !(a.cast_int(0)) )
	    {
                a = -bb;
	    }

	    else
	    {
		goto basecase;
	    }
	}

	else
	{
	basecase:
            gentype b(bb);

            a -= b;
	}
    }

    else if ( a.isValInteger() )
    {
        // Need to allow for potential overflow!

        int aa = a.cast_int(0);

        if ( ( bb == INT_MIN ) || ( ( aa >= 0 ) && ( (INT_MAX-aa) < -bb ) ) || ( ( aa <= 0 ) && ( -bb < (INT_MIN-aa) ) ) )
        {
            a.force_double() = ((double) aa)-((double) bb);
        }

        else
        {
            a.dir_int() = aa-bb;
        }
    }

    else if ( a.isValNull()    ) { ;                                                                  }
    else if ( a.isValReal()    ) {                a.dir_double() -= bb;                               }
    else if ( a.isValAnion()   ) {                a.dir_anion()  -= (double) bb;                      }
    else if ( a.isValVector()  ) { gentype b(bb); a.dir_vector() -= b;                                }
    else if ( a.isValMatrix()  ) { gentype b(bb); a.dir_matrix() -= b;                                }
    else if ( a.isValSet()     ) { gentype b(bb); a.dir_set()    -= b;                                }
    else if ( a.isValDgraph()  ) { constructError(a,a,"Error: cannot subtract an int from a graph."); }

    else
    {
        constructError(a,a,"Error: incompatible types in subtraction.");
    }

    return a;
}

gentype &operator*=(gentype &a, int bb)
{
    //NB:  need to keep structure of result, even if it is zero
    //if ( bb == 0 )
    //{
    //    a = 0;
    //}

    if ( ( bb == 1 ) && !a.isValSet() )
    {
        ;
    }

    else if ( a.isValEqnDir() )
    {
	if ( a.isCastableToIntegerWithoutLoss() )
	{
	    if ( !(a.cast_int(0)) )
	    {
                a = 0;
	    }

            else if ( a.cast_int(0) == 1 )
            {
                a = bb;
            }

	    else
	    {
		goto basecase;
	    }
	}

	else
	{
	basecase:
            gentype b(bb);

            a *= b;
	}
    }

    else if ( a.isValNull()    ) { ;                                                                }
    else if ( a.isValReal()    ) {                a.dir_double() *= bb;                             }
    else if ( a.isValAnion()   ) {                a.dir_anion()  *= (double) bb;                    }
    else if ( a.isValVector()  ) { gentype b(bb); a.dir_vector() *= b;                              }
    else if ( a.isValMatrix()  ) { gentype b(bb); a.dir_matrix() *= b;                              }
    else if ( a.isValSet()     ) { gentype b(bb); a = a.dir_set()*b;                                }
    else if ( a.isValDgraph()  ) { constructError(a,a,"Error: cannot multiply a graph and a int."); }

    else if ( a.isValInteger() )
    {
        // Need to allow for potential overflow

        int vala = a.cast_int(0);
        int valb = bb;

        int resa = vala*valb;

        if ( ( vala != 0 ) && ( resa/vala != valb ) )
        {
            a.force_double() = ((double) vala)*((double) valb);
        }

        else
        {
            a.dir_int() = resa;
        }
        //a.dir_int() *= bb;
    }

    else
    {
        std::string errstr("Error: incompatible types in multiplication ");
        errstr += a.cast_string(0);
        errstr += "*=double";

        constructError(a,a,errstr.c_str());
    }

    return a;
}

gentype &operator+=(gentype &a, double bb)
{
    if ( ( bb == 0 ) && !a.isValSet() )
    {
        ;
    }

    else if ( a.isValEqnDir() )
    {
	if ( a.isCastableToIntegerWithoutLoss() )
	{
	    if ( !(a.cast_int(0)) )
	    {
                a = bb;
	    }

	    else
	    {
		goto basecase;
	    }
	}

	else
	{
	basecase:
            gentype b(bb);

            a += b;
	}
    }

    else if ( a.isValNull()    ) { ;                                                              }
    else if ( a.isValInteger() ) {                a.dir_double() += bb;                           }
    else if ( a.isValReal()    ) {                a.dir_double() += bb;                           }
    else if ( a.isValAnion()   ) {                a.dir_anion()  += bb;                           }
    else if ( a.isValVector()  ) { gentype b(bb); a.dir_vector() += b;                            }
    else if ( a.isValMatrix()  ) { gentype b(bb); a.dir_matrix() += b;                            }
    else if ( a.isValSet()     ) { gentype b(bb); a.dir_set()    += b;                            }
    else if ( a.isValDgraph()  ) { constructError(a,a,"Error: cannot add a graph and a double."); }

    else
    {
        constructError(a,a,"Error: incompatible types in addition.");
    }

    return a;
}

gentype &operator-=(gentype &a, double bb)
{
    if ( ( bb == 0 ) && !a.isValSet() )
    {
        ;
    }

    else if ( a.isValEqnDir() )
    {
	if ( a.isCastableToIntegerWithoutLoss() )
	{
	    if ( !(a.cast_int(0)) )
	    {
                a = -bb;
	    }

	    else
	    {
		goto basecase;
	    }
	}

	else
	{
	basecase:
            gentype b(bb);

            a -= b;
	}
    }

    else if ( a.isValNull()    ) { ;                                                                    }
    else if ( a.isValInteger() ) {                a.dir_double() -= bb;                                 }
    else if ( a.isValReal()    ) {                a.dir_double() -= bb;                                 }
    else if ( a.isValAnion()   ) {                a.dir_anion()  -= bb;                                 }
    else if ( a.isValVector()  ) { gentype b(bb); a.dir_vector() -= b;                                  }
    else if ( a.isValMatrix()  ) { gentype b(bb); a.dir_matrix() -= b;                                  }
    else if ( a.isValSet()     ) { gentype b(bb); a.dir_set()    -= b;                                  }
    else if ( a.isValDgraph()  ) { constructError(a,a,"Error: cannot subtract a double from a graph."); }

    else
    {
        constructError(a,a,"Error: incompatible types in subtraction.");
    }

    return a;
}

gentype &operator*=(gentype &a, double bb)
{
    //NB:  need to keep structure of result, even if it is zero
    //if ( bb == 0 )
    //{
    //    a = 0;
    //}

    if ( ( bb == 1 ) && !a.isValSet() )
    {
        ;
    }

    else if ( a.isValEqnDir() )
    {
	if ( a.isCastableToIntegerWithoutLoss() )
	{
	    if ( !(a.cast_int(0)) )
	    {
                a = 0;
	    }

            else if ( a.cast_int(0) == 1 )
            {
                a = bb;
            }

	    else
	    {
		goto basecase;
	    }
	}

	else
	{
	basecase:
            gentype b(bb);

            a *= b;
	}
    }

    else if ( a.isValNull()    ) { ;                                                                   }
    else if ( a.isValInteger() ) {                a.dir_double() *= bb;                                }
    else if ( a.isValReal()    ) {                a.dir_double() *= bb;                                }
    else if ( a.isValAnion()   ) {                a.dir_anion()  *= bb;                                }
    else if ( a.isValVector()  ) { gentype b(bb); a.dir_vector() *= b;                                 }
    else if ( a.isValMatrix()  ) { gentype b(bb); a.dir_matrix() *= b;                                 }
    else if ( a.isValSet()     ) { gentype b(bb); a = a.dir_set()*b;                                   }
    else if ( a.isValDgraph()  ) { constructError(a,a,"Error: cannot multiply a graph and a double."); }

    else
    {
        std::string errstr("Error: incompatible types in multiplication ");
        errstr += a.cast_string(0);
        errstr += "*=double";

        constructError(a,a,errstr.c_str());
    }

    return a;
}

gentype &operator+=(gentype &a, const d_anion  &bb)
{
    if ( ( bb == 0 ) && !a.isValSet() )
    {
        ;
    }

    else if ( a.isValEqnDir() )
    {
	if ( a.isCastableToIntegerWithoutLoss() )
	{
	    if ( !(a.cast_int(0)) )
	    {
                a = bb;
	    }

	    else
	    {
		goto basecase;
	    }
	}

	else
	{
	basecase:
            gentype b(bb);

            a += b;
	}
    }

    else if ( a.isValNull()    ) { ;                                                              }
    else if ( a.isValInteger() ) {                a.dir_anion()  += bb;                           }
    else if ( a.isValReal()    ) {                a.dir_anion()  += bb;                           }
    else if ( a.isValAnion()   ) {                a.dir_anion()  += bb;                           }
    else if ( a.isValVector()  ) { gentype b(bb); a.dir_vector() += b;                            }
    else if ( a.isValMatrix()  ) { gentype b(bb); a.dir_matrix() += b;                            }
    else if ( a.isValSet()     ) { gentype b(bb); a.dir_set()    += b;                            }
    else if ( a.isValDgraph()  ) { constructError(a,a,"Error: cannot add a graph and a double."); }

    else
    {
        constructError(a,a,"Error: incompatible types in addition.");
    }

    return a;
}

gentype &operator-=(gentype &a, const d_anion  &bb)
{
    if ( ( bb == 0 ) && !a.isValSet() )
    {
        ;
    }

    else if ( a.isValEqnDir() )
    {
	if ( a.isCastableToIntegerWithoutLoss() )
	{
	    if ( !(a.cast_int(0)) )
	    {
                a = -bb;
	    }

	    else
	    {
		goto basecase;
	    }
	}

	else
	{
	basecase:
            gentype b(bb);

            a -= b;
	}
    }

    else if ( a.isValNull()    ) { ;                                                                    }
    else if ( a.isValInteger() ) {                a.dir_anion()  -= bb;                                 }
    else if ( a.isValReal()    ) {                a.dir_anion()  -= bb;                                 }
    else if ( a.isValAnion()   ) {                a.dir_anion()  -= bb;                                 }
    else if ( a.isValVector()  ) { gentype b(bb); a.dir_vector() -= b;                                  }
    else if ( a.isValMatrix()  ) { gentype b(bb); a.dir_matrix() -= b;                                  }
    else if ( a.isValSet()     ) { gentype b(bb); a.dir_set()    -= b;                                  }
    else if ( a.isValDgraph()  ) { constructError(a,a,"Error: cannot subtract a double from a graph."); }

    else
    {
        constructError(a,a,"Error: incompatible types in subtraction.");
    }

    return a;
}

gentype &operator*=(gentype &a, const d_anion  &bb)
{
    //NB:  need to keep structure of result, even if it is zero
    //if ( bb == 0 )
    //{
    //    a = 0;
    //}

    if ( ( bb == 1 ) && !a.isValSet() )
    {
        ;
    }

    else if ( a.isValEqnDir() )
    {
	if ( a.isCastableToIntegerWithoutLoss() )
	{
	    if ( !(a.cast_int(0)) )
	    {
                a = 0;
	    }

            else if ( a.cast_int(0) == 1 )
            {
                a = bb;
            }

	    else
	    {
		goto basecase;
	    }
	}

	else
	{
	basecase:
            gentype b(bb);

            a *= b;
	}
    }

    else if ( a.isValNull()    ) { ;                                                                   }
    else if ( a.isValInteger() ) {                a.dir_anion()  *= bb;                                }
    else if ( a.isValReal()    ) {                a.dir_anion()  *= bb;                                }
    else if ( a.isValAnion()   ) {                a.dir_anion()  *= bb;                                }
    else if ( a.isValVector()  ) { gentype b(bb); a.dir_vector() *= b;                                 }
    else if ( a.isValMatrix()  ) { gentype b(bb); a.dir_matrix() *= b;                                 }
    else if ( a.isValSet()     ) { gentype b(bb); a=a.dir_set()*b;                                     }
    else if ( a.isValDgraph()  ) { constructError(a,a,"Error: cannot multiply a graph and a double."); }

    else
    {
        std::string errstr("Error: incompatible types in multiplication ");
        errstr += a.cast_string(0);
        errstr += "*=double";

        constructError(a,a,errstr.c_str());
    }

    return a;
}



















































































// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
//
// Generic form functions for various types of maths functions
//
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================


// fname        = the function name
// elmfn        = the elementwise function
// anionfn      = the anion valued function used otherwise (nullptr if restanionfn used instead)
// restanionfn  = the real-value, anion-argument form
// doublefn     = the double valued function
// intfn        = the integer-valued function, if it is defined and returns an integer.
//                use nullptr if no such function is available.
// outRangeTest = returns 0 if the function will return a real for the given real
//                argument, 1 if it must return an anion for the given real argument
// andor = 0 if logic test is combined with OR, 1 if logic is AND



int trueOR (double dummy);
int falseOR(double dummy);

int invertOR(int a);
int bufferOR(int a);

int andOR (int a, int b);
int orOR  (int a, int b);
int norOR (int a, int b);
int nandOR(int a, int b);
int xorOR (int a, int b);
int xandOR(int a, int b);

int trueOR  (double) { return 1; }
int falseOR (double) { return 0; }

int invertOR(int a) { return !a; }
int bufferOR(int a) { return a;  }

int andOR (int a, int b) { return a && b;                     }
int orOR  (int a, int b) { return a || b;                     }
int norOR (int a, int b) { return !(a || b);                  }
int nandOR(int a, int b) { return !(a && b);                  }
int xorOR (int a, int b) { return ( a && !b ) || ( !a && b ); }
int xandOR(int a, int b) { return ( !a && !b ) || ( a && b ); }


gentype &OP_elementwiseDefaultCallA(gentype &a, const gentype &fnbare, const char *fname, gentype &(*op_elmfn)(gentype &), d_anion (*anionfn)(const d_anion &), double (*restanionfn)(const d_anion &), double (*doublefn)(double), int (*intfn)(int), int (*outRangeTest)(double));
gentype &elementwiseDefaultCallB(gentype &res, const gentype &a, const gentype &b, const char *fname, gentype (*elmfn)(const gentype &, const void *), gentype (*specfn)(const gentype &, const gentype &));
gentype &elementwiseDefaultCallC(gentype &res, const gentype &a, const gentype &b, const char *fname, gentype (*elmfn)(const gentype &, const gentype &), gentype (*fn)(const gentype &, const gentype &), int (*intfn)(int,int));
gentype &maxmincommonform(gentype &res, const gentype &a, const char *fname, gentype (*matfn)(const Matrix<gentype> &, int &, int &), gentype (*vecfn)(const Vector<gentype> &, int &), gentype (*basevecfn)(const Vector<gentype> &), gentype (*setfn)(const Set<gentype> &), int &i, int &j, int getarg, int absres, int allres);
gentype &zaxmincommonform(gentype &res, const gentype &a, const char *fname, const gentype &(*matfn)(const Matrix<gentype> &, int &, int &), const gentype &(*vecfn)(const Vector<gentype> &, int &), const gentype &(*basevecfn)(const Vector<gentype> &), const gentype &(*setfn)(const Set<gentype> &), int &i, int &j, int getarg, int absres, int allres);
gentype &binLogicForm(gentype &res, const gentype &a, const gentype &b, const char *opname, int (*elmfn)(const gentype &, const gentype &), int andor);

gentype &OP_elementwiseDefaultCallA(gentype &a, const gentype &fnbare, const char *fname, gentype &(*elmfn)(gentype &), d_anion (*anionfn)(const d_anion &), double (*restanionfn)(const d_anion &), double (*doublefn)(double), int (*intfn)(int), int (*outRangeTest)(double))
{
    if ( a.isValEqnDir() )
    {
        //phantomxyz
        //std::string resstr;
        //gentype res;
        //
        //resstr = fname;
        //resstr += "(x)";
        //res = resstr;
        //a = res(a);

        a = fnbare(a);
    }

    else if ( anionfn != nullptr )
    {
             if ( a.isValStrErr()                        ) { std::string errstr = fname; errstr += " ill-defined for string"; constructError(a,a,errstr); }
        else if ( a.isValDgraph()                        ) { std::string errstr = fname; errstr += " ill-defined for dgraph"; constructError(a,a,errstr); }
        else if ( a.isValSet()                           ) { (a.dir_set()   ).applyon(elmfn); }
        else if ( a.isValDict()                          ) { (a.dir_dict()  ).applyon(elmfn); }
        else if ( a.isValMatrix()                        ) { (a.dir_matrix()).applyon(elmfn); }
        else if ( a.isValVector()                        ) { (a.dir_vector()).applyon(elmfn); }
        else if ( a.isValAnion()                         ) { a.dir_anion()  = anionfn( a.cast_anion(0) ); }
        else if ( outRangeTest(a.cast_double(0))         ) { a.dir_anion()  = anionfn( a.cast_anion(0) ); }
        else if ( a.isValReal()                          ) { a.dir_double() = doublefn(a.cast_double(0)); }
        else if ( a.isValInteger() && ( intfn == nullptr ) ) { a.dir_double() = doublefn(a.cast_double(0)); }
        else if ( a.isValNull()                          ) { ; }
        else                                               { a.dir_int()    = intfn(   a.cast_int(0)   ); }
    }

    else if ( restanionfn != nullptr )
    {
             if ( a.isValStrErr()                        ) { std::string errstr = fname; errstr += " ill-defined for string"; constructError(a,a,errstr); }
        else if ( a.isValDgraph()                        ) { std::string errstr = fname; errstr += " ill-defined for dgraph"; constructError(a,a,errstr); }
        else if ( a.isValSet()                           ) { (a.dir_set()   ).applyon(elmfn); }
        else if ( a.isValDict()                          ) { (a.dir_dict()  ).applyon(elmfn); }
        else if ( a.isValMatrix()                        ) { (a.dir_matrix()).applyon(elmfn); }
        else if ( a.isValVector()                        ) { (a.dir_vector()).applyon(elmfn); }
        else if ( a.isValAnion()                         ) { a.dir_anion()  = restanionfn(a.cast_anion(0) ); }
        else if ( outRangeTest(a.cast_double(0))         ) { a.dir_anion()  = restanionfn(a.cast_anion(0) ); }
        else if ( a.isValReal()                          ) { a.dir_double() = doublefn(   a.cast_double(0)); }
        else if ( a.isValInteger() && ( intfn == nullptr ) ) { a.dir_double() = doublefn(   a.cast_double(0)); }
        else if ( a.isValNull()                          ) { ; }
        else                                               { a.dir_int()    = intfn(      a.cast_int(0)   ); }
    }

    else if ( doublefn != nullptr )
    {
             if ( a.isValStrErr()                        ) { std::string errstr = fname; errstr += " ill-defined for string"; constructError(a,a,errstr); }
        else if ( a.isValDgraph()                        ) { std::string errstr = fname; errstr += " ill-defined for dgraph"; constructError(a,a,errstr); }
        else if ( a.isValSet()                           ) { (a.dir_set()   ).applyon(elmfn); }
        else if ( a.isValDict()                          ) { (a.dir_dict()  ).applyon(elmfn); }
        else if ( a.isValMatrix()                        ) { (a.dir_matrix()).applyon(elmfn); }
        else if ( a.isValVector()                        ) { (a.dir_vector()).applyon(elmfn); }
        else if ( a.isValAnion()                         ) { std::string errstr = fname; errstr += " ill-defined for anions"; constructError(a,a,errstr); }
        else if ( outRangeTest(a.cast_double(0))         ) { std::string errstr = fname; errstr += " ill-defined for out-of-range reals"; constructError(a,a,errstr); }
        else if ( a.isValReal()                          ) { a.dir_double() = doublefn(a.cast_double(0)); }
        else if ( a.isValInteger() && ( intfn == nullptr ) ) { a.dir_double() = doublefn(a.cast_double(0)); }
        else if ( a.isValNull()                          ) { ; }
        else                                               { a.dir_int()    = intfn(   a.cast_int(0)   ); }
    }

    else
    {
             if ( a.isValStrErr()                        ) { std::string errstr = fname; errstr += " ill-defined for string"; constructError(a,a,errstr); }
        else if ( a.isValDgraph()                        ) { std::string errstr = fname; errstr += " ill-defined for dgraph"; constructError(a,a,errstr); }
        else if ( a.isValSet()                           ) { (a.dir_set()   ).applyon(elmfn); }
        else if ( a.isValDict()                          ) { (a.dir_dict()  ).applyon(elmfn); }
        else if ( a.isValMatrix()                        ) { (a.dir_matrix()).applyon(elmfn); }
        else if ( a.isValVector()                        ) { (a.dir_vector()).applyon(elmfn); }
        else if ( a.isValAnion()                         ) { std::string errstr = fname; errstr += " ill-defined for anions"; constructError(a,a,errstr); }
        else if ( outRangeTest(a.cast_double(0))         ) { std::string errstr = fname; errstr += " ill-defined for out-of-range reals"; constructError(a,a,errstr); }
        else if ( a.isValReal()                          ) { std::string errstr = fname; errstr += " ill-defined for reals"; constructError(a,a,errstr); }
        else if ( a.isValInteger() && ( intfn == nullptr ) ) { std::string errstr = fname; errstr += " ill-defined for integers out of range"; constructError(a,a,errstr); }
        else if ( a.isValNull()                          ) { ; }
        else                                               { a.dir_int() = intfn(a.cast_int(0)); }
    }

    return a;
}

gentype &elementwiseDefaultCallB(gentype &res, const gentype &a, const gentype &b, const char *fname, gentype (*elmfn)(const gentype &, const void *), gentype (*specfn)(const gentype &, const gentype &))
{
    if ( a.isValEqnDir() )
    {
        std::string resstr;

	resstr = fname;
        resstr += "(x,y)";
        res = resstr;
	res = res(a,b);
    }

    else
    {
	     if ( a.isValStrErr() ) { std::string errstr = fname; errstr += " ill-defined for string"; constructError(a,res,errstr); }
        else if ( a.isValDgraph() ) { std::string errstr = fname; errstr += " ill-defined for dgraph"; constructError(a,res,errstr); }
        else if ( a.isValSet()    ) { Set<gentype>              temp(a.cast_set(0));    temp.applyon(elmfn, (const void *) &b); res = temp; }
        else if ( a.isValDict()   ) { Dict<gentype,dictkey>     temp(a.cast_dict(0));   temp.applyon(elmfn, (const void *) &b); res = temp; }
	else if ( a.isValMatrix() ) { Matrix<gentype>           temp(a.cast_matrix(0)); temp.applyon(elmfn, (const void *) &b); res = temp; }
	else if ( a.isValVector() ) { Vector<gentype>           temp(a.cast_vector(0)); temp.applyon(elmfn, (const void *) &b); res = temp; }
	else                        { res = specfn(a,b); }
    }

    return res;
}

// NB: elementwise operations propogate, so for example if you have to matrices of matrices
// and you elementwise multiply them then the individual elements will be elementwise multiplied
// together.

gentype &elementwiseDefaultCallC(gentype &res, const gentype &a, const gentype &b, const char *fname, gentype (*elmfn)(const gentype &, const gentype &), gentype (*fn)(const gentype &, const gentype &), int (*intfn)(int, int))
{
    if ( a.isValMatrix() || b.isValMatrix() )
    {
        // Case 1: either operand is a matrix, so recurse, either by
        // testing dimensions agree and applying elementwise or by
        // matricising either a and b as required and retrying.

	if ( !a.isValMatrix() )
	{
	    Matrix<gentype> aaa(b.numRows(),b.numCols());
	    aaa = a;
	    gentype aa = aaa;
            elementwiseDefaultCallC(res,aa,b,fname,elmfn,fn,intfn);
	}

	else if ( !b.isValMatrix() )
	{
	    Matrix<gentype> bbb(a.numRows(),a.numCols());
	    bbb = b;
	    gentype bb = bbb;
            elementwiseDefaultCallC(res,a,bb,fname,elmfn,fn,intfn);
	}

	else if ( ( a.numRows() == b.numRows() ) && ( a.numCols() == b.numCols() ) )
	{
	    int i,j;

            Matrix<gentype> mres(a.cast_matrix(0));
	    Matrix<gentype> aa(a.cast_matrix(0));
	    Matrix<gentype> bb(b.cast_matrix(0));

            if ( a.numRows() && a.numCols() )
            {
                for ( i = 0 ; i < a.numRows() ; ++i )
	        {
	            for ( j = 0 ; j < a.numCols() ; ++j )
	            {
                        mres("&",i,j) = elmfn(aa(i,j),bb(i,j));
	            }
		}
            }

            res = mres;
	}

	else
	{
	    std::string errstr = fname;
	    errstr += " matrix dimensions do not agree";
	    constructError(a,b,res,errstr);
	}
    }

    else if ( a.isValVector() || b.isValVector() )
    {
        // Case 2: either operand is a vector, so recurse, either by
        // testing dimensions agree and applying elementwise or by
        // vectorising either a and b as required and retrying.

	if ( !a.isValVector() )
	{
	    Vector<gentype> aaa(b.size());
	    aaa = a;
	    gentype aa(aaa);
            elementwiseDefaultCallC(res,aa,b,fname,elmfn,fn,intfn);
	}

	else if ( !b.isValVector() )
	{
	    Vector<gentype> bbb(a.size());
	    bbb = b;
	    gentype bb(bbb);
            elementwiseDefaultCallC(res,a,bb,fname,elmfn,fn,intfn);
	}

	else if ( a.size() == b.size() )
	{
	    int i;

            Vector<gentype> vres(a.cast_vector(0));
	    Vector<gentype> aa(a.cast_vector(0));
	    Vector<gentype> bb(b.cast_vector(0));

            //if ( a.size() )
            {
	        for ( i = 0 ; i < a.size() ; ++i )
	        {
		    vres("&",i) = elmfn(aa(i),bb(i));
		}
	    }

            res = vres;
	}

	else
	{
	    std::string errstr = fname;
	    errstr += " vector dimensions do not agree";
	    constructError(a,b,res,errstr);
	}
    }

    else if ( a.isValEqnDir() || b.isValEqnDir() )
    {
        // Case 3: either operand is a function, so leave as-is.

        std::string resstr = fname;
	resstr += "(x,y)";
	res = resstr;
	res = res(a,b);
    }

    else if ( fn != nullptr )
    {
        // Case 4: no vectors, matrices or equations present.  Proceed with
        // non-elementwise function if well defined.

        res = fn(a,b);
    }

    else if ( a.isValNull() && b.isValNull() )
    {
        res.makeNull();
    }

    else if ( a.isCastableToIntegerWithoutLoss() && b.isCastableToIntegerWithoutLoss() && ( intfn != nullptr ) )
    {
        // Case 5: no vectors, matrices or equations present, no
        // non-elementwise function defined, but both are integers (or
        // castable to without loss), and integer function is defined, so
        // use that.

        res = intfn(a.cast_int(0),b.cast_int(0));
    }

    else
    {
        // Case 6: fail-through.

        std::string errstr = fname;
	errstr += " defined only for bool/integer.";
	constructError(a,b,res,errstr);
    }

    return res;
}

gentype &maxmincommonform(gentype &res, const gentype &a, const char *fname, gentype (*matfn)(const Matrix<gentype> &, int &, int &),
                                                                             gentype (*vecfn)(const Vector<gentype> &, int &),
                                                                             gentype (*basevecfn)(const Vector<gentype> &),
                                                                             gentype (*setfn)(const Set<gentype> &),
                          int &i, int &j, int getarg, int absres, int allres)
{
    i = 0;
    j = 0;

    if ( a.isValEqnDir() )
    {
	std::string resstr = fname;
        resstr += "(x)";
	res = resstr;
        res = res(a);
    }

    if ( a.isValStrErr() )
    {
        std::string fnname = fname;
        constructError(a,res,"String "+fnname+" not implemented");
    }

    else if ( a.isValMatrix() && ( matfn != nullptr ) )
    {
        res = matfn(a.cast_matrix(0),i,j);

        if ( getarg )
        {
            Vector<gentype> ii(2);

            ii("&",0) = i;
            ii("&",1) = j;

            res = ii;
        }
    }

    else if ( a.isValMatrix() )
    {
        std::string fnname = fname;
        constructError(a,res,"Matrix "+fnname+" not implemented");
    }

    else if ( a.isValVector() && ( vecfn != nullptr ) )
    {
        res = vecfn(a.cast_vector(0),i);

        if ( getarg && allres )
        {
            Vector<gentype> ii(0);
            gentype iii(i);

            if ( a.size() )
            {
                int k;
                gentype kk;

                for ( k = 0 ; k < a.size() ; ++k )
                {
                    kk = k;

                    if ( !absres )
                    {
                        if ( derefv(a,iii) == derefv(a,kk) )
                        {
                            ii.add(ii.size());
                            ii("&",ii.size()-1) = kk;
                        }
                    }

                    else
                    {
                        if ( abs2(derefv(a,iii)) == abs2(derefv(a,kk)) )
                        {
                            ii.add(ii.size());
                            ii("&",ii.size()-1) = kk;
                        }
                    }
                }
            }

            gentype iiii(ii);
            Vector<gentype> ayeayecaptn(1);
            ayeayecaptn("&",0) = iiii;
            res = ayeayecaptn;
        }

        else if ( getarg )
        {
            Vector<gentype> ii(1);
            ii("&",0) = i;
            res = ii;
        }
    }

    else if ( a.isValSet() && ( setfn != nullptr ) )
    {
        res = setfn(a.cast_set(0));
    }

    else if ( a.isValDict() )
    {
        std::string fnname = fname;
        constructError(a,res,"Dict "+fnname+" not implemented");
    }

    else if ( a.isValVector() && ( basevecfn != nullptr ) )
    {
        res = basevecfn(a.cast_vector(0));
    }

    else if ( a.isValVector() )
    {
        std::string fnname = fname;
        constructError(a,res,"Vector "+fnname+" not implemented");
    }

    else if ( getarg )
    {
        Vector<gentype> ii(0);
        res = ii;
    }

    else if ( absres )
    {
        res = abs2(a);
    }

    else
    {
        res = a;
    }

    return res;
}

gentype &zaxmincommonform(gentype &res, const gentype &a, const char *fname, const gentype &(*matfn)(const Matrix<gentype> &, int &, int &), const gentype &(*vecfn)(const Vector<gentype> &, int &), const gentype &(*basevecfn)(const Vector<gentype> &), const gentype &(*setfn)(const Set<gentype> &), int &i, int &j, int getarg, int absres, int allres)
{
    i = 0;
    j = 0;

    if ( a.isValEqnDir() )
    {
	std::string resstr = fname;
        resstr += "(x)";
	res = resstr;
        res = res(a);
    }

    if ( a.isValStrErr() )
    {
        std::string fnname = fname;
        constructError(a,res,"String "+fnname+" not implemented");
    }

    else if ( a.isValMatrix() && ( matfn != nullptr ) )
    {
        res = matfn(a.cast_matrix(0),i,j);

        if ( getarg )
        {
            Vector<gentype> ii(2);

            ii("&",0) = i;
            ii("&",1) = j;

            res = ii;
        }
    }

    else if ( a.isValMatrix() )
    {
        std::string fnname = fname;
        constructError(a,res,"Matrix "+fnname+" not implemented");
    }

    else if ( a.isValVector() && ( vecfn != nullptr ) )
    {
        res = vecfn(a.cast_vector(0),i);

        if ( getarg && allres )
        {
            Vector<gentype> ii(0);
            gentype iii(i);

            if ( a.size() )
            {
                int k;
                gentype kk;

                for ( k = 0 ; k < a.size() ; ++k )
                {
                    kk = k;

                    if ( !absres )
                    {
                        if ( derefv(a,iii) == derefv(a,kk) )
                        {
                            ii.add(ii.size());
                            ii("&",ii.size()-1) = kk;
                        }
                    }

                    else
                    {
                        if ( abs2(derefv(a,iii)) == abs2(derefv(a,kk)) )
                        {
                            ii.add(ii.size());
                            ii("&",ii.size()-1) = kk;
                        }
                    }
                }
            }

            gentype iiii(ii);
            Vector<gentype> ayeayecaptn(1);
            ayeayecaptn("&",0) = iiii;
            res = ayeayecaptn;
        }

        else if ( getarg )
        {
            Vector<gentype> ii(1);
            ii("&",0) = i;
            res = ii;
        }
    }

    else if ( a.isValSet() && ( setfn != nullptr ) )
    {
        res = setfn(a.cast_set(0));
    }

    else if ( a.isValDict() )
    {
        std::string fnname = fname;
        constructError(a,res,"Dict "+fnname+" not implemented");
    }

    else if ( a.isValVector() && ( basevecfn != nullptr ) )
    {
        res = basevecfn(a.cast_vector(0));
    }

    else if ( a.isValVector() )
    {
        std::string fnname = fname;
        constructError(a,res,"Vector "+fnname+" not implemented");
    }

    else if ( getarg )
    {
        Vector<gentype> ii(0);
        res = ii;
    }

    else if ( absres )
    {
        res = abs2(a);
    }

    else
    {
        res = a;
    }

    return res;
}


gentype &binLogicForm(gentype &res, const gentype &a, const gentype &b, const char *opname, int (*elmfn)(const gentype &, const gentype &), int andor)
{
    if ( a.isValEqnDir() || b.isValEqnDir() )
    {
	std::string extname = opname;
        extname += "(x,y)";
	res = res(a,b);

        return res;
    }

    if ( a.isValMatrix() && b.isValMatrix() && ( a.numRows() == b.numRows() ) && ( a.numCols() == b.numCols() ) )
    {
        if ( a.numRows() && a.numCols() )
        {
            int i,j;
            Matrix<gentype> am(a.cast_matrix(0));
            Matrix<gentype> bm(b.cast_matrix(0));
            gentype temp;

            res = andor;

            for ( i = 0 ; i < a.numRows() ; ++i )
            {
                for ( j = 0 ; j < a.numCols() ; ++j )
                {
                    if ( andor )
                    {
                        res = land(res,binLogicForm(temp,am(i,j),bm(i,j),opname,elmfn,andor));
                    }

                    else
                    {
                        res = lor(res,binLogicForm(temp,am(i,j),bm(i,j),opname,elmfn,andor));
                    }
                }
            }
        }

        else
        {
            res = 1;
        }
    }

    else if ( a.isValVector() && b.isValVector() && ( a.size() == b.size() ) )
    {
        if ( a.size() )
        {
            int i;
            Vector<gentype> av(a.cast_vector(0));
            Vector<gentype> bv(b.cast_vector(0));
            gentype temp;

            res = andor;

            for ( i = 0 ; i < a.size() ; ++i )
            {
                if ( andor )
                {
                    res = land(res,binLogicForm(temp,av(i),bv(i),opname,elmfn,andor));
                }

                else
                {
                    res = lor(res,binLogicForm(temp,av(i),bv(i),opname,elmfn,andor));
                }
            }
        }

        else
        {
            res = 1;
        }
    }

    else if ( a.isValSet() && b.isValSet() && ( a.size() == b.size() ) )
    {
        if ( a.size() )
        {
            int i;
            Vector<gentype> av((a.cast_set(0)).all());
            Vector<gentype> bv((b.cast_set(0)).all());
            gentype temp;

            res = andor;

            for ( i = 0 ; i < a.size() ; ++i )
            {
                if ( andor )
                {
                    res = land(res,binLogicForm(temp,av(i),bv(i),opname,elmfn,andor));
                }

                else
                {
                    res = lor(res,binLogicForm(temp,av(i),bv(i),opname,elmfn,andor));
                }
            }
        }

        else
        {
            res = 1;
        }
    }

    else if ( a.isValMatrix() || b.isValMatrix() || a.isValVector() || b.isValVector() || a.isValSet() || b.isValSet() )
    {
        res = 0;
    }

    else
    {
	res = elmfn(a,b);
    }

    return res;
}











// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
//
// Non-trivial maths functions
//
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================
// =========================================================================================================================================================================

gentype realDeriv(const gentype &i, const gentype &j, const gentype &a)
{
    const static int varInd = getfnind("var");
    const static int VarInd = getfnind("Var");
    const static int gvarInd = getfnind("gvar");
    const static int gVarInd = getfnind("gVar");
    const static int realDerivInd = getfnind("realDeriv");

    int fnnameind = a.getfnnameind();

    if ( a.isValEqnDir() && !(a.realDerivDefinedDir()) && ( ( realDerivInd == fnnameind ) || ( fnnameind == gvarInd ) || ( fnnameind == gVarInd ) || ( fnnameind == varInd ) || ( VarInd == fnnameind ) ) )
    {
        const static gentype res("realDeriv(x,y,z)");

        return res(i,j,a);
    }

    else if ( a.isValEqnDir() && !(a.realDerivDefinedDir()) )
    {
        gentype res;

        constructError(i,j,a,res,"Derivative not defined for this function.");

        return res;
    }

    gentype res = a;
    res.realDeriv(i,j);

    return res;
}

gentype idiv(const gentype &a, const gentype &b)
{
    if ( a.isValEqnDir() || b.isValEqnDir() )
    {
        const static gentype res("idiv(x,y)");

        return res(a,b);
    }

    gentype res;

    // Design choice: integer division should work for all numbers that can be
    // cast as integers without loss of precision, regardless of "actual" type.

    if ( a.isCastableToIntegerWithoutLoss() && b.isCastableToIntegerWithoutLoss() )
    {
        if ( b.cast_int(0) )
        {
            res = a.cast_int(0) / b.cast_int(0);
        }

        else
        {
            constructError(a,b,res,"divide by zero error");
        }
    }

    else
    {
	constructError(a,b,res,"idiv defined only for integers");
    }

    return res;
}

gentype &OP_idiv(gentype &a, const gentype &b)
{
    if ( a.isValEqnDir() || b.isValEqnDir() )
    {
        const static gentype res("idiv(x,y)");

        return a = res(a,b);
    }

    // Design choice: integer division should work for all numbers that can
    // be cast as integers without loss of precision, regardless of "actual"
    // type.

    if ( a.isCastableToIntegerWithoutLoss() && b.isCastableToIntegerWithoutLoss() )
    {
        if ( b.cast_int(0) )
        {
            a = a.cast_int(0) / b.cast_int(0);
        }

        else
        {
            constructError(a,b,a,"divide by zero error");
        }
    }

    else
    {
        constructError(a,b,a,"idiv defined only for integers");
    }

    return a;
}

gentype dubpow(const gentype &a, const void *b);
gentype dubpow(const gentype &a, const void *b)
{
    return pow(a,*((const gentype *) b));
}

gentype genpowintern(const gentype &a, const gentype &b, const char *powname, d_anion (*anionpow)(const d_anion &, const d_anion &));
gentype genpowintern(const gentype &a, const gentype &b, const char *powname, d_anion (*anionpow)(const d_anion &, const d_anion &))
{
    gentype res;
    std::string strpowname = powname;

    if ( a.isValEqnDir() || b.isValEqnDir() )
    {
	if ( b.isCastableToIntegerWithoutLoss() )
	{
	    if ( b.cast_int(0) == 0 )
	    {
                res = 1;
	    }

	    else if ( b.cast_int(0) == 1 )
	    {
                res = a;
	    }

	    else
	    {
		goto basecase;
	    }
	}

	else
	{
	basecase:
            const static gentype resx(strpowname+"(x,y)");

            return resx(a,b);
	}

	return res;
    }

         if ( a.isValStrErr() ) { constructError(a,b,res,strpowname+" ill-defined for string"); }
    else if ( a.isValSet()    ) { constructError(a,b,res,strpowname+" ill-defined for set"   ); }
    else if ( a.isValDict()   ) { constructError(a,b,res,strpowname+" ill-defined for dict"  ); }
    else if ( a.isValDgraph() ) { constructError(a,b,res,strpowname+" ill-defined for dgraph"); }
    else if ( a.isValVector() ) { constructError(a,b,res,strpowname+" ill-defined for vector"); }
    else if ( b.isValStrErr() ) { constructError(a,b,res,strpowname+" ill-defined for string exponent"); }
    else if ( b.isValMatrix() ) { constructError(a,b,res,strpowname+" ill-defined for matrix exponent"); }
    else if ( b.isValVector() ) { constructError(a,b,res,strpowname+" ill-defined for vector exponent"); }

    else if ( a.isValMatrix() )
    {
	if ( !( b.isCastableToIntegerWithoutLoss() ) )
	{
            constructError(a,b,res,strpowname+" ill-defined for matrices raised to non-integer exponents");
	}

	else
	{
	    int bint = b.cast_int(0);
	    int absbint = ( bint < 0 ) ? -bint : bint;
	    int i;

	    if ( !bint )
	    {
		Matrix<gentype> thisisanemptymatrixifyouhadntguessedthatalreadyyousillymanyouwhatonearthwereyouthinkingyoureallyneedtochangematrixhtotreatemptymatrixlikeunitmatrix;

                res = thisisanemptymatrixifyouhadntguessedthatalreadyyousillymanyouwhatonearthwereyouthinkingyoureallyneedtochangematrixhtotreatemptymatrixlikeunitmatrix;
	    }

	    else
	    {
		for ( i = 0 ; i < absbint ; ++i )
		{
		    if ( !i )
		    {
			res = a;
		    }

		    else
		    {
			res *= a;
		    }
		}

		if ( bint < 0 )
		{
		    res = inv(res);
		}
	    }
	}
    }

    else
    {
        if ( a.isCastableToIntegerWithoutLoss() && b.isCastableToIntegerWithoutLoss() )
	{
            int aa = a.cast_int(0);
            int bb = b.cast_int(0);

            int bbmag = ( bb >= 0 ) ? bb : -bb;
            int bbsgn = ( bb >= 0 ) ? 1 : -1;

            if ( bbmag == 0 )
            {
                res = 1; // includes 0^0 = 1
            }

            else if ( aa == 0 )
            {
                res = 0; // don't waste time calculating!
            }

            else
            {
                bool intgood = true;

                int i;
                int ires = 1;

                for ( i = 0 ; i < bbmag ; ++i )
                {
                    int vala = ires;

                    ires *= aa;

                    if ( ( vala != 0 ) && ( ires/vala != vala ) )
                    {
                        intgood = false;
                        break;
                    }
                }

                if ( intgood )
                {
                    res = ires;
                }

                else
                {
                    double dres = 1;

                    for ( i = 0 ; i < bbmag ; ++i )
                    {
                        dres *= aa;
                    }

                    res = dres;
                }

                if ( bbsgn == -1 )
                {
                    res = inv(res);
                }
            }

	    //int bint = b.cast_int(0);
	    //int absbint = ( bint < 0 ) ? -bint : bint;
	    //int i;
            //
	    //res = 1;
            //
	    //for ( i = 0 ; i < absbint ; ++i )
	    //{
	    //    res *= a;
	    //}
            //
	    //if ( bint < 0 )
	    //{
            //    res = inv(res);
	    //}
	}

        else if ( a.isValReal() && b.isCastableToIntegerWithoutLoss() )
	{
            double aa = a.cast_double(0);
            int bb = b.cast_int(0);

            int bbmag = ( bb >= 0 ) ? bb : -bb;
            int bbsgn = ( bb >= 0 ) ? 1 : -1;

            if ( bbmag == 0 )
            {
                res = 1; // includes 0^0 = 1
            }

            else if ( aa == 0 )
            {
                res = 0; // don't waste time calculating!
            }

            else
            {
                int i;
                double dres = 1;

                for ( i = 0 ; i < bbmag ; ++i )
                {
                    dres *= aa;
                }

                res = dres;

                if ( bbsgn == -1 )
                {
                    res = inv(res);
                }
            }

	    //int bint = b.cast_int(0);
	    //int absbint = ( bint < 0 ) ? -bint : bint;
	    //int i;
            //
	    //res = 1;
            //
	    //for ( i = 0 ; i < absbint ; ++i )
	    //{
	    //    res *= a;
	    //}
            //
	    //if ( bint < 0 )
	    //{
            //    res = inv(res);
	    //}
	}

	else if ( a.isValAnion() || b.isValAnion() )
	{
            res = anionpow(a.cast_anion(0),b.cast_anion(0));
	}

        else if ( ( a.cast_double(0) < 0 ) || ( b.cast_double(0) < 0 ) )
        {
            // negative fractional powers involved, result will be an anion

            res = anionpow(a.cast_anion(0), b.cast_anion(0));
        }

        else
        {
            res = pow(a.cast_double(0), b.cast_double(0));
        }
    }

    return res;
}

gentype nthrtintern(const gentype &a, const gentype &b);
gentype nthrtintern(const gentype &a, const gentype &b)
{
    gentype res;

    if ( a.isValEqnDir() || b.isValEqnDir() )
    {
	if ( b.isCastableToIntegerWithoutLoss() && ( b.cast_int(0) == 1 ) )
	{
            res = a;
	}

	else
	{
            const static gentype resx("nthrt(x,y)");

            return resx(a,b);
	}

	return res;
    }

    else if ( ( a.isValReal() || a.isCastableToIntegerWithoutLoss() ) && b.isCastableToIntegerWithoutLoss() && ( ( a.cast_double(0) >= 0 ) || ( (b.cast_int(0))%2 ) ) )
    {
        double aa = a.cast_double(0);
        int bb = b.cast_int(0);

        res = nthrt(aa,bb);
    }

    else
    {
        res = pow(a,inv(b));
    }

    return res;
}

gentype Nthrtintern(const gentype &a, const gentype &b);
gentype Nthrtintern(const gentype &a, const gentype &b)
{
    gentype res;

    if ( a.isValEqnDir() || b.isValEqnDir() )
    {
	if ( b.isCastableToIntegerWithoutLoss() && ( b.cast_int(0) == 1 ) )
	{
            res = a;
	}

	else
	{
            const static gentype resx("Nthrt(x,y)");

            return resx(a,b);
	}

	return res;
    }

    else if ( ( a.isValReal() || a.isCastableToIntegerWithoutLoss() ) && b.isCastableToIntegerWithoutLoss() && ( ( a.cast_double(0) >= 0 ) || ( (b.cast_int(0))%2 ) ) )
    {
        double aa = a.cast_double(0);
        int bb = b.cast_int(0);

        res = nthrt(aa,bb);
    }

    else
    {
        res = Pow(a,inv(b));
    }

    return res;
}

gentype powintern (const gentype &a, const gentype &b);
gentype Powintern (const gentype &a, const gentype &b);
gentype powlintern(const gentype &a, const gentype &b);
gentype Powlintern(const gentype &a, const gentype &b);
gentype powrintern(const gentype &a, const gentype &b);
gentype Powrintern(const gentype &a, const gentype &b);

gentype powintern (const gentype &a, const gentype &b) { return genpowintern(a,b,"pow", pow);  }
gentype Powintern (const gentype &a, const gentype &b) { return genpowintern(a,b,"Pow", Pow);  }
gentype powlintern(const gentype &a, const gentype &b) { return genpowintern(a,b,"powl",powl); }
gentype Powlintern(const gentype &a, const gentype &b) { return genpowintern(a,b,"Powl",Powl); }
gentype powrintern(const gentype &a, const gentype &b) { return genpowintern(a,b,"powr",powr); }
gentype Powrintern(const gentype &a, const gentype &b) { return genpowintern(a,b,"Powr",Powr); }

gentype ifthenelse(const gentype &a, const gentype &b, const gentype &c)
{
    gentype res;

    if ( a.isValEqnDir() )
    {
	if ( b == c )
	{
            res = b;
	}

	else
	{
            const static gentype resx("ifthenelse(x,y,z)");

            return resx(a,b,c);
	}

	return res;
    }

    if ( a.isValMatrix() )
    {
	if ( b.isValMatrix() && c.isValMatrix() )
	{
	    if ( ( a.numRows() != b.numRows() ) || ( a.numRows() != c.numRows() ) || ( a.numCols() != b.numCols() ) || ( a.numCols() != c.numCols() ) )
	    {
		constructError(a,b,c,res,"matrix dimensions must agree in ifthenelse elementwise matrix form");
	    }

	    else if ( a.numRows() && a.numCols() )
	    {
		int i,j;

		Matrix<gentype> tempres(a.numRows(),a.numCols());
		Matrix<gentype> tempa(a.cast_matrix(0));
                Matrix<gentype> tempb(b.cast_matrix(0));
                Matrix<gentype> tempc(c.cast_matrix(0));

		for ( i = 0 ; i < a.numRows() ; ++i )
		{
		    for ( j = 0 ; j < a.numCols() ; ++j )
		    {
			tempres("&",i,j) = ifthenelse(tempa(i,j),tempb(i,j),tempc(i,j));
		    }
		}

                res = tempres;
	    }

	    else
	    {
                res = a;
	    }
	}

	else
	{
	    if ( a.numRows() && a.numCols() )
	    {
		int i,j;

                Matrix<gentype> tempres(a.numRows(),a.numCols());
		Matrix<gentype> tempa(a.cast_matrix(0));

		for ( i = 0 ; i < a.numRows() ; ++i )
		{
		    for ( j = 0 ; j < a.numCols() ; ++j )
		    {
			tempres("&",i,j) = ifthenelse(tempa(i,j),b,c);
		    }
		}

                res = tempres;
	    }

	    else
	    {
                res = a;
	    }
	}
    }

    else if ( a.isValVector() )
    {
	if ( b.isValVector() && c.isValVector() )
	{
	    if ( ( a.size() != b.size() ) || ( a.size() != c.size() ) )
	    {
		constructError(a,b,c,res,"vector dimensions must agree in ifthenelse elementwise vector form");
	    }

	    else if ( a.size() )
	    {
		int i;

		Vector<gentype> tempres(a.size());
                Vector<gentype> tempa(a.cast_vector(0));
                Vector<gentype> tempb(b.cast_vector(0));
                Vector<gentype> tempc(c.cast_vector(0));

		for ( i = 0 ; i < a.size() ; ++i )
		{
		    tempres("&",i) = ifthenelse(tempa(i),tempb(i),tempc(i));
		}

                res = tempres;
	    }

	    else
	    {
                res = a;
	    }
	}

	else
	{
	    if ( a.size() )
	    {
		int i;

                Vector<gentype> tempres(a.size());
                Vector<gentype> tempa(a.cast_vector(0));

		for ( i = 0 ; i < a.size() ; ++i )
		{
		    tempres("&",i) = ifthenelse(tempa(i),b,c);
		}

                res = tempres;
	    }

	    else
	    {
                res = a;
	    }
	}
    }

    else if ( !a.isCastableToIntegerWithoutLoss() )
    {
	constructError(a,b,c,res,"ifthenelse requires integer (bool) first argument");
    }

    else
    {
	res = a.cast_int(0) ? b : c;
    }

    return res;
}












// Basic typing functions
//
// Design decision: if it looks like a duck and quacks like a duck...
//
// Ints are also real and anion
// Reals are also anions (and may be ints)
// Anions may be ints and/or reals

gentype &OP_isnull(gentype &x)
{
    if ( x.isValEqnDir() )
    {
        const static gentype res("isnull(x)");
        x = res(x);
    }

    else
    {
        x = x.isCastableToNullWithoutLoss();
    }

    return x;
}

gentype &OP_isint(gentype &x)
{
    if ( x.isValEqnDir() )
    {
        const static gentype res("isint(x)");
        x = res(x);
    }

    else
    {
        x = x.isCastableToIntegerWithoutLoss();
    }

    return x;
}

gentype &OP_isreal(gentype &x)
{
    if ( x.isValEqnDir() )
    {
        const static gentype res("isreal(x)");
        x   = res(x);
    }

    else
    {
        x = x.isCastableToRealWithoutLoss();
    }

    return x;
}

gentype &OP_isanion(gentype &x)
{
    if ( x.isValEqnDir() )
    {
        const static gentype res("isanion(x)");
        x   = res(x);
    }

    else
    {
        x = x.isCastableToAnionWithoutLoss();
    }

    return x;
}

gentype &OP_isvector(gentype &x)
{
    if ( x.isValEqnDir() )
    {
        const static gentype res("isvector(x)");
        x   = res(x);
    }

    else
    {
        x = x.isValVector();
    }

    return x;
}

gentype &OP_ismatrix(gentype &x)
{
    if ( x.isValEqnDir() )
    {
        const static gentype res("ismatrix(x)");
        x   = res(x);
    }

    else
    {
        x = x.isValMatrix();
    }

    return x;
}

gentype &OP_isset(gentype &x)
{
    if ( x.isValEqnDir() )
    {
        const static gentype res("isset(x)");
        x   = res(x);
    }

    else
    {
        x = x.isValSet();
    }

    return x;
}

gentype &OP_isdict(gentype &x)
{
    if ( x.isValEqnDir() )
    {
        const static gentype res("isdict(x)");
        x   = res(x);
    }

    else
    {
        x = x.isValDict();
    }

    return x;
}

gentype &OP_isdgraph(gentype &x)
{
    if ( x.isValEqnDir() )
    {
        const static gentype res("isdgraph(x)");
        x   = res(x);
    }

    else
    {
        x = x.isValDgraph();
    }

    return x;
}

gentype &OP_isstring(gentype &x)
{
    if ( x.isValEqnDir() )
    {
        const static gentype res("isstring(x)");
        x   = res(x);
    }

    else
    {
        x = x.isValStrErr();
    }

    return x;
}

gentype &OP_iserror(gentype &x)
{
    if ( x.isValEqnDir() )
    {
        const static gentype res("iserror(x)");
        x   = res(x);
    }

    else
    {
        x = x.isValError();
    }

    return x;
}

gentype &OP_isvnan(gentype &x)
{
    if ( x.isValEqnDir() )
    {
        const static gentype res("isvnan(x)");
        x = res(x);
    }

    else
    {
        x = testisvnan(x);
    }

    return x;
}

gentype &OP_isinf(gentype &x)
{
    if ( x.isValEqnDir() )
    {
        const static gentype res("isinf(x)");
        x = res(x);
    }

    else
    {
        x = testisinf(x);
    }

    return x;
}

gentype &OP_ispinf(gentype &x)
{
    if ( x.isValEqnDir() )
    {
        const static gentype res("ispinf(x)");
        x = res(x);
    }

    else
    {
        x = testispinf(x);
    }

    return x;
}

gentype &OP_isninf(gentype &x)
{
    if ( x.isValEqnDir() )
    {
        const static gentype res("isninf(x)");
        x = res(x);
    }

    else
    {
        x = testisninf(x);
    }

    return x;
}

gentype &OP_size(gentype &a)
{
    if ( a.isValEqnDir() )
    {
        const static gentype res("size(x)");
        a   = res(a);
    }

    else
    {
        a = a.size();
    }

    return a;
}

gentype &OP_numRows(gentype &a)
{
    if ( a.isValEqnDir() )
    {
        const static gentype res("numRows(x)");
        a   = res(a);
    }

    else
    {
        a = a.numRows();
    }

    return a;
}

gentype &OP_numCols(gentype &a)
{
    if ( a.isValEqnDir() )
    {
        const static gentype res("numCols(x)");
        a   = res(a);
    }

    else
    {
        a = a.numCols();
    }

    return a;
}








// Basic anion and vector and construction

gentype eps_comm(const gentype &n, const gentype &q, const gentype &r, const gentype &s)
{
    gentype res;

    if ( n.isValEqnDir() || q.isValEqnDir() || r.isValEqnDir() || s.isValEqnDir() )
    {
        const static gentype resx("eps_comm(x,y,z,v)");
        return resx(n,q,r,s);
    }

         if ( !n.isCastableToIntegerWithoutLoss()      ) { constructError(n,q,r,s,res,"eps_comm must have integer arguments"); }
    else if ( !q.isCastableToIntegerWithoutLoss()      ) { constructError(n,q,r,s,res,"eps_comm must have integer arguments"); }
    else if ( !r.isCastableToIntegerWithoutLoss()      ) { constructError(n,q,r,s,res,"eps_comm must have integer arguments"); }
    else if ( !s.isCastableToIntegerWithoutLoss()      ) { constructError(n,q,r,s,res,"eps_comm must have integer arguments"); }
    else if ( n.cast_int(0) < 0                        ) { constructError(n,q,r,s,res,"eps_comm must have n >= 0");            }
    else if ( q.cast_int(0) < 0                        ) { constructError(n,q,r,s,res,"eps_comm must have q >= 0");            }
    else if ( r.cast_int(0) < 0                        ) { constructError(n,q,r,s,res,"eps_comm must have r >= 0");            }
    else if ( s.cast_int(0) < 0                        ) { constructError(n,q,r,s,res,"eps_comm must have s >= 0");            }
    else if ( q.cast_int(0) > pow(2.0,n.cast_int(0))-1 ) { constructError(n,q,r,s,res,"eps_comm must have q < 2^n-1");         }
    else if ( r.cast_int(0) > pow(2.0,n.cast_int(0))-1 ) { constructError(n,q,r,s,res,"eps_comm must have r < 2^n-1");         }
    else if ( s.cast_int(0) > pow(2.0,n.cast_int(0))-1 ) { constructError(n,q,r,s,res,"eps_comm must have s < 2^n-1");         }

    else
    {
	int nn = n.cast_int(0);
	int qq = q.cast_int(0);
	int rr = r.cast_int(0);
	int ss = s.cast_int(0);

	if ( !qq || !rr || !ss )
	{
            res = 0;
	}

	else
	{
	    res = epsilon(nn,qq-1,rr-1,ss-1);
	}
    }

    return res;
}

gentype eps_assoc(const gentype &n, const gentype &q, const gentype &r, const gentype &s, const gentype &t)
{
    gentype res;

    if ( n.isValEqnDir() || q.isValEqnDir() || r.isValEqnDir() || s.isValEqnDir() || t.isValEqnDir() )
    {
        const static gentype resx("eps_assoc(x,y,z,v,w)");
        return resx(n,q,r,s,t);
    }

         if ( !n.isCastableToIntegerWithoutLoss()             ) { constructError(n,q,r,s,res,"eps_assoc must have integer arguments"); }
    else if ( !q.isCastableToIntegerWithoutLoss()             ) { constructError(n,q,r,s,res,"eps_assoc must have integer arguments"); }
    else if ( !r.isCastableToIntegerWithoutLoss()             ) { constructError(n,q,r,s,res,"eps_assoc must have integer arguments"); }
    else if ( !s.isCastableToIntegerWithoutLoss()             ) { constructError(n,q,r,s,res,"eps_assoc must have integer arguments"); }
    else if ( !t.isCastableToIntegerWithoutLoss()             ) { constructError(n,q,r,s,res,"eps_assoc must have integer arguments"); }
    else if ( n.cast_int(0) < 0                                ) { constructError(n,q,r,s,res,"eps_assoc must have n >= 0");           }
    else if ( q.cast_int(0) < 0                                ) { constructError(n,q,r,s,res,"eps_assoc must have q >= 0");           }
    else if ( r.cast_int(0) < 0                                ) { constructError(n,q,r,s,res,"eps_assoc must have r >= 0");           }
    else if ( s.cast_int(0) < 0                                ) { constructError(n,q,r,s,res,"eps_assoc must have s >= 0");           }
    else if ( t.cast_int(0) < 0                                ) { constructError(n,q,r,s,res,"eps_assoc must have t >= 0");           }
    else if ( q.cast_int(0) > pow(2.0,(double) n.cast_int(0))-1 ) { constructError(n,q,r,s,res,"eps_assoc must have q < 2^n-1");       }
    else if ( r.cast_int(0) > pow(2.0,(double) n.cast_int(0))-1 ) { constructError(n,q,r,s,res,"eps_assoc must have r < 2^n-1");       }
    else if ( s.cast_int(0) > pow(2.0,(double) n.cast_int(0))-1 ) { constructError(n,q,r,s,res,"eps_assoc must have s < 2^n-1");       }
    else if ( t.cast_int(0) > pow(2.0,(double) n.cast_int(0))-1 ) { constructError(n,q,r,s,res,"eps_assoc must have t < 2^n-1");       }

    else
    {
	int nn = n.cast_int(0);
	int qq = q.cast_int(0);
	int rr = r.cast_int(0);
	int ss = s.cast_int(0);
	int tt = t.cast_int(0);

	if ( !qq || !rr || !ss || !tt )
	{
            res = 0;
	}

	else
	{
	    res = epsilon(nn,qq-1,rr-1,ss-1,tt=1);
	}
    }

    return res;
}

gentype im_complex(const gentype &x)
{
    gentype res;

    if ( x.isValEqnDir() )
    {
        const static gentype resx("im_quat(x)");
        return resx(x);
    }

         if ( !x.isCastableToIntegerWithoutLoss() ) { constructError(x,res,"im_complex must have integer arguments"); }
    else if ( x.cast_int(0) < 0                    ) { constructError(x,res,"im_complex argument must be 0 or 1");    }
    else if ( x.cast_int(0) > 1                    ) { constructError(x,res,"im_complex argument must be 0 or 1");    }
    else
    {
	d_anion tres(1);
        tres("&",x.cast_int(0)) = 1.0;
        res = tres;
    }

    return res;
}

gentype im_quat(const gentype &x)
{
    gentype res;

    if ( x.isValEqnDir() )
    {
        const static gentype resx("im_quat(x)");
        return resx(x);
    }

         if ( !x.isCastableToIntegerWithoutLoss() ) { constructError(x,res,"im_quat must have integer arguments"); }
    else if ( x.cast_int(0) < 0                   ) { constructError(x,res,"im_quat argument must be 0,1,2,3");    }
    else if ( x.cast_int(0) > 3                   ) { constructError(x,res,"im_quat argument must be 0,1,2,3");    }
    else
    {
	d_anion tres(2);
        tres("&",x.cast_int(0)) = 1.0;
        res = tres;
    }

    return res;
}

gentype im_octo(const gentype &x)
{
    gentype res;

    if ( x.isValEqnDir() )
    {
        const static gentype resx("im_octo(x)");
        return resx(x);
    }

         if ( !x.isCastableToIntegerWithoutLoss() ) { constructError(x,res,"im_octo must have integer arguments");      }
    else if ( x.cast_int(0) < 0                   ) { constructError(x,res,"im_octo argument must be 0,1,2,3,4,5,6,7"); }
    else if ( x.cast_int(0) > 7                   ) { constructError(x,res,"im_octo argument must be 0,1,2,3,4,5,6,7"); }
    else
    {
	d_anion tres(3);
        tres("&",x.cast_int(0)) = 1.0;
	res = tres;
    }

    return res;
}

gentype im_anion(const gentype &x, const gentype &y)
{
    gentype res;

    if ( x.isValEqnDir() || y.isValEqnDir() )
    {
        const static gentype resx("im_anion(x,y)");
        return resx(x,y);
    }

         if ( !y.isCastableToIntegerWithoutLoss()               ) { constructError(x,y,res,"im_anion must have integer arguments");    }
    else if ( !x.isCastableToIntegerWithoutLoss()               ) { constructError(x,y,res,"im_anion must have integer arguments");    }
    else if ( y.cast_int(0) < 0                                 ) { constructError(x,y,res,"im_anion argument must be 0,1,...,2^n-1"); }
    else if ( y.cast_int(0) > pow(2.0,(double) x.cast_int(0))-1 ) { constructError(x,y,res,"im_anion argument must be 0,1,...,2^n-1"); }
    else
    {
	d_anion tres(x.cast_int(0));
        tres("&",y.cast_int(0)) = 1.0;
        res = tres;
   }

    return res;
}

gentype Im_complex(const gentype &x)
{
    gentype res;

    if ( x.isValEqnDir() )
    {
        const static gentype resx("im_quat(x)");
        return resx(x);
    }

         if ( !x.isCastableToIntegerWithoutLoss() ) { constructError(x,res,"im_complex must have integer arguments"); }
    else if ( x.cast_int(0) < 0                   ) { constructError(x,res,"im_complex argument must be 0 or 1");     }
    else if ( x.cast_int(0) > 1                   ) { constructError(x,res,"im_complex argument must be 0 or 1");     }
    else
    {
	d_anion tres(1);
        tres("&",x.cast_int(0)) = x.cast_int(0) ? -1.0 : 1.0;
        res = tres;
    }

    return res;
}

gentype Im_quat(const gentype &x)
{
    gentype res;

    if ( x.isValEqnDir() )
    {
        const static gentype resx("im_quat(x)");
        return resx(x);
    }

         if ( !x.isCastableToIntegerWithoutLoss() ) { constructError(x,res,"im_quat must have integer arguments"); }
    else if ( x.cast_int(0) < 0                   ) { constructError(x,res,"im_quat argument must be 0,1,2,3");    }
    else if ( x.cast_int(0) > 3                   ) { constructError(x,res,"im_quat argument must be 0,1,2,3");    }
    else
    {
	d_anion tres(2);
        tres("&",x.cast_int(0)) = x.cast_int(0) ? -1.0 : 1.0;
        res = tres;
    }

    return res;
}

gentype Im_octo(const gentype &x)
{
    gentype res;

    if ( x.isValEqnDir() )
    {
        const static gentype resx("im_octo(x)");
        return resx(x);
    }

         if ( !x.isCastableToIntegerWithoutLoss() ) { constructError(x,res,"im_octo must have integer arguments");      }
    else if ( x.cast_int(0) < 0                   ) { constructError(x,res,"im_octo argument must be 0,1,2,3,4,5,6,7"); }
    else if ( x.cast_int(0) > 7                   ) { constructError(x,res,"im_octo argument must be 0,1,2,3,4,5,6,7"); }
    else
    {
	d_anion tres(3);
        tres("&",x.cast_int(0)) = x.cast_int(0) ? -1.0 : 1.0;
	res = tres;
    }

    return res;
}

gentype Im_anion(const gentype &x, const gentype &y)
{
    gentype res;

    if ( x.isValEqnDir() || y.isValEqnDir() )
    {
        const static gentype resx("im_anion(x,y)");
        return resx(x,y);
    }

         if ( !y.isCastableToIntegerWithoutLoss()               ) { constructError(x,y,res,"im_anion must have integer arguments");    }
    else if ( !x.isCastableToIntegerWithoutLoss()               ) { constructError(x,y,res,"im_anion must have integer arguments");    }
    else if ( y.cast_int(0) < 0                                 ) { constructError(x,y,res,"im_anion argument must be 0,1,...,2^n-1"); }
    else if ( y.cast_int(0) > pow(2.0,(double) x.cast_int(0))-1 ) { constructError(x,y,res,"im_anion argument must be 0,1,...,2^n-1"); }
    else
    {
	d_anion tres(x.cast_int(0));
        tres("&",x.cast_int(0)) = x.cast_int(0) ? -1.0 : 1.0;
        res = tres;
   }

    return res;
}


gentype vect_const(const gentype &x, const gentype &y)
{
    gentype res;

    if ( x.isValEqnDir() )
    {
        const static gentype resx("vect_const(x,y)");
        return resx(x,y);
    }

         if ( !x.isCastableToIntegerWithoutLoss() ) { constructError(x,y,res,"vect_const must have integer vector size"); }
    else if ( x.cast_int(0) < 0                   ) { constructError(x,y,res,"vect_const must have non-negative size");   }
    else
    {
	Vector<gentype> tres(x.cast_int(0));
	tres = y;
        res = tres;
    }

    return res;
}

gentype vect_unit(const gentype &x, const gentype &y)
{
    gentype res;

    if ( x.isValEqnDir() || y.isValEqnDir() )
    {
        const static gentype resx("vect_unit(x,y)");
        return resx(x,y);
    }

         if ( !x.isCastableToIntegerWithoutLoss()   ) { constructError(x,y,res,"vect_unit must have integer arguments");           }
    else if ( !y.isCastableToIntegerWithoutLoss()   ) { constructError(x,y,res,"vect_unit must have integer arguments");           }
    else if ( x.cast_int(0) < 0                     ) { constructError(x,y,res,"vect_unit must have non-negative size");           }
    else if ( y.cast_int(0) < 0                     ) { constructError(x,y,res,"vect_unit must have non-negative index");          }
    else if ( y.cast_int(0) >= x.cast_int(0)        ) { constructError(x,y,res,"vect_unit must have index less than vector size"); }
    else
    {
	Vector<gentype> tres(x.cast_int(0));
	tres = 0_gent;
        tres("&",y.cast_int(0)) = 1;
        res = tres;
    }

    return res;
}


gentype ivect(const gentype &x, const gentype &y, const gentype &z)
{
    gentype res;

    if ( x.isValEqnDir() || y.isValEqnDir() || z.isValEqnDir() )
    {
        const static gentype resx("ivect(x,y,z)");
        return resx(x,y,z);
    }

    if ( !(x.isCastableToRealWithoutLoss()) || !(y.isCastableToRealWithoutLoss()) || !(z.isCastableToRealWithoutLoss()) )
    {
        constructError(x,y,z,res,"ivect arguments must be ordered scalars.");

        return res;
    }

    if ( x.isCastableToIntegerWithoutLoss() && y.isCastableToIntegerWithoutLoss() && z.isCastableToIntegerWithoutLoss() )
    {
        int xx = x.cast_int(0);
        int yy = y.cast_int(0);
        int zz = z.cast_int(0);

        Vector<gentype> vres;

        while ( xx <= zz )
        {
            vres.add(vres.size());

            vres("&",vres.size()-1) = xx;

            xx += yy;
        }

        res = vres;
    }

    else
    {
        double xx = x.cast_double(0);
        double yy = y.cast_double(0);
        double zz = z.cast_double(0);

        Vector<gentype> vres;

        while ( xx <= zz )
        {
            vres.add(vres.size());

            vres("&",vres.size()-1) = xx;

            xx += yy;
        }

        res = vres;
    }

    return res;
}

gentype cayleyDickson(const gentype &x, const gentype &y)
{
    gentype res;

    if ( x.isValEqnDir() || y.isValEqnDir() )
    {
        const static gentype resx("cayleyDickson(x,y)");
        return resx(x,y);
    }

	 if ( x.isValStrErr() || y.isValStrErr() ) { constructError(x,y,res,"CayleyDickson not defined for strings.");    }
    else if ( x.isValMatrix() || y.isValMatrix() ) { constructError(x,y,res,"CayleyDickson not defined for matrices.");   }
    else if ( x.isValVector() || y.isValVector() ) { constructError(x,y,res,"CayleyDickson not defined for vectors.");    }
    else if ( x.isValSet()    || y.isValSet()    ) { constructError(x,y,res,"CayleyDickson not defined for sets.");       }
    else if ( x.isValDict()   || y.isValDict()   ) { constructError(x,y,res,"CayleyDickson not defined for dictionary."); }
    else if ( x.isValDgraph() || y.isValDgraph() ) { constructError(x,y,res,"CayleyDickson not defined for dgraphs.");    }
    else                                           { d_anion temp(x.cast_anion(0),y.cast_anion(0)); res = temp;           }

    return res;
}

gentype rmul(const gentype &x, const gentype &y)
{
    if ( x.isValEqnDir() || y.isValEqnDir() )
    {
        const static gentype resx("rmul(x,y)");
        return resx(x,y);
    }

    gentype res(x);

    return res.rightmult(y);
}

gentype CayleyDickson(const gentype &x, const gentype &y)
{
    gentype res;

    if ( x.isValEqnDir() || y.isValEqnDir() )
    {
        const static gentype resx("CayleyDickson(x,y)");
        return resx(x,y);
    }

	 if ( x.isValStrErr() || y.isValStrErr() ) { constructError(x,y,res,"CayleyDickson not defined for strings.");  }
    else if ( x.isValMatrix() || y.isValMatrix() ) { constructError(x,y,res,"CayleyDickson not defined for matrices."); }
    else if ( x.isValVector() || y.isValVector() ) { constructError(x,y,res,"CayleyDickson not defined for vectors.");  }
    else if ( x.isValSet()    || y.isValSet()    ) { constructError(x,y,res,"CayleyDickson not defined for sets.");     }
    else if ( x.isValDict()   || y.isValDict()   ) { constructError(x,y,res,"CayleyDickson not defined for dict.");     }
    else if ( x.isValDgraph() || y.isValDgraph() ) { constructError(x,y,res,"CayleyDickson not defined for dgraphs.");  }
    else                                           { d_anion temp(conj(x.cast_anion(0)),-y.cast_anion(0)); res = temp;  }

    return res;
}





gentype eye(const gentype &i, const gentype &j)
{
    gentype res;

    if ( i.isValEqn() || j.isValEqn() )
    {
        const static gentype resx("eye(x,y)");
        return resx(i,j);
    }

    if ( i.isCastableToIntegerWithoutLoss() && j.isCastableToIntegerWithoutLoss() && ( (int) i >= 0 ) && ( (int) j >= 0 ) )
    {
        res.force_matrix((int) i, (int) j);

        res.dir_matrix() = 0.0_gent; //zerogentype();

        int ii;
        int ij = ( ( (int) i ) < ( (int) j ) ) ? ( (int) i ) : ( (int) j );

        for ( ii = 0 ; ii < ij ; ++ii )
        {
//            res.dir_matrix()("&",ii,ii) = onedblgentype();
            res.dir_matrix()("&",ii,ii) = 1.0_gent;
        }
    }

    else
    {
        constructError(i,j,res,"eye size must be non-negative integers");
    }

    return res;
}









// Permutations, combinations and other integer stuff

gentype kronDelta(const gentype &i, const gentype &j)
{
    gentype res;

    if ( i.isValEqn() || j.isValEqn() )
    {
        const static gentype resx("kronDelta(x,y)");
        return resx(i,j);
    }

    return eq(i,j);
}

gentype diracDelta(const gentype &x)
{
    gentype res;

    if ( x.isValEqn() )
    {
        const static gentype resx("diracDelta(x)");
        return resx(x);
    }

//    return ifthenelse(eq(x,zerointgentype()),pinf(),res);
    return ifthenelse(eq(x,0_gent),pinf(),res);
}

gentype ekronDelta(const gentype &i, const gentype &j)
{
    gentype res;

    if ( i.isValEqnDir() || j.isValEqnDir() )
    {
        const static gentype resx("ekronDelta(x,y)");
        return resx(i,j);
    }

    return eeq(i,j);
}

gentype ediracDelta(const gentype &x)
{
    gentype res;

    if ( x.isValEqnDir() )
    {
        const static gentype resx("ediracDelta(x)");
        return resx(x);
    }

//    return ifthenelse(eeq(x,zerointgentype()),pinf(),res);
    return ifthenelse(eeq(x,0_gent),pinf(),res);
}

gentype perm(const gentype &i, const gentype &j)
{
    gentype res;

    if ( i.isValEqnDir() || j.isValEqnDir() )
    {
        const static gentype resx("perm(x,y)");
        return resx(i,j);
    }

    if ( !i.isCastableToIntegerWithoutLoss() || !j.isCastableToIntegerWithoutLoss() )
    {
	if ( i.isValMatrix() )
	{
	    if ( j.isValMatrix() )
	    {
		if ( ( i.numRows() != j.numRows() ) || ( i.numCols() != j.numCols() ) )
		{
		    constructError(i,j,res,"matrix dimensions must agree in perm elementwise matrix form");
		}

		else if ( i.numRows() && i.numCols() )
		{
		    int ii,jj;

		    Matrix<gentype> tempres(i.numRows(),i.numCols());
		    Matrix<gentype> tempi(i.cast_matrix(0));
		    Matrix<gentype> tempj(j.cast_matrix(0));

		    for ( ii = 0 ; ii < i.numRows() ; ++ii )
		    {
			for ( jj = 0 ; jj < i.numCols() ; ++jj )
			{
			    tempres("&",ii,jj) = perm(tempi(ii,jj),tempj(ii,jj));
			}
		    }

		    res = tempres;
		}

		else
		{
		    res = i;
		}
	    }

	    else
	    {
		if ( i.numRows() && i.numCols() )
		{
		    int ii,jj;

		    Matrix<gentype> tempres(i.numRows(),i.numCols());
		    Matrix<gentype> tempi(i.cast_matrix(0));

		    for ( ii = 0 ; ii < i.numRows() ; ++ii )
		    {
			for ( jj = 0 ; jj < i.numCols() ; ++jj )
			{
			    tempres("&",ii,jj) = perm(tempi(ii,jj),j);
			}
		    }

		    res = tempres;
		}

		else
		{
		    res = i;
		}
	    }
	}

	else if ( i.isValVector() )
	{
	    if ( j.isValVector() )
	    {
		if ( i.size() != j.size() )
		{
		    constructError(i,j,res,"vector dimensions must agree in perm elementwise vector form");
		}

		else if ( i.size() )
		{
		    int ii;

		    Vector<gentype> tempres(i.size());
		    Vector<gentype> tempi(i.cast_vector(0));
		    Vector<gentype> tempj(j.cast_vector(0));

		    for ( ii = 0 ; ii < i.size() ; ++ii )
		    {
			tempres("&",ii) = perm(tempi(ii),tempj(ii));
		    }

		    res = tempres;
		}

		else
		{
		    res = i;
		}
	    }

	    else
	    {
		if ( i.size() )
		{
		    int ii;

		    Vector<gentype> tempres(i.size());
		    Vector<gentype> tempi(i.cast_vector(0));

		    for ( ii = 0 ; ii < i.size() ; ++ii )
		    {
			tempres("&",ii) = perm(tempi(ii),j);
		    }

		    res = tempres;
		}

		else
		{
		    res = i;
		}
	    }
	}

	else
	{
	    constructError(i,j,res,"perm only defined for integers");
	}
    }

    else
    {
        // Need to allow for possible overflow

	int ii = i.cast_int(0);
	int jj = j.cast_int(0);
	int kk;
        int ires;
        double dres;
        bool haveoverflow = false;

	if ( ( ii >= 0 ) && ( jj >= 0 ) && ( ii >= jj ) )
	{
	    ires = 1;
	    dres = 1;

	    if ( ii > jj )
	    {
		for ( kk = jj+1 ; kk <= ii ; ++kk )
		{
                    //result *= kk;
                    dres *= kk;

                    int vala = ires;
                    int valb = kk;
                    int resa = vala*valb;

                    if ( haveoverflow || ( ( vala != 0 ) && ( resa/vala != valb ) ) )
                    {
                        haveoverflow = true;
                    }

                    else
                    {
                        ires = resa;
                    }
		}
	    }

            if ( haveoverflow )
            {
                res = dres;
            }

            else
            {
                res = ires;
            }
	}

	else
	{
            constructError(i,j,res,"perm assumes i >= j >= 0");
	}
    }

    return res;
}

gentype comb(const gentype &i, const gentype &j)
{
    gentype res;

    if ( i.isValEqnDir() || j.isValEqnDir() )
    {
        const static gentype resx("comb(x,y)");
        return resx(i,j);
    }

    if ( !i.isCastableToIntegerWithoutLoss() || !j.isCastableToIntegerWithoutLoss() )
    {
	if ( i.isValMatrix() )
	{
	    if ( j.isValMatrix() )
	    {
		if ( ( i.numRows() != j.numRows() ) || ( i.numCols() != j.numCols() ) )
		{
		    constructError(i,j,res,"matrix dimensions must agree in comb elementwise matrix form");
		}

		else if ( i.numRows() && i.numCols() )
		{
		    int ii,jj;

		    Matrix<gentype> tempres(i.numRows(),i.numCols());
		    Matrix<gentype> tempi(i.cast_matrix(0));
		    Matrix<gentype> tempj(j.cast_matrix(0));

		    for ( ii = 0 ; ii < i.numRows() ; ++ii )
		    {
			for ( jj = 0 ; jj < i.numCols() ; ++jj )
			{
			    tempres("&",ii,jj) = comb(tempi(ii,jj),tempj(ii,jj));
			}
		    }

		    res = tempres;
		}

		else
		{
		    res = i;
		}
	    }

	    else
	    {
		if ( i.numRows() && i.numCols() )
		{
		    int ii,jj;

		    Matrix<gentype> tempres(i.numRows(),i.numCols());
		    Matrix<gentype> tempi(i.cast_matrix(0));

		    for ( ii = 0 ; ii < i.numRows() ; ++ii )
		    {
			for ( jj = 0 ; jj < i.numCols() ; ++jj )
			{
			    tempres("&",ii,jj) = comb(tempi(ii,jj),j);
			}
		    }

		    res = tempres;
		}

		else
		{
		    res = i;
		}
	    }
	}

	else if ( i.isValVector() )
	{
	    if ( j.isValVector() )
	    {
		if ( i.size() != j.size() )
		{
		    constructError(i,j,res,"vector dimensions must agree in comb elementwise vector form");
		}

		else if ( i.size() )
		{
		    int ii;

		    Vector<gentype> tempres(i.size());
		    Vector<gentype> tempi(i.cast_vector(0));
		    Vector<gentype> tempj(j.cast_vector(0));

		    for ( ii = 0 ; ii < i.size() ; ++ii )
		    {
			tempres("&",ii) = comb(tempi(ii),tempj(ii));
		    }

		    res = tempres;
		}

		else
		{
		    res = i;
		}
	    }

	    else
	    {
		if ( i.size() )
		{
		    int ii;

		    Vector<gentype> tempres(i.size());
		    Vector<gentype> tempi(i.cast_vector(0));

		    for ( ii = 0 ; ii < i.size() ; ++ii )
		    {
			tempres("&",ii) = comb(tempi(ii),j);
		    }

		    res = tempres;
		}

		else
		{
		    res = i;
		}
	    }
	}

	else
	{
	    constructError(i,j,res,"comb only defined for integers");
	}
    }

    else
    {
        // Need to allow for possible overflow

	int n = i.cast_int(0);
	int r = j.cast_int(0);

	if ( ( n >= 0 ) && ( r >= 0 ) && ( n >= r ) )
	{
            //res = xnCr(n,r);

            int ires = 1;
            double dres = 1;
            bool haveoverflow = false;

            if ( ( r > 0 ) && ( n != r ) )
            {
                // Want r as large as possible

                if ( r > n/2 )
                {
                    r = n-r;
                }

                int kk;

                for ( kk = 1 ; kk <= r ; ++kk )
                {
                    //ires *= (n-r+kk);
                    //ires /= kk;

                    dres *= (n-r+kk)/kk;

                    int vala = ires;
                    int valb = n-r+kk;
                    int resa = vala*valb;

                    if ( haveoverflow || ( ( vala != 0 ) && ( resa/vala != valb ) ) )
                    {
                        haveoverflow = true;
                    }

                    else
                    {
                        ires = resa;
                        ires /= kk;
                    }
                }
            }

            if ( haveoverflow )
            {
                res = dres;
            }

            else
            {
                res = ires;
            }
	}

	else
	{
	    constructError(i,j,res,"comb assumes n >= r >= 0");
	}
    }

    return res;
}

gentype fact(const gentype &i)
{
    gentype res;

    if ( i.isValEqnDir() )
    {
        const static gentype resx("fact(x)");
        return resx(i);
    }

    if ( i.isValMatrix() )
    {
        Matrix<gentype> temp(i.cast_matrix(0));
        temp.applyon(fact);
        res = temp;
    }

    else if ( i.isValVector() )
    {
        Vector<gentype> temp(i.cast_vector(0));
        temp.applyon(fact);
        res = temp;
    }

    else if ( !i.isCastableToIntegerWithoutLoss() )
    {
//        res = gamma(add(i,oneintgentype()));
        res = gamma(add(i,1_gent));
    }

    else if ( i.cast_int(0) < 0 )
    {
//        res = gamma(add(i,oneintgentype()));
        res = gamma(add(i,1_gent));
    }

    else if ( i.cast_int(0) > MAXINTFACT )
    {
//        res = gamma(add(i,oneintgentype()));
        res = gamma(add(i,1_gent));
    }

    else
    {
        res = xnfact(i.cast_int(0));
    }

    return res;
}

gentype dfact(const gentype &i)
{
    gentype res;

    if ( i.isValEqnDir() )
    {
        const static gentype resx("dfact(x)");
        return resx(i);
    }

    if ( i.isValMatrix() )
    {
        Matrix<gentype> temp(i.cast_matrix(0));
        temp.applyon(dfact);
        res = temp;
    }

    else if ( i.isValVector() )
    {
        Vector<gentype> temp(i.cast_vector(0));
        temp.applyon(dfact);
        res = temp;
    }

    else if ( !i.isCastableToIntegerWithoutLoss() || ( i.cast_int(0) < 0 ) || ( i.cast_int(0) > MAXINTFACT ) )
    {
        gentype q = cos(mul(pi(),i));

        res = mul(mul(pow(2_gent,div(add(1_gent,sub(mul(2_gent,i),q)),4_gent)),pow(pi(),div(sub(q,1_gent),4_gent))),gamma(add(1_gent,div(i,2_gent))));
//        res = mul(mul(pow(2_gent,div(add(oneintgentype(),sub(mul(2_gent,i),q)),4_gent)),pow(pi(),div(sub(q,oneintgentype()),4_gent))),gamma(add(oneintgentype(),div(i,2_gent))));
////        res = (2^((oneintgentype()+(2*i)-cos(pi()*i))/4))*(pi()^((cos(pi()*i)-oneintgentype())/4))*gamma(oneintgentype()+(i/2))
    }

    else
    {
        res = xnmultifact(i.cast_int(0),2);
    }

    return res;
}

gentype tfact(const gentype &i)
{
    gentype res;

    if ( i.isValEqnDir() )
    {
        const static gentype resx("tfact(x)");
        return resx(i);
    }

    if ( i.isValMatrix() )
    {
        Matrix<gentype> temp(i.cast_matrix(0));
        temp.applyon(tfact);
        res = temp;
    }

    else if ( i.isValVector() )
    {
        Vector<gentype> temp(i.cast_vector(0));
        temp.applyon(tfact);
        res = temp;
    }

    else if ( !i.isCastableToIntegerWithoutLoss() || ( i.cast_int(0) < 0 ) || ( i.cast_int(0) > MAXINTFACT ) )
    {
        res = div(mul(pow(3.0_gent,div(sub(i,1.0_gent),3.0_gent)),gamma(add(div(i,3.0_gent),1.0_gent))),gamma(add(div(i,3.0_gent),1.0_gent)));
    }

    else
    {
        res = xnmultifact(i.cast_int(0),3);
    }

    return res;
}

gentype sf(const gentype &i)
{
    gentype res;

    if ( i.isValEqnDir() )
    {
        const static gentype resx("sf(x)");
        return resx(i);
    }

    if ( i.isValMatrix() )
    {
        Matrix<gentype> temp(i.cast_matrix(0));
        temp.applyon(sf);
        res = temp;
    }

    else if ( i.isValVector() )
    {
        Vector<gentype> temp(i.cast_vector(0));
        temp.applyon(sf);
        res = temp;
    }

    else if ( !i.isCastableToIntegerWithoutLoss() )
    {
        res.makeError("sf not defined for non-integers");
    }

    else if ( i.cast_int(0) <= 0 )
    {
        res.force_int() = 1;
    }

    else
    {
        res.dir_int() = 1;

        int k;
        int ii = i.cast_int(0);

        for ( k = 0 ; k <= ii ; ++k )
        {
            gentype kk(k);

            res *= fact(kk);
        }
    }

    return res;
}

gentype psf(const gentype &i)
{
    gentype res;

    if ( i.isValEqnDir() )
    {
        const static gentype resx("psf(x)");
        return resx(i);
    }

    if ( i.isValMatrix() )
    {
        Matrix<gentype> temp(i.cast_matrix(0));
        temp.applyon(psf);
        res = temp;
    }

    else if ( i.isValVector() )
    {
        Vector<gentype> temp(i.cast_vector(0));
        temp.applyon(psf);
        res = temp;
    }

    else if ( !i.isCastableToIntegerWithoutLoss() )
    {
        res.makeError("psf not defined for non-integers");
    }

    else
    {
        int k;
        gentype ibang((double) fact(i));
        gentype tmpg;
        int ii = i.cast_int(0);

        res = ibang;

        for ( k = 1 ; k < ii ; ++k )
        {
            res = pow(ibang,res);
        }

        res = div(res,ibang);
    }

    return res;
}

gentype dubmultifact(const gentype &i, const void *m);
gentype dubmultifact(const gentype &i, const void *m)
{
    return multifact(i,*((const gentype *) m));
}

gentype multifact(const gentype &i, const gentype &m)
{
    gentype res;

    if ( i.isValEqnDir() || m.isValEqnDir() )
    {
        const static gentype resx("multifact(x,y)");
        return resx(i,m);
    }

         if ( i.isValStrErr()                     ) { constructError(i,m,res,"multifact not defined for strings."); }
    else if ( i.isValDgraph()                     ) { constructError(i,m,res,"multifact not defined for dgraphs."); }
    else if ( i.isValAnion()                      ) { constructError(i,m,res,"multifact not defined for anions.");  }
    else if ( i.isValSet()                        ) { Set<gentype>              temp(i.cast_set(0));    temp.applyon(dubmultifact,(void *) &m); res = temp; }
    else if ( i.isValDict()                       ) { Dict<gentype,dictkey>     temp(i.cast_dict(0));   temp.applyon(dubmultifact,(void *) &m); res = temp; }
    else if ( i.isValMatrix()                     ) { Matrix<gentype>           temp(i.cast_matrix(0)); temp.applyon(dubmultifact,(void *) &m); res = temp; }
    else if ( i.isValVector()                     ) { Vector<gentype>           temp(i.cast_vector(0)); temp.applyon(dubmultifact,(void *) &m); res = temp; }
    //else if ( !i.isCastableToIntegerWithoutLoss() ) { constructError(i,m,res,"multifact not defined for non-integers."); }
    //else if ( !m.isCastableToIntegerWithoutLoss() ) { constructError(i,m,res,"multifact not defined for non-integer m."); }

    else if ( !i.isCastableToIntegerWithoutLoss() || !m.isCastableToIntegerWithoutLoss() || ( i.cast_int(0) < 0 ) || ( i.cast_int(0) > MAXINTFACT ) )
    {
        res = div(mul(pow(m,div(sub(i,1.0_gent),m)),gamma(add(div(i,m),1.0_gent))),gamma(add(div(i,m),1.0_gent)));
    }

    else
    {
        res.force_double() = xnmultifact(i.cast_int(0),m.cast_int(0));
    }

    return res;
}

gentype subfact(const gentype &i)
{
    gentype res;
//    const static gentype onegone(-1);

    if ( i.isValEqnDir() )
    {
        const static gentype resx("subfact(x)");
        return resx(i);
    }

    if ( i.isValMatrix() )
    {
        Matrix<gentype> temp(i.cast_matrix(0));
        temp.applyon(subfact);
        res = temp;
    }

    else if ( i.isValVector() )
    {
        Vector<gentype> temp(i.cast_vector(0));
        temp.applyon(subfact);
        res = temp;
    }

    else if ( !i.isCastableToIntegerWithoutLoss() )
    {
        res = gami(-1_gent,add(i,1_gent));
//        res = gami(negone,add(i,oneintgentype()));
        res /= NUMBASE_E;
    }

    else if ( i.cast_int(0) < 0 )
    {
        res = gami(-1_gent,add(i,1_gent));
//        res = gami(negone,add(i,oneintgentype()));
        res /= NUMBASE_E;
    }

    else if ( i.cast_int(0) == 0 )
    {
        res = 1;
    }

    else if ( i.cast_int(0) == 1 )
    {
        res = 0;
    }

    else if ( i.cast_int(0) > MAXINTFACT )
    {
        res = gami(-1_gent,add(i,1_gent));
//        res = gami(negone,add(i,oneintgentype()));
        res /= NUMBASE_E;
    }

    else
    {
        res = (int) floor((((double) xnfact(i.cast_int(0)))+1)/NUMBASE_E);
    }

    return res;
}










// Given a vector of functions - eg:
//
// [ x y ]
//
// we can't just use the standard vectorial norm as we
// can't cast x to double!  So instead we need the following.

gentype abs1vec  (const Vector<gentype> &a);
gentype abs2vec  (const Vector<gentype> &a);
gentype abspvec  (const Vector<gentype> &a, double p);
gentype absinfvec(const Vector<gentype> &a);
gentype abs0vec  (const Vector<gentype> &a);

gentype norm1vec(const Vector<gentype> &a);
gentype norm2vec(const Vector<gentype> &a);
gentype normpvec(const Vector<gentype> &a, double p);

gentype abs1mat  (const Vector<gentype> &a);
gentype abs2mat  (const Vector<gentype> &a);
gentype abspmat  (const Vector<gentype> &a, double p);
gentype absinfmat(const Vector<gentype> &a);
gentype abs0mat  (const Vector<gentype> &a);

gentype norm1mat(const Vector<gentype> &a);
gentype norm2mat(const Vector<gentype> &a);
gentype normpmat(const Vector<gentype> &a, double p);

gentype abs1vec(const Vector<gentype> &a)
{
    int i;
    gentype result;

    if ( a.infsize() )
    {
        result = norm1(a);
    }

    else if ( a.size() )
    {
	result = norm1(a(0));

	//if ( a.size() > 1 )
	{
	    for ( i = 1 ; i < a.size() ; ++i )
	    {
		result += norm1(a(i));
	    }
	}
    }

    return result;
}

gentype abs2vec(const Vector<gentype> &a)
{
    int i;
    gentype result;

    if ( a.infsize() )
    {
        result = norm2(a);
    }

    else if ( a.size() )
    {
	result = norm2(a(0));

	//if ( a.size() > 1 )
	{
	    for ( i = 1 ; i < a.size() ; ++i )
	    {
		result += norm2(a(i));
	    }
	}
    }

    return sqrt(result);
}

gentype abspvec(const Vector<gentype> &a, double p)
{
    int i;
    gentype result;

    if ( a.infsize() )
    {
        result = normp(a,p);
    }

    else if ( a.size() )
    {
	result = normp(a(0),p);

	//if ( a.size() > 1 )
	{
	    for ( i = 1 ; i < a.size() ; ++i )
	    {
		result += normp(a(i),p);
	    }
	}
    }

    gentype invp(1/p);

    return pow(result,invp);
}

gentype absinfvec(const Vector<gentype> &a)
{
    int i;
    gentype result(a);
    gentype temp;
    double dres = 0.0;
    double dtemp = 0.0;

    if ( a.infsize() )
    {
        result = absinf(a);
    }

    else if ( a.size() )
    {
        for ( i = 0 ; i < a.size() ; ++i )
        {
            temp = absinf(a(i));

            if ( temp.isValEqn() )
            {
                return result;
            }

            dtemp = (double) temp;

            dres = ( !i || ( dtemp > dres ) ) ? dtemp : dres;
	}

        result = dres;
    }

    else
    {
        result = dres;
    }

    return result;
}

gentype abs0vec(const Vector<gentype> &a)
{
    int i;
    gentype result(a);
    gentype temp;
    double dres = 0.0;
    double dtemp = 0.0;

    if ( a.infsize() )
    {
        result = abs0(a);
    }

    else if ( a.size() )
    {
        for ( i = 0 ; i < a.size() ; ++i )
        {
            temp = abs0(a(i));

            if ( temp.isValEqn() )
            {
                return result;
            }

            dtemp = (double) temp;

            dres = ( !i || ( dtemp < dres ) ) ? dtemp : dres;
	}

        result = dres;
    }

    else
    {
        result = dres;
    }

    return result;
}

gentype norm1vec(const Vector<gentype> &a)
{
    int i;
    gentype result;

    if ( a.infsize() )
    {
        result = norm1(a);
    }

    else if ( a.size() )
    {
	result = norm1(a(0));

	//if ( a.size() > 1 )
	{
	    for ( i = 1 ; i < a.size() ; ++i )
	    {
		result += norm1(a(i));
	    }
	}
    }

    return result;
}

gentype norm2vec(const Vector<gentype> &a)
{
    int i;
    gentype result;

    if ( a.infsize() )
    {
        result = norm2(a);
    }

    else if ( a.size() )
    {
	result = norm2(a(0));

	//if ( a.size() > 1 )
	{
	    for ( i = 1 ; i < a.size() ; ++i )
	    {
		result += norm2(a(i));
	    }
	}
    }

    return result;
}

gentype normpvec(const Vector<gentype> &a, double p)
{
    int i;
    gentype result;

    if ( a.infsize() )
    {
        result = normp(a,p);
    }

    else if ( a.size() )
    {
	result = normp(a(0),p);

	//if ( a.size() > 1 )
	{
	    for ( i = 1 ; i < a.size() ; ++i )
	    {
		result += normp(a(i),p);
	    }
	}
    }

    return result;
}






gentype abs1mat(const Matrix<gentype> &a)
{
    int i,j;
    gentype result;

    if ( a.numRows() && a.numCols() )
    {
	for ( i = 0 ; i < a.numRows() ; ++i )
	{
	    for ( j = 0 ; j < a.numCols() ; ++j )
	    {
		result += norm1(a(i,j));
	    }
	}
    }

    return result;
}

gentype abs2mat(const Matrix<gentype> &a)
{
    int i,j;
    gentype result;

    if ( a.numRows() && a.numCols() )
    {
	for ( i = 0 ; i < a.numRows() ; ++i )
	{
	    for ( j = 0 ; j < a.numCols() ; ++j )
	    {
		result += norm2(a(i,j));
	    }
	}
    }

    return sqrt(result);
}

gentype abspmat(const Matrix<gentype> &a, double p)
{
    int i,j;
    gentype result;

    if ( a.numRows() && a.numCols() )
    {
	for ( i = 0 ; i < a.numRows() ; ++i )
	{
	    for ( j = 0 ; j < a.numCols() ; ++j )
	    {
		result += normp(a(i,j),p);
	    }
	}
    }

    gentype invp(1/p);

    return pow(result,invp);
}

gentype absinfmat(const Matrix<gentype> &a)
{
    int i,j;
    gentype result(a);
    gentype temp;
    double dres = 0.0;
    double dtemp = 0.0;

    if ( a.numRows() && a.numCols() )
    {
	for ( i = 0 ; i < a.numRows() ; ++i )
	{
	    for ( j = 0 ; j < a.numCols() ; ++j )
	    {
		temp = absinf(a(i,j));

                if ( temp.isValEqn() )
                {
                    return result;
                }

                dtemp = (double) temp;

                dres = ( (!i && !j ) || ( dtemp > dres ) ) ? dtemp : dres;
	    }
	}
    }

    result = dres;

    return result;
}

gentype abs0mat(const Matrix<gentype> &a)
{
    int i,j;
    gentype result(a);
    gentype temp;
    double dres = 0.0;
    double dtemp = 0.0;

    if ( a.numRows() && a.numCols() )
    {
	for ( i = 0 ; i < a.numRows() ; ++i )
	{
	    for ( j = 0 ; j < a.numCols() ; ++j )
	    {
		temp = abs0(a(i,j));

                if ( temp.isValEqn() )
                {
                    return result;
                }

                dtemp = (double) temp;

                dres = ( ( !i && !j ) || ( dtemp < dres ) ) ? dtemp : dres;
	    }
	}
    }

    result = dres;

    return result;
}

gentype norm1mat(const Matrix<gentype> &a)
{
    int i,j;
    gentype result;

    if ( a.numRows() && a.numCols() )
    {
	for ( i = 0 ; i < a.numRows() ; ++i )
	{
	    for ( j = 0 ; j < a.numCols() ; ++j )
	    {
		result += norm1(a(i,j));
	    }
	}
    }

    return result;
}

gentype norm2mat(const Matrix<gentype> &a)
{
    int i,j;
    gentype result;

    if ( a.numRows() && a.numCols() )
    {
	for ( i = 0 ; i < a.numRows() ; ++i )
	{
	    for ( j = 0 ; j < a.numCols() ; ++j )
	    {
		result += norm2(a(i,j));
	    }
	}
    }

    return result;
}

gentype normpmat(const Matrix<gentype> &a, double p)
{
    int i,j;
    gentype result;

    if ( a.numRows() && a.numCols() )
    {
	for ( i = 0 ; i < a.numRows() ; ++i )
	{
	    for ( j = 0 ; j < a.numCols() ; ++j )
	    {
		result += normp(a(i,j),p);
	    }
	}
    }

    return result;
}



// Non-elementwise maths functions

gentype abs1(const gentype &a)
{
    gentype res;

    if ( a.scalarfn_isscalarfn() && !a.isValVector() )
    {
        return norm1(a);
    }

    else if ( a.isValEqnDir() )
    {
        const static gentype resx("abs1(x)");
        return resx(a);
    }

    else if ( a.isValStrErr()  ) { constructError(a,res,"String norm not implemented");    }
    else if ( a.isValDict()    ) { constructError(a,res,"Dictonary norm not implemented"); }
    else if ( a.isValSet()     ) { res = abs1(a.cast_set(0));                              }
    else if ( a.isValDgraph()  ) { res = abs1(a.cast_dgraph(0));                           }
    else if ( a.isValMatrix()  ) { res = abs1mat(a.cast_matrix(0));                        }
    else if ( a.isValVector()  ) { res = abs1vec(a.cast_vector(0));                        }
    else if ( a.isValAnion()   ) { res = abs1(a.cast_anion(0));                            }
    else if ( a.isValReal()    ) { res = abs1(a.cast_double(0));                           }
    else if ( a.isValInteger() ) { res = abs1(a.cast_int(0));                              }
    else                         { res = a;                                                }

    return res;
}

gentype abs2(const gentype &a)
{
    gentype res;

    if ( a.scalarfn_isscalarfn() && !a.isValVector() )
    {
        return sqrt(norm2(a));
    }

    else if ( a.isValEqnDir() )
    {
        const static gentype resx("abs2(x)");
        return resx(a);
    }

    else if ( a.isValStrErr()  ) { constructError(a,res,"String norm not implemented");    }
    else if ( a.isValDict()    ) { constructError(a,res,"Dictonary norm not implemented"); }
    else if ( a.isValSet()     ) { res = abs2(a.cast_set(0));                              }
    else if ( a.isValDgraph()  ) { res = abs2(a.cast_dgraph(0));                           }
    else if ( a.isValMatrix()  ) { res = abs2mat(a.cast_matrix(0));                        }
    else if ( a.isValVector()  ) { res = abs2vec(a.cast_vector(0));                        }
    else if ( a.isValAnion()   ) { res = abs2(a.cast_anion(0));                            }
    else if ( a.isValReal()    ) { res = abs2(a.cast_double(0));                           }
    else if ( a.isValInteger() ) { res = abs2(a.cast_int(0));                              }
    else                         { res = a;                                                }

    return res;
}

gentype absp(const gentype &a, const gentype &q)
{
    gentype res;

    if ( a.scalarfn_isscalarfn() && !a.isValVector() && q.isCastableToRealWithoutLoss() )
    {
        return pow(normp(a,q),inv(q));
    }

    else if ( a.isValEqnDir() || q.isValEqnDir() )
    {
        const static gentype resx("absp(x,y)");
        return resx(a,q);
    }

    else if ( !q.isCastableToRealWithoutLoss() )
    {
        constructError(a,q,res,"p must be real or integer for p-norm");
    }

    else if ( a.isValStrErr()  ) { constructError(a,q,res,"String norm not implemented");    }
    else if ( a.isValDict()    ) { constructError(a,q,res,"Dictonary norm not implemented"); }
    else if ( a.isValSet()     ) { res = absp(a.cast_set(0),q.cast_double(0));               }
    else if ( a.isValDgraph()  ) { res = absp(a.cast_dgraph(0),q.cast_double(0));            }
    else if ( a.isValMatrix()  ) { res = abspmat(a.cast_matrix(0),q.cast_double(0));         }
    else if ( a.isValVector()  ) { res = abspvec(a.cast_vector(0),q.cast_double(0));         }
    else if ( a.isValAnion()   ) { res = absp(a.cast_anion(0),q.cast_double(0));             }
    else if ( a.isValReal()    ) { res = absp(a.cast_double(0),q.cast_double(0));            }
    else if ( a.isValInteger() ) { res = absp(a.cast_int(0),q.cast_double(0));               }
    else                         { res = a;                                                  }

    return res;
}

gentype absinf(const gentype &a)
{
    gentype res;

    if ( a.scalarfn_isscalarfn() && ( a.scalarfn_i().size() == 0 ) )
    {
        NiceAssert( a.scalarfn_i().size() == a.scalarfn_j().size() );

        res.zero();
        res.scalarfn_setisscalarfn(0);

        return res;
    }

    else if ( a.scalarfn_isscalarfn() && ( a.scalarfn_i().size() == 1 ) )
    {
        NiceAssert( a.scalarfn_i().size() == a.scalarfn_j().size() );

        int numpts = a.scalarfn_numpts();

        int i;

        res.zero();

        SparseVector<SparseVector<gentype> > xa;

        double temp = 0;
        double restemp = 0;

        for ( i = 0 ; i < numpts ; ++i )
        {
            xa("&",a.scalarfn_i()(0))("&",a.scalarfn_j()(0)) = (((double) i)+0.5)/((double) numpts);

            if ( ( temp = (double) norm1(a(xa)) ) > restemp )
            {
                restemp = temp;
            }
        }

        res = restemp;
        res.scalarfn_setisscalarfn(0);

        return res;
    }

    else if ( a.scalarfn_isscalarfn() )
    {
        NiceAssert( a.scalarfn_i().size() == a.scalarfn_j().size() );

        int numvar = a.scalarfn_i().size();
        int numpts = a.scalarfn_numpts();
        int numtot = (int) pow(numpts,numvar);

        int i,j;
        Vector<int> k(numvar);

        k = 0;

        res.zero();

        SparseVector<SparseVector<gentype> > xa;

        double temp = 0;
        double restemp = 0;

        for ( i = 0 ; i < numtot ; ++i )
        {
            for ( j = 0 ; j < numvar ; ++j )
            {
                xa("&",a.scalarfn_i()(j))("&",a.scalarfn_j()(j)) = (((double) k(j))+0.5)/((double) numpts);
            }

            if ( ( temp = (double) abs1(a(xa)) ) > restemp )
            {
                restemp = temp;
            }

            for ( j = 0 ; j < numvar ; ++j )
            {
                ++(k("&",j));

                if ( k(j) >= numpts )
                {
                    k("&",j) = 0;
                }

                else
                {
                    break;
                }
            }
        }

        res = restemp;
        res.scalarfn_setisscalarfn(0);

        return res;
    }

    else if ( a.isValEqnDir() )
    {
        const static gentype resx("absinf(x)");
        return resx(a);
    }

    else if ( a.isValStrErr()  ) { constructError(a,res,"String norm not implemented");    }
    else if ( a.isValDict()    ) { constructError(a,res,"Dictonary norm not implemented"); }
    else if ( a.isValMatrix()  ) { res = absinfmat(a.cast_matrix(0));                      }
    else if ( a.isValSet()     ) { res = absinf(a.cast_set(0));                            }
    else if ( a.isValDgraph()  ) { res = absinf(a.cast_dgraph(0));                         }
    else if ( a.isValVector()  ) { res = absinfvec(a.cast_vector(0));                      }
    else if ( a.isValAnion()   ) { res = absinf(a.cast_anion(0));                          }
    else if ( a.isValReal()    ) { res = absinf(a.cast_double(0));                         }
    else if ( a.isValInteger() ) { res = absinf(a.cast_int(0));                            }
    else                         { res = a;                                                }

    return res;
}

gentype abs0(const gentype &a)
{
    gentype res;

    if ( a.scalarfn_isscalarfn() && ( a.scalarfn_i().size() == 0 ) )
    {
        NiceAssert( a.scalarfn_i().size() == a.scalarfn_j().size() );

        res.zero();
        res.scalarfn_setisscalarfn(0);

        return res;
    }

    else if ( a.scalarfn_isscalarfn() && ( a.scalarfn_i().size() == 1 ) )
    {
        NiceAssert( a.scalarfn_i().size() == a.scalarfn_j().size() );

        int numpts = a.scalarfn_numpts();

        int i;

        res.zero();

        SparseVector<SparseVector<gentype> > xa;

        double temp = 0;
        double restemp = 0;

        for ( i = 0 ; i < numpts ; ++i )
        {
            xa("&",a.scalarfn_i()(0))("&",a.scalarfn_j()(0)) = (((double) i)+0.5)/((double) numpts);

            if ( !i || ( ( temp = (double) norm1(a(xa)) ) < restemp ) )
            {
                restemp = temp;
            }
        }

        res = restemp;
        res.scalarfn_setisscalarfn(0);

        return res;
    }

    else if ( a.scalarfn_isscalarfn() )
    {
        NiceAssert( a.scalarfn_i().size() == a.scalarfn_j().size() );

        int numvar = a.scalarfn_i().size();
        int numpts = a.scalarfn_numpts();
        int numtot = (int) pow(numpts,numvar);

        int i,j;
        Vector<int> k(numvar);

        k = 0;

        res.zero();

        SparseVector<SparseVector<gentype> > xa;

        double temp = 0;
        double restemp = 0;

        for ( i = 0 ; i < numtot ; ++i )
        {
            for ( j = 0 ; j < numvar ; ++j )
            {
                xa("&",a.scalarfn_i()(j))("&",a.scalarfn_j()(j)) = (((double) k(j))+0.5)/((double) numpts);
            }

            if ( !i || ( ( temp = (double) abs1(a(xa)) ) < restemp ) )
            {
                restemp = temp;
            }

            for ( j = 0 ; j < numvar ; ++j )
            {
                ++(k("&",j));

                if ( k(j) >= numpts )
                {
                    k("&",j) = 0;
                }

                else
                {
                    break;
                }
            }
        }

        res = restemp;
        res.scalarfn_setisscalarfn(0);

        return res;
    }

    else if ( a.isValEqnDir() )
    {
        const static gentype resx("abs0(x)");
        return resx(a);
    }

    else if ( a.isValStrErr()  ) { constructError(a,res,"String norm not implemented");    }
    else if ( a.isValDict()    ) { constructError(a,res,"Dictonary norm not implemented"); }
    else if ( a.isValMatrix()  ) { res = abs0mat(a.cast_matrix(0));                        }
    else if ( a.isValSet()     ) { res = abs0(a.cast_set(0));                              }
    else if ( a.isValDgraph()  ) { res = abs0(a.cast_dgraph(0));                           }
    else if ( a.isValVector()  ) { res = abs0vec(a.cast_vector(0));                        }
    else if ( a.isValAnion()   ) { res = abs0(a.cast_anion(0));                            }
    else if ( a.isValReal()    ) { res = abs0(a.cast_double(0));                           }
    else if ( a.isValInteger() ) { res = abs0(a.cast_int(0));                              }
    else                         { res = a;                                                }

    return res;
}

gentype norm1(const gentype &a)
{
    gentype res;

    if ( a.scalarfn_isscalarfn() && ( a.scalarfn_i().size() == 0 ) )
    {
        NiceAssert( a.scalarfn_i().size() == a.scalarfn_j().size() );

        res.zero();
        res.scalarfn_setisscalarfn(0);

        return res;
    }

    else if ( a.scalarfn_isscalarfn() && ( a.scalarfn_i().size() == 1 ) )
    {
        NiceAssert( a.scalarfn_i().size() == a.scalarfn_j().size() );

        int numpts = a.scalarfn_numpts();

        int i;

        res.zero();

        SparseVector<SparseVector<gentype> > xa;

        gentype aa,bb;

        for ( i = 0 ; i < numpts ; ++i )
        {
            xa("&",a.scalarfn_i()(0))("&",a.scalarfn_j()(0)) = (((double) i)+0.5)/((double) numpts);

            aa = a(xa);
            aa.finalise();

            if ( aa.isValEqnDir() )
            {
                const static gentype resx("norm1(x)");
                bb = resx(aa);
            }

            else if ( aa.isValStrErr()  ) { constructError(aa,bb,"String norm not implemented");    }
            else if ( aa.isValDict()    ) { constructError(aa,bb,"Dictonary norm not implemented"); }
            else if ( aa.isValSet()     ) { bb = norm1(aa.cast_set(0));                             }
            else if ( aa.isValDgraph()  ) { bb = norm1(aa.cast_dgraph(0));                          }
            else if ( aa.isValMatrix()  ) { bb = norm2mat(aa.cast_matrix(0));                       }
            else if ( aa.isValVector()  ) { bb = norm1vec(aa.cast_vector(0));                       }
            else if ( aa.isValAnion()   ) { bb = norm1(aa.cast_anion(0));                           }
            else if ( aa.isValReal()    ) { bb = norm1(aa.cast_double(0));                          }
            else if ( aa.isValInteger() ) { bb = norm1(aa.cast_int(0));                             }
            else                          { bb = aa;                                                }

            bb /= ((double) numpts);

            res += bb;
        }

        res.scalarfn_setisscalarfn(0);

        return res;
    }

    else if ( a.scalarfn_isscalarfn() )
    {
        NiceAssert( a.scalarfn_i().size() == a.scalarfn_j().size() );

        int numvar = a.scalarfn_i().size();
        int numpts = a.scalarfn_numpts();
        int numtot = (int) pow(numpts,numvar);

        int i,j;
        Vector<int> k(numvar);

        k = 0;

        res.zero();

        SparseVector<SparseVector<gentype> > xa;

        gentype aa,bb;

        for ( i = 0 ; i < numtot ; ++i )
        {
            for ( j = 0 ; j < numvar ; ++j )
            {
                xa("&",a.scalarfn_i()(j))("&",a.scalarfn_j()(j)) = (((double) k(j))+0.5)/((double) numpts);
            }

            aa = a(xa);
            aa.finalise();

            if ( aa.isValEqnDir() )
            {
                const static gentype resx("norm1(x)");
                bb = resx(aa);
            }

            else if ( aa.isValStrErr()  ) { constructError(aa,bb,"String norm not implemented");    }
            else if ( aa.isValDict()    ) { constructError(aa,bb,"Dictonary norm not implemented"); }
            else if ( aa.isValSet()     ) { bb = norm1(aa.cast_set(0));                             }
            else if ( aa.isValDgraph()  ) { bb = norm1(aa.cast_dgraph(0));                          }
            else if ( aa.isValMatrix()  ) { bb = norm2mat(aa.cast_matrix(0));                       }
            else if ( aa.isValVector()  ) { bb = norm1vec(aa.cast_vector(0));                       }
            else if ( aa.isValAnion()   ) { bb = norm1(aa.cast_anion(0));                           }
            else if ( aa.isValReal()    ) { bb = norm1(aa.cast_double(0));                          }
            else if ( aa.isValInteger() ) { bb = norm1(aa.cast_int(0));                             }
            else                          { bb = aa;                                                }

            bb /= ((double) numtot);

            res += bb;

            for ( j = 0 ; j < numvar ; ++j )
            {
                ++(k("&",j));

                if ( k(j) >= numpts )
                {
                    k("&",j) = 0;
                }

                else
                {
                    break;
                }
            }
        }

        res.scalarfn_setisscalarfn(0);

        return res;
    }

    else if ( a.isValEqnDir() )
    {
        const static gentype resx("norm1(x)");
        return resx(a);
    }

    else if ( a.isValStrErr()  ) { constructError(a,res,"String norm not implemented");    }
    else if ( a.isValDict()    ) { constructError(a,res,"Dictonary norm not implemented"); }
    else if ( a.isValSet()     ) { res = norm1(a.cast_set(0));                             }
    else if ( a.isValDgraph()  ) { res = norm1(a.cast_dgraph(0));                          }
    else if ( a.isValMatrix()  ) { res = norm2mat(a.cast_matrix(0));                       }
    else if ( a.isValVector()  ) { res = norm1vec(a.cast_vector(0));                       }
    else if ( a.isValAnion()   ) { res = norm1(a.cast_anion(0));                           }
    else if ( a.isValReal()    ) { res = norm1(a.cast_double(0));                          }
    else if ( a.isValInteger() ) { res = norm1(a.cast_int(0));                             }
    else                         { res = a;                                                }

    // The integer case might overflow, but probably not unless we're very unlucky

    return res;
}

gentype norm2(const gentype &a)
{
    gentype res;

    if ( a.scalarfn_isscalarfn() && ( a.scalarfn_i().size() == 0 ) )
    {
        NiceAssert( a.scalarfn_i().size() == a.scalarfn_j().size() );

        res.zero();
        res.scalarfn_setisscalarfn(0);

        return res;
    }

    else if ( a.scalarfn_isscalarfn() && ( a.scalarfn_i().size() == 1 ) )
    {
//errstream() << "phantomxg 0\n";
        NiceAssert( a.scalarfn_i().size() == a.scalarfn_j().size() );

        int numpts = a.scalarfn_numpts();

//errstream() << "phantomxg 1: " << numpts << "\n";
        int i;

        res.zero();

        SparseVector<SparseVector<gentype> > xa;

        gentype aa,bb;

        for ( i = 0 ; i < numpts ; ++i )
        {
            xa("&",a.scalarfn_i()(0))("&",a.scalarfn_j()(0)) = (((double) i)+0.5)/((double) numpts);
//errstream() << "phantomxg 2(" << i << "): " << xa << "\n";

            aa = a(xa);
//errstream() << "phantomxg 3(" << i << "): " << aa << "\n";
            aa.finalise();
//errstream() << "phantomxg 4(" << i << "): " << aa << "\n";

            if ( aa.isValEqnDir() )
            {
                const static gentype resx("norm2(x)");
                bb = resx(aa);
            }

            else if ( aa.isValStrErr()  ) { constructError(aa,bb,"String norm not implemented");    }
            else if ( aa.isValDict()    ) { constructError(aa,bb,"Dictonary norm not implemented"); }
            else if ( aa.isValSet()     ) { bb = norm2(aa.cast_set(0));                             }
            else if ( aa.isValDgraph()  ) { bb = norm2(aa.cast_dgraph(0));                          }
            else if ( aa.isValMatrix()  ) { bb = norm2mat(aa.cast_matrix(0));                       }
            else if ( aa.isValVector()  ) { bb = norm2vec(aa.cast_vector(0));                       }
            else if ( aa.isValAnion()   ) { bb = norm2(aa.cast_anion(0));                           }
            else if ( aa.isValReal()    ) { bb = norm2(aa.cast_double(0));                          }
            else if ( aa.isValInteger() ) { bb = norm2(aa.cast_double(0));                          }
            else                          { bb = aa;                                                }

            bb /= ((double) numpts);
//errstream() << "phantomxg 5(" << i << "): " << bb << "\n";

            res += bb;
//errstream() << "phantomxg 6(" << i << "): " << res << "\n";
        }

//errstream() << "phantomxg 7: " << res << "\n";
        res.scalarfn_setisscalarfn(0);

        return res;
    }

    else if ( a.scalarfn_isscalarfn() )
    {
        NiceAssert( a.scalarfn_i().size() == a.scalarfn_j().size() );

        int numvar = a.scalarfn_i().size();
        int numpts = a.scalarfn_numpts();
        int numtot = (int) pow(numpts,numvar);

        int i,j;
        Vector<int> k(numvar);

        k = 0;

        res.zero();

        SparseVector<SparseVector<gentype> > xa;

        gentype aa,bb;

        for ( i = 0 ; i < numtot ; ++i )
        {
            for ( j = 0 ; j < numvar ; ++j )
            {
                xa("&",a.scalarfn_i()(j))("&",a.scalarfn_j()(j)) = (((double) k(j))+0.5)/((double) numpts);
            }

            aa = a(xa);
            aa.finalise();

            if ( aa.isValEqnDir() )
            {
                const static gentype resx("norm2(x)");
                bb = resx(aa);
            }

            else if ( aa.isValStrErr()  ) { constructError(aa,bb,"String norm2 not implemented");   }
            else if ( aa.isValDict()    ) { constructError(aa,bb,"Dictonary norm not implemented"); }
            else if ( aa.isValSet()     ) { bb = norm2(aa.cast_set(0));                             }
            else if ( aa.isValDgraph()  ) { bb = norm2(aa.cast_dgraph(0));                          }
            else if ( aa.isValMatrix()  ) { bb = norm2mat(aa.cast_matrix(0));                       }
            else if ( aa.isValVector()  ) { bb = norm2vec(aa.cast_vector(0));                       }
            else if ( aa.isValAnion()   ) { bb = norm2(aa.cast_anion(0));                           }
            else if ( aa.isValReal()    ) { bb = norm2(aa.cast_double(0));                          }
            else if ( aa.isValInteger() ) { bb = norm2(aa.cast_double(0));                          }
            else                          { bb = aa;                                                }

            bb /= ((double) numtot);

            res += bb;

            for ( j = 0 ; j < numvar ; ++j )
            {
                ++(k("&",j));

                if ( k(j) >= numpts )
                {
                    k("&",j) = 0;
                }

                else
                {
                    break;
                }
            }
        }

        res.scalarfn_setisscalarfn(0);

        return res;
    }

    else if ( a.isValEqnDir() )
    {
        const static gentype resx("norm2(x)");
        return resx(a);
    }

    else if ( a.isValStrErr()  ) { constructError(a,res,"String norm2 not implemented");   }
    else if ( a.isValDict()    ) { constructError(a,res,"Dictonary norm not implemented"); }
    else if ( a.isValSet()     ) { res = norm2(a.cast_set(0));                             }
    else if ( a.isValDgraph()  ) { res = norm2(a.cast_dgraph(0));                          }
    else if ( a.isValMatrix()  ) { res = norm2mat(a.cast_matrix(0));                       }
    else if ( a.isValVector()  ) { res = norm2vec(a.cast_vector(0));                       }
    else if ( a.isValAnion()   ) { res = norm2(a.cast_anion(0));                           }
    else if ( a.isValReal()    ) { res = norm2(a.cast_double(0));                          }
    else if ( a.isValInteger() ) { res = norm2(a.cast_double(0));                          }
    else                         { res = a;                                                }

    //else if ( a.isValInteger() ) { res = norm2(a.cast_double(0)); }

    return res;
}

gentype normp(const gentype &a, const gentype &q)
{
    gentype res;

    if ( a.scalarfn_isscalarfn() && ( a.scalarfn_i().size() == 0 ) && q.isCastableToRealWithoutLoss() )
    {
        NiceAssert( a.scalarfn_i().size() == a.scalarfn_j().size() );

        res.zero();
        res.scalarfn_setisscalarfn(0);

        return res;
    }

    else if ( a.scalarfn_isscalarfn() && ( a.scalarfn_i().size() == 1 ) && q.isCastableToRealWithoutLoss() )
    {
        NiceAssert( a.scalarfn_i().size() == a.scalarfn_j().size() );

        int numpts = a.scalarfn_numpts();

        int i;

        res.zero();

        SparseVector<SparseVector<gentype> > xa;

        gentype aa,bb;

        double p = q.cast_double(0);

        for ( i = 0 ; i < numpts ; ++i )
        {
            xa("&",a.scalarfn_i()(0))("&",a.scalarfn_j()(0)) = (((double) i)+0.5)/((double) numpts);

            aa = a(xa);
            aa.finalise();

            if ( aa.isValEqnDir() )
            {
                const static gentype resx("normp(x,q)");
                bb = resx(aa,q);
            }

            else if ( aa.isValStrErr()  ) { constructError(aa,bb,"String norm not implemented");    }
            else if ( aa.isValDict()    ) { constructError(aa,bb,"Dictonary norm not implemented"); }
            else if ( aa.isValSet()     ) { bb = normp(aa.cast_set(0),p);                           }
            else if ( aa.isValDgraph()  ) { bb = normp(aa.cast_dgraph(0),p);                        }
            else if ( aa.isValMatrix()  ) { bb = normpmat(aa.cast_matrix(0),p);                     }
            else if ( aa.isValVector()  ) { bb = normpvec(aa.cast_vector(0),p);                     }
            else if ( aa.isValAnion()   ) { bb = normp(aa.cast_anion(0),p);                         }
            else if ( aa.isValReal()    ) { bb = normp(aa.cast_double(0),p);                        }
            else if ( aa.isValInteger() ) { bb = normp((double) aa.cast_int(0),p);                  }
            else                          { bb = aa;                                                }

            bb /= ((double) numpts);

            res += bb;
        }

        res.scalarfn_setisscalarfn(0);

        return res;
    }

    else if ( a.scalarfn_isscalarfn() && q.isCastableToRealWithoutLoss() )
    {
        NiceAssert( a.scalarfn_i().size() == a.scalarfn_j().size() );

        int numvar = a.scalarfn_i().size();
        int numpts = a.scalarfn_numpts();
        int numtot = (int) pow(numpts,numvar);

        int i,j;
        Vector<int> k(numvar);

        k = 0;

        res.zero();

        SparseVector<SparseVector<gentype> > xa;

        gentype aa,bb;

        double p = q.cast_double(0);

        for ( i = 0 ; i < numtot ; ++i )
        {
            for ( j = 0 ; j < numvar ; ++j )
            {
                xa("&",a.scalarfn_i()(j))("&",a.scalarfn_j()(j)) = (((double) k(j))+0.5)/((double) numpts);
            }

            aa = a(xa);
            aa.finalise();

            if ( aa.isValEqnDir() )
            {
                const static gentype resx("normp(x,y)");
                bb = resx(aa,q);
            }

            else if ( aa.isValStrErr()  ) { constructError(aa,bb,"String norm not implemented");    }
            else if ( aa.isValDict()    ) { constructError(aa,bb,"Dictonary norm not implemented"); }
            else if ( aa.isValSet()     ) { bb = normp(aa.cast_set(0),p);                           }
            else if ( aa.isValDgraph()  ) { bb = normp(aa.cast_dgraph(0),p);                        }
            else if ( aa.isValMatrix()  ) { bb = normpmat(aa.cast_matrix(0),p);                     }
            else if ( aa.isValVector()  ) { bb = normpvec(aa.cast_vector(0),p);                     }
            else if ( aa.isValAnion()   ) { bb = normp(aa.cast_anion(0),p);                         }
            else if ( aa.isValReal()    ) { bb = normp(aa.cast_double(0),p);                        }
            else if ( aa.isValInteger() ) { bb = normp((double) aa.cast_int(0),p);                  }
            else                          { bb = aa;                                                }

            bb /= ((double) numtot);

            res += bb;

            for ( j = 0 ; j < numvar ; ++j )
            {
                ++(k("&",j));

                if ( k(j) >= numpts )
                {
                    k("&",j) = 0;
                }

                else
                {
                    break;
                }
            }
        }

        res.scalarfn_setisscalarfn(0);

        return res;
    }

    else if ( a.isValEqnDir() || q.isValEqnDir() )
    {
        const static gentype resx("normp(x,y)");
        return resx(a,q);
    }

    else if ( !q.isCastableToRealWithoutLoss() )
    {
        constructError(a,q,res,"p must be real or integer for p-norm");
    }

    else if ( a.isValStrErr()  ) { constructError(a,q,res,"String norm not implemented");    }
    else if ( a.isValDict()    ) { constructError(a,q,res,"Dictonary norm not implemented"); }
    else if ( a.isValSet()     ) { res = normp(a.cast_set(0),q.cast_double(0));              }
    else if ( a.isValDgraph()  ) { res = normp(a.cast_dgraph(0),q.cast_double(0));           }
    else if ( a.isValMatrix()  ) { res = normpmat(a.cast_matrix(0),q.cast_double(0));        }
    else if ( a.isValVector()  ) { res = normpvec(a.cast_vector(0),q.cast_double(0));        }
    else if ( a.isValAnion()   ) { res = normp(a.cast_anion(0),q.cast_double(0));            }
    else if ( a.isValReal()    ) { res = normp(a.cast_double(0),q.cast_double(0));           }
    else if ( a.isValInteger() ) { res = normp(a.cast_double(0),q.cast_double(0));           }
    else                         { res = a;                                                  }

    return res;
}

gentype angle(const gentype &a)
{
    gentype res;

    if ( a.isValEqnDir() )
    {
        const static gentype resx("angle(x)");
        return resx(a);
    }

         if ( a.isValStrErr()  ) { constructError(a,res,"angle ill-defined for string");  }
    else if ( a.isValDict()    ) { constructError(a,res,"angle ill-defined for dict");    }
    else if ( a.isValSet()     ) { constructError(a,res,"angle ill-defined for sets");    }
    else if ( a.isValDgraph()  ) { constructError(a,res,"angle ill-defined for dgraphs"); }
    else if ( a.isValMatrix()  ) { res = angle(a.cast_matrix(0));                         }
    else if ( a.isValVector()  ) { res = angle(a.cast_vector(0));                         }
    else if ( a.isValAnion()   ) { res = angle(a.cast_anion(0));                          }
    else if ( a.isValReal()    ) { res = angle(a.cast_double(0));                         }
    else if ( a.isValInteger() ) { res = angle(a.cast_int(0));                            }
    else                         { res = a;                                               }

    return res;
}

gentype inv(const gentype &a)
{
    gentype res;

    if ( a.isValEqnDir() )
    {
        const static gentype resx("inv(x)");
        return resx(a);
    }

    // NB: inv returns pseudo-inverse for non-square matrices

         if ( a.isValStrErr()  ) { constructError(a,res,"inv ill-defined for string");  }
    else if ( a.isValSet()     ) { constructError(a,res,"inv ill-defined for sets");    }
    else if ( a.isValDict()    ) { constructError(a,res,"inv ill-defined for dict");    }
    else if ( a.isValDgraph()  ) { constructError(a,res,"inv ill-defined for dgraphs"); }
    else if ( a.isValMatrix()  ) { res = inv(a.cast_matrix(0));                         }
    else if ( a.isValVector()  ) { constructError(a,res,"inv ill-defined for vector");  }
    else if ( a.isValAnion()   ) { res = inv(a.cast_anion(0));                          }
    else if ( a.isValReal()    ) { res = inv(a.cast_double(0));                         }
    else if ( a.isValInteger() ) { res = inv(a.cast_int(0));                            }
    else                         { res = a;                                             }

    return res;
}










// Various maths functions

gentype dubeabsp    (const gentype &a, const void *q);
gentype dubenormp   (const gentype &a, const void *q);
gentype dubpolyDistr(const gentype &a, const void *q);
gentype dubPolyDistr(const gentype &a, const void *q);

gentype dubeabsp    (const gentype &a, const void *q) { return eabsp    (a,*((const gentype *) q)); }
gentype dubenormp   (const gentype &a, const void *q) { return enormp   (a,*((const gentype *) q)); }
gentype dubpolyDistr(const gentype &a, const void *q) { return polyDistr(a,*((const gentype *) q)); }
gentype dubPolyDistr(const gentype &a, const void *q) { return PolyDistr(a,*((const gentype *) q)); }

double imagx(double x);
int imagx(int x);

double imagx(double) { return 0; }
int    imagx(int   ) { return 0; }

int sqrtOR    (double a);
int logOR     (double a);
int acashypOR (double a);
int acaschypOR(double a);
int log10OR   (double a);
int asinOR    (double a);
int acosOR    (double a);
int acastrgOR (double a);
int acasctrgOR(double a);
int acosecOR  (double a);
int asecOR    (double a);
int aversOR   (double a);
int acoversOR (double a);
int ahavOR    (double a);
int aexcosecOR(double a);
int aexsecOR  (double a);
int acoshOR   (double a);
int atanhOR   (double a);
int asechOR   (double a);
int acothOR   (double a);
int avershOR  (double a);
int ahavhOR   (double a);
int aexsechOR (double a);
int asigmOR   (double a);
int agdOR     (double a);

int sqrtOR    (double a) { return a <= 0;                                            }
int logOR     (double a) { return a <= 0;                                            }
int acashypOR (double a) { return a <= 0;                                            }
int acaschypOR(double a) { return a <= 0;                                            }
int log10OR   (double a) { return a <= 0;                                            }
int asinOR    (double a) { return ( a <  -1             ) || ( a >  1             ); }
int acosOR    (double a) { return ( a <  -1             ) || ( a >  1             ); }
int acastrgOR (double a) { return ( a <  -NUMBASE_SQRT2 ) || ( a >  NUMBASE_SQRT2 ); }
int acasctrgOR(double a) { return ( a <  -NUMBASE_SQRT2 ) || ( a >  NUMBASE_SQRT2 ); }
int acosecOR  (double a) { return ( a >  -1             ) && ( a <  1             ); } // acosec(x) = asin(1/x)
int asecOR    (double a) { return ( a >  -1             ) && ( a <  1             ); } // asec(x) = acos(1/x)
int aversOR   (double a) { return ( a <  -2             ) || ( a >  0             ); } // avers(x) = acos(1+x)
int acoversOR (double a) { return ( a <  -2             ) || ( a >  0             ); } // avers(x) = asin(1+x)
int ahavOR    (double a) { return ( a <  -1             ) || ( a >  0             ); } // ahav(x) = avers(2x)
int aexcosecOR(double a) { return ( a >  -2             ) && ( a <  0             ); } // aexcosec(x) = acosec(1+x)
int aexsecOR  (double a) { return ( a >  -2             ) && ( a <  0             ); } // aexsec(x) = asec(1+x)
int acoshOR   (double a) { return a < 1;                                             }
int atanhOR   (double a) { return ( a <  -1             ) || ( a >  1             ); }
int asechOR   (double a) { return ( a >  1              ) || ( a <  0             ); } // asech(x) = acosh(1/x)
int acothOR   (double a) { return ( a >  -1             ) && ( a <  1             ); } // acoth(x) = atanh(1/x)
int avershOR  (double a) { return a < 0;                                             } // aversh(x) = acosh(1+x)
int ahavhOR   (double a) { return a < 0;                                             } // ahavh(x) = aversh(2x)
int aexsechOR (double a) { return ( a >  0              ) || ( a <  -1            ); } // aexsechOR(x) = asech(1+x)
int asigmOR   (double a) { return ( a <= 0              ) || ( a >= 1             ); } // asigmOR(a) = log((1/a)-1)
int agdOR     (double a) { return ( a < -NUMBASE_PI/2   ) || ( a >  NUMBASE_PI/2  ); } // agdOR(a) = 2.atanh(tan(a/2))
























// Various elementwise maths functions that do not yet have complex/anionic implementations

gentype gamma(const gentype &a)
{
    gentype res;

    if ( a.isValEqnDir() )
    {
        const static gentype resx("gamma(x)");
        return resx(a);
    }

    // Design note: the double type has a much larger range than the
    // integer type, and gamma is liable to produce very large outputs.
    // For this reason we automatically promote integers to doubles when
    // calculating.  To avoid this, use fact(a-1) instead, or re-instate
    // the following line of code:
    //
    // else if ( a.isValInteger()) { res = fact(a-oneintgentype()); }

         if ( a.isValStrErr() ) { constructError(a,res,"gamma not defined for strings."); }
    else if ( a.isValDgraph() ) { constructError(a,res,"gamma not defined for dgraphs."); }
    else if ( a.isValAnion()  ) { constructError(a,res,"gamma not defined for anions.");  }
    else if ( a.isValSet()    ) { Set<gentype>          temp(a.cast_set(0));    temp.applyon(gamma); res = temp; }
    else if ( a.isValDict()   ) { Dict<gentype,dictkey> temp(a.cast_dict(0));   temp.applyon(gamma); res = temp; }
    else if ( a.isValMatrix() ) { Matrix<gentype>       temp(a.cast_matrix(0)); temp.applyon(gamma); res = temp; }
    else if ( a.isValVector() ) { Vector<gentype>       temp(a.cast_vector(0)); temp.applyon(gamma); res = temp; }

    else
    {
        res.force_double() = numbase_gamma(a.cast_double(0));
/*
        int ires = numbase_gamma(res.force_double(),a.cast_double(0));

        if ( ires )
	{
            constructError(a,res,"Error calculating gamma");
	}
*/
    }

    return res;
}

gentype lngamma(const gentype &a)
{
    gentype res;

    if ( a.isValEqnDir() )
    {
        const static gentype resx("lngamma(x)");
        return resx(a);
    }

         if ( a.isValStrErr() ) { constructError(a,res,"lngamma not defined for strings."); }
    else if ( a.isValDgraph() ) { constructError(a,res,"lngamma not defined for dgraphs."); }
    else if ( a.isValAnion()  ) { constructError(a,res,"lngamma not defined for anions.");  }
    else if ( a.isValSet()    ) { Set<gentype>          temp(a.cast_set(0));    temp.applyon(lngamma); res = temp; }
    else if ( a.isValDict()   ) { Dict<gentype,dictkey> temp(a.cast_dict(0));   temp.applyon(lngamma); res = temp; }
    else if ( a.isValMatrix() ) { Matrix<gentype>       temp(a.cast_matrix(0)); temp.applyon(lngamma); res = temp; }
    else if ( a.isValVector() ) { Vector<gentype>       temp(a.cast_vector(0)); temp.applyon(lngamma); res = temp; }

    else
    {
        res.force_double() = numbase_lngamma(a.cast_double(0));

/*
        int ires = numbase_lngamma(res.force_double(),a.cast_double(0));

        if ( ires )
	{
            constructError(a,res,"Error calculating lngamma");
	}
*/
    }

    return res;
}

gentype psi(const gentype &x)
{
    gentype res;

    if ( x.isValEqnDir() )
    {
        const static gentype resx("psi(x)");
        return resx(x);
    }

         if ( x.isValStrErr() ) { constructError(x,res,"psi not defined for strings."); }
    else if ( x.isValDgraph() ) { constructError(x,res,"psi not defined for dgraphs."); }
    else if ( x.isValAnion()  ) { constructError(x,res,"psi not defined for anions.");  }
    else if ( x.isValSet()    ) { Set<gentype>          temp(x.cast_set(0));    temp.applyon(psi); res = temp; }
    else if ( x.isValDict()   ) { Dict<gentype,dictkey> temp(x.cast_dict(0));   temp.applyon(psi); res = temp; }
    else if ( x.isValMatrix() ) { Matrix<gentype>       temp(x.cast_matrix(0)); temp.applyon(psi); res = temp; }
    else if ( x.isValVector() ) { Vector<gentype>       temp(x.cast_vector(0)); temp.applyon(psi); res = temp; }

    else
    {
        int ires = numbase_psi(res.force_double(),x.cast_double(0));

        if ( ires )
	{
            constructError(x,res,"Error calculating psi");
	}
    }

    return res;
}

gentype dubpsi_n(const gentype &x, const void *i);
gentype dubpsi_n(const gentype &x, const void *i)
{
    return psi_n(*((const gentype *) i),x);
}

gentype psi_n(const gentype &i, const gentype &x)
{
    gentype res;

    if ( i.isValEqnDir() || x.isValEqnDir() )
    {
        const static gentype resx("psi_n(x,y)");
        return resx(i,x);
    }

         if ( x.isValStrErr()                     ) { constructError(i,x,res,"psi_n not defined for strings."); }
    else if ( x.isValDgraph()                     ) { constructError(i,x,res,"psi_n not defined for dgraphs."); }
    else if ( x.isValAnion()                      ) { constructError(i,x,res,"psi_n not defined for anions.");  }
    else if ( x.isValSet()                        ) { Set<gentype>          temp(x.cast_set(0));    temp.applyon(dubpsi_n,(void *) &i); res = temp; }
    else if ( x.isValDict()                       ) { Dict<gentype,dictkey> temp(x.cast_dict(0));   temp.applyon(dubpsi_n,(void *) &i); res = temp; }
    else if ( x.isValMatrix()                     ) { Matrix<gentype>       temp(x.cast_matrix(0)); temp.applyon(dubpsi_n,(void *) &i); res = temp; }
    else if ( x.isValVector()                     ) { Vector<gentype>       temp(x.cast_vector(0)); temp.applyon(dubpsi_n,(void *) &i); res = temp; }
    else if ( !i.isCastableToIntegerWithoutLoss() ) { constructError(i,x,res,"psi_n not defined for non-integer n."); }

    else
    {
        int ires = numbase_psi_n(res.force_double(),i.cast_int(0),x.cast_double(0));

        if ( ires )
	{
            constructError(x,res,"Error calculating psi_n");
	}
    }

    return res;
}

gentype dubgamic(const gentype &a, const void *x);
gentype dubgamic(const gentype &a, const void *x)
{
    return gamic(a,*((const gentype *) x));
}

gentype debgamic(const gentype &x, const void *a);
gentype debgamic(const gentype &x, const void *a)
{
    return gamic(*((const gentype *) a),x);
}

gentype gamic(const gentype &a, const gentype &x)
{
    gentype res;

    if ( a.isValEqnDir() || x.isValEqnDir() )
    {
        const static gentype resx("gamic(x,y)");
        return resx(a,x);
    }

         if ( a.isValStrErr() ) { constructError(a,x,res,"gamic not defined for strings."); }
    else if ( a.isValDgraph() ) { constructError(a,x,res,"gamic not defined for dgraphs."); }
    else if ( a.isValAnion()  ) { constructError(a,x,res,"gamic not defined for anions.");  }
    else if ( a.isValSet()    ) { Set<gentype>          temp(a.cast_set(0));  temp.applyon(dubgamic,(void *) &x); res = temp; }
    else if ( a.isValDict()   ) { Dict<gentype,dictkey> temp(a.cast_dict(0)); temp.applyon(dubgamic,(void *) &x); res = temp; }
    else if ( a.isValMatrix() ) { Matrix<gentype> temp(a.cast_matrix(0)); temp.applyon(dubgamic,(void *) &x); res = temp; }
    else if ( a.isValVector() ) { Vector<gentype> temp(a.cast_vector(0)); temp.applyon(dubgamic,(void *) &x); res = temp; }
    else if ( x.isValStrErr() ) { constructError(a,x,res,"gamic not defined for strings."); }
    else if ( x.isValDgraph() ) { constructError(a,x,res,"gamic not defined for dgraphs."); }
    else if ( x.isValAnion()  ) { constructError(a,x,res,"gamic not defined for anions.");  }
    else if ( x.isValSet()    ) { Set<gentype>    temp(x.cast_set(0));    temp.applyon(debgamic,(void *) &a); res = temp; }
    else if ( x.isValMatrix() ) { Matrix<gentype> temp(x.cast_matrix(0)); temp.applyon(debgamic,(void *) &a); res = temp; }
    else if ( x.isValVector() ) { Vector<gentype> temp(x.cast_vector(0)); temp.applyon(debgamic,(void *) &a); res = temp; }

    else
    {
        int ires = numbase_gamma_inc(res.force_double(),a.cast_double(0),x.cast_double(0));

        if ( ires )
	{
            constructError(x,res,"Error calculating gamma_inc");
	}
    }

    return res;
}

gentype zeta(const gentype &a)
{
    gentype res;

    if ( a.isValEqnDir() )
    {
        const static gentype resx("zeta(x)");
        return resx(a);
    }

    // Design note: zeta almost always evaluates to double, so we simply
    // assume this for all cases.

         if ( a.isValStrErr() ) { constructError(a,res,"zeta not defined for strings."); }
    else if ( a.isValDgraph() ) { constructError(a,res,"zeta not defined for dgraphs."); }
    else if ( a.isValAnion()  ) { constructError(a,res,"zeta not defined for anions.");  }
    else if ( a.isValSet()    ) { Set<gentype>          temp(a.cast_set (0));   temp.applyon(zeta); res = temp; }
    else if ( a.isValDict()   ) { Dict<gentype,dictkey> temp(a.cast_dict(0));   temp.applyon(zeta); res = temp; }
    else if ( a.isValMatrix() ) { Matrix<gentype>       temp(a.cast_matrix(0)); temp.applyon(zeta); res = temp; }
    else if ( a.isValVector() ) { Vector<gentype>       temp(a.cast_vector(0)); temp.applyon(zeta); res = temp; }

    else
    {
        res.force_double() = numbase_zeta(a.cast_double(0));
    }

    return res;
}

gentype lambertW(const gentype &a)
{
    gentype res;

    if ( a.isValEqnDir() )
    {
        const static gentype resx("lambertW(x)");
        return resx(a);
    }

    // Design note: lambert W almost always evaluates to double, so we simply
    // assume this for all cases.

         if ( a.isValStrErr() ) { constructError(a,res,"lambert W not defined for strings."); }
    else if ( a.isValDgraph() ) { constructError(a,res,"lambert W not defined for dgraphs."); }
    else if ( a.isValAnion()  ) { constructError(a,res,"lambert W not defined for anions.");  }
    else if ( a.isValSet()    ) { Set<gentype>          temp(a.cast_set(0));    temp.applyon(lambertW); res = temp; }
    else if ( a.isValDict()   ) { Dict<gentype,dictkey> temp(a.cast_dict(0));   temp.applyon(lambertW); res = temp; }
    else if ( a.isValMatrix() ) { Matrix<gentype>       temp(a.cast_matrix(0)); temp.applyon(lambertW); res = temp; }
    else if ( a.isValVector() ) { Vector<gentype>       temp(a.cast_vector(0)); temp.applyon(lambertW); res = temp; }

    else
    {
        int ires = numbase_lambertW(res.force_double(),a.cast_double(0));

        if ( ires )
	{
            constructError(a,res,"Error calculating lambert W");
	}
    }

    return res;
}

gentype lambertWx(const gentype &a)
{
    gentype res;

    if ( a.isValEqnDir() )
    {
        const static gentype resx("lambertWx(x)");
        return resx(a);
    }

    // Design note: lambert W almost always evaluates to double, so we simply
    // assume this for all cases.

         if ( a.isValStrErr() ) { constructError(a,res,"lambert W not defined for strings."); }
    else if ( a.isValDgraph() ) { constructError(a,res,"lambert W not defined for dgraphs."); }
    else if ( a.isValAnion()  ) { constructError(a,res,"lambert W not defined for anions.");  }
    else if ( a.isValSet()    ) { Set<gentype>          temp(a.cast_set(0));    temp.applyon(lambertWx); res = temp; }
    else if ( a.isValDict()   ) { Dict<gentype,dictkey> temp(a.cast_dict(0));   temp.applyon(lambertWx); res = temp; }
    else if ( a.isValMatrix() ) { Matrix<gentype>       temp(a.cast_matrix(0)); temp.applyon(lambertWx); res = temp; }
    else if ( a.isValVector() ) { Vector<gentype>       temp(a.cast_vector(0)); temp.applyon(lambertWx); res = temp; }

    else
    {
        int ires = numbase_lambertWx(res.force_double(),a.cast_double(0));

        if ( ires )
	{
            constructError(a,res,"Error calculating lambert W");
	}
    }

    return res;
}

/*
gentype erf(const gentype &x)
{
    gentype res;

    if ( x.isValEqnDir() )
    {
        const static gentype resx("erf(x)");
        return resx(x);
    }

         if ( x.isValStrErr() ) { constructError(x,res,"erf not defined for strings."); }
    else if ( x.isValDgraph() ) { constructError(x,res,"erf not defined for dgraphs."); }
    else if ( x.isValSet()    ) { Set<gentype>    temp(x.cast_set(0));    temp.applyon(erf); res = temp; }
    else if ( x.isValMatrix() ) { Matrix<gentype> temp(x.cast_matrix(0)); temp.applyon(erf); res = temp; }
    else if ( x.isValVector() ) { Vector<gentype> temp(x.cast_vector(0)); temp.applyon(erf); res = temp; }
    else if ( x.isValAnion()  ) { constructError(x,res,"erf not defined for anions."); }

    else
    {
        //int ires = numbase_erf(res.force_double(),x.cast_double(0));
        //
        //if ( ires )
	//{
        //    constructError(x,res,"Error calculating erf");
	//}

        res.force_double() = erf(x.cast_double(0));
    }

    return res;
}

gentype erfc(const gentype &x)
{
    gentype res;

    if ( x.isValEqnDir() )
    {
        const static gentype resx("erfc(x)");
        return resx(x);
    }

         if ( x.isValStrErr() ) { constructError(x,res,"erfc not defined for strings."); }
    else if ( x.isValDgraph() ) { constructError(x,res,"erfc not defined for dgraphs."); }
    else if ( x.isValSet()    ) { Set<gentype>    temp(x.cast_set(0));    temp.applyon(erfc); res = temp; }
    else if ( x.isValMatrix() ) { Matrix<gentype> temp(x.cast_matrix(0)); temp.applyon(erfc); res = temp; }
    else if ( x.isValVector() ) { Vector<gentype> temp(x.cast_vector(0)); temp.applyon(erfc); res = temp; }
    else if ( x.isValAnion()  ) { constructError(x,res,"erfc not defined for anions."); }

    else
    {
        //int ires = numbase_erfc(res.force_double(),x.cast_double(0));
        //
        //if ( ires )
	//{
        //    constructError(x,res,"Error calculating erfc");
	//}

        res.force_double() = erfc(x.cast_double(0));
    }

    return res;
}
*/

gentype dawson(const gentype &x)
{
    gentype res;

    if ( x.isValEqnDir() )
    {
        const static gentype resx("dawson(x)");
        return resx(x);
    }

         if ( x.isValStrErr() ) { constructError(x,res,"dawson not defined for strings."); }
    else if ( x.isValDgraph() ) { constructError(x,res,"dawson not defined for dgraphs."); }
    else if ( x.isValAnion()  ) { constructError(x,res,"dawson not defined for anions.");  }
    else if ( x.isValSet()    ) { Set<gentype>          temp(x.cast_set(0));    temp.applyon(dawson); res = temp; }
    else if ( x.isValDict()   ) { Dict<gentype,dictkey> temp(x.cast_dict(0));   temp.applyon(dawson); res = temp; }
    else if ( x.isValMatrix() ) { Matrix<gentype>       temp(x.cast_matrix(0)); temp.applyon(dawson); res = temp; }
    else if ( x.isValVector() ) { Vector<gentype>       temp(x.cast_vector(0)); temp.applyon(dawson); res = temp; }

    else
    {
        int ires = numbase_dawson(res.force_double(),x.cast_double(0));

        if ( ires )
	{
            constructError(x,res,"Error calculating dawson");
	}
    }

    return res;
}




/*
gentype emaxv(const gentype &a, const gentype &b)
{
    gentype res;

    if ( a.isValEqnDir() || b.isValEqnDir() )
    {
        const static gentype resx("emaxv(a,b)");
        return resx(a,b);
    }

    if ( a.isValMatrix() ) 
    {
        if ( !b.isValMatrix() )
        {
            constructError(a,b,res,"emaxv have either neither or both matrix");
            return res;
        }

        const Matrix<gentype> &aa = (const Matrix<gentype> &) aa;
        const Matrix<gentype> &bb = (const Matrix<gentype> &) bb;

        if ( aa.numRows() != bb.numRows() )
        {
            constructError(a,b,res,"emaxv matrix row sizes must agree");
            return res;
        }

        if ( aa.numRows() != bb.numRows() )
        {
            constructError(a,b,res,"emaxv matrix column sizes must agree");
            return res;
        }

        int i,j;

        Matrix<gentype> &tres = res.force_matrix().resize(aa.numRows(),aa.numCols());

        for ( i = 0 ; i < aa.numRows() ; ++i )
        {
            for ( j = 0 ; j < aa.numCols() ; ++j )
            {
                tres("&",i,j) = emaxv(aa(i,j),bb(i,j));
            }
        }
    }

    else if ( b.isValVector() ) 
    { 
        if ( !b.isValVector() )
        {
            constructError(a,b,res,"emaxv have either neither or both vector");
            return res;
        }

        const Vector<gentype> &aa = (const Vector<gentype> &) aa;
        const Vector<gentype> &bb = (const Vector<gentype> &) bb;

        if ( aa.size() != bb.size() )
        {
            constructError(a,b,res,"emaxv vector sizes must agree");
            return res;
        }

        int i;

        Vector<gentype> &tres = res.force_vector().resize(aa.numRows(),aa.numCols());

        for ( i = 0 ; i < aa.size() ; ++i )
        {
            tres("&",i,j) = emaxv(aa(i),bb(i));
        }
    }

    else
    {
        gentype tmp = ge(a,b);

        if ( !tmp.isCastableToIntegerWithoutLoss() )
        {
            constructError(a,b,res,"emaxv comparison failed");
            return res;
        }

        res = ((int) tmp) ? a : b;
    }

    return res;
}




gentype eminv(const gentype &a, const gentype &b)
{
    gentype res;

    if ( a.isValEqnDir() || b.isValEqnDir() )
    {
        const static gentype resx("eminv(a,b)");
        return resx(a,b);
    }

    if ( a.isValMatrix() ) 
    {
        if ( !b.isValMatrix() )
        {
            constructError(a,b,res,"emaxv have either neither or both matrix");
            return res;
        }

        const Matrix<gentype> &aa = (const Matrix<gentype> &) aa;
        const Matrix<gentype> &bb = (const Matrix<gentype> &) bb;

        if ( aa.numRows() != bb.numRows() )
        {
            constructError(a,b,res,"eminv matrix row sizes must agree");
            return res;
        }

        if ( aa.numRows() != bb.numRows() )
        {
            constructError(a,b,res,"eminv matrix column sizes must agree");
            return res;
        }

        int i,j;

        Matrix<gentype> &tres = res.force_matrix().resize(aa.numRows(),aa.numCols());

        for ( i = 0 ; i < aa.numRows() ; ++i )
        {
            for ( j = 0 ; j < aa.numCols() ; ++j )
            {
                tres("&",i,j) = eminv(aa(i,j),bb(i,j));
            }
        }
    }

    else if ( b.isValVector() ) 
    { 
        if ( !b.isValVector() )
        {
            constructError(a,b,res,"eminv have either neither or both vector");
            return res;
        }

        const Vector<gentype> &aa = (const Vector<gentype> &) aa;
        const Vector<gentype> &bb = (const Vector<gentype> &) bb;

        if ( aa.size() != bb.size() )
        {
            constructError(a,b,res,"eminv vector sizes must agree");
            return res;
        }

        int i;

        Vector<gentype> &tres = res.force_vector().resize(aa.numRows(),aa.numCols());

        for ( i = 0 ; i < aa.size() )
        {
            tres("&",i,j) = eminv(aa(i),bb(i));
        }
    }

    else
    {
        gentype tmp = le(a,b);

        if ( !tmp.isCastableToIntegerWithoutLoss() )
        {
            constructError(a,b,res,"eminv comparison failed");
            return res;
        }

        res = ((int) tmp) ? a : b;
    }

    return res;
}
*/










// Global function table access

inline gentype fnA(const gentype &i, const gentype &j)
{
    gentype res;

    if ( i.isValEqnDir() || j.isValEqnDir() )
    {
        const static gentype resx("fnA(x,y)");
        return resx(i,j);
    }

    if ( !i.isCastableToIntegerWithoutLoss() || !j.isCastableToIntegerWithoutLoss() )
    {
        constructError(i,j,res,"fnA not defined for non-integer function index.");
    }

    else
    {
        const gentype xa;
        const gentype xb;

        int ia = 0;
        int ib = 0;

        evalgenFunc(i.cast_int(0),j.cast_int(0),xa,ia,xb,ib,res);
    }

    return res;
}

inline gentype fnB(const gentype &i, const gentype &j, const gentype &xa)
{
    gentype res;

    if ( i.isValEqnDir() || j.isValEqnDir() || xa.isValEqnDir() )
    {
        const static gentype resx("fnB(x,y,z)");
        return resx(i,j,xa);
    }

    if ( !i.isCastableToIntegerWithoutLoss() || !j.isCastableToIntegerWithoutLoss() ) 
    { 
        constructError(i,j,xa,res,"fnB not defined for non-integer function index."); 
    }

    else
    {
        const gentype xb;

        int ia = 0;
        int ib = 0;

        evalgenFunc(i.cast_int(0),j.cast_int(0),xa,ia,xb,ib,res);
    }

    return res;
}

inline gentype fnC(const gentype &i, const gentype &j, const gentype &xa, const gentype &xb)
{
    gentype res;

    if ( i.isValEqnDir() || j.isValEqnDir() || xa.isValEqnDir() || xb.isValEqnDir() )
    {
        const static gentype resx("fnC(x,y,z,var(0,3))");
        return resx(i,j,xa,xb);
    }

    if ( !i.isCastableToIntegerWithoutLoss() || !j.isCastableToIntegerWithoutLoss() ) 
    { 
        constructError(i,j,xa,xb,res,"fnC not defined for non-integer function index."); 
    }

    else
    {
        int ia = 0;
        int ib = 0;

        evalgenFunc(i.cast_int(0),j.cast_int(0),xa,ia,xb,ib,res);
    }

    return res;
}

inline gentype dfnB(const gentype &i, const gentype &j, const gentype &xa, const gentype &ia)
{
    gentype res;

    if ( i.isValEqnDir() || j.isValEqnDir() || xa.isValEqnDir() || ia.isValEqnDir() )
    {
        const static gentype resx("dfnB(x,y,z,var(0,3))");
        return resx(i,j,xa,ia);
    }

    if ( !i.isCastableToIntegerWithoutLoss() || !j.isCastableToIntegerWithoutLoss() || !ia.isCastableToIntegerWithoutLoss() ) 
    { 
        constructError(i,j,xa,ia,res,"dfnB not defined for non-integer function index."); 
    }

    else
    {
        const gentype xb;

        int ib = 0;

        evalgenFunc(i.cast_int(0),j.cast_int(0),xa,ia.cast_int(0),xb,ib,res);
    }

    return res;
}

inline gentype dfnC(const gentype &i, const gentype &j, const gentype &xa, const gentype &ia, const gentype &xb, const gentype &ib)
{
    gentype res;

    if ( i.isValEqnDir() || j.isValEqnDir() || xa.isValEqnDir() || ia.isValEqnDir() || xb.isValEqnDir() || ib.isValEqnDir() )
    {
        const static gentype resx("dfnC(x,y,z,var(0,3),var(0,4),var(0,5))");
        return resx(i,j,xa,ia,xb,ib);
    }

    if ( !i.isCastableToIntegerWithoutLoss() || !j.isCastableToIntegerWithoutLoss() || !ia.isCastableToIntegerWithoutLoss() || !ib.isCastableToIntegerWithoutLoss() ) 
    { 
        constructError(i,j,xa,ia,xb,ib,res,"dfnC not defined for non-integer function index."); 
    }

    else
    {
        evalgenFunc(i.cast_int(0),j.cast_int(0),xa,ia.cast_int(0),xb,ib.cast_int(0),res);
    }

    return res;
}

inline gentype efnB(const gentype &i, const gentype &j, const gentype &xa)
{
    gentype res;

    if ( i.isValEqnDir() || j.isValEqnDir() || xa.isValEqnDir() )
    {
        const static gentype resx("efnB(x,y,z)");
        return resx(i,j,xa);
    }

    if ( !i.isCastableToIntegerWithoutLoss() || !j.isCastableToIntegerWithoutLoss() ) 
    { 
        constructError(i,j,xa,res,"efnB not defined for non-integer function index."); 
    }

    else if ( !xa.isValVector() )
    {
        const Vector<gentype> xb(xa.size());

        int ia = 0;
        int ib = 0;

        evalegenFunc(i.cast_int(0),j.cast_int(0),(const Vector<gentype> &) xa,ia,xb,ib,res.force_vector());
    }

    else
    {
        constructError(i,j,xa,res,"efnB not defined for non-vector argument."); 
    }

    return res;
}

inline gentype efnC(const gentype &i, const gentype &j, const gentype &xa, const gentype &xb)
{
    gentype res;

    if ( i.isValEqnDir() || j.isValEqnDir() || xa.isValEqnDir() || xb.isValEqnDir() )
    {
        const static gentype resx("efnC(x,y,z,var(0,3))");
        return resx(i,j,xa,xb);
    }

    if ( !i.isCastableToIntegerWithoutLoss() || !j.isCastableToIntegerWithoutLoss() ) 
    { 
        constructError(i,j,xa,xb,res,"efnC not defined for non-integer function index."); 
    }

    else if ( !xa.isValVector() || !xb.isValVector() )
    {
        int ia = 0;
        int ib = 0;

        evalegenFunc(i.cast_int(0),j.cast_int(0),(const Vector<gentype> &) xa,ia,(const Vector<gentype> &) xb,ib,res.force_vector());
    }

    else
    {
        constructError(i,j,xa,res,"efnB not defined for non-vector argument."); 
    }

    return res;
}

inline gentype edfnB(const gentype &i, const gentype &j, const gentype &xa, const gentype &ia)
{
    gentype res;

    if ( i.isValEqnDir() || j.isValEqnDir() || xa.isValEqnDir() || ia.isValEqnDir() )
    {
        const static gentype resx("edfnB(x,y,z,var(0,3))");
        return resx(i,j,xa,ia);
    }

    if ( !i.isCastableToIntegerWithoutLoss() || !j.isCastableToIntegerWithoutLoss() || !ia.isCastableToIntegerWithoutLoss() ) 
    { 
        constructError(i,j,xa,ia,res,"edfnB not defined for non-integer function index."); 
    }

    else
    {
        const Vector<gentype> xb(xa.size());

        int ib = 0;

        evalegenFunc(i.cast_int(0),j.cast_int(0),(const Vector<gentype> &) xa,ia.cast_int(0),xb,ib,res.force_vector());
    }

    return res;
}

inline gentype edfnC(const gentype &i, const gentype &j, const gentype &xa, const gentype &ia, const gentype &xb, const gentype &ib)
{
    gentype res;

    if ( i.isValEqnDir() || j.isValEqnDir() || xa.isValEqnDir() || ia.isValEqnDir() || xb.isValEqnDir() || ib.isValEqnDir() )
    {
        const static gentype resx("edfnC(x,y,z,var(0,3),var(0,4),var(0,5))");
        return resx(i,j,xa,ia,xb,ib);
    }

    if ( !i.isCastableToIntegerWithoutLoss() || !j.isCastableToIntegerWithoutLoss() || !ia.isCastableToIntegerWithoutLoss() || !ib.isCastableToIntegerWithoutLoss() ) 
    { 
        constructError(i,j,xa,ia,xb,ib,res,"edfnC not defined for non-integer function index."); 
    }

    else
    {
        evalegenFunc(i.cast_int(0),j.cast_int(0),(const Vector<gentype> &) xa,ia.cast_int(0),(const Vector<gentype> &) xb,ib.cast_int(0),res.force_vector());
    }

    return res;
}

gentype irand(const gentype &i)
{
    gentype res;

    if ( i.isValEqnDir() )
    {
        const static gentype resx("irand(x)");
        return resx(i);
    }

    if ( i.isCastableToIntegerWithoutLoss() )
    {
        //res.force_int() = (svm_rand()%(i.cast_int(0)));
        res.force_int() = (rand()%(i.cast_int(0)));
    }

    else if ( i.isValVector() )
    {
        Vector<gentype> &r = res.force_vector(i.size());

        int ii;

        for ( ii = 0 ; ii < i.size() ; ++ii )
        {
            r("&",ii) = irand(i(ii));
        }
    }

    else if ( i.isValMatrix() )
    {
        Matrix<gentype> &r = res.force_matrix(i.numRows(),i.numCols());

        int ii,jj;

        for ( ii = 0 ; ii < i.numRows() ; ++ii )
        {
            for ( jj = 0 ; jj < i.numCols() ; ++jj )
            {
                r("&",ii,jj) = irand(i(ii,jj));
            }
        }
    }

    else
    { 
        constructError(i,res,"irand only defined for integer, vector and matrix."); 
    }

    return res;
}

gentype urand(const gentype &l, const gentype &u)
{
    gentype res;

    if ( l.isValEqnDir() || u.isValEqnDir() )
    {
        const static gentype resx("urand(x,y)");
        return resx(l,u);
    }

    if ( l.isCastableToRealWithoutLoss() && u.isCastableToRealWithoutLoss() ) 
    {
        randufill(res);
        res.force_double() *= ( u.cast_double(0) - l.cast_double(0) );
        res.force_double() += l.cast_double(0);
    }

    else if ( l.isValVector() && u.isValVector() )
    {
        NiceAssert( l.size() == u.size() );

        Vector<gentype> &r = res.force_vector(l.size());

        int ii;

        for ( ii = 0 ; ii < l.size() ; ++ii )
        {
            r("&",ii) = urand(l(ii),u(ii));
        }
    }

    else if ( l.isValMatrix() && u.isValMatrix() )
    {
        NiceAssert( l.numRows() == u.numRows() );
        NiceAssert( l.numCols() == u.numCols() );

        Matrix<gentype> &r = res.force_matrix(l.numRows(),l.numCols());

        int ii,jj;

        for ( ii = 0 ; ii < l.numRows() ; ++ii )
        {
            for ( jj = 0 ; jj < l.numCols() ; ++jj )
            {
                r("&",ii,jj) = urand(l(ii,jj),u(ii,jj));
            }
        }
    }

    else
    { 
        constructError(l,u,res,"urand only defined for real, vector and matrix."); 
    }

    return res;
}

gentype grand(const gentype &m, const gentype &v)
{
    gentype res;

    if ( m.isValEqnDir() || v.isValEqnDir() )
    {
        const static gentype resx("grand(x,y)");
        return resx(m,v);
    }

    if ( m.isCastableToRealWithoutLoss() && v.isCastableToRealWithoutLoss() ) 
    {
        double &r = res.force_double();

        double mm = m.cast_double(0);
        double vv = v.cast_double(0);

        randnfill(r);

        r *= sqrt(vv);
        r += mm;
    }

    else if ( m.isValVector() && v.isCastableToRealWithoutLoss() )
    {
        Vector<gentype> &r = res.force_vector(m.size());

        const Vector<gentype> &mm = m.cast_vector(0);

        // Assumption: vv is symmetric positive definite

        int ii;

        for ( ii = 0 ; ii < m.size() ; ++ii )
        {
            randnfill(r("&",ii).force_double());
        }

        r *= sqrt(v);
        r += mm;
    }

    else if ( m.isValVector() && v.isValMatrix() )
    {
        // We use a partial Cholesky factorisation to allow for positive *semi*-definite covariances

        // v = LL' = LU (U = L')
        //
        // r = m + L.n
        // r(p) = m(p) + L(p,:).n(:)
        // r(p) = m(p) + L(p,p).n(p)
        // r(p) = m(p) + L(p,p(0:1:s-1)).n(p(0:1:s-1))

        Vector<gentype> &r = res.force_vector(m.size());

        const Vector<gentype> &mm = (m.cast_vector(0));
        const Matrix<gentype> &vv = (v.cast_matrix(0));

        NiceAssert( vv.isSquare() );
        NiceAssert( mm.size() == vv.numRows() );

        // Assumption: vv is symmetric positive definite

        Matrix<gentype> L(m.size(),m.size());
        Vector<int> p(m.size());
        int s;

        vv.naivepartChol(L,p,s);

        int ii;

        //if ( s > 0 )
        {
            for ( ii = 0 ; ii < s ; ++ii )
            {
                randnfill(r("&",ii).force_double());
            }
        }

        //if ( s < m.size() )
        {
            for ( ii = s ; ii < m.size() ; ++ii )
            {
                r("&",ii).force_double() = 0.0;
            }
        }

        retVector<gentype> tmpva;
        retVector<gentype> tmpvb;
        retVector<int>     tmpvc;
        retVector<int>     tmpvd;
        retMatrix<gentype> tmpma;

        r("&",p,tmpva) = (L(p,p(0,1,s-1,tmpvc),tmpma))*r(p(0,1,s-1,tmpvd),tmpvb);
        r += mm;


// This version works, but only if v is positive definite, not positive *semi*-definite

//        // c = UU'
//        //
//        // r = m + U.n
//        // r' = m' + n'.U'
//
//        Vector<gentype> &r = res.force_vector(m.size());
//
//        const Vector<gentype> &mm = (m.cast_vector(0));
//        const Matrix<gentype> &vv = (v.cast_matrix(0));
//
//        NiceAssert( vv.isSquare() );
//        NiceAssert( mm.size() == vv.numRows() );
//
//        // Assumption: vv is symmetric positive definite
//
//        Matrix<gentype> cc(m.size(),m.size());
//
//        vv.naiveChol(cc,0);
//	
//        int ii;
//
//        for ( ii = 0 ; ii < m.size() ; ++ii )
//        {
//            randnfill(r("&",ii).force_double());
//        }
//
//        r *= cc.transpose();
//        r += mm;


// This version doesn't work as the SVD code I found is faulty (try [ 1 1 1 1 ; 1 1 1 1 ; 1 1 1 1 ; 1 1 1 1 ] and watch it fail

//        // c = UDV   (V=U')
//        //
//        // r = m + U.sqrt(D).n
//        // r' = m' + n'.sqrt(D).V
//
//        Vector<double> r(m.size());
//
//        const Vector<double> &mm = (const Vector<double> &) m;
//        const Matrix<double> &cc = (const Matrix<double> &) v;
//
//        NiceAssert( cc.isSquare() );
//        NiceAssert( mm.size() == cc.numRows() );
//
//        Matrix<double> uu,vv;
//        Vector<double> dd;
//
//        cc.SVD(uu,dd,vv);
//
//errstream() << "phantomx: uu = " << uu << "\n";	
//errstream() << "phantomx: dd = " << dd << "\n";	
//errstream() << "phantomx: vv = " << vv << "\n";	
//Matrix<double> ddd(dd.size(),dd.size());
//ddd = 0.0;
//ddd.diagoffset(dd);
//uu.transpose();
//errstream() << "phantomx: uu.dd.vv = " << uu*(ddd*vv) << "\n";
//        int ii;
//
//        for ( ii = 0 ; ii < m.size() ; ++ii )
//        {
//            randnfill(r("&",ii));
//
//            r("&",ii) *= sqrt(dd(ii));
//        }
//
////        r *= vv;
//
//        Vector<double> s(r);
//
//        s = ((uu*r)+mm);
//
//        res = r;
    }

    else
    { 
        constructError(m,v,res,"grand only defined for real,real and vector,matrix."); 
    }

    return res;
}

gentype testfn(const gentype &i, const gentype &x)
{
    gentype res;

    if ( i.isValEqnDir() || x.isValEqnDir() )
    {
        eqnfallback:
        const static gentype resx("testfn(x,y)");
        return resx(i,x);
    }

    if ( !(i.isCastableToIntegerWithoutLoss()) )
    {
        constructError(i,x,res,"Index must be integer for testfn.");
    }

    else if ( !(x.isCastableToVectorWithoutLoss()) )
    {
        vecfallback:
        constructError(i,x,res,"x must be castable to real-valued vector for testfn.");
    }

    else
    {
        int ii = (int) i;
        const Vector<gentype> &xx = (const Vector<gentype> &) x;

        int j;

        for ( j = 0 ; j < xx.size() ; ++j )
        {
            if ( xx(j).isValEqnDir() )
            {
                goto eqnfallback;
            }

            if ( !(xx(j).isCastableToRealWithoutLoss()) )
            {
                goto vecfallback;
            }
        }

        const Vector<double> &xxx = (const Vector<double> &) x;

        if ( evalTestFn(ii,res.force_double(),xxx) )
        {
            constructError(i,x,res,"x non-feasible in testfn.");
        }
    }

    return res;
}

gentype testfnA(const gentype &i, const gentype &x, const gentype &A)
{
    gentype res;

    if ( i.isValEqnDir() || x.isValEqnDir() || A.isValEqnDir() )
    {
        eqnfallback:
        const static gentype resx("testfnA(x,y,z)");
        return resx(i,x,A);
    }

    if ( !(i.isCastableToIntegerWithoutLoss()) )
    {
        constructError(i,x,A,res,"Index must be integer for testfnA.");
    }

    else if ( !(x.isCastableToVectorWithoutLoss()) )
    {
        vecfallback:
        constructError(i,x,A,res,"x must be castable to real-valued vector for testfnA.");
    }

    else if ( !(A.isCastableToMatrixWithoutLoss()) )
    {
        matfallback:
        constructError(i,x,A,res,"A must be castable to real-valued matrix for testfnA.");
    }

    else
    {
        int ii = (int) i;
        const Vector<gentype> &xx = (const Vector<gentype> &) x;
        const Matrix<gentype> &AA = (const Matrix<gentype> &) A;

        int j,k;

        for ( j = 0 ; j < xx.size() ; ++j )
        {
            if ( xx(j).isValEqnDir() )
            {
                goto eqnfallback;
            }

            if ( !(xx(j).isCastableToRealWithoutLoss()) )
            {
                goto vecfallback;
            }
        }

        for ( j = 0 ; j < AA.numRows() ; ++j )
        {
            for ( k = 0 ; k < AA.numCols() ; ++k )
            {
                if ( !(AA(j,k).isCastableToRealWithoutLoss()) )
                {
                    goto matfallback;
                }
            }
        }

        const Vector<double> &xxx = (const Vector<double> &) x;
        const Matrix<double> &AAA = (const Matrix<double> &) A;

        if ( evalTestFn(ii,res.force_double(),xxx,&AAA) )
        {
            constructError(i,x,A,res,"x non-feasible in testfnA.");
        }
    }

    return res;
}

gentype partestfn(const gentype &i, const gentype &M, const gentype &x)
{
    gentype res;

    if ( i.isValEqnDir() || M.isValEqnDir() || x.isValEqnDir() )
    {
        const static gentype resx("partestfn(x,y,z)");
        return resx(i,M,x);
    }

    if ( !(i.isCastableToIntegerWithoutLoss()) )
    {
        constructError(i,M,x,res,"Index must be integer for partestfn.");
    }

    else if ( !(M.isCastableToIntegerWithoutLoss()) )
    {
        constructError(i,M,x,res,"Target dimensino must be integer for partestfn.");
    }

    else if ( !(x.isCastableToVectorWithoutLoss()) )
    {
        vecfallback:
        constructError(i,M,x,res,"x must be castable to real-valued vector for partestfn.");
    }

    else
    {
        int ii = (int) i;
        int MM = (int) M;
        const Vector<gentype> &xx = (const Vector<gentype> &) x;

        int j;

        for ( j = 0 ; j < xx.size() ; ++j )
        {
            if ( !(xx(j).isCastableToRealWithoutLoss()) )
            {
                goto vecfallback;
            }
        }

        const Vector<double> &xxx = (const Vector<double> &) x;

        Vector<double> ress(MM);

        if ( evalTestFn(ii,xxx.size(),MM,ress,xxx) )
        {
            constructError(i,M,x,res,"x non-feasible in partestfn.");
        }

        else
        {
            res = ress;
        }
    }

    return res;
}

gentype partestfnA(const gentype &i, const gentype &M, const gentype &x, const gentype &alpha)
{
    gentype res;

    if ( i.isValEqnDir() || M.isValEqnDir() || x.isValEqnDir() || alpha.isValEqnDir() )
    {
        const static gentype resx("partestfnA(x,y,z,v)");
        return resx(i,M,x,alpha);
    }

    if ( !(i.isCastableToIntegerWithoutLoss()) )
    {
        constructError(i,M,x,alpha,res,"Index must be integer for partestfnA.");
    }

    else if ( !(M.isCastableToIntegerWithoutLoss()) )
    {
        constructError(i,M,x,alpha,res,"Target dimension must be integer for partestfnA.");
    }

    else if ( !(x.isCastableToVectorWithoutLoss()) )
    {
        vecfallback:
        constructError(i,M,x,alpha,res,"x must be castable to real-valued vector for partestfnA.");
    }

    else if ( !(alpha.isCastableToRealWithoutLoss()) )
    {
        constructError(i,M,x,alpha,res,"alpha must be castable to real for partestfnA.");
    }

    else
    {
        int ii = (int) i;
        int MM = (int) M;
        const Vector<gentype> &xx = (const Vector<gentype> &) x;
        double Alpha = (double) alpha;

        int j;

        for ( j = 0 ; j < xx.size() ; ++j )
        {
            if ( !(xx(j).isCastableToRealWithoutLoss()) )
            {
                goto vecfallback;
            }
        }

        const Vector<double> &xxx = (const Vector<double> &) x;

        Vector<double> ress(MM);

        if ( evalTestFn(ii,xxx.size(),MM,ress,xxx,Alpha) )
        {
            constructError(i,M,x,alpha,res,"x non-feasible in partestfn.");
        }

        else
        {
            res = ress;
        }
    }

    return res;
}











// System/exe/python calls

gentype syscall(const gentype &c, const gentype &x)
{
    gentype res;

    if ( c.isValEqnDir() || x.isValEqnDir() )
    {
        const static gentype resx("syscall(x,y)");
        return resx(c,x);
    }

    if ( !(c.isValString()) )
    {
        constructError(c,x,res,"Command must evaluate to string in syscall.");
    }

    else
    {
        std::string resstr;
        std::string callstr((const std::string &) c);

        callstr += " ";
        callstr += (const std::string &) x;
        svm_execall(resstr,callstr);

        // Just in case you call python this way... see comment in pycall function.

        std::stringstream pleasework(resstr);
        pleasework >> res;
    }

    return res;
}

gentype pycall(const gentype &c, const gentype &x)
{
    gentype res;

    if ( c.isValEqnDir() || x.isValEqnDir() )
    {
        const static gentype resx("pycall(x,y)");
        return resx(c,x);
    }

    if ( !(c.isValString()) )
    {
        constructError(c,x,res,"Command must evaluate to string in pycall.");
    }

    else
    {
        pycall((const std::string &) c,res,x);
/*
        std::string resstr;
        std::string callstr((const std::string &) c);

        callstr += " ";
        callstr += (const std::string &) x;
        svm_pycall(resstr,callstr);

        // At this point I would like to just write "res = resstr", but
        // python messes things up with unix-y newlines that seem to
        // break stuff, and C++ seems to actively impede me stripping
        // said characters from the string. Quick workaround below...
        //
        // Why the actual fuck is this sort of crap still a thing?

        std::stringstream pleasework(resstr);
        pleasework >> res;
*/
    }

//outstream() << "gentype pycall result " << res << "\n";
    return res;
}

#ifndef PYLOCAL
// If not local python then we use a system call
void pycall(const std::string &fn, gentype &res,       int               x) { gentype xx(x);      pycall(fn,res,xx); }
void pycall(const std::string &fn, gentype &res,       double            x) { gentype xx(x);      pycall(fn,res,xx); }
void pycall(const std::string &fn, gentype &res, const d_anion          &x) { gentype xx(x);      pycall(fn,res,xx); }
void pycall(const std::string &fn, gentype &res, const std::string      &x) { gentype xx(x);      pycall(fn,res,xx); }
void pycall(const std::string &fn, gentype &res, int size, const double *x) { gentype xx(size,x); pycall(fn,res,xx); }

void pycall(const std::string &evalstr, gentype &res, const gentype &x)
{
        std::string resstr;
        std::string callstr(evalstr);

        callstr += " ";
        callstr += (const std::string &) x;
        svm_pycall(resstr,callstr);

        // At this point I would like to just write "res = resstr", but
        // python messes things up with unix-y newlines that seem to
        // break stuff, and C++ seems to actively impede me stripping
        // said characters from the string. Quick workaround below...
        //
        // Why the actual fuck is this sort of crap still a thing?

        std::stringstream pleasework(resstr);
        pleasework >> res;
}
#endif


















// Type conversion functions

gentype ceil(const gentype &a)
{
    gentype res;

    if ( a.isValEqnDir() )
    {
        const static gentype resx("ceil(x)");
        return resx(a);
    }

         if ( a.isValStrErr()  ) { constructError(a,res,"ceil not defined for strings."); }
    else if ( a.isValDgraph()  ) { constructError(a,res,"ceil not defined for dgraphs."); }
    else if ( a.isValAnion()   ) { constructError(a,res,"ceil not defined for anions.");  }
    else if ( a.isValSet()     ) { Set<gentype>          temp(a.cast_set(0));    temp.applyon(ceil); res = temp; }
    else if ( a.isValDict()    ) { Dict<gentype,dictkey> temp(a.cast_dict(0));   temp.applyon(ceil); res = temp; }
    else if ( a.isValMatrix()  ) { Matrix<gentype>       temp(a.cast_matrix(0)); temp.applyon(ceil); res = temp; }
    else if ( a.isValVector()  ) { Vector<gentype>       temp(a.cast_vector(0)); temp.applyon(ceil); res = temp; }
    else if ( a.isValInteger() ) { res = a; }
    else if ( a.isCastableToIntegerWithoutLoss() ) { res = a.cast_int(0); }

    else
    {
        // Allow for potential overflow

	double x = a.cast_double(0);

        if ( x > INT_MAX )
        {
            constructError(a,res,"ceil caused integer overflow");
        }

        else
        {
            int j = (int) x;

            res.force_int() = ( j < x ) ? j+1 : j;
        }
    }

    return res;
}

gentype floor(const gentype &a)
{
    gentype res;

    if ( a.isValEqnDir() )
    {
        const static gentype resx("floor(x)");
        return resx(a);
    }

         if ( a.isValStrErr()  ) { constructError(a,res,"floor not defined for strings."); }
    else if ( a.isValDgraph()  ) { constructError(a,res,"floor not defined for dgraphs."); }
    else if ( a.isValAnion()   ) { constructError(a,res,"floor not defined for anions.");  }
    else if ( a.isValSet()     ) { Set<gentype>          temp(a.cast_set(0));    temp.applyon(floor); res = temp; }
    else if ( a.isValDict()    ) { Dict<gentype,dictkey> temp(a.cast_dict(0));   temp.applyon(floor); res = temp; }
    else if ( a.isValMatrix()  ) { Matrix<gentype>       temp(a.cast_matrix(0)); temp.applyon(floor); res = temp; }
    else if ( a.isValVector()  ) { Vector<gentype>       temp(a.cast_vector(0)); temp.applyon(floor); res = temp; }
    else if ( a.isValInteger() ) { res = a; }
    else if ( a.isCastableToIntegerWithoutLoss() ) { res = a.cast_int(0); }

    else
    {
        // Allow for potential overflow

	double x = a.cast_double(0);

        if ( x < INT_MIN )
        {
            constructError(a,res,"floor caused integer overflow");
        }

        else
        {
            int j = (int) x;

            res.force_int() = ( j > x ) ? j-1 : j;
        }
    }

    return res;
}

gentype rint(const gentype &a)
{
    gentype res;

    if ( a.isValEqnDir() )
    {
        const static gentype resx("rint(x)");
        return resx(a);
    }

         if ( a.isValStrErr() ) { constructError(a,res,"rint not defined for strings."); }
    else if ( a.isValDgraph() ) { constructError(a,res,"rint not defined for dgraphs."); }
    else if ( a.isValAnion()  ) { constructError(a,res,"rint not defined for anions.");  }
    else if ( a.isValSet()    ) { Set<gentype>          temp(a.cast_set(0));    temp.applyon(rint); res = temp; }
    else if ( a.isValDict()   ) { Dict<gentype,dictkey> temp(a.cast_dict(0));   temp.applyon(rint); res = temp; }
    else if ( a.isValMatrix() ) { Matrix<gentype>       temp(a.cast_matrix(0)); temp.applyon(rint); res = temp; }
    else if ( a.isValVector() ) { Vector<gentype>       temp(a.cast_vector(0)); temp.applyon(rint); res = temp; }
    else if ( a.isValInteger() ) { res = a; }
    else if ( a.isCastableToIntegerWithoutLoss() ) { res = a.cast_int(0); }

    else
    {
        // Allow for potential overflow

	double x = a.cast_double(0);

        if ( ( x < INT_MIN ) || ( x > INT_MAX ) )
        {
            constructError(a,res,"rint caused integer overflow");
        }

        else
        {
            int j = (int) x;

            int jceil  = ( j < x ) ? j+1 : j;
            int jfloor = ( j > x ) ? j-1 : j;

            res.force_int() = ( abs2(((double) jceil)-x) < abs2(((double) jfloor)-x) ) ? jceil : jfloor;
        }
    }

    return res;
}


gentype deref(const gentype &a, const gentype &i)
{
    gentype res;

    if ( a.isValEqnDir() || i.isValEqnDir() )
    {
        const static gentype resx("deref(x,y)");
        return resx(a,i);
    }

    else if ( a.isValMatrix() )
    {
        if ( !(i.isValVector()) )
        {
            constructError(a,i,res,"deref index incorrect for matrix.");
        }

        else if ( i.size() != 2 )
        {
            constructError(a,i,res,"bad deref index size for matrix.");
        }

        else
        {
//            res = derefm(a,derefv(i,zerointgentype()),derefv(i,oneintgentype()));
            res = derefm(a,derefv(i,0_gent),derefv(i,1_gent));
        }
    }

    else if ( a.isValVector() )
    {
        if ( !(i.isValVector()) )
        {
            constructError(a,i,res,"deref index incorrect for vector.");
        }

        else if ( i.size() != 1 )
        {
            constructError(a,i,res,"deref index size for vector.");
        }

        else
        {
//            res = derefv(a,derefv(i,zerointgentype()));
            res = derefv(a,derefv(i,0_gent));
        }
    }

    else
    {
        if ( !(i.isValVector()) )
        {
            constructError(a,i,res,"deref index incorrect for scalar.");
        }

        else if ( i.size() )
        {
            constructError(a,i,res,"deref index size for scalar.");
        }

        else
        {
            res = a;
        }
    }

    return res;
}



gentype derefv(const gentype &a, const gentype &i)
{
    gentype res;

    if ( a.scalarfn_isscalarfn() && ( a.scalarfn_i().size() >= 1 ) && ( a.scalarfn_j().size() >= 1 ) )
    {
        // This case is basically an infinite-dimensional vector, so treat as such
        // We assume that it is the first argument in the scalar function that is being
        // substituted!

        res = a;

        Vector<int> is(a.scalarfn_i());
        Vector<int> js(a.scalarfn_j());

        int vi = is(0);
        int vj = js(0);

        is.remove(0);
        js.remove(0);

        if ( !is.size() || !js.size() )
        {
            res.scalarfn_setisscalarfn(0);
        }

        else
        {
            res.scalarfn_seti(is);
            res.scalarfn_setj(js);
        }

        SparseVector<SparseVector<gentype> > subvals;

        subvals("&",vi)("&",vj) = i;

        res.substitute(subvals);
    }

    else if ( a.isValEqnDir() || i.isValEqnDir() )
    {
        const static gentype resx("derefv(x,y)");
        return resx(a,i);
    }

    else if ( !(a.isValVector()) )
    {
        constructError(a,i,res,"derefv works only on vectors.");
    }

    else if ( a.infsize() )
    {
        (a.cast_vector(0))(res,i);
    }

    else if ( i.isCastableToIntegerWithoutLoss() )
    {
        if ( ( i.cast_int(0) < 0 ) || ( i.cast_int(0) >= a.size() ) )
        {
            constructError(a,i,res,"index out of range in derefv.");
        }

        else
        {
            res = (a.cast_vector(0))(i.cast_int(0));
        }
    }

    else if ( i.isValVector() )
    {
        int k;
        gentype kk;
        Vector<gentype> resv(i.size());

        //if ( i.size() )
        {
            for ( k = 0 ; k < i.size() ; ++k )
            {
                kk = k;
                resv("&",k) = derefv(a,derefv(i,kk));
            }
        }

        res = resv;
    }

    else
    {
        constructError(a,i,res,"malformed index in derefv.");
    }

    return res;
}



gentype derefm(const gentype &a, const gentype &i, const gentype &j)
{
    gentype res;

    if ( a.isValEqnDir() || i.isValEqnDir() || j.isValEqnDir() )
    {
        const static gentype resx("derefm(x,y,z)");
        return resx(a,i,j);
    }

    if ( !(a.isValMatrix()) )
    {
        constructError(a,i,j,res,"derefm works only on matrices.");
    }

    else if ( i.isCastableToIntegerWithoutLoss() && j.isCastableToIntegerWithoutLoss() )
    {
        if ( ( i.cast_int(0) < 0 ) || ( i.cast_int(0) >= a.numRows() ) ||
             ( j.cast_int(0) < 0 ) || ( j.cast_int(0) >= a.numCols() )    )
        {
            constructError(a,i,j,res,"index out of range in derefm.");
        }

        else
        {
            res = (a.cast_matrix(0))(i.cast_int(0),j.cast_int(0));
        }
    }

    else if ( i.isValVector() && j.isCastableToIntegerWithoutLoss() )
    {
        if ( ( j.cast_int(0) < 0 ) || ( j.cast_int(0) >= a.numCols() ) )
        {
            constructError(a,i,j,res,"index out of range in derefm.");
        }

        else
        {
            int k;
            gentype kk;
            Vector<gentype> resv(i.size());

            //if ( i.size() )
            {
                for ( k = 0 ; k < i.size() ; ++k )
                {
                    kk = k;
                    resv("&",k) = derefm(a,derefv(i,kk),j);
                }
            }

            res = resv;
        }
    }

    else if ( i.isCastableToIntegerWithoutLoss() && j.isValVector() )
    {
        if ( ( i.cast_int(0) < 0 ) || ( i.cast_int(0) >= a.numCols() ) )
        {
            constructError(a,i,j,res,"index out of range in derefm.");
        }

        else
        {
            int l;
            gentype ll;
            Vector<gentype> resv(j.size());

            //if ( i.size() )
            {
                for ( l = 0 ; l < j.size() ; ++l )
                {
                    ll = l;
                    resv("&",l) = derefm(a,i,derefv(j,ll));
                }
            }

            res = resv;
        }
    }

    else if ( i.isValVector() && j.isValVector() )
    {
        int k,l;
        gentype kk,ll;
        Matrix<gentype> resm(i.size(),j.size());

        if ( i.size() && j.size() )
        {
            for ( k = 0 ; k < i.size() ; ++k )
            {
                for ( l = 0 ; l < j.size() ; ++l )
                {
                    kk = k;
                    ll = l;

                    resm("&",k,l) = derefm(a,derefv(i,kk),derefv(j,ll));
                }
            }
        }

        res = resm;
    }

    else
    {
        constructError(a,i,res,"malformed index in derefv.");
    }

    return res;
}



gentype derefa(const gentype &a, const gentype &i)
{
    gentype res;

    if ( a.isValEqnDir() || i.isValEqnDir() )
    {
        const static gentype resx("derefv(x,y)");
        return resx(a,i);
    }

    if ( a.isValVector() && a.infsize() )
    {
        constructError(a,i,res,"derefa can't cast infinite dimensional vector to anion for dereference.");
    }

    else if ( a.isValVector() )
    {
        int k;
        gentype kk;
        Vector<gentype> resv(a.size());

        //if ( a.size() )
        {
            for ( k = 0 ; k < a.size() ; ++k )
            {
                kk = k;
                resv("&",k) = derefa(derefv(a,kk),i);
            }
        }

        res = resv;
    }

    else if ( !(a.isCastableToAnionWithoutLoss()) )
    {
        constructError(a,i,res,"derefa works only on anions.");
    }

    else if ( i.isCastableToIntegerWithoutLoss() )
    {
        if ( i.cast_int(0) < 0 )
        {
            constructError(a,i,res,"index out of range in derefa.");
        }

        else
        {
            res = (a.cast_anion(0))(i.cast_int(0));
        }
    }

    else if ( i.isValVector() )
    {
        int k;
        gentype kk;
        Vector<gentype> resv(i.size());

        //if ( i.size() )
        {
            for ( k = 0 ; k < i.size() ; ++k )
            {
                kk = k;
                resv("&",k) = derefa(a,derefv(i,kk));
            }
        }

        res = resv;
    }

    else
    {
        constructError(a,i,res,"malformed index in derefa.");
    }

    return res;
}




gentype collapse(const gentype &a)
{
    int i,j,k,l;
    gentype res;

    if ( a.isValMatrix() )
    {
        int badres = 0;
        Vector<int> coldim(a.numCols());
	Vector<int> rowdim(a.numRows());
        Matrix<gentype> aa(a.cast_matrix(0));

	if ( aa.numRows() && aa.numCols() )
	{
	    for ( i = 0 ; ( i < aa.numRows() ) && !badres ; ++i )
	    {
		rowdim("&",i) = aa(i,0).numRows();

		for ( j = 0 ; j < aa.numCols() ; ++j )
		{
		    coldim("&",j) = aa(0,j).numCols();

		    if ( ( aa(i,j).numRows() != rowdim(i) ) || ( aa(i,j).numCols() != coldim(j) ) )
		    {
			constructError(a,res,"Element dimensions must agree in collapse.");
                        badres = 1;
                        break;
		    }
		}
	    }

	    if ( !badres )
	    {
		Matrix<gentype> mres(sum(rowdim),sum(coldim));

		k = 0;

                retMatrix<gentype> tmpma;

		for ( i = 0 ; i < aa.numRows() ; ++i )
		{
		    l = 0;

		    for ( j = 0 ; j < aa.numCols() ; ++j )
		    {
			if ( aa(i,j).isValMatrix() || aa(i,j).isValVector() )
			{
			    mres("&",k,1,k+rowdim(i)-1,l,1,l+coldim(j)-1,tmpma) = aa(i,j).cast_matrix(0);
			}

			else
			{
			    mres("&",k,l) = aa(i,j);
			}

			l += coldim(j);
		    }

		    k += rowdim(i);
		}

		res = mres;
	    }
	}

	else
	{
            res = a;
	}
    }

    else if ( a.isValVector() )
    {
        int badres = 0;
        int coldim = -1;
	Vector<int> rowdim(a.size());
        Vector<gentype> aa(a.cast_vector(0));

        if ( aa.infsize() )
        {
            constructError(a,res,"Can't collapse vector of infinite size.");
            badres = 1;
        }

	else if ( aa.size() )
	{
	    for ( i = 0 ; i < aa.size() ; ++i )
	    {
		rowdim("&",i) = aa(i).numRows();
                coldim         = aa(0).numCols();

		if ( coldim != aa(i).numCols() )
		{
		    constructError(a,res,"Element dimensions must agree in collapse.");
		    badres = 1;
		    break;
		}
	    }

	    if ( !badres )
	    {
		if ( coldim == 1 )
		{
		    Vector<gentype> vres(sum(rowdim));

		    k = 0;

                    retVector<gentype> tmpva;

		    for ( i = 0 ; i < aa.size() ; ++i )
		    {
			if ( aa(i).isValMatrix() || aa(i).isValVector() )
			{
			    vres("&",k,1,k+rowdim(i)-1,tmpva) = aa(i).cast_vector(0);
			}

			else
			{
			    vres("&",k) = aa(i);
			}

			k += rowdim(i);
		    }

                    res = vres;
		}

		else
		{
                    Matrix<gentype> mres(sum(rowdim),coldim);

		    k = 0;

                    retMatrix<gentype> tmpma;

		    for ( i = 0 ; i < aa.size() ; ++i )
		    {
			if ( aa(i).isValMatrix() || aa(i).isValVector() )
			{
			    mres("&",k,1,k+rowdim(i)-1,0,1,coldim-1,tmpma) = aa(i).cast_matrix(0);
			}

			else
			{
			    mres("&",k,0) = aa(k);
			}

			k += rowdim(i);
		    }

                    res = mres;
		}
	    }
	}

	else
	{
            res = a;
	}
    }

    else
    {
	res = a;
    }

    return res;
}






























































gentype fourProd(const gentype &a, const gentype &b, const gentype &c, const gentype &d)
{
    gentype res;

    if ( a.isValEqnDir() || b.isValEqnDir() || c.isValEqnDir() || d.isValEqnDir() )
    {
        const static gentype resx("fourProd(x,y,z,v)");
        return resx(a,b,c,d);
    }

         if ( a.isValStrErr() || b.isValStrErr() || c.isValStrErr() || d.isValStrErr() ) { constructError(a,b,c,d,res,"String 4-product not implemented"); }
    else if ( a.isValDict()   || b.isValDict()   || c.isValDict()   || d.isValDict()   ) { constructError(a,b,c,d,res,"Dict 4-product not implemented");   }
    else if ( a.isValDgraph() || b.isValDgraph() || c.isValDgraph() || d.isValDgraph() ) { constructError(a,b,c,d,res,"Dgraph 4-product not implemented"); }
    else if ( a.isValMatrix() || b.isValMatrix() || c.isValMatrix() || d.isValMatrix() ) { constructError(a,b,c,d,res,"Matrix 4-product not implemented"); }
    else if ( a.isValSet()    || b.isValSet()    || c.isValSet()    || d.isValSet()    ) { if ( ( a.size() != b.size() ) || ( b.size() != c.size() ) || ( c.size() != d.size() ) ) { constructError(a,b,c,d,res,"Size mismatch in 4-product"); } else { gentype temp; fourProduct(temp.force_double(),a.cast_set   (0),b.cast_set   (0),c.cast_set   (0),d.cast_set   (0)); res = temp; } }
    else if ( a.isValVector() || b.isValVector() || c.isValVector() || d.isValVector() ) { if ( ( a.size() != b.size() ) || ( b.size() != c.size() ) || ( c.size() != d.size() ) ) { constructError(a,b,c,d,res,"Size mismatch in 4-product"); } else { gentype temp; fourProduct(temp,a.cast_vector(0),b.cast_vector(0),c.cast_vector(0),d.cast_vector(0)); res = temp; } }
    else if ( a.isValAnion()  || b.isValAnion()  || c.isValAnion()  || d.isValAnion()  ) { res = (a.cast_anion (0))*(b.cast_anion (0))*(c.cast_anion (0))*(d.cast_anion (0)); }
    else                                                                                 { res = (a.cast_double(0))*(b.cast_double(0))*(c.cast_double(0))*(d.cast_double(0)); }
    //else if ( a.isValReal()   || b.isValReal()   || c.isValReal()   || d.isValReal()   ) { res = (a.cast_double(0))*(b.cast_double(0))*(c.cast_double(0))*(d.cast_double(0)); }
    //else                                                                                 { res = (a.cast_int(0))*(b.cast_int(0))*(c.cast_int(0))*(d.cast_int(0)); }

    return res;
}

gentype outerProd(const gentype &a, const gentype &b)
{
    gentype res;

    if ( a.isValEqnDir() || b.isValEqnDir() )
    {
        const static gentype resx("outerProd(x,y)");
        return resx(a,b);
    }

         if ( a.isValStrErr() || b.isValStrErr() ) { constructError(a,b,res,"String outer product not implemented"); }
    else if ( a.isValDict()   || b.isValDict()   ) { constructError(a,b,res,"Dict outer product not implemented");   }
    else if ( a.isValDgraph() || b.isValDgraph() ) { constructError(a,b,res,"Dgraph outer product not implemented"); }
    else if ( a.isValMatrix() || b.isValMatrix() ) { constructError(a,b,res,"Matrix outer product not implemented"); }
    else if ( a.isValSet()    || b.isValSet()    ) { constructError(a,b,res,"Set outer product not implemented");    }
    else if ( a.isValVector() || b.isValVector() ) { res = outerProduct(a.cast_vector(0),b.cast_vector(0)); }
    else if ( a.isValAnion()  || b.isValAnion()  ) { res = (a.cast_anion(0))*conj(b.cast_anion(0)); }
    else                                           { res = (a.cast_double(0))*(b.cast_double(0)); }
    //else if ( a.isValReal()   || b.isValReal()   ) { res = (a.cast_double(0))*(b.cast_double(0)); }
    //else                                           { res = (a.cast_int(0))*(b.cast_int(0)); }

    return res;
}

gentype trans(const gentype &a)
{
    gentype res;

    if ( a.isValEqnDir() )
    {
        const static gentype resx("trans(x)");
        return resx(a);
    }

    else
    {
	res = a;
        res.transpose();
    }

    return res;
}

gentype det(const gentype &a)
{
    gentype res;

    if ( a.isValEqnDir() )
    {
        const static gentype resx("det(x)");
        return resx(a);
    }

         if ( a.isValStrErr() ) { constructError(a,res,"String det not implemented"); }
    else if ( a.isValSet()    ) { constructError(a,res,"Set det not implemented");    }
    else if ( a.isValDict()   ) { constructError(a,res,"Dict det not implemented");   }
    else if ( a.isValDgraph() ) { constructError(a,res,"Dgraph det not implemented"); }
    else if ( a.isValVector() ) { constructError(a,res,"Vector det not implemented"); }
    else if ( a.isValMatrix() ) { if ( a.numRows() != a.numCols() ) { constructError(a,res,"Determinant only defined for square matrices."); } else { res = (a.cast_matrix(0)).det(); } }
    else                        { res = a; }

    return res;
}

gentype trace(const gentype &a)
{
    gentype res;

    if ( a.isValEqnDir() )
    {
        const static gentype resx("trace(x)");
        return resx(a);
    }

         if ( a.isValStrErr() ) { constructError(a,res,"String trace not implemented"); }
    else if ( a.isValSet()    ) { constructError(a,res,"Set trace not implemented");    }
    else if ( a.isValDict()   ) { constructError(a,res,"Dict trace not implemented");   }
    else if ( a.isValDgraph() ) { constructError(a,res,"Dgraph trace not implemented"); }
    else if ( a.isValVector() ) { constructError(a,res,"Vector trace not implemented"); }
    else if ( a.isValMatrix() ) { if ( a.numRows() != a.numCols() ) { constructError(a,res,"Trace only defined for square matrices."); } else { res = (a.cast_matrix(0)).trace(); } }
    else                        { res = a; }

    return res;
}

gentype miner(const gentype &a, const gentype &i, const gentype &j)
{
    gentype res;

    if ( a.isValEqnDir() || i.isValEqnDir() || j.isValEqnDir() )
    {
        const static gentype resx("miner(x,y,z)");
        return resx(a,i,j);
    }

         if ( !i.isCastableToIntegerWithoutLoss() ) { constructError(a,i,j,res,"Matrix minor requires integer coefficients"); }
    else if ( !j.isCastableToIntegerWithoutLoss() ) { constructError(a,i,j,res,"Matrix minor requires integer coefficients"); }
    else if ( !a.isValMatrix()                    ) { constructError(a,i,j,res,"Matrix minor only defined for matrices");     }
    else
    {
	if ( a.numRows() != a.numCols() )
	{
	    constructError(a,i,j,res,"miner only defined for square matrices.");
	}

	else if ( !a.numRows() )
	{
	    constructError(a,i,j,res,"miner only defined for non-empty matrices.");
	}

	else if ( ( i.cast_int(0) < 0 ) || ( i.cast_int(0) >= a.numRows() ) )
	{
	    constructError(a,i,j,res,"index out of range for miner.");
	}

	else if ( ( j.cast_int(0) < 0 ) || ( j.cast_int(0) >= a.numRows() ) )
	{
	    constructError(a,i,j,res,"index out of range for miner.");
	}

	else
	{
	    res = (a.cast_matrix(0)).miner(i.cast_int(0),j.cast_int(0));
	}
    }

    return res;
}

gentype cofactor(const gentype &a, const gentype &i, const gentype &j)
{
    gentype res;

    if ( a.isValEqnDir() || i.isValEqnDir() || j.isValEqnDir() )
    {
        const static gentype resx("cofactor(x,y,z)");
        return resx(a,i,j);
    }

         if ( !i.isCastableToIntegerWithoutLoss() ) { constructError(a,i,j,res,"Matrix cofactor requires integer coefficients"); }
    else if ( !j.isCastableToIntegerWithoutLoss() ) { constructError(a,i,j,res,"Matrix cofactor requires integer coefficients"); }
    else if ( !a.isValMatrix()                    ) { constructError(a,i,j,res,"Matrix cofactor only defined for matrices");     }
    else
    {
	if ( a.numRows() != a.numCols() )
	{
	    constructError(a,i,j,res,"cofactor only defined for square matrices.");
	}

	else if ( !a.numRows() )
	{
	    constructError(a,i,j,res,"cofactor only defined for non-empty matrices.");
	}

	else if ( ( i.cast_int(0) < 0 ) || ( i.cast_int(0) >= a.numRows() ) )
	{
	    constructError(a,i,j,res,"index out of range for cofactor.");
	}

	else if ( ( j.cast_int(0) < 0 ) || ( j.cast_int(0) >= a.numRows() ) )
	{
	    constructError(a,i,j,res,"index out of range for cofactor.");
	}

	else
	{
	    res = (a.cast_matrix(0)).cofactor(i.cast_int(0),j.cast_int(0));
	}
    }

    return res;
}

gentype adj(const gentype &a)
{
    gentype res;

    if ( a.isValEqnDir() )
    {
        const static gentype resx("adj(x)");
        return resx(a);
    }

    if ( !a.isValMatrix() ) { constructError(a,res,"adjoint only defined for matrices"); }

    else
    {
	if ( a.numRows() != a.numCols() )
	{
	    constructError(a,res,"adj only defined for square matrices.");
	}

	else if ( !a.numRows() )
	{
	    constructError(a,res,"adj only defined for non-empty matrices.");
	}

	else
	{
	    res = (a.cast_matrix(0)).adj();
	}
    }

    return res;
}







gentype polar (const gentype &x, const gentype &y, const gentype &a) { return div(add(emul(x,exp(emul(y,a))),emul(exp(emul(a,y)),x)),2_gent);          }
gentype polard(const gentype &x, const gentype &y, const gentype &a) { return div(add(emul(x,exp(emul(y,a))),emul(exp(emul(a,y)),x)),2_gent);          }
gentype polarx(const gentype &x, const gentype &a)                   { return div(add(emul(x,exp(a)),emul(exp(a),x)),2_gent);                          }
//gentype polar (const gentype &x, const gentype &y, const gentype &a) { return div(add(emul(x,exp(emul(y,a))),emul(exp(emul(a,y)),x)),twointgentype()); }
//gentype polard(const gentype &x, const gentype &y, const gentype &a) { return div(add(emul(x,exp(emul(y,a))),emul(exp(emul(a,y)),x)),twointgentype()); }
//gentype polarx(const gentype &x, const gentype &a)                   { return div(add(emul(x,exp(a)),emul(exp(a),x)),twointgentype());                 }

//gentype logb (const gentype &a, const gentype &b) { return mul(halfdblgentype(),add(logbl(a,b),logbr(a,b))); }
gentype logb (const gentype &a, const gentype &b) { return emul(einv(log(b)),log(a));                        }
gentype logbl(const gentype &a, const gentype &b) { return emul(log(a),einv(log(b)));                        }
gentype logbr(const gentype &a, const gentype &b) { return emul(einv(log(b)),log(a));                        }
//gentype Logb (const gentype &a, const gentype &b) { return mul(halfdblgentype(),add(Logbl(a,b),Logbr(a,b))); }
gentype Logb (const gentype &a, const gentype &b) { return emul(einv(Log(b)),Log(a));                        }
gentype Logbl(const gentype &a, const gentype &b) { return emul(Log(a),einv(Log(b)));                        }
gentype Logbr(const gentype &a, const gentype &b) { return emul(einv(Log(b)),Log(a));                        }

gentype commutate    (const gentype &x, const gentype &y                  ) { return div(add(emul(x,y),neg(emul(y,x))),2_gent);                          }
gentype anticommutate(const gentype &x, const gentype &y                  ) { return div(add(emul(x,y),    emul(y,x) ),2_gent);                          }
gentype associate    (const gentype &x, const gentype &y, const gentype &z) { return div(add(emul(x,emul(y,z)),neg(emul(emul(x,y),z))),2_gent);          }
gentype antiassociate(const gentype &x, const gentype &y, const gentype &z) { return div(add(emul(x,emul(y,z)),    emul(emul(x,y),z) ),2_gent);          }
//gentype commutate    (const gentype &x, const gentype &y                  ) { return div(add(emul(x,y),neg(emul(y,x))),twointgentype());                 }
//gentype anticommutate(const gentype &x, const gentype &y                  ) { return div(add(emul(x,y),    emul(y,x) ),twointgentype());                 }
//gentype associate    (const gentype &x, const gentype &y, const gentype &z) { return div(add(emul(x,emul(y,z)),neg(emul(emul(x,y),z))),twointgentype()); }
//gentype antiassociate(const gentype &x, const gentype &y, const gentype &z) { return div(add(emul(x,emul(y,z)),    emul(emul(x,y),z) ),twointgentype()); }

// bern(w,x):    returns the Bernstein polynomial of order size(w) (w is a weight vector) evaluated at x
// bernv(w):     returns the Bernstein polynomial *vector* of order size(w) (w is a weight vector)

gentype bern(const gentype &w, const gentype &x)
{
    NiceAssert( w.isCastableToVectorWithoutLoss() );
    NiceAssert( !w.infsize() );

    const Vector<gentype> &ww = w.cast_vector(0);
    int n = ww.size()-1;
    gentype nn(n);
    gentype ov(1.0);
    gentype res;

    if ( n == -1 )
    {
        res = 1.0;
    }

    else
    {
        for ( int j = 0 ; j <= n ; ++j )
        {
            gentype jj(j);
            gentype tmp;

            tmp = ww(j)*pow(x,jj)*pow(ov-x,nn-jj)*((double) xnCr(n,j));

            if ( !j )
            {
                res = tmp;
            }

            else
            {
                res += tmp;
            }
        }
    }

    return res;
}

gentype funcv(const gentype &f)
{
    // Note that the Functional vector class FuncVector has not actually been defined
    // at this point... however, the basis for *streaming* to such a class has been
    // preempted in vector.h, so we can cheat by creating a string representation 
    // of the result and then streaming that in to a regular vector.

    gentype res;
    Vector<gentype> &rres = res.force_vector(0);

    std::stringstream buffer;

    buffer << "[[ FN f: " << f  << " : 1 ]]";
    buffer >> rres;

    return res;
}

gentype rkhsv(const gentype &k, const gentype &x, const gentype &a)
{
    NiceAssert( x.isCastableToVectorWithoutLoss() );
    NiceAssert( !x.infsize() );

    NiceAssert( a.isCastableToVectorWithoutLoss() );
    NiceAssert( !a.infsize() );

    const Vector<gentype> &xx = x.cast_vector(0);
    const Vector<gentype> &aa = a.cast_vector(0);

    // Note that the RKHS vector class RKHSVector has not actually been defined
    // at this point... however, the basis for *streaming* to such a class has been
    // preempted in vector.h, so we can cheat by creating a string representation 
    // of the result and then streaming that in to a regular vector.

    gentype res;
    Vector<gentype> &rres = res.force_vector(0);

    std::stringstream buffer;

    buffer << "[[ RKHS kernel: " << k.cast_string()  << "\n   RKHS x: " << xx << "\n   RKHS a: " << aa << " ]]";
    buffer >> rres;

    return res;
}

gentype bernv(const gentype &w)
{
    NiceAssert( w.isCastableToVectorWithoutLoss() );
    NiceAssert( !w.infsize() );

    const Vector<gentype> &ww = w.cast_vector(0);

    // Note that the Bernstein vector class BernVector has not actually been defined
    // at this point... however, the basis for *streaming* to such a class has been
    // preempted in vector.h, so we can cheat by creating a string representation 
    // of the result and then streaming that in to a regular vector.

    gentype res;
    Vector<gentype> &rres = res.force_vector(0);

    std::stringstream buffer;

    buffer << "[[ Bern w: " << ww  << " ]]";
    buffer >> rres;

    return res;
}

gentype normDistr(const gentype &x)
{
    gentype res;

    if ( x.isValEqnDir() )
    {
        const static gentype resx("normDistr(x)");
        return resx(x);
    }

         if ( x.isValEqnDir() ) { constructError(x,res,"String normDistr not implemented"); }
    else if ( x.isValDgraph() ) { constructError(x,res,"Dgraph normDistr not implemented"); }
    else if ( x.isValSet()    ) { Set<gentype>    temp(x.cast_set(0));    temp.applyon(normDistr); res = temp; }
    else if ( x.isValMatrix() ) { Matrix<gentype> temp(x.cast_matrix(0)); temp.applyon(normDistr); res = temp; }
    else if ( x.isValVector() ) { Vector<gentype> temp(x.cast_vector(0)); temp.applyon(normDistr); res = temp; }
    else
    {
        res = 0.398942280401*exp((-x*x)/2.0);
    }

    return res;
}

gentype polyDistrintern(const gentype &x, const gentype &n);
gentype polyDistrintern(const gentype &x, const gentype &n)
{
    gentype res;

    if ( x.isCastableToAnionWithoutLoss() && n.isCastableToAnionWithoutLoss() )
    {
        gentype consa = gamma(div(1_gent,n));
        gentype consb = gamma(div(3_gent,n));
        gentype consc = sqrt(div(consb,consa));
//        const static gentype consa = gamma(div(oneintgentype(),n));
//        const static gentype consb = gamma(div(threeintgentype(),n));
//        const static gentype consc = sqrt(div(consb,consa));

        res = mul(mul(n,div(consc,(2.0*consa))),exp(mul(neg(pow(consc,n)),pow(x,n))));

//        res = mul(div(mul(n,sqrt(gamma(div(threeintgentype(),n))/gamma(div(oneintgentype(),n)))),mul(twointgentype(),gamma(div(oneintgentype(),n))))),exp(mul(neg(pow(sqrt(gamma(div(threeintgentype(),n))/gamma(div(oneintgentype(),n))),n)),pow(x,n))));
//        res = (mul(n,div(sqrt(div(gamma(div(threeintgentype(),n)),gamma(div(oneintgentype(),n)))),(mul(twointgentype(),gamma(div(oneintgentype(),n)))))))*  exp(mul(-((pow(sqrt(div(gamma(div(threeintgentype(),n)),gamma(div(oneintgentype(),n)))),n)),pow(x,n))));
//        res = (mul(n,div(sqrt(div(gamma(div(threeintgentype(),n)),gamma(div(oneintgentype(),n)))),(mul(twointgentype(),gamma(div(oneintgentype(),n)))))))*exp(mul-((pow(sqrt(div(gamma(div(threeintgentype(),n)),gamma(div(oneintgentype(),n)))),n)),pow(x,n)));
//        res = (mul(n,div(sqrt(div(gamma(div(threeintgentype(),n)),gamma(div(oneintgentype(),n)))),(mul(twointgentype(),gamma(div(oneintgentype(),n)))))))*exp(mul-((sqrt(div(gamma(div(threeintgentype(),n)),gamma(div(oneintgentype(),n))))^n),(x^n)));
//        res = (n*sqrt(gamma(threeintgentype()/n)/gamma(oneintgentype()/n))/(twointgentype()*gamma(oneintgentype()/n)))*exp(-(sqrt(gamma(threeintgentype()/n)/gamma(oneintgentype()/n))^n)*(x^n));
//        res = (n*sqrt(gamma(3/n)/gamma(1/n))/(2*gamma(1/n)))*exp(-(sqrt(gamma(3/n)/gamma(1/n))^n)*(x^n));
    }

    else
    {
        constructError(x,n,res,"polyDistr does not work on strings.");
    }

    return res;
}

gentype PolyDistrintern(const gentype &x, const gentype &n);
gentype PolyDistrintern(const gentype &x, const gentype &n)
{
    gentype res;

    if ( x.isCastableToAnionWithoutLoss() && n.isCastableToAnionWithoutLoss() )
    {
        res = mul(div(mul(n,Sqrt(div(gamma(div(3_gent,n)),gamma(div(1_gent,n))))),mul(2_gent,gamma(div(1_gent,n)))),exp(mul(neg(Pow(Sqrt(div(gamma(div(3_gent,n)),gamma(div(1_gent,n)))),n)),Pow(x,n))));
//        res = mul(div(mul(n,Sqrt(div(gamma(div(threeintgentype(),n)),gamma(div(oneintgentype(),n))))),mul(twointgentype(),gamma(div(oneintgentype(),n)))),exp(mul(neg(Pow(Sqrt(div(gamma(div(threeintgentype(),n)),gamma(div(oneintgentype(),n)))),n)),Pow(x,n))));
    }

    else
    {
        constructError(x,n,res,"PolyDistr does not work on strings.");
    }

    return res;
}








































gentype operator"" _gent(const char *val) { return gentype(val); }

gentype operator"" _gent(long double val) { return gentype(double(val)); }

gentype operator"" _igent    (long double val) { return gentype(d_anion(0.0, double(val))); }
gentype operator"" _iconjgent(long double val) { return gentype(d_anion(0.0,-double(val))); }

gentype operator"" _iqgent(long double valI) { return gentype(d_anion(0.0,double(valI),0.0,0.0)); }
gentype operator"" _jqgent(long double valJ) { return gentype(d_anion(0.0,0.0,double(valJ),0.0)); }
gentype operator"" _kqgent(long double valK) { return gentype(d_anion(0.0,0.0,0.0,double(valK))); }

gentype operator"" _lgent(long double vall) { return gentype(d_anion(0.0,double(vall),0.0,0.0,0.0,0.0,0.0,0.0)); }
gentype operator"" _mgent(long double valm) { return gentype(d_anion(0.0,0.0,double(valm),0.0,0.0,0.0,0.0,0.0)); }
gentype operator"" _ngent(long double valn) { return gentype(d_anion(0.0,0.0,0.0,double(valn),0.0,0.0,0.0,0.0)); }
gentype operator"" _ogent(long double valo) { return gentype(d_anion(0.0,0.0,0.0,0.0,double(valo),0.0,0.0,0.0)); }
gentype operator"" _pgent(long double valp) { return gentype(d_anion(0.0,0.0,0.0,0.0,0.0,double(valp),0.0,0.0)); }
gentype operator"" _qgent(long double valq) { return gentype(d_anion(0.0,0.0,0.0,0.0,0.0,0.0,double(valq),0.0)); }
gentype operator"" _rgent(long double valr) { return gentype(d_anion(0.0,0.0,0.0,0.0,0.0,0.0,0.0,double(valr))); }

gentype operator"" _gent(unsigned long long int val) { return gentype(int(val)); }

gentype operator"" _igent    (unsigned long long int val) { return gentype(d_anion(0.0, double(val))); }
gentype operator"" _iconjgent(unsigned long long int val) { return gentype(d_anion(0.0,-double(val))); }

gentype operator"" _iqgent(unsigned long long int valI) { return gentype(d_anion(0.0,double(valI),0.0,0.0)); }
gentype operator"" _jqgent(unsigned long long int valJ) { return gentype(d_anion(0.0,0.0,double(valJ),0.0)); }
gentype operator"" _kqgent(unsigned long long int valK) { return gentype(d_anion(0.0,0.0,0.0,double(valK))); }

gentype operator"" _lgent(unsigned long long int vall) { return gentype(d_anion(0.0,double(vall),0.0,0.0,0.0,0.0,0.0,0.0)); }
gentype operator"" _mgent(unsigned long long int valm) { return gentype(d_anion(0.0,0.0,double(valm),0.0,0.0,0.0,0.0,0.0)); }
gentype operator"" _ngent(unsigned long long int valn) { return gentype(d_anion(0.0,0.0,0.0,double(valn),0.0,0.0,0.0,0.0)); }
gentype operator"" _ogent(unsigned long long int valo) { return gentype(d_anion(0.0,0.0,0.0,0.0,double(valo),0.0,0.0,0.0)); }
gentype operator"" _pgent(unsigned long long int valp) { return gentype(d_anion(0.0,0.0,0.0,0.0,0.0,double(valp),0.0,0.0)); }
gentype operator"" _qgent(unsigned long long int valq) { return gentype(d_anion(0.0,0.0,0.0,0.0,0.0,0.0,double(valq),0.0)); }
gentype operator"" _rgent(unsigned long long int valr) { return gentype(d_anion(0.0,0.0,0.0,0.0,0.0,0.0,0.0,double(valr))); }















//phantomxyz












gentype eq(const gentype &a, const gentype &b) { gentype res; return binLogicForm(res,a,b,"eq",operator==,1); }
gentype ne(const gentype &a, const gentype &b) { gentype res; return binLogicForm(res,a,b,"ne",operator!=,0); }
gentype gt(const gentype &a, const gentype &b) { gentype res; return binLogicForm(res,a,b,"gt",operator> ,1); }
gentype ge(const gentype &a, const gentype &b) { gentype res; return binLogicForm(res,a,b,"ge",operator>=,1); }
gentype le(const gentype &a, const gentype &b) { gentype res; return binLogicForm(res,a,b,"le",operator<=,1); }
gentype lt(const gentype &a, const gentype &b) { gentype res; return binLogicForm(res,a,b,"lt",operator< ,1); }

gentype isnull  (const gentype &a) { gentype res = a; return OP_isnull  (res); }
gentype isint   (const gentype &a) { gentype res = a; return OP_isint   (res); }
gentype isreal  (const gentype &a) { gentype res = a; return OP_isreal  (res); }
gentype isanion (const gentype &a) { gentype res = a; return OP_isanion (res); }
gentype isvector(const gentype &a) { gentype res = a; return OP_isvector(res); }
gentype ismatrix(const gentype &a) { gentype res = a; return OP_ismatrix(res); }
gentype isset   (const gentype &a) { gentype res = a; return OP_isset   (res); }
gentype isdgraph(const gentype &a) { gentype res = a; return OP_isdgraph(res); }
gentype isstring(const gentype &a) { gentype res = a; return OP_isstring(res); }
gentype iserror (const gentype &a) { gentype res = a; return OP_iserror (res); }

gentype isvnan(const gentype &a) { gentype res = a; return OP_isvnan(res); }
gentype isinf (const gentype &a) { gentype res = a; return OP_isinf (res); }
gentype ispinf(const gentype &a) { gentype res = a; return OP_ispinf(res); }
gentype isninf(const gentype &a) { gentype res = a; return OP_isninf(res); }

gentype size   (const gentype &a) { gentype res = a; return OP_size   (res); }
gentype numRows(const gentype &a) { gentype res = a; return OP_numRows(res); }
gentype numCols(const gentype &a) { gentype res = a; return OP_numCols(res); }

gentype lnot     (const gentype &a) { gentype res = a; return OP_lnot     (res); }
gentype lis      (const gentype &a) { gentype res = a; return OP_lis      (res); }
gentype eabs2    (const gentype &a) { gentype res = a; return OP_eabs2    (res); }
gentype eabs1    (const gentype &a) { gentype res = a; return OP_eabs1    (res); }
gentype eabsinf  (const gentype &a) { gentype res = a; return OP_eabsinf  (res); }
gentype eabs0    (const gentype &a) { gentype res = a; return OP_eabs0    (res); }
gentype enorm2   (const gentype &a) { gentype res = a; return OP_enorm2   (res); }
gentype enorm1   (const gentype &a) { gentype res = a; return OP_enorm1   (res); }
gentype real     (const gentype &a) { gentype res = a; return OP_real     (res); }
gentype imag     (const gentype &a) { gentype res = a; return OP_imag     (res); }
gentype arg      (const gentype &a) { gentype res = a; return OP_arg      (res); }
gentype eangle   (const gentype &a) { gentype res = a; return OP_eangle   (res); }
gentype einv     (const gentype &a) { gentype res = a; return OP_einv     (res); }
gentype imagd    (const gentype &a) { gentype res = a; return OP_imagd    (res); }
gentype imagx    (const gentype &a) { gentype res = a; return OP_imagx    (res); }
gentype argd     (const gentype &a) { gentype res = a; return OP_argd     (res); }
gentype argx     (const gentype &a) { gentype res = a; return OP_argx     (res); }
gentype Imagd    (const gentype &a) { gentype res = a; return OP_Imagd    (res); }
gentype Argd     (const gentype &a) { gentype res = a; return OP_Argd     (res); }
gentype Argx     (const gentype &a) { gentype res = a; return OP_Argx     (res); }
gentype sgn      (const gentype &a) { gentype res = a; return OP_sgn      (res); }
gentype sqrt     (const gentype &a) { gentype res = a; return OP_sqrt     (res); }
gentype Sqrt     (const gentype &a) { gentype res = a; return OP_Sqrt     (res); }
gentype cbrt     (const gentype &a) { gentype res = a; return OP_cbrt     (res); }
gentype Cbrt     (const gentype &a) { gentype res = a; return OP_Cbrt     (res); }
gentype exp      (const gentype &a) { gentype res = a; return OP_exp      (res); }
gentype tenup    (const gentype &a) { gentype res = a; return OP_tenup    (res); }
gentype log      (const gentype &a) { gentype res = a; return OP_log      (res); }
gentype log10    (const gentype &a) { gentype res = a; return OP_log10    (res); }
gentype Log      (const gentype &a) { gentype res = a; return OP_Log      (res); }
gentype Log10    (const gentype &a) { gentype res = a; return OP_Log10    (res); }
gentype sin      (const gentype &a) { gentype res = a; return OP_sin      (res); }
gentype cos      (const gentype &a) { gentype res = a; return OP_cos      (res); }
gentype tan      (const gentype &a) { gentype res = a; return OP_tan      (res); }
gentype cosec    (const gentype &a) { gentype res = a; return OP_cosec    (res); }
gentype sec      (const gentype &a) { gentype res = a; return OP_sec      (res); }
gentype cot      (const gentype &a) { gentype res = a; return OP_cot      (res); }
gentype vers     (const gentype &a) { gentype res = a; return OP_vers     (res); }
gentype covers   (const gentype &a) { gentype res = a; return OP_covers   (res); }
gentype hav      (const gentype &a) { gentype res = a; return OP_hav      (res); }
gentype excosec  (const gentype &a) { gentype res = a; return OP_excosec  (res); }
gentype exsec    (const gentype &a) { gentype res = a; return OP_exsec    (res); }
gentype castrg   (const gentype &a) { gentype res = a; return OP_castrg   (res); }
gentype casctrg  (const gentype &a) { gentype res = a; return OP_casctrg  (res); }
gentype asin     (const gentype &a) { gentype res = a; return OP_asin     (res); }
gentype acos     (const gentype &a) { gentype res = a; return OP_acos     (res); }
gentype Asin     (const gentype &a) { gentype res = a; return OP_Asin     (res); }
gentype Acos     (const gentype &a) { gentype res = a; return OP_Acos     (res); }
gentype atan     (const gentype &a) { gentype res = a; return OP_atan     (res); }
gentype acosec   (const gentype &a) { gentype res = a; return OP_acosec   (res); }
gentype asec     (const gentype &a) { gentype res = a; return OP_asec     (res); }
gentype Acosec   (const gentype &a) { gentype res = a; return OP_Acosec   (res); }
gentype Asec     (const gentype &a) { gentype res = a; return OP_Asec     (res); }
gentype acot     (const gentype &a) { gentype res = a; return OP_acot     (res); }
gentype avers    (const gentype &a) { gentype res = a; return OP_avers    (res); }
gentype acovers  (const gentype &a) { gentype res = a; return OP_acovers  (res); }
gentype ahav     (const gentype &a) { gentype res = a; return OP_ahav     (res); }
gentype aexcosec (const gentype &a) { gentype res = a; return OP_aexcosec (res); }
gentype aexsec   (const gentype &a) { gentype res = a; return OP_aexsec   (res); }
gentype acastrg  (const gentype &a) { gentype res = a; return OP_acastrg  (res); }
gentype acasctrg (const gentype &a) { gentype res = a; return OP_acasctrg (res); }
gentype Avers    (const gentype &a) { gentype res = a; return OP_Avers    (res); }
gentype Acovers  (const gentype &a) { gentype res = a; return OP_Acovers  (res); }
gentype Ahav     (const gentype &a) { gentype res = a; return OP_Ahav     (res); }
gentype Aexcosec (const gentype &a) { gentype res = a; return OP_Aexcosec (res); }
gentype Aexsec   (const gentype &a) { gentype res = a; return OP_Aexsec   (res); }
gentype Acastrg  (const gentype &a) { gentype res = a; return OP_Acastrg  (res); }
gentype Acasctrg (const gentype &a) { gentype res = a; return OP_Acasctrg (res); }
gentype sinc     (const gentype &a) { gentype res = a; return OP_sinc     (res); }
gentype cosc     (const gentype &a) { gentype res = a; return OP_cosc     (res); }
gentype tanc     (const gentype &a) { gentype res = a; return OP_tanc     (res); }
gentype sinh     (const gentype &a) { gentype res = a; return OP_sinh     (res); }
gentype cosh     (const gentype &a) { gentype res = a; return OP_cosh     (res); }
gentype tanh     (const gentype &a) { gentype res = a; return OP_tanh     (res); }
gentype cosech   (const gentype &a) { gentype res = a; return OP_cosech   (res); }
gentype sech     (const gentype &a) { gentype res = a; return OP_sech     (res); }
gentype coth     (const gentype &a) { gentype res = a; return OP_coth     (res); }
gentype versh    (const gentype &a) { gentype res = a; return OP_versh    (res); }
gentype coversh  (const gentype &a) { gentype res = a; return OP_coversh  (res); }
gentype havh     (const gentype &a) { gentype res = a; return OP_havh     (res); }
gentype excosech (const gentype &a) { gentype res = a; return OP_excosech (res); }
gentype exsech   (const gentype &a) { gentype res = a; return OP_exsech   (res); }
gentype cashyp   (const gentype &a) { gentype res = a; return OP_cashyp   (res); }
gentype caschyp  (const gentype &a) { gentype res = a; return OP_caschyp  (res); }
gentype asinh    (const gentype &a) { gentype res = a; return OP_asinh    (res); }
gentype acosh    (const gentype &a) { gentype res = a; return OP_acosh    (res); }
gentype atanh    (const gentype &a) { gentype res = a; return OP_atanh    (res); }
gentype Acosh    (const gentype &a) { gentype res = a; return OP_Acosh    (res); }
gentype Atanh    (const gentype &a) { gentype res = a; return OP_Atanh    (res); }
gentype acosech  (const gentype &a) { gentype res = a; return OP_acosech  (res); }
gentype asech    (const gentype &a) { gentype res = a; return OP_asech    (res); }
gentype acoth    (const gentype &a) { gentype res = a; return OP_acoth    (res); }
gentype aversh   (const gentype &a) { gentype res = a; return OP_aversh   (res); }
gentype acovrsh  (const gentype &a) { gentype res = a; return OP_acovrsh  (res); }
gentype ahavh    (const gentype &a) { gentype res = a; return OP_ahavh    (res); }
gentype aexcosech(const gentype &a) { gentype res = a; return OP_aexcosech(res); }
gentype aexsech  (const gentype &a) { gentype res = a; return OP_aexsech  (res); }
gentype acashyp  (const gentype &a) { gentype res = a; return OP_acashyp  (res); }
gentype acaschyp (const gentype &a) { gentype res = a; return OP_acaschyp (res); }
gentype Asech    (const gentype &a) { gentype res = a; return OP_Asech    (res); }
gentype Acoth    (const gentype &a) { gentype res = a; return OP_Acoth    (res); }
gentype Aversh   (const gentype &a) { gentype res = a; return OP_Aversh   (res); }
gentype Ahavh    (const gentype &a) { gentype res = a; return OP_Ahavh    (res); }
gentype Aexsech  (const gentype &a) { gentype res = a; return OP_Aexsech  (res); }
gentype Acashyp  (const gentype &a) { gentype res = a; return OP_Acashyp  (res); }
gentype Acaschyp (const gentype &a) { gentype res = a; return OP_Acaschyp (res); }
gentype sinhc    (const gentype &a) { gentype res = a; return OP_sinhc    (res); }
gentype coshc    (const gentype &a) { gentype res = a; return OP_coshc    (res); }
gentype tanhc    (const gentype &a) { gentype res = a; return OP_tanhc    (res); }
gentype sigm     (const gentype &a) { gentype res = a; return OP_sigm     (res); }
gentype gd       (const gentype &a) { gentype res = a; return OP_gd       (res); }
gentype asigm    (const gentype &a) { gentype res = a; return OP_asigm    (res); }
gentype agd      (const gentype &a) { gentype res = a; return OP_agd      (res); }
gentype Asigm    (const gentype &a) { gentype res = a; return OP_Asigm    (res); }
gentype Agd      (const gentype &a) { gentype res = a; return OP_Agd      (res); }
gentype erf      (const gentype &a) { gentype res = a; return OP_erf      (res); }
gentype erfc     (const gentype &a) { gentype res = a; return OP_erfc     (res); }


gentype eabsp    (const gentype &a, const gentype &q) { gentype res; return elementwiseDefaultCallB(res,a,q,"eabsp"    ,&dubeabsp    ,&absp           ); }
gentype enormp   (const gentype &a, const gentype &q) { gentype res; return elementwiseDefaultCallB(res,a,q,"enormp"   ,&dubenormp   ,&normp          ); }
gentype polyDistr(const gentype &a, const gentype &q) { gentype res; return elementwiseDefaultCallB(res,a,q,"polyDistr",&dubpolyDistr,&polyDistrintern); }
gentype PolyDistr(const gentype &a, const gentype &q) { gentype res; return elementwiseDefaultCallB(res,a,q,"PolyDistr",&dubPolyDistr,&PolyDistrintern); }

gentype emul (const gentype &a, const gentype &b) { gentype res; return elementwiseDefaultCallC(res,a,b,"emul" ,emul       ,mul        ,nullptr); }
gentype ermul(const gentype &a, const gentype &b) { gentype res; return elementwiseDefaultCallC(res,a,b,"ermul",ermul      ,rmul       ,nullptr); }
gentype ediv (const gentype &a, const gentype &b) { gentype res; return elementwiseDefaultCallC(res,a,b,"ediv" ,ediv       ,div        ,nullptr); }
gentype eidiv(const gentype &a, const gentype &b) { gentype res; return elementwiseDefaultCallC(res,a,b,"eidiv",eidiv      ,idiv       ,nullptr); }
gentype erdiv(const gentype &a, const gentype &b) { gentype res; return elementwiseDefaultCallC(res,a,b,"erdiv",erdiv      ,rdiv       ,nullptr); }
gentype emod (const gentype &a, const gentype &b) { gentype res; return elementwiseDefaultCallC(res,a,b,"emod" ,emod       ,mod        ,nullptr); }
gentype epow (const gentype &a, const gentype &b) { gentype res; return elementwiseDefaultCallC(res,a,b,"epow" ,epow       ,pow        ,nullptr); }
gentype Epow (const gentype &a, const gentype &b) { gentype res; return elementwiseDefaultCallC(res,a,b,"Epow" ,Epow       ,Pow        ,nullptr); }
gentype epowl(const gentype &a, const gentype &b) { gentype res; return elementwiseDefaultCallC(res,a,b,"epowl",epowl      ,powl       ,nullptr); }
gentype Epowl(const gentype &a, const gentype &b) { gentype res; return elementwiseDefaultCallC(res,a,b,"Epowl",Epowl      ,Powl       ,nullptr); }
gentype epowr(const gentype &a, const gentype &b) { gentype res; return elementwiseDefaultCallC(res,a,b,"epowr",epowr      ,powr       ,nullptr); }
gentype Epowr(const gentype &a, const gentype &b) { gentype res; return elementwiseDefaultCallC(res,a,b,"Epowr",Epowr      ,Powr       ,nullptr); }
gentype nthrt(const gentype &a, const gentype &b) { gentype res; return elementwiseDefaultCallC(res,a,b,"nthrt",nthrtintern,nthrtintern,nullptr); }
gentype Nthrt(const gentype &a, const gentype &b) { gentype res; return elementwiseDefaultCallC(res,a,b,"Nthrt",Nthrtintern,Nthrtintern,nullptr); }
gentype eeq  (const gentype &a, const gentype &b) { gentype res; return elementwiseDefaultCallC(res,a,b,"eeq"  ,eeq        ,eq         ,nullptr); }
gentype ene  (const gentype &a, const gentype &b) { gentype res; return elementwiseDefaultCallC(res,a,b,"ene"  ,ene        ,ne         ,nullptr); }
gentype egt  (const gentype &a, const gentype &b) { gentype res; return elementwiseDefaultCallC(res,a,b,"egt"  ,egt        ,gt         ,nullptr); }
gentype ege  (const gentype &a, const gentype &b) { gentype res; return elementwiseDefaultCallC(res,a,b,"ege"  ,ege        ,ge         ,nullptr); }
gentype ele  (const gentype &a, const gentype &b) { gentype res; return elementwiseDefaultCallC(res,a,b,"ele"  ,ele        ,le         ,nullptr); }
gentype elt  (const gentype &a, const gentype &b) { gentype res; return elementwiseDefaultCallC(res,a,b,"elt"  ,elt        ,lt         ,nullptr); }
gentype lor  (const gentype &a, const gentype &b) { gentype res; return elementwiseDefaultCallC(res,a,b,"lor"  ,lor        ,nullptr    ,orOR   ); }
gentype lnor (const gentype &a, const gentype &b) { gentype res; return elementwiseDefaultCallC(res,a,b,"lnor" ,lnor       ,nullptr    ,norOR  ); }
gentype land (const gentype &a, const gentype &b) { gentype res; return elementwiseDefaultCallC(res,a,b,"land" ,land       ,nullptr    ,andOR  ); }
gentype lnand(const gentype &a, const gentype &b) { gentype res; return elementwiseDefaultCallC(res,a,b,"lnand",lnand      ,nullptr    ,nandOR ); }
gentype lxor (const gentype &a, const gentype &b) { gentype res; return elementwiseDefaultCallC(res,a,b,"lxor" ,lxor       ,nullptr    ,xorOR  ); }
gentype lxand(const gentype &a, const gentype &b) { gentype res; return elementwiseDefaultCallC(res,a,b,"lxand",lxand      ,nullptr    ,xandOR ); }

gentype max       (const gentype &a) { gentype res; int i,j; return zaxmincommonform(res,a,"max"       ,max       ,max    ,nullptr,max    ,i,j,0,0,0); }
gentype min       (const gentype &a) { gentype res; int i,j; return zaxmincommonform(res,a,"min"       ,min       ,min    ,nullptr,min    ,i,j,0,0,0); }
gentype maxabs    (const gentype &a) { gentype res; int i,j; return maxmincommonform(res,a,"maxabs"    ,maxabs    ,maxabs ,nullptr,maxabs ,i,j,0,1,0); }
gentype minabs    (const gentype &a) { gentype res; int i,j; return maxmincommonform(res,a,"minabs"    ,minabs    ,minabs ,nullptr,minabs ,i,j,0,1,0); }
gentype maxdiag   (const gentype &a) { gentype res; int i,j; return zaxmincommonform(res,a,"maxdiag"   ,maxdiag   ,nullptr,nullptr,nullptr,i,j,0,0,0); }
gentype mindiag   (const gentype &a) { gentype res; int i,j; return zaxmincommonform(res,a,"mindiag"   ,mindiag   ,nullptr,nullptr,nullptr,i,j,0,0,0); }
gentype maxabsdiag(const gentype &a) { gentype res; int i,j; return maxmincommonform(res,a,"maxabsdiag",maxabsdiag,nullptr,nullptr,nullptr,i,j,0,1,0); }
gentype minabsdiag(const gentype &a) { gentype res; int i,j; return maxmincommonform(res,a,"minabsdiag",minabsdiag,nullptr,nullptr,nullptr,i,j,0,1,0); }

gentype argmax       (const gentype &a) { gentype res; int i,j; return zaxmincommonform(res,a,"argmax"       ,max       ,max    ,nullptr,nullptr,i,j,1,0,0); }
gentype argmin       (const gentype &a) { gentype res; int i,j; return zaxmincommonform(res,a,"argmin"       ,min       ,min    ,nullptr,nullptr,i,j,1,0,0); }
gentype argmaxabs    (const gentype &a) { gentype res; int i,j; return maxmincommonform(res,a,"argmaxabs"    ,maxabs    ,maxabs ,nullptr,nullptr,i,j,1,1,0); }
gentype argminabs    (const gentype &a) { gentype res; int i,j; return maxmincommonform(res,a,"argminabs"    ,minabs    ,minabs ,nullptr,nullptr,i,j,1,1,0); }
gentype argmaxdiag   (const gentype &a) { gentype res; int i,j; return zaxmincommonform(res,a,"argmaxdiag"   ,maxdiag   ,nullptr,nullptr,nullptr,i,j,1,0,0); }
gentype argmindiag   (const gentype &a) { gentype res; int i,j; return zaxmincommonform(res,a,"argmindiag"   ,mindiag   ,nullptr,nullptr,nullptr,i,j,1,0,0); }
gentype argmaxabsdiag(const gentype &a) { gentype res; int i,j; return maxmincommonform(res,a,"argmaxabsdiag",maxabsdiag,nullptr,nullptr,nullptr,i,j,1,1,0); }
gentype argminabsdiag(const gentype &a) { gentype res; int i,j; return maxmincommonform(res,a,"argminabsdiag",minabsdiag,nullptr,nullptr,nullptr,i,j,1,1,0); }

gentype allargmax       (const gentype &a) { gentype res; int i,j; return zaxmincommonform(res,a,"argmax"       ,max       ,max    ,nullptr,nullptr,i,j,1,0,1); }
gentype allargmin       (const gentype &a) { gentype res; int i,j; return zaxmincommonform(res,a,"argmin"       ,min       ,min    ,nullptr,nullptr,i,j,1,0,1); }
gentype allargmaxabs    (const gentype &a) { gentype res; int i,j; return maxmincommonform(res,a,"argmaxabs"    ,maxabs    ,maxabs ,nullptr,nullptr,i,j,1,1,1); }
gentype allargminabs    (const gentype &a) { gentype res; int i,j; return maxmincommonform(res,a,"argminabs"    ,minabs    ,minabs ,nullptr,nullptr,i,j,1,1,1); }
gentype allargmaxdiag   (const gentype &a) { gentype res; int i,j; return zaxmincommonform(res,a,"argmaxdiag"   ,maxdiag   ,nullptr,nullptr,nullptr,i,j,1,0,1); }
gentype allargmindiag   (const gentype &a) { gentype res; int i,j; return zaxmincommonform(res,a,"argmindiag"   ,mindiag   ,nullptr,nullptr,nullptr,i,j,1,0,1); }
gentype allargmaxabsdiag(const gentype &a) { gentype res; int i,j; return maxmincommonform(res,a,"argmaxabsdiag",maxabsdiag,nullptr,nullptr,nullptr,i,j,1,1,1); }
gentype allargminabsdiag(const gentype &a) { gentype res; int i,j; return maxmincommonform(res,a,"argminabsdiag",minabsdiag,nullptr,nullptr,nullptr,i,j,1,1,1); }

gentype sum      (const gentype &a) { gentype res; int i,j; return maxmincommonform(res,a,"sum"      ,nullptr,nullptr,sum    ,sum    ,i,j,0,0,0); }
gentype prod     (const gentype &a) { gentype res; int i,j; return maxmincommonform(res,a,"prod"     ,nullptr,nullptr,prod   ,prod   ,i,j,0,0,0); }
gentype Prod     (const gentype &a) { gentype res; int i,j; return maxmincommonform(res,a,"Prod"     ,nullptr,nullptr,Prod   ,Prod   ,i,j,0,0,0); }
gentype mean     (const gentype &a) { gentype res; int i,j; return maxmincommonform(res,a,"mean"     ,nullptr,nullptr,mean   ,mean   ,i,j,0,0,0); }
gentype median   (const gentype &a) { gentype res; int i,j; return zaxmincommonform(res,a,"median"   ,nullptr,median ,nullptr,median ,i,j,0,0,0); }
gentype argmedian(const gentype &a) { gentype res; int i,j; return zaxmincommonform(res,a,"argmedian",nullptr,median ,nullptr,nullptr,i,j,1,0,0); }

gentype pow  (const gentype &a, const gentype &b) { return powintern (a,b); }
gentype powl (const gentype &a, const gentype &b) { return powlintern(a,b); }
gentype powr (const gentype &a, const gentype &b) { return powrintern(a,b); }
gentype Pow  (const gentype &a, const gentype &b) { return Powintern (a,b); }
gentype Powl (const gentype &a, const gentype &b) { return Powlintern(a,b); }
gentype Powr (const gentype &a, const gentype &b) { return Powrintern(a,b); }































































gentype &OP_lnot     (gentype &a) { const static gentype fnbare("lnot(x)");      return OP_elementwiseDefaultCallA(a,fnbare,"lnot"     ,&OP_lnot     ,nullptr   ,nullptr   ,nullptr      ,&invertOR,&falseOR   ); }
gentype &OP_lis      (gentype &a) { const static gentype fnbare("lis(x)");       return OP_elementwiseDefaultCallA(a,fnbare,"lis"      ,&OP_lis      ,nullptr   ,nullptr   ,nullptr      ,&bufferOR,&falseOR   ); }
gentype &OP_eabs2    (gentype &a) { const static gentype fnbare("eabs2(x)");     return OP_elementwiseDefaultCallA(a,fnbare,"eabs2"    ,&OP_eabs2    ,nullptr   ,&abs2     ,&abs2     ,&abs2    ,&falseOR   ); }
gentype &OP_eabs1    (gentype &a) { const static gentype fnbare("eabs1(x)");     return OP_elementwiseDefaultCallA(a,fnbare,"eabs1"    ,&OP_eabs1    ,nullptr   ,&abs1     ,&abs1     ,&abs1    ,&falseOR   ); }
gentype &OP_eabsinf  (gentype &a) { const static gentype fnbare("eabsinf(x)");   return OP_elementwiseDefaultCallA(a,fnbare,"eabsinf"  ,&OP_eabsinf  ,nullptr   ,&absinf   ,&absinf   ,&absinf  ,&falseOR   ); }
gentype &OP_eabs0    (gentype &a) { const static gentype fnbare("eabs0(x)");     return OP_elementwiseDefaultCallA(a,fnbare,"eabs0"    ,&OP_eabs0    ,nullptr   ,&abs0     ,&abs0     ,&abs0    ,&falseOR   ); }
gentype &OP_enorm2   (gentype &a) { const static gentype fnbare("enorm2(x)");    return OP_elementwiseDefaultCallA(a,fnbare,"enorm2"   ,&OP_enorm2   ,nullptr   ,&norm2    ,&norm2    ,&norm2   ,&falseOR   ); }
gentype &OP_enorm1   (gentype &a) { const static gentype fnbare("enorm1(x)");    return OP_elementwiseDefaultCallA(a,fnbare,"enorm1"   ,&OP_enorm1   ,nullptr   ,&norm1    ,&norm1    ,&norm1   ,&falseOR   ); }
gentype &OP_real     (gentype &a) { const static gentype fnbare("real(x)");      return OP_elementwiseDefaultCallA(a,fnbare,"real"     ,&OP_real     ,nullptr   ,&real     ,&real     ,&real    ,&falseOR   ); }
gentype &OP_imag     (gentype &a) { const static gentype fnbare("imag(x)");      return OP_elementwiseDefaultCallA(a,fnbare,"imag"     ,&OP_imag     ,nullptr   ,&imag     ,&imag     ,&imag    ,&falseOR   ); }
gentype &OP_arg      (gentype &a) { const static gentype fnbare("arg(x)");       return OP_elementwiseDefaultCallA(a,fnbare,"arg"      ,&OP_arg      ,nullptr   ,&arg      ,&arg      ,nullptr     ,&falseOR   ); }
gentype &OP_eangle   (gentype &a) { const static gentype fnbare("eangle(x)");    return OP_elementwiseDefaultCallA(a,fnbare,"eangle"   ,&OP_eangle   ,&angle    ,nullptr   ,&angle    ,nullptr     ,&falseOR   ); }
gentype &OP_einv     (gentype &a) { const static gentype fnbare("einv(x)");      return OP_elementwiseDefaultCallA(a,fnbare,"einv"     ,&OP_einv     ,&inv      ,nullptr   ,&inv      ,nullptr     ,&falseOR   ); }
gentype &OP_imagd    (gentype &a) { const static gentype fnbare("imagd(x)");     return OP_elementwiseDefaultCallA(a,fnbare,"imagd"    ,&OP_imagd    ,&imagd    ,nullptr   ,nullptr      ,nullptr     ,&trueOR    ); }
gentype &OP_imagx    (gentype &a) { const static gentype fnbare("imagx(x)");     return OP_elementwiseDefaultCallA(a,fnbare,"imagx"    ,&OP_imagx    ,&imagx    ,nullptr   ,&imagx    ,&imagx   ,&falseOR   ); }
gentype &OP_argd     (gentype &a) { const static gentype fnbare("argd(x)");      return OP_elementwiseDefaultCallA(a,fnbare,"argd"     ,&OP_argd     ,&argd     ,nullptr   ,nullptr      ,nullptr     ,&trueOR    ); }
gentype &OP_argx     (gentype &a) { const static gentype fnbare("argx(x)");      return OP_elementwiseDefaultCallA(a,fnbare,"argx"     ,&OP_argx     ,&argx     ,nullptr   ,nullptr      ,nullptr     ,&trueOR    ); }
gentype &OP_Imagd    (gentype &a) { const static gentype fnbare("Imagd(x)");     return OP_elementwiseDefaultCallA(a,fnbare,"Imagd"    ,&OP_Imagd    ,&Imagd    ,nullptr   ,nullptr      ,nullptr     ,&trueOR    ); }
gentype &OP_Argd     (gentype &a) { const static gentype fnbare("Argd(x)");      return OP_elementwiseDefaultCallA(a,fnbare,"Argd"     ,&OP_Argd     ,&Argd     ,nullptr   ,nullptr      ,nullptr     ,&trueOR    ); }
gentype &OP_Argx     (gentype &a) { const static gentype fnbare("Argx(x)");      return OP_elementwiseDefaultCallA(a,fnbare,"Argx"     ,&OP_Argx     ,&Argx     ,nullptr   ,nullptr      ,nullptr     ,&trueOR    ); }
gentype &OP_sgn      (gentype &a) { const static gentype fnbare("sgn(x)");       return OP_elementwiseDefaultCallA(a,fnbare,"sgn"      ,&OP_sgn      ,&sgn      ,nullptr   ,&sgn      ,&sgn     ,&falseOR   ); }
gentype &OP_sqrt     (gentype &a) { const static gentype fnbare("sqrt(x)");      return OP_elementwiseDefaultCallA(a,fnbare,"sqrt"     ,&OP_sqrt     ,&sqrt     ,nullptr   ,&sqrt     ,nullptr     ,&sqrtOR    ); }
gentype &OP_Sqrt     (gentype &a) { const static gentype fnbare("Sqrt(x)");      return OP_elementwiseDefaultCallA(a,fnbare,"Sqrt"     ,&OP_Sqrt     ,&Sqrt     ,nullptr   ,&sqrt     ,nullptr     ,&sqrtOR    ); }
gentype &OP_cbrt     (gentype &a) { const static gentype fnbare("cbrt(x)");      return OP_elementwiseDefaultCallA(a,fnbare,"cbrt"     ,&OP_cbrt     ,&cbrt     ,nullptr   ,&cbrt     ,nullptr     ,&falseOR   ); }
gentype &OP_Cbrt     (gentype &a) { const static gentype fnbare("Cbrt(x)");      return OP_elementwiseDefaultCallA(a,fnbare,"Cbrt"     ,&OP_Cbrt     ,&Cbrt     ,nullptr   ,&cbrt     ,nullptr     ,&falseOR   ); }
gentype &OP_exp      (gentype &a) { const static gentype fnbare("exp(x)");       return OP_elementwiseDefaultCallA(a,fnbare,"exp"      ,&OP_exp      ,&exp      ,nullptr   ,&exp      ,nullptr     ,&falseOR   ); }
gentype &OP_tenup    (gentype &a) { const static gentype fnbare("tenup(x)");     return OP_elementwiseDefaultCallA(a,fnbare,"tenup"    ,&OP_tenup    ,&tenup    ,nullptr   ,&tenup    ,nullptr     ,&falseOR   ); }
gentype &OP_log      (gentype &a) { const static gentype fnbare("log(x)");       return OP_elementwiseDefaultCallA(a,fnbare,"log"      ,&OP_log      ,&log      ,nullptr   ,&log      ,nullptr     ,&logOR     ); }
gentype &OP_log10    (gentype &a) { const static gentype fnbare("log10(x)");     return OP_elementwiseDefaultCallA(a,fnbare,"log10"    ,&OP_log10    ,&log10    ,nullptr   ,&log10    ,nullptr     ,&log10OR   ); }
gentype &OP_Log      (gentype &a) { const static gentype fnbare("Log(x)");       return OP_elementwiseDefaultCallA(a,fnbare,"Log"      ,&OP_Log      ,&Log      ,nullptr   ,&log      ,nullptr     ,&logOR     ); }
gentype &OP_Log10    (gentype &a) { const static gentype fnbare("Log10(x)");     return OP_elementwiseDefaultCallA(a,fnbare,"Log10"    ,&OP_Log10    ,&Log10    ,nullptr   ,&log10    ,nullptr     ,&log10OR   ); }
gentype &OP_sin      (gentype &a) { const static gentype fnbare("sin(x)");       return OP_elementwiseDefaultCallA(a,fnbare,"sin"      ,&OP_sin      ,&sin      ,nullptr   ,&sin      ,nullptr     ,&falseOR   ); }
gentype &OP_cos      (gentype &a) { const static gentype fnbare("cos(x)");       return OP_elementwiseDefaultCallA(a,fnbare,"cos"      ,&OP_cos      ,&cos      ,nullptr   ,&cos      ,nullptr     ,&falseOR   ); }
gentype &OP_tan      (gentype &a) { const static gentype fnbare("tan(x)");       return OP_elementwiseDefaultCallA(a,fnbare,"tan"      ,&OP_tan      ,&tan      ,nullptr   ,&tan      ,nullptr     ,&falseOR   ); }
gentype &OP_cosec    (gentype &a) { const static gentype fnbare("cosec(x)");     return OP_elementwiseDefaultCallA(a,fnbare,"cosec"    ,&OP_cosec    ,&cosec    ,nullptr   ,&cosec    ,nullptr     ,&falseOR   ); }
gentype &OP_sec      (gentype &a) { const static gentype fnbare("sec(x)");       return OP_elementwiseDefaultCallA(a,fnbare,"sec"      ,&OP_sec      ,&sec      ,nullptr   ,&sec      ,nullptr     ,&falseOR   ); }
gentype &OP_cot      (gentype &a) { const static gentype fnbare("cot(x)");       return OP_elementwiseDefaultCallA(a,fnbare,"cot"      ,&OP_cot      ,&cot      ,nullptr   ,&cot      ,nullptr     ,&falseOR   ); }
gentype &OP_vers     (gentype &a) { const static gentype fnbare("vers(x)");      return OP_elementwiseDefaultCallA(a,fnbare,"vers"     ,&OP_vers     ,&vers     ,nullptr   ,&vers     ,nullptr     ,&falseOR   ); }
gentype &OP_covers   (gentype &a) { const static gentype fnbare("covers(x)");    return OP_elementwiseDefaultCallA(a,fnbare,"covers"   ,&OP_covers   ,&covers   ,nullptr   ,&covers   ,nullptr     ,&falseOR   ); }
gentype &OP_hav      (gentype &a) { const static gentype fnbare("hav(x)");       return OP_elementwiseDefaultCallA(a,fnbare,"hav"      ,&OP_hav      ,&hav      ,nullptr   ,&hav      ,nullptr     ,&falseOR   ); }
gentype &OP_excosec  (gentype &a) { const static gentype fnbare("excosec(x)");   return OP_elementwiseDefaultCallA(a,fnbare,"excosec"  ,&OP_excosec  ,&excosec  ,nullptr   ,&excosec  ,nullptr     ,&falseOR   ); }
gentype &OP_exsec    (gentype &a) { const static gentype fnbare("exsec(x)");     return OP_elementwiseDefaultCallA(a,fnbare,"exsec"    ,&OP_exsec    ,&exsec    ,nullptr   ,&exsec    ,nullptr     ,&falseOR   ); }
gentype &OP_castrg   (gentype &a) { const static gentype fnbare("castrg(x)");    return OP_elementwiseDefaultCallA(a,fnbare,"castrg"   ,&OP_castrg   ,&castrg   ,nullptr   ,&castrg   ,nullptr     ,&falseOR   ); }
gentype &OP_casctrg  (gentype &a) { const static gentype fnbare("casctrg(x)");   return OP_elementwiseDefaultCallA(a,fnbare,"casctrg"  ,&OP_casctrg  ,&casctrg  ,nullptr   ,&casctrg  ,nullptr     ,&falseOR   ); }
gentype &OP_asin     (gentype &a) { const static gentype fnbare("asin(x)");      return OP_elementwiseDefaultCallA(a,fnbare,"asin"     ,&OP_asin     ,&asin     ,nullptr   ,&asin     ,nullptr     ,&asinOR    ); }
gentype &OP_acos     (gentype &a) { const static gentype fnbare("acos(x)");      return OP_elementwiseDefaultCallA(a,fnbare,"acos"     ,&OP_acos     ,&acos     ,nullptr   ,&acos     ,nullptr     ,&acosOR    ); }
gentype &OP_Asin     (gentype &a) { const static gentype fnbare("Asin(x)");      return OP_elementwiseDefaultCallA(a,fnbare,"Asin"     ,&OP_Asin     ,&Asin     ,nullptr   ,&asin     ,nullptr     ,&asinOR    ); }
gentype &OP_Acos     (gentype &a) { const static gentype fnbare("Acos(x)");      return OP_elementwiseDefaultCallA(a,fnbare,"Acos"     ,&OP_Acos     ,&Acos     ,nullptr   ,&acos     ,nullptr     ,&acosOR    ); }
gentype &OP_atan     (gentype &a) { const static gentype fnbare("atan(x)");      return OP_elementwiseDefaultCallA(a,fnbare,"atan"     ,&OP_atan     ,&atan     ,nullptr   ,&atan     ,nullptr     ,&falseOR   ); }
gentype &OP_acosec   (gentype &a) { const static gentype fnbare("acosec(x)");    return OP_elementwiseDefaultCallA(a,fnbare,"acosec"   ,&OP_acosec   ,&acosec   ,nullptr   ,&acosec   ,nullptr     ,&acosecOR  ); }
gentype &OP_asec     (gentype &a) { const static gentype fnbare("asec(x)");      return OP_elementwiseDefaultCallA(a,fnbare,"asec"     ,&OP_asec     ,&asec     ,nullptr   ,&asec     ,nullptr     ,&asecOR    ); }
gentype &OP_Acosec   (gentype &a) { const static gentype fnbare("Acosec(x)");    return OP_elementwiseDefaultCallA(a,fnbare,"Acosec"   ,&OP_Acosec   ,&Acosec   ,nullptr   ,&acosec   ,nullptr     ,&acosecOR  ); }
gentype &OP_Asec     (gentype &a) { const static gentype fnbare("Asec(x)");      return OP_elementwiseDefaultCallA(a,fnbare,"Asec"     ,&OP_Asec     ,&Asec     ,nullptr   ,&asec     ,nullptr     ,&asecOR    ); }
gentype &OP_acot     (gentype &a) { const static gentype fnbare("acot(x)");      return OP_elementwiseDefaultCallA(a,fnbare,"acot"     ,&OP_acot     ,&acot     ,nullptr   ,&acot     ,nullptr     ,&falseOR   ); }
gentype &OP_avers    (gentype &a) { const static gentype fnbare("avers(x)");     return OP_elementwiseDefaultCallA(a,fnbare,"avers"    ,&OP_avers    ,&avers    ,nullptr   ,&avers    ,nullptr     ,&aversOR   ); }
gentype &OP_acovers  (gentype &a) { const static gentype fnbare("acovers(x)");   return OP_elementwiseDefaultCallA(a,fnbare,"acovers"  ,&OP_acovers  ,&acovers  ,nullptr   ,&acovers  ,nullptr     ,&acoversOR ); }
gentype &OP_ahav     (gentype &a) { const static gentype fnbare("ahav(x)");      return OP_elementwiseDefaultCallA(a,fnbare,"ahav"     ,&OP_ahav     ,&ahav     ,nullptr   ,&ahav     ,nullptr     ,&ahavOR    ); }
gentype &OP_aexcosec (gentype &a) { const static gentype fnbare("aexcosec(x)");  return OP_elementwiseDefaultCallA(a,fnbare,"aexcosec" ,&OP_aexcosec ,&aexcosec ,nullptr   ,&aexcosec ,nullptr     ,&aexcosecOR); }
gentype &OP_aexsec   (gentype &a) { const static gentype fnbare("aexsec(x)");    return OP_elementwiseDefaultCallA(a,fnbare,"aexsec"   ,&OP_aexsec   ,&aexsec   ,nullptr   ,&aexsec   ,nullptr     ,&aexsecOR  ); }
gentype &OP_acastrg  (gentype &a) { const static gentype fnbare("acastrg(x)");   return OP_elementwiseDefaultCallA(a,fnbare,"acastrg"  ,&OP_acastrg  ,&acastrg  ,nullptr   ,&acastrg  ,nullptr     ,&acastrgOR); }
gentype &OP_acasctrg (gentype &a) { const static gentype fnbare("acasctrg(x)");  return OP_elementwiseDefaultCallA(a,fnbare,"acasctrg" ,&OP_acasctrg ,&acasctrg ,nullptr   ,&acasctrg ,nullptr     ,&acasctrgOR); }
gentype &OP_Avers    (gentype &a) { const static gentype fnbare("Avers(x)");     return OP_elementwiseDefaultCallA(a,fnbare,"Avers"    ,&OP_Avers    ,&Avers    ,nullptr   ,&avers    ,nullptr     ,&aversOR   ); }
gentype &OP_Acovers  (gentype &a) { const static gentype fnbare("Acovers(x)");   return OP_elementwiseDefaultCallA(a,fnbare,"Acovers"  ,&OP_Acovers  ,&Acovers  ,nullptr   ,&acovers  ,nullptr     ,&acoversOR ); }
gentype &OP_Ahav     (gentype &a) { const static gentype fnbare("Ahav(x)");      return OP_elementwiseDefaultCallA(a,fnbare,"Ahav"     ,&OP_Ahav     ,&Ahav     ,nullptr   ,&ahav     ,nullptr     ,&ahavOR    ); }
gentype &OP_Aexcosec (gentype &a) { const static gentype fnbare("Aexcosec(x)");  return OP_elementwiseDefaultCallA(a,fnbare,"Aexcosec" ,&OP_Aexcosec ,&Aexcosec ,nullptr   ,&aexcosec ,nullptr     ,&aexcosecOR); }
gentype &OP_Aexsec   (gentype &a) { const static gentype fnbare("Aexsec(x)");    return OP_elementwiseDefaultCallA(a,fnbare,"Aexsec"   ,&OP_Aexsec   ,&Aexsec   ,nullptr   ,&aexsec   ,nullptr     ,&aexsecOR  ); }
gentype &OP_Acastrg  (gentype &a) { const static gentype fnbare("Acastrg(x)");   return OP_elementwiseDefaultCallA(a,fnbare,"Acastrg"  ,&OP_Acastrg  ,&Acastrg  ,nullptr   ,&acastrg  ,nullptr     ,&acastrgOR);  }
gentype &OP_Acasctrg (gentype &a) { const static gentype fnbare("Acasctrg(x)");  return OP_elementwiseDefaultCallA(a,fnbare,"Acasctrg" ,&OP_Acasctrg ,&Acasctrg ,nullptr   ,&acasctrg ,nullptr     ,&acasctrgOR); }
gentype &OP_sinc     (gentype &a) { const static gentype fnbare("sinc(x)");      return OP_elementwiseDefaultCallA(a,fnbare,"sinc"     ,&OP_sinc     ,&sinc     ,nullptr   ,&sinc     ,nullptr     ,&falseOR   ); }
gentype &OP_cosc     (gentype &a) { const static gentype fnbare("cosc(x)");      return OP_elementwiseDefaultCallA(a,fnbare,"cosc"     ,&OP_cosc     ,&cosc     ,nullptr   ,&cosc     ,nullptr     ,&falseOR   ); }
gentype &OP_tanc     (gentype &a) { const static gentype fnbare("tanc(x)");      return OP_elementwiseDefaultCallA(a,fnbare,"tanc"     ,&OP_tanc     ,&tanh     ,nullptr   ,&tanc     ,nullptr     ,&falseOR   ); }
gentype &OP_sinh     (gentype &a) { const static gentype fnbare("sinh(x)");      return OP_elementwiseDefaultCallA(a,fnbare,"sinh"     ,&OP_sinh     ,&sinh     ,nullptr   ,&sinh     ,nullptr     ,&falseOR   ); }
gentype &OP_cosh     (gentype &a) { const static gentype fnbare("cosh(x)");      return OP_elementwiseDefaultCallA(a,fnbare,"cosh"     ,&OP_cosh     ,&cosh     ,nullptr   ,&cosh     ,nullptr     ,&falseOR   ); }
gentype &OP_tanh     (gentype &a) { const static gentype fnbare("tanh(x)");      return OP_elementwiseDefaultCallA(a,fnbare,"tanh"     ,&OP_tanh     ,&tanh     ,nullptr   ,&tanh     ,nullptr     ,&falseOR   ); }
gentype &OP_cosech   (gentype &a) { const static gentype fnbare("cosech(x)");    return OP_elementwiseDefaultCallA(a,fnbare,"cosech"   ,&OP_cosech   ,&cosech   ,nullptr   ,&cosech   ,nullptr     ,&falseOR   ); }
gentype &OP_sech     (gentype &a) { const static gentype fnbare("sech(x)");      return OP_elementwiseDefaultCallA(a,fnbare,"sech"     ,&OP_sech     ,&sech     ,nullptr   ,&sech     ,nullptr     ,&falseOR   ); }
gentype &OP_coth     (gentype &a) { const static gentype fnbare("coth(x)");      return OP_elementwiseDefaultCallA(a,fnbare,"coth"     ,&OP_coth     ,&coth     ,nullptr   ,&coth     ,nullptr     ,&falseOR   ); }
gentype &OP_versh    (gentype &a) { const static gentype fnbare("versh(x)");     return OP_elementwiseDefaultCallA(a,fnbare,"versh"    ,&OP_versh    ,&versh    ,nullptr   ,&versh    ,nullptr     ,&falseOR   ); }
gentype &OP_coversh  (gentype &a) { const static gentype fnbare("coversh(x)");   return OP_elementwiseDefaultCallA(a,fnbare,"coversh"  ,&OP_coversh  ,&coversh  ,nullptr   ,&coversh  ,nullptr     ,&falseOR   ); }
gentype &OP_havh     (gentype &a) { const static gentype fnbare("havh(x)");      return OP_elementwiseDefaultCallA(a,fnbare,"havh"     ,&OP_havh     ,&havh     ,nullptr   ,&havh     ,nullptr     ,&falseOR   ); }
gentype &OP_excosech (gentype &a) { const static gentype fnbare("excosech(x)");  return OP_elementwiseDefaultCallA(a,fnbare,"excosech" ,&OP_excosech ,&excosech ,nullptr   ,&excosech ,nullptr     ,&falseOR   ); }
gentype &OP_exsech   (gentype &a) { const static gentype fnbare("exsech(x)");    return OP_elementwiseDefaultCallA(a,fnbare,"exsech"   ,&OP_exsech   ,&exsech   ,nullptr   ,&exsech   ,nullptr     ,&falseOR   ); }
gentype &OP_cashyp   (gentype &a) { const static gentype fnbare("cashyp(x)");    return OP_elementwiseDefaultCallA(a,fnbare,"cashyp"   ,&OP_cashyp   ,&cashyp   ,nullptr   ,&cashyp   ,nullptr     ,&falseOR   ); }
gentype &OP_caschyp  (gentype &a) { const static gentype fnbare("caschyp(x)");   return OP_elementwiseDefaultCallA(a,fnbare,"caschyp"  ,&OP_caschyp  ,&caschyp  ,nullptr   ,&caschyp  ,nullptr     ,&falseOR   ); }
gentype &OP_asinh    (gentype &a) { const static gentype fnbare("asinh(x)");     return OP_elementwiseDefaultCallA(a,fnbare,"asinh"    ,&OP_asinh    ,&asinh    ,nullptr   ,&asinh    ,nullptr     ,&falseOR   ); }
gentype &OP_acosh    (gentype &a) { const static gentype fnbare("acosh(x)");     return OP_elementwiseDefaultCallA(a,fnbare,"acosh"    ,&OP_acosh    ,&acosh    ,nullptr   ,&acosh    ,nullptr     ,&acoshOR   ); }
gentype &OP_atanh    (gentype &a) { const static gentype fnbare("atanh(x)");     return OP_elementwiseDefaultCallA(a,fnbare,"atanh"    ,&OP_atanh    ,&atanh    ,nullptr   ,&atanh    ,nullptr     ,&atanhOR   ); }
gentype &OP_Acosh    (gentype &a) { const static gentype fnbare("Acosh(x)");     return OP_elementwiseDefaultCallA(a,fnbare,"Acosh"    ,&OP_Acosh    ,&Acosh    ,nullptr   ,&acosh    ,nullptr     ,&acoshOR   ); }
gentype &OP_Atanh    (gentype &a) { const static gentype fnbare("Atanh(x)");     return OP_elementwiseDefaultCallA(a,fnbare,"Atanh"    ,&OP_Atanh    ,&Atanh    ,nullptr   ,&atanh    ,nullptr     ,&atanhOR   ); }
gentype &OP_acosech  (gentype &a) { const static gentype fnbare("acosech(x)");   return OP_elementwiseDefaultCallA(a,fnbare,"acosech"  ,&OP_acosech  ,&acosech  ,nullptr   ,&acosech  ,nullptr     ,&falseOR   ); }
gentype &OP_asech    (gentype &a) { const static gentype fnbare("asech(x)");     return OP_elementwiseDefaultCallA(a,fnbare,"asech"    ,&OP_asech    ,&asech    ,nullptr   ,&asech    ,nullptr     ,&asechOR   ); }
gentype &OP_acoth    (gentype &a) { const static gentype fnbare("acoth(x)");     return OP_elementwiseDefaultCallA(a,fnbare,"acoth"    ,&OP_acoth    ,&acoth    ,nullptr   ,&acoth    ,nullptr     ,&acothOR   ); }
gentype &OP_aversh   (gentype &a) { const static gentype fnbare("aversh(x)");    return OP_elementwiseDefaultCallA(a,fnbare,"aversh"   ,&OP_aversh   ,&aversh   ,nullptr   ,&aversh   ,nullptr     ,&avershOR  ); }
gentype &OP_acovrsh  (gentype &a) { const static gentype fnbare("acovrsh(x)");   return OP_elementwiseDefaultCallA(a,fnbare,"acovrsh"  ,&OP_acovrsh  ,&acovrsh  ,nullptr   ,&acovrsh  ,nullptr     ,&falseOR   ); }
gentype &OP_ahavh    (gentype &a) { const static gentype fnbare("ahavh(x)");     return OP_elementwiseDefaultCallA(a,fnbare,"ahavh"    ,&OP_ahavh    ,&ahavh    ,nullptr   ,&ahavh    ,nullptr     ,&ahavhOR   ); }
gentype &OP_aexcosech(gentype &a) { const static gentype fnbare("aexcosech(x)"); return OP_elementwiseDefaultCallA(a,fnbare,"aexcosech",&OP_aexcosech,&aexcosech,nullptr   ,&aexcosech,nullptr     ,&falseOR   ); }
gentype &OP_aexsech  (gentype &a) { const static gentype fnbare("aexsech(x)");   return OP_elementwiseDefaultCallA(a,fnbare,"aexsech"  ,&OP_aexsech  ,&aexsech  ,nullptr   ,&aexsech  ,nullptr     ,&aexsechOR ); }
gentype &OP_acashyp  (gentype &a) { const static gentype fnbare("acashyp(x)");   return OP_elementwiseDefaultCallA(a,fnbare,"acashyp"  ,&OP_acashyp  ,&acashyp  ,nullptr   ,&acashyp  ,nullptr     ,&acashypOR ); }
gentype &OP_acaschyp (gentype &a) { const static gentype fnbare("acaschyp(x)");  return OP_elementwiseDefaultCallA(a,fnbare,"acaschyp" ,&OP_acaschyp ,&acaschyp ,nullptr   ,&acaschyp ,nullptr     ,&acaschypOR); }
gentype &OP_Asech    (gentype &a) { const static gentype fnbare("Asech(x)");     return OP_elementwiseDefaultCallA(a,fnbare,"Asech"    ,&OP_Asech    ,&Asech    ,nullptr   ,&asech    ,nullptr     ,&asechOR   ); }
gentype &OP_Acoth    (gentype &a) { const static gentype fnbare("Acoth(x)");     return OP_elementwiseDefaultCallA(a,fnbare,"Acoth"    ,&OP_Acoth    ,&Acoth    ,nullptr   ,&acoth    ,nullptr     ,&acothOR   ); }
gentype &OP_Aversh   (gentype &a) { const static gentype fnbare("Aversh(x)");    return OP_elementwiseDefaultCallA(a,fnbare,"Aversh"   ,&OP_Aversh   ,&Aversh   ,nullptr   ,&aversh   ,nullptr     ,&avershOR  ); }
gentype &OP_Ahavh    (gentype &a) { const static gentype fnbare("Ahavh(x)");     return OP_elementwiseDefaultCallA(a,fnbare,"Ahavh"    ,&OP_Ahavh    ,&Ahavh    ,nullptr   ,&ahavh    ,nullptr     ,&ahavhOR   ); }
gentype &OP_Aexsech  (gentype &a) { const static gentype fnbare("Aexsech(x)");   return OP_elementwiseDefaultCallA(a,fnbare,"Aexsech"  ,&OP_Aexsech  ,&Aexsech  ,nullptr   ,&aexsech  ,nullptr     ,&aexsechOR ); }
gentype &OP_Acashyp  (gentype &a) { const static gentype fnbare("Acashyp(x)");   return OP_elementwiseDefaultCallA(a,fnbare,"Acashyp"  ,&OP_Acashyp  ,&Acashyp  ,nullptr   ,&acashyp  ,nullptr     ,&acashypOR ); }
gentype &OP_Acaschyp (gentype &a) { const static gentype fnbare("Acaschyp(x)");  return OP_elementwiseDefaultCallA(a,fnbare,"Acaschyp" ,&OP_Acaschyp ,&Acaschyp ,nullptr   ,&acaschyp ,nullptr     ,&acaschypOR); }
gentype &OP_sinhc    (gentype &a) { const static gentype fnbare("sinhc(x)");     return OP_elementwiseDefaultCallA(a,fnbare,"sinhc"    ,&OP_sinhc    ,&sinhc    ,nullptr   ,&sinhc    ,nullptr     ,&falseOR   ); }
gentype &OP_coshc    (gentype &a) { const static gentype fnbare("coshc(x)");     return OP_elementwiseDefaultCallA(a,fnbare,"coshc"    ,&OP_coshc    ,&coshc    ,nullptr   ,&coshc    ,nullptr     ,&falseOR   ); }
gentype &OP_tanhc    (gentype &a) { const static gentype fnbare("tanhc(x)");     return OP_elementwiseDefaultCallA(a,fnbare,"tanhc"    ,&OP_tanhc    ,&tanhc    ,nullptr   ,&tanhc    ,nullptr     ,&falseOR   ); }
gentype &OP_sigm     (gentype &a) { const static gentype fnbare("sigm(x)");      return OP_elementwiseDefaultCallA(a,fnbare,"sigm"     ,&OP_sigm     ,&sigm     ,nullptr   ,&sigm     ,nullptr     ,&falseOR   ); }
gentype &OP_gd       (gentype &a) { const static gentype fnbare("gd(x)");        return OP_elementwiseDefaultCallA(a,fnbare,"gd"       ,&OP_gd       ,&gd       ,nullptr   ,&gd       ,nullptr     ,&falseOR   ); }
gentype &OP_asigm    (gentype &a) { const static gentype fnbare("asigm(x)");     return OP_elementwiseDefaultCallA(a,fnbare,"asigm"    ,&OP_asigm    ,&asigm    ,nullptr   ,&asigm    ,nullptr     ,&asigmOR   ); }
gentype &OP_agd      (gentype &a) { const static gentype fnbare("agd(x)");       return OP_elementwiseDefaultCallA(a,fnbare,"agd"      ,&OP_agd      ,&agd      ,nullptr   ,&agd      ,nullptr     ,&agdOR     ); }
gentype &OP_Asigm    (gentype &a) { const static gentype fnbare("Asigm(x)");     return OP_elementwiseDefaultCallA(a,fnbare,"Asigm"    ,&OP_Asigm    ,&Asigm    ,nullptr   ,&asigm    ,nullptr     ,&asigmOR   ); }
gentype &OP_Agd      (gentype &a) { const static gentype fnbare("Agd(x)");       return OP_elementwiseDefaultCallA(a,fnbare,"Agd"      ,&OP_Agd      ,&Agd      ,nullptr   ,&agd      ,nullptr     ,&agdOR     ); }
gentype &OP_erf      (gentype &a) { const static gentype fnbare("erf(x)");       return OP_elementwiseDefaultCallA(a,fnbare,"erf"      ,&OP_erf      ,nullptr   ,nullptr   ,&erf      ,nullptr     ,&falseOR   ); }
gentype &OP_erfc     (gentype &a) { const static gentype fnbare("erfc(x)");      return OP_elementwiseDefaultCallA(a,fnbare,"erfc"     ,&OP_erfc     ,nullptr   ,nullptr   ,&erfc     ,nullptr     ,&falseOR   ); }














gentype &raiseto(gentype &a, int b)
{
    if ( a.isValInteger() )
    {
        if ( b > 0 )
        {
            // Allow for possible overflow

            bool intgood = true;

            int i;
            int res = 1;
            int aa = a.cast_int(0);

            for ( i = 0 ; i < b ; ++i )
            {
                int vala = res;

                res *= aa;

                if ( ( vala != 0 ) && ( res/vala != vala ) )
                {
                    intgood = false;
                    break;
                }
            }

            if ( intgood )
            {
                a = res;
            }

            else
            {
                double dres = 1;

                for ( i = 0 ; i < b ; ++i )
                {
                    dres *= aa;
                }

                a = dres;
            }
        }

        else if ( b < 0 )
        {
            int i;
            double res = 1;
            int aa = a.cast_int(0);

            for ( i = 0 ; i < -b ; ++i )
            {
                res /= aa;
            }

            a = res;
        }

        else
        {
            a = 1;
        }
    }

    else if ( a.isValReal() )
    {
        if ( b > 0 )
        {
            int i;
            double res = 1;
            double aa = a.cast_double(0);

            for ( i = 0 ; i < b ; ++i )
            {
                res *= aa;
            }

            a = res;
        }

        else if ( b < 0 )
        {
            int i;
            double res = 1;
            double aa = a.cast_double(0);

            for ( i = 0 ; i < -b ; ++i )
            {
                res /= aa;
            }

            a = res;
        }

        else
        {
            a = 1.0;
        }
    }

    else if ( a.isValVector() )
    {
        gentype btemp(b);

        a = epow(a,btemp);
    }

    else
    {
        gentype btemp(b);

        a = pow(a,btemp);
    }

    return a;
}








Vector<gentype> &assign(Vector<gentype> &dest, const Vector<double > &src)
{
    if ( dest.size() != src.size() )
    {
        dest.resize(src.size());
    }

    //if ( src.size() )
    {
        for ( int i = 0 ; i < src.size() ; ++i )
        {
            dest("&",i) = src(i);
        }
    }

    return dest;
}

Vector<double > &assign(Vector<double > &dest, const Vector<gentype> &src)
{
    if ( dest.size() != src.size() )
    {
        dest.resize(src.size());
    }

    //if ( src.size() )
    {
        for ( int i = 0 ; i < src.size() ; ++i )
        {
            dest("&",i) = src(i).cast_double(0);
        }
    }

    return dest;
}

gentype &postProInnerProd(gentype &a)
{
    if ( a.scalarfn_isscalarfn() && ( a.scalarfn_i().size() == 1 ) )
    {
        gentype res;

        NiceAssert( a.scalarfn_i().size() == a.scalarfn_j().size() );

        int numpts = a.scalarfn_numpts();

        int i;

        res.zero();

        SparseVector<SparseVector<gentype> > xa;

        gentype aa;

        for ( i = 0 ; i < numpts ; ++i )
        {
            xa("&",a.scalarfn_i()(0))("&",a.scalarfn_j()(0)) = (((double) i)+0.5)/((double) numpts);

            aa = a(xa);
            aa.finalise();
            aa /= ((double) numpts);

            res += aa;
        }

        a = res;

        a.scalarfn_setisscalarfn(0);
    }

    if ( a.scalarfn_isscalarfn() )
    {
        gentype res;

        NiceAssert( a.scalarfn_i().size() == a.scalarfn_j().size() );

        int numvar = a.scalarfn_i().size();
        int numpts = a.scalarfn_numpts();
        int numtot = (int) pow(numpts,numvar);

        int i,j;
        Vector<int> k(numvar);

        k = 0;

        res.zero();

        SparseVector<SparseVector<gentype> > xa;

        gentype aa;

        for ( i = 0 ; i < numtot ; ++i )
        {
            for ( j = 0 ; j < numvar ; ++j )
            {
                xa("&",a.scalarfn_i()(j))("&",a.scalarfn_j()(j)) = (((double) k(j))+0.5)/((double) numpts);
            }

            aa = a(xa);
            aa.finalise();
            aa /= ((double) numtot);

            res += aa;

            for ( j = 0 ; j < numvar ; ++j )
            {
                ++(k("&",j));

                if ( k(j) >= numpts )
                {
                    k("&",j) = 0;
                }

                else
                {
                    break;
                }
            }
        }

        a = res;

        a.scalarfn_setisscalarfn(0);
    }

    return a;
}


void gentype::scalarfn_setisscalarfn(int nv)
{
    varid_isscalar = nv;

    //NB use of short-circuit: if !eqnargs the *eqnargs never evaluated
    if ( !nv && eqnargs && (*eqnargs).size() )
    {
	int i;

        for ( i = 0 ; i < (*eqnargs).size() ; ++i )
        {
            ((*eqnargs)("&",i)).scalarfn_setisscalarfn(nv);
	}
    }

    return;
}





































































































// Calculator

//#define NUMPLOTLINES 33
#define NUMPLOTLINES 28

#define PLOTREPTIME 0.5

int genplotit(double xmin, double xmax, double ymin, double ymax,
              const std::string &fname, const std::string &dname, int outformat, const gentype &baseline,
              int usevar);

// Calculator state is mostly stored here (at least stuff affected by brackets, so it can be pushed/popped)

class calcState
{
    public:

    calcState()
    {
        oplastkey = 0;

        gentype tempXY;
        std::string tempot;
        int tempft = -1;
        std::string tempfn("           ");

        XYdata.push(tempXY); // two elements on stack (X and Y)
        XYdata.push(tempXY);
        optype.push(tempot); // one element on stack, deliberately an empty string
        fntype.push(tempft); // one element on stack, deliberately -1
        fnname.push(tempfn);

        isK     = 0; // not repeating on start
        argKset = 0;

        whichassoc = 0;
        whichdms   = 0;
    }

    calcState(const calcState &src)
    {
        oplastkey = src.oplastkey;

        XYdata = src.XYdata;
        optype = src.optype;
        fntype = src.fntype;
        fnname = src.fnname;

        isK     = src.isK;
        argK    = src.argK;
        opK     = src.opK;
        argKset = src.argKset;

        whichassoc = src.whichassoc;
        whichdms   = src.whichdms;
        dmsaccum   = src.dmsaccum;
    }

    calcState &operator=(const calcState &src)
    {
        oplastkey = src.oplastkey;

        XYdata = src.XYdata;
        optype = src.optype;
        fntype = src.fntype;
        fnname = src.fnname;

        isK     = src.isK;
        argK    = src.argK;
        opK     = src.opK;
        argKset = src.argKset;

        whichassoc = src.whichassoc;
        whichdms   = src.whichdms;
        dmsaccum   = src.dmsaccum;

        return *this;
    }

    int oplastkey;

    Stack<gentype> XYdata;
    Stack<std::string> optype;
    Stack<int> fntype;
    Stack<std::string> fnname;

    int isK;
    gentype argK;
    std::string opK;
    int argKset;

    int whichassoc; // 0 normal, 1 started associator/antiassociator, 2 final
    int whichdms;   // 0 normal, 1 entering minutes, 2 entering seconds
    gentype dmsaccum;
};

inline void qswap(calcState &a, calcState &b);
inline void qswap(calcState &a, calcState &b)
{
    qswap(a.oplastkey,b.oplastkey);

    qswap(a.XYdata,b.XYdata);
    qswap(a.optype,b.optype);
    qswap(a.fntype,b.fntype);
    qswap(a.fnname,b.fnname);

    qswap(a.isK    ,a.isK    );
    qswap(a.argK   ,b.argK   );
    qswap(a.opK    ,b.opK    );
    qswap(a.argKset,b.argKset);

    qswap(a.whichassoc,b.whichassoc);
    qswap(a.whichdms  ,b.whichdms  );
    qswap(a.dmsaccum  ,b.dmsaccum  );
}

inline calcState &setzero(calcState &a);
inline calcState &setzero(calcState &a)
{
    a.oplastkey = 0;

    gentype tempXY;
    std::string tempot;
    int tempft = -1;
    std::string tempfn("           ");

    a.XYdata.resize(0);
    a.XYdata.push(tempXY);
    a.XYdata.push(tempXY);

    a.optype.resize(0);
    a.optype.push(tempot);

    a.fntype.resize(0);
    a.fntype.push(tempft);

    a.fnname.resize(0);
    a.fnname.push(tempfn);

    a.isK     = 0;
    a.argK    = 0;
    a.opK     = "";
    a.argKset = 0;

    a.whichassoc = 0;
    a.whichdms   = 0;
    a.dmsaccum   = 0;

    return a;
}

inline calcState &setposate(calcState &a);
inline calcState &setnegate(calcState &a);
inline calcState &setconj(calcState &a);
inline calcState &setrand(calcState &a);
inline calcState &setident(calcState &a);
inline calcState &setzeropassive(calcState &a);
inline calcState &settranspose(calcState &a);

inline calcState &setposate(calcState &a)      {                                           return a; }
inline calcState &setnegate(calcState &a)      { NiceThrow("Cant setnegate calcState");    return a; }
inline calcState &setconj(calcState &a)        { NiceThrow("Cant setconj calcState");      return a; }
inline calcState &setrand(calcState &a)        { NiceThrow("Cant setrand calcState");      return a; }
inline calcState &setident(calcState &a)       { NiceThrow("Cant setident calcState");     return a; }
inline calcState &setzeropassive(calcState &a) { NiceThrow("Cant zeropassive calcState");  return a; }
inline calcState &settranspose(calcState &a)   { NiceThrow("Cant settranspose calcState"); return a; }

#define calcNest theCalcNest("&",theCalcNest.size()-1)

bool isophigh(const std::string &refop, const std::string &newop);
bool isophigh(const std::string &refop, const std::string &newop)
{
    int reflevel = 0;
    int newlevel = 0;

    if      ( ( refop == "^^"  ) || ( refop == "^^<"  ) || ( refop == "^^>"  ) || ( refop == "^^/" )                                             ) { reflevel = 1; }
    else if ( ( refop == ".^^" ) || ( refop == ".^^<" ) || ( refop == ".^^>" )                                                                   ) { reflevel = 1; }
    else if ( ( refop == "^"   ) || ( refop == "^<"   ) || ( refop == "^>"   ) || ( refop == "^/"  )                                             ) { reflevel = 1; }
    else if ( ( refop == ".^"  ) || ( refop == ".^<"  ) || ( refop == ".^>"  )                                                                   ) { reflevel = 1; }
    else if ( ( refop == "*"   ) || ( refop == "*>"   ) || ( refop == "/"    ) || ( refop == "//"  ) || ( refop == "\\"  ) || ( refop == "%"   ) ) { reflevel = 2; }
    else if ( ( refop == ".*"  ) || ( refop == ".*>"  ) || ( refop == "./"   ) || ( refop == ".//" ) || ( refop == ".\\" ) || ( refop == ".%"  ) ) { reflevel = 2; }
    else if ( ( refop == "+"   ) || ( refop == "-"    )                                                                                          ) { reflevel = 3; }
    else if ( ( refop == "|"   ) || ( refop == "|@"   )                                                                                          ) { reflevel = 4; }
    else if ( ( refop == "=="  ) || ( refop == "~="   ) || ( refop == ">"    ) || ( refop == ">="  ) || ( refop == "<"   ) || ( refop == "<="  ) ) { reflevel = 5; }
    else if ( ( refop == ".==" ) || ( refop == ".~="  ) || ( refop == ".>"   ) || ( refop == ".>=" ) || ( refop == ".<"  ) || ( refop == ".<=" ) ) { reflevel = 5; }
    else if ( ( refop == "&&"  ) || ( refop == "||"   )                                                                                          ) { reflevel = 6; }

    if      ( ( newop == "^^"  ) || ( newop == "^^<"  ) || ( newop == "^^>"  ) || ( newop == "^^/" )                                             ) { newlevel = 1; }
    else if ( ( newop == ".^^" ) || ( newop == ".^^<" ) || ( newop == ".^^>" )                                                                   ) { newlevel = 1; }
    else if ( ( newop == "^"   ) || ( newop == "^<"   ) || ( newop == "^>"   ) || ( newop == "^/"  )                                             ) { newlevel = 1; }
    else if ( ( newop == ".^"  ) || ( newop == ".^<"  ) || ( newop == ".^>"  )                                                                   ) { newlevel = 1; }
    else if ( ( newop == "*"   ) || ( newop == "*>"   ) || ( newop == "/"    ) || ( newop == "//"  ) || ( newop == "\\"  ) || ( newop == "%"   ) ) { newlevel = 2; }
    else if ( ( newop == ".*"  ) || ( newop == ".*>"  ) || ( newop == "./"   ) || ( newop == ".//" ) || ( newop == ".\\" ) || ( newop == ".%"  ) ) { newlevel = 2; }
    else if ( ( newop == "+"   ) || ( newop == "-"    )                                                                                          ) { newlevel = 3; }
    else if ( ( newop == "|"   ) || ( newop == "|@"   )                                                                                          ) { newlevel = 4; }
    else if ( ( newop == "=="  ) || ( newop == "~="   ) || ( newop == ">"    ) || ( newop == ">="  ) || ( newop == "<"   ) || ( newop == "<="  ) ) { newlevel = 5; }
    else if ( ( newop == ".==" ) || ( newop == ".~="  ) || ( newop == ".>"   ) || ( newop == ".>=" ) || ( newop == ".<"  ) || ( newop == ".<=" ) ) { newlevel = 5; }
    else if ( ( newop == "&&"  ) || ( newop == "||"   )                                                                                          ) { newlevel = 6; }

//    return ( reflevel >= newlevel ) || !reflevel || !newlevel;
// Powers are right-to-left, so don't evaluate until the final request!
    return ( reflevel > newlevel ) || ( ( reflevel == newlevel ) && ( reflevel != 1 ) ) || !reflevel || !newlevel;
}

bool isbeg(char x);
bool isbeg(char x)
{
    return ( x == '(' ) || ( x == '[' ) || ( x == '{'  ) || ( x == ';'  ) || ( x == ',' ) || ( x == '|' ) ||
           ( x == '*' ) || ( x == '%' ) || ( x == '/'  ) || ( x == '\\' ) || ( x == '+' ) || ( x == '-' ) ||
           ( x == '^' ) || ( x == '~' ) || ( x == ':'  ) || ( x == '='  ) || ( x == '<' ) || ( x == '>' ) ||
           ( x == '&' ) || ( x == ' ' ) || ( x == '\t' );
}

bool isopstartkey(int x);
bool isopstartkey(int x)
{
    return ( x == '!' ) || ( x == '^' ) || ( x == '.' ) || ( x == '*' ) || ( x == '/' ) || ( x == '\\' ) ||
           ( x == '%' ) || ( x == '+' ) || ( x == '-' ) || ( x == '|' ) || ( x == '=' ) || ( x == '~'  ) ||
           ( x == '>' ) || ( x == '<' ) || ( x == '&' );
}

// Data flow

#define GETX (calcNest.XYdata("&",calcNest.XYdata.size()-1))
#define GETY (calcNest.XYdata("&",calcNest.XYdata.size()-2))
#define GETZ (calcNest.XYdata("&",calcNest.XYdata.size()-3))

#define PUTINRAD(q) ((q)*(( DRGtype == 0 ) ? (NUMBASE_PI/180.0) : ( ( DRGtype == 1 ) ? 1.0 : (NUMBASE_PI/200.0) )))
#define PUTINDRG(q) ((q)*(( DRGtype == 0 ) ? (180.0/NUMBASE_PI) : ( ( DRGtype == 1 ) ? 1.0 : (200.0/NUMBASE_PI) )))

// Optionally take data off screen and put in memory

#define UPDATE_PREPRE_OP                                \
{                                                       \
    if ( !dataDisplay )                                 \
    {                                                   \
        if ( entryval.size() )                          \
        {                                               \
            GETX = entryval;                            \
        }                                               \
                                                        \
        else                                            \
        {                                               \
            GETX = 0;                                   \
        }                                               \
                                                        \
        dataDisplay = 1;                                \
    }                                                   \
}

#define UPDATE_PRE_EDIT                                 \
{                                                       \
    if ( dataDisplay )                                  \
    {                                                   \
        dataDisplay = 0;                                \
        entryval = "";                                  \
    }                                                   \
}

#define UPDATE_PREEVAL_OP(newoptype)                                                                                                  \
{                                                                                                                                     \
    if ( calcNest.XYdata.size() == 2 )                                                                                                \
    {                                                                                                                                 \
        ;                                                                                                                             \
    }                                                                                                                                 \
                                                                                                                                      \
    else if ( ( calcNest.XYdata.size() == 3 ) && ( calcNest.fntype.accessTop() != -1 ) && ( calcNest.fntype.accessTop() < 1000 ) )    \
    {                                                                                                                                 \
        gentype oparga = GETY;                                                                                                        \
        gentype opargb = GETX;                                                                                                        \
                                                                                                                                      \
        int ftype = calcNest.fntype.accessTop();                                                                                      \
                                                                                                                                      \
        {                                                                                                                             \
            calcNest.XYdata.pop();                                                                                                    \
            calcNest.fntype.pop();                                                                                                    \
            calcNest.fnname.pop();                                                                                                    \
            calcNest.optype.pop();                                                                                                    \
        }                                                                                                                             \
                                                                                                                                      \
        gentype &resval = GETX;                                                                                                       \
        gentype &altval = GETY;                                                                                                       \
                                                                                                                                      \
        SparseVector<SparseVector<gentype> > temp;                                                                                    \
                                                                                                                                      \
        if      ( ftype == 1  ) { resval = sqrt(norm2(oparga)+norm2(opargb)); altval = PUTINDRG(arg(cayleyDickson(oparga,opargb))); } \
        else if ( ftype == 2  ) { resval = oparga*cos(PUTINRAD(opargb));      altval = oparga*sin(PUTINRAD(opargb));                } \
        else if ( ftype == 3  ) { resval = isah ? PolyDistr(oparga,opargb) : polyDistr(oparga,opargb);                              } \
        else if ( ftype == 46 ) { resval = isah ? Logbl    (oparga,opargb) : logbl    (oparga,opargb);                              } \
        else if ( ftype == 48 ) { resval = isah ? Logbr    (oparga,opargb) : logbr    (oparga,opargb);                              } \
        else if ( ftype == 50 ) { resval = isah ? Logb     (oparga,opargb) : logb     (oparga,opargb);                              } \
        else if ( ftype == 4  ) { resval = psi_n        (oparga,opargb);                                                            } \
        else if ( ftype == 5  ) { resval = gami         (oparga,opargb);                                                            } \
        else if ( ftype == 6  ) { resval = gamic        (oparga,opargb);                                                            } \
        else if ( ftype == 7  ) { resval = bern         (oparga,opargb);                                                            } \
        else if ( ftype == 45 ) { resval = outerProd    (oparga,opargb);                                                            } \
        else if ( ftype == 8  ) { resval = perm         (oparga,opargb);                                                            } \
        else if ( ftype == 9  ) { resval = comb         (oparga,opargb);                                                            } \
        else if ( ftype == 10 ) { resval = kronDelta    (oparga,opargb);                                                            } \
        else if ( ftype == 54 ) { resval = ekronDelta   (oparga,opargb);                                                            } \
        else if ( ftype == 11 ) { resval = multifact    (oparga,opargb);                                                            } \
        else if ( ftype == 12 ) { resval = eye          (oparga,opargb);                                                            } \
        else if ( ftype == 29 ) { resval = absp         (oparga,opargb);                                                            } \
        else if ( ftype == 55 ) { resval = eabsp        (oparga,opargb);                                                            } \
        else if ( ftype == 30 ) { resval = gt           (oparga,opargb);                                                            } \
        else if ( ftype == 31 ) { resval = le           (oparga,opargb);                                                            } \
        else if ( ftype == 32 ) { resval = lt           (oparga,opargb);                                                            } \
        else if ( ftype == 33 ) { resval = ge           (oparga,opargb);                                                            } \
        else if ( ftype == 34 ) { resval = eq           (oparga,opargb);                                                            } \
        else if ( ftype == 35 ) { resval = ne           (oparga,opargb);                                                            } \
        else if ( ftype == 57 ) { resval = egt          (oparga,opargb);                                                            } \
        else if ( ftype == 58 ) { resval = ele          (oparga,opargb);                                                            } \
        else if ( ftype == 59 ) { resval = elt          (oparga,opargb);                                                            } \
        else if ( ftype == 60 ) { resval = ege          (oparga,opargb);                                                            } \
        else if ( ftype == 61 ) { resval = eeq          (oparga,opargb);                                                            } \
        else if ( ftype == 62 ) { resval = ene          (oparga,opargb);                                                            } \
        else if ( ftype == 36 ) { resval = land         (oparga,opargb);                                                            } \
        else if ( ftype == 37 ) { resval = lnand        (oparga,opargb);                                                            } \
        else if ( ftype == 38 ) { resval = lor          (oparga,opargb);                                                            } \
        else if ( ftype == 39 ) { resval = lnor         (oparga,opargb);                                                            } \
        else if ( ftype == 40 ) { resval = lxor         (oparga,opargb);                                                            } \
        else if ( ftype == 41 ) { resval = lxand        (oparga,opargb);                                                            } \
        else if ( ftype == 52 ) { resval = commutate    (oparga,opargb);                                                            } \
        else if ( ftype == 53 ) { resval = anticommutate(oparga,opargb);                                                            } \
        else if ( ftype == 42 ) { resval = testfnA(23_gent,oparga,opargb);                                                          } \
        else if ( ftype == 43 ) { resval = partestfnA(4_gent,testM,oparga,opargb);                                                  } \
        else if ( ftype == 13 ) { temp("&",0)("&",0)   = opargb; resval = oparga; resval.substitute(temp);                          } \
        else if ( ftype == 14 ) { temp("&",0)("&",1)   = opargb; resval = oparga; resval.substitute(temp);                          } \
        else if ( ftype == 15 ) { temp("&",0)("&",2)   = opargb; resval = oparga; resval.substitute(temp);                          } \
        else if ( ftype == 16 ) { temp("&",0)("&",3)   = opargb; resval = oparga; resval.substitute(temp);                          } \
        else if ( ftype == 17 ) { temp("&",0)("&",4)   = opargb; resval = oparga; resval.substitute(temp);                          } \
        else if ( ftype == 18 ) { temp("&",0)("&",5)   = opargb; resval = oparga; resval.substitute(temp);                          } \
        else if ( ftype == 44 ) { temp("&",42)("&",42) = opargb; resval = oparga; resval.substitute(temp);                          } \
        else if ( ftype == 56 ) { temp("&",1)("&",1)   = opargb; resval = oparga; resval.substitute(temp);                          } \
        else if ( ftype == 19 ) { resval = randlfill(tr,(double) oparga, (double) opargb);                                          } \
        else if ( ftype == 20 ) { resval = randCfill(tr,(double) oparga, (double) opargb);                                          } \
        else if ( ftype == 21 ) { resval = randffill(tr,(double) oparga, (double) opargb);                                          } \
        else if ( ftype == 22 ) { resval = randbfill(tr,(int)    oparga, (double) opargb);                                          } \
        else if ( ftype == 23 ) { resval = randBfill(tr,(int)    oparga, (double) opargb);                                          } \
        else if ( ftype == 24 ) { resval = randufill(tr,(double) oparga, (double) opargb);                                          } \
        else if ( ftype == 25 ) { resval = randGfill(tr,(double) oparga, (double) opargb);                                          } \
        else if ( ftype == 26 ) { resval = randwfill(tr,(double) oparga, (double) opargb);                                          } \
        else if ( ftype == 27 ) { resval = randxfill(tr,(double) oparga, (double) opargb);                                          } \
        else if ( ftype == 28 ) { resval = randnfill(tr,(double) oparga, (double) opargb);                                          } \
    }                                                                                                                                 \
                                                                                                                                      \
    else if ( ( calcNest.XYdata.size() == 3 ) && ( calcNest.fntype.accessTop() != -1 ) && ( calcNest.fntype.accessTop() >= 1000 ) )   \
    {                                                                                                                                 \
        /* */                                                                                                                         \
    }                                                                                                                                 \
                                                                                                                                      \
    else if ( ( calcNest.XYdata.size() == 4 ) && ( calcNest.fntype.accessTop() != -1 ) && ( calcNest.fntype.accessTop() >= 1000 ) )   \
    {                                                                                                                                 \
        {                                                                                                                             \
            calcNest.whichassoc = 0;                                                                                                  \
                                                                                                                                      \
            gentype oparga = GETZ;                                                                                                    \
            gentype opargb = GETY;                                                                                                    \
            gentype opargc = GETX;                                                                                                    \
                                                                                                                                      \
            int ftype = calcNest.fntype.accessTop();                                                                                  \
                                                                                                                                      \
            {                                                                                                                         \
                calcNest.XYdata.pop();                                                                                                \
                calcNest.fntype.pop();                                                                                                \
                calcNest.fnname.pop();                                                                                                \
                calcNest.optype.pop();                                                                                                \
                                                                                                                                      \
                calcNest.XYdata.pop();                                                                                                \
                calcNest.fntype.pop();                                                                                                \
                calcNest.fnname.pop();                                                                                                \
                calcNest.optype.pop();                                                                                                \
            }                                                                                                                         \
                                                                                                                                      \
            gentype &resval = GETX;                                                                                                   \
                                                                                                                                      \
            SparseVector<SparseVector<gentype> > temp;                                                                                \
                                                                                                                                      \
                 if ( ftype == 1000 ) { resval = associate    (oparga,opargb,opargc);                                               } \
            else if ( ftype == 1001 ) { resval = antiassociate(oparga,opargb,opargc);                                               } \
        }                                                                                                                             \
    }                                                                                                                                 \
                                                                                                                                      \
    else                                                                                                                              \
    {                                                                                                                                 \
        std::string evalstring;                                                                                                       \
        std::string tempstring;                                                                                                       \
                                                                                                                                      \
        SparseVector<SparseVector<gentype> > temp;                                                                                    \
                                                                                                                                      \
        int iiii = 0;                                                                                                                  \
                                                                                                                                      \
        while ( ( calcNest.XYdata.size() > 2 ) && isophigh(newoptype,calcNest.optype.accessTop()) )                                   \
        {                                                                                                                             \
            tempstring  = calcNest.optype.accessTop();                                                                                \
            tempstring += "var(100,";                                                                                                 \
            tempstring += std::to_string(iiii);                                                                                        \
            tempstring += ")";                                                                                                        \
                                                                                                                                      \
            temp("&",100)("&",iiii) = GETX;                                                                                            \
                                                                                                                                      \
            evalstring = tempstring+evalstring;                                                                                       \
                                                                                                                                      \
            calcNest.XYdata.pop();                                                                                                    \
            calcNest.optype.pop();                                                                                                    \
            calcNest.fntype.pop();                                                                                                    \
            calcNest.fnname.pop();                                                                                                    \
                                                                                                                                      \
            iiii++;                                                                                                                    \
        }                                                                                                                             \
                                                                                                                                      \
        tempstring  = "var(100,";                                                                                                     \
        tempstring += std::to_string(iiii);                                                                                            \
        tempstring += ")";                                                                                                            \
                                                                                                                                      \
        temp("&",100)("&",iiii) = GETX;                                                                                                \
                                                                                                                                      \
        evalstring = tempstring+evalstring;                                                                                           \
                                                                                                                                      \
        gentype finres(evalstring);                                                                                                   \
        finres.substitute(temp);                                                                                                      \
                                                                                                                                      \
        GETX = finres;                                                                                                                \
    }                                                                                                                                 \
}

#define UPDATE_EVAL_OP                                                                                                                \
{                                                                                                                                     \
    if ( ( calcNest.XYdata.size() == 2 ) && !calcNest.argKset )                                                                       \
    {                                                                                                                                 \
        ;                                                                                                                             \
    }                                                                                                                                 \
                                                                                                                                      \
    else if ( ( calcNest.XYdata.size() == 3 ) && ( calcNest.fntype.accessTop() != -1 ) && ( calcNest.fntype.accessTop() < 1000 ) )    \
    {                                                                                                                                 \
        gentype oparga = GETY;                                                                                                        \
        gentype opargb = GETX;                                                                                                        \
                                                                                                                                      \
        int ftype = calcNest.fntype.accessTop();                                                                                      \
                                                                                                                                      \
        {                                                                                                                             \
            calcNest.XYdata.pop();                                                                                                    \
            calcNest.fntype.pop();                                                                                                    \
            calcNest.fnname.pop();                                                                                                    \
            calcNest.optype.pop();                                                                                                    \
        }                                                                                                                             \
                                                                                                                                      \
        gentype &resval = GETX;                                                                                                       \
        gentype &altval = GETY;                                                                                                       \
                                                                                                                                      \
        SparseVector<SparseVector<gentype> > temp;                                                                                    \
                                                                                                                                      \
        if      ( ftype == 1  ) { resval = sqrt(norm2(oparga)+norm2(opargb)); altval = PUTINDRG(arg(cayleyDickson(oparga,opargb))); } \
        else if ( ftype == 2  ) { resval = oparga*cos(PUTINRAD(opargb));      altval = oparga*sin(PUTINRAD(opargb));                } \
        else if ( ftype == 3  ) { resval = isah ? PolyDistr(oparga,opargb) : polyDistr(oparga,opargb);                              } \
        else if ( ftype == 46 ) { resval = isah ? Logbl    (oparga,opargb) : logbl    (oparga,opargb);                              } \
        else if ( ftype == 48 ) { resval = isah ? Logbr    (oparga,opargb) : logbr    (oparga,opargb);                              } \
        else if ( ftype == 50 ) { resval = isah ? Logb     (oparga,opargb) : logb     (oparga,opargb);                              } \
        else if ( ftype == 4  ) { resval = psi_n        (oparga,opargb);                                                            } \
        else if ( ftype == 5  ) { resval = gami         (oparga,opargb);                                                            } \
        else if ( ftype == 6  ) { resval = gamic        (oparga,opargb);                                                            } \
        else if ( ftype == 7  ) { resval = bern         (oparga,opargb);                                                            } \
        else if ( ftype == 45 ) { resval = outerProd    (oparga,opargb);                                                            } \
        else if ( ftype == 8  ) { resval = perm         (oparga,opargb);                                                            } \
        else if ( ftype == 9  ) { resval = comb         (oparga,opargb);                                                            } \
        else if ( ftype == 10 ) { resval = kronDelta    (oparga,opargb);                                                            } \
        else if ( ftype == 54 ) { resval = ekronDelta   (oparga,opargb);                                                            } \
        else if ( ftype == 11 ) { resval = multifact    (oparga,opargb);                                                            } \
        else if ( ftype == 12 ) { resval = eye          (oparga,opargb);                                                            } \
        else if ( ftype == 29 ) { resval = absp         (oparga,opargb);                                                            } \
        else if ( ftype == 55 ) { resval = eabsp        (oparga,opargb);                                                            } \
        else if ( ftype == 30 ) { resval = gt           (oparga,opargb);                                                            } \
        else if ( ftype == 31 ) { resval = le           (oparga,opargb);                                                            } \
        else if ( ftype == 32 ) { resval = lt           (oparga,opargb);                                                            } \
        else if ( ftype == 33 ) { resval = ge           (oparga,opargb);                                                            } \
        else if ( ftype == 34 ) { resval = eq           (oparga,opargb);                                                            } \
        else if ( ftype == 35 ) { resval = ne           (oparga,opargb);                                                            } \
        else if ( ftype == 57 ) { resval = egt          (oparga,opargb);                                                            } \
        else if ( ftype == 58 ) { resval = ele          (oparga,opargb);                                                            } \
        else if ( ftype == 59 ) { resval = elt          (oparga,opargb);                                                            } \
        else if ( ftype == 60 ) { resval = ege          (oparga,opargb);                                                            } \
        else if ( ftype == 61 ) { resval = eeq          (oparga,opargb);                                                            } \
        else if ( ftype == 62 ) { resval = ene          (oparga,opargb);                                                            } \
        else if ( ftype == 36 ) { resval = land         (oparga,opargb);                                                            } \
        else if ( ftype == 37 ) { resval = lnand        (oparga,opargb);                                                            } \
        else if ( ftype == 38 ) { resval = lor          (oparga,opargb);                                                            } \
        else if ( ftype == 39 ) { resval = lnor         (oparga,opargb);                                                            } \
        else if ( ftype == 40 ) { resval = lxor         (oparga,opargb);                                                            } \
        else if ( ftype == 41 ) { resval = lxand        (oparga,opargb);                                                            } \
        else if ( ftype == 52 ) { resval = commutate    (oparga,opargb);                                                            } \
        else if ( ftype == 53 ) { resval = anticommutate(oparga,opargb);                                                            } \
        else if ( ftype == 42 ) { resval = testfnA(23_gent,oparga,opargb);                                                          } \
        else if ( ftype == 43 ) { resval = partestfnA(4_gent,testM,oparga,opargb);                                                  } \
        else if ( ftype == 13 ) { temp("&",0)("&",0)   = opargb; resval = oparga; resval.substitute(temp);                          } \
        else if ( ftype == 14 ) { temp("&",0)("&",1)   = opargb; resval = oparga; resval.substitute(temp);                          } \
        else if ( ftype == 15 ) { temp("&",0)("&",2)   = opargb; resval = oparga; resval.substitute(temp);                          } \
        else if ( ftype == 16 ) { temp("&",0)("&",3)   = opargb; resval = oparga; resval.substitute(temp);                          } \
        else if ( ftype == 17 ) { temp("&",0)("&",4)   = opargb; resval = oparga; resval.substitute(temp);                          } \
        else if ( ftype == 18 ) { temp("&",0)("&",5)   = opargb; resval = oparga; resval.substitute(temp);                          } \
        else if ( ftype == 44 ) { temp("&",42)("&",42) = opargb; resval = oparga; resval.substitute(temp);                          } \
        else if ( ftype == 56 ) { temp("&",1)("&",1)   = opargb; resval = oparga; resval.substitute(temp);                          } \
        else if ( ftype == 19 ) { resval = randlfill(tr,(double) oparga, (double) opargb);                                          } \
        else if ( ftype == 20 ) { resval = randCfill(tr,(double) oparga, (double) opargb);                                          } \
        else if ( ftype == 21 ) { resval = randffill(tr,(double) oparga, (double) opargb);                                          } \
        else if ( ftype == 22 ) { resval = randbfill(tr,(int)    oparga, (double) opargb);                                          } \
        else if ( ftype == 23 ) { resval = randBfill(tr,(int)    oparga, (double) opargb);                                          } \
        else if ( ftype == 24 ) { resval = randufill(tr,(double) oparga, (double) opargb);                                          } \
        else if ( ftype == 25 ) { resval = randGfill(tr,(double) oparga, (double) opargb);                                          } \
        else if ( ftype == 26 ) { resval = randwfill(tr,(double) oparga, (double) opargb);                                          } \
        else if ( ftype == 27 ) { resval = randxfill(tr,(double) oparga, (double) opargb);                                          } \
        else if ( ftype == 28 ) { resval = randnfill(tr,(double) oparga, (double) opargb);                                          } \
    }                                                                                                                                 \
                                                                                                                                      \
    else if ( ( calcNest.XYdata.size() == 3 ) && ( calcNest.fntype.accessTop() != -1 ) && ( calcNest.fntype.accessTop() >= 1000 ) )   \
    {                                                                                                                                 \
        /* */                                                                                                                         \
    }                                                                                                                                 \
                                                                                                                                      \
    else if ( ( calcNest.XYdata.size() == 4 ) && ( calcNest.fntype.accessTop() != -1 ) && ( calcNest.fntype.accessTop() >= 1000 ) )   \
    {                                                                                                                                 \
        {                                                                                                                             \
            calcNest.whichassoc = 0;                                                                                                  \
                                                                                                                                      \
            gentype oparga = GETZ;                                                                                                    \
            gentype opargb = GETY;                                                                                                    \
            gentype opargc = GETX;                                                                                                    \
                                                                                                                                      \
            int ftype = calcNest.fntype.accessTop();                                                                                  \
                                                                                                                                      \
            {                                                                                                                         \
                calcNest.XYdata.pop();                                                                                                \
                calcNest.fntype.pop();                                                                                                \
                calcNest.fnname.pop();                                                                                                \
                calcNest.optype.pop();                                                                                                \
                                                                                                                                      \
                calcNest.XYdata.pop();                                                                                                \
                calcNest.fntype.pop();                                                                                                \
                calcNest.fnname.pop();                                                                                                \
                calcNest.optype.pop();                                                                                                \
            }                                                                                                                         \
                                                                                                                                      \
            gentype &resval = GETX;                                                                                                   \
                                                                                                                                      \
            SparseVector<SparseVector<gentype> > temp;                                                                                \
                                                                                                                                      \
                 if ( ftype == 1000 ) { resval = associate    (oparga,opargb,opargc);                                               } \
            else if ( ftype == 1001 ) { resval = antiassociate(oparga,opargb,opargc);                                               } \
        }                                                                                                                             \
    }                                                                                                                                 \
                                                                                                                                      \
    else                                                                                                                              \
    {                                                                                                                                 \
        std::string evalstring;                                                                                                       \
        std::string tempstring;                                                                                                       \
                                                                                                                                      \
        SparseVector<SparseVector<gentype> > temp;                                                                                    \
                                                                                                                                      \
        int iiii = 0;                                                                                                                  \
                                                                                                                                      \
        if ( calcNest.isK && !calcNest.argKset )                                                                                      \
        {                                                                                                                             \
            calcNest.argK = GETX;                                                                                                     \
            calcNest.opK  = calcNest.optype.accessTop();                                                                              \
            calcNest.argKset = 1;                                                                                                     \
                                                                                                                                      \
            calcNest.XYdata.pop();                                                                                                    \
            calcNest.optype.pop();                                                                                                    \
            calcNest.fntype.pop();                                                                                                    \
            calcNest.fnname.pop();                                                                                                    \
        }                                                                                                                             \
                                                                                                                                      \
        if ( calcNest.isK )                                                                                                           \
        {                                                                                                                             \
            calcNest.XYdata.push(calcNest.argK);                                                                                      \
            calcNest.optype.push(calcNest.opK);                                                                                       \
            calcNest.fntype.push(tempft);                                                                                             \
            calcNest.fnname.push(tempfn);                                                                                             \
        }                                                                                                                             \
                                                                                                                                      \
        while ( calcNest.XYdata.size() > 2 )                                                                                          \
        {                                                                                                                             \
            tempstring  = calcNest.optype.accessTop();                                                                                \
            tempstring += "var(100,";                                                                                                 \
            tempstring += std::to_string(iiii);                                                                                        \
            tempstring += ")";                                                                                                        \
                                                                                                                                      \
            temp("&",100)("&",iiii) = GETX;                                                                                            \
                                                                                                                                      \
            evalstring = tempstring+evalstring;                                                                                       \
                                                                                                                                      \
            calcNest.XYdata.pop();                                                                                                    \
            calcNest.optype.pop();                                                                                                    \
            calcNest.fntype.pop();                                                                                                    \
            calcNest.fnname.pop();                                                                                                    \
                                                                                                                                      \
            iiii++;                                                                                                                    \
        }                                                                                                                             \
                                                                                                                                      \
        tempstring  = "var(100,";                                                                                                     \
        tempstring += std::to_string(iiii);                                                                                            \
        tempstring += ")";                                                                                                            \
                                                                                                                                      \
        temp("&",100)("&",iiii) = GETX;                                                                                                \
                                                                                                                                      \
        evalstring = tempstring+evalstring;                                                                                           \
                                                                                                                                      \
        gentype finres(evalstring);                                                                                                   \
        finres.substitute(temp);                                                                                                      \
                                                                                                                                      \
        GETX = finres;                                                                                                                \
    }                                                                                                                                 \
}

#define FIRSTSF_PAGE 0

#define MYCALCSF_PAGE      0   // Basic functionality for my vintage calculator, plus HYP and some extensions
#define OBSCURETRIGI__PAGE 1   // Basic functionality with obscure trig functions I
#define OBSCURETRIGII_PAGE 2   // Basic functionality with obscure trig functions II
#define ABSANGARG_PAGE     3   // Absolute, angle, arg (complex), rounding and some obscurities
#define ODDITIES_PAGE      4   // other
#define ADVANCEDSFI_PAGE   5   // Advanced special functions I
#define COMBMAXMIN_PAGE    6   // Combinatorics, max/min
#define VARDERIV_PAGE      7   // Variables and derivatives
#define VARSET_PAGE        8   // Variable setting
#define TESTFUNCI___PAGE   9   // Test function page I
#define TESTFUNCII__PAGE   10  // Test function page II
#define TESTFUNCIII_PAGE   11  // Test function page III
#define TESTFUNCIV__PAGE   12  // Test function page IV
#define DISTRIBI___PAGE    13  // Distributions page I
#define DISTRIBII__PAGE    14  // Distributions page II
#define DISTRIBIII_PAGE    15  // Distributions page III
#define LOGIC_PAGE         16  // Logical operations
#define FTYPE_PAGE         17  // Function types
#define TIME_PAGE          18  // Time related functions

#define LASTSF_PAGE 18




//void intercalc(std::ostream &output, std::istream &input)
void intercalc(std::ostream &, std::istream &)
{
    size_t datawidth  = 67; // width of calculator screen

    size_t calcwidth  = 77; // width of calculator
    size_t calcheight = 44; // height of calculator

    int screenrows = -1; // width of screen
    int screencols = -1; // height of screen

    std::string rightplot[NUMPLOTLINES]; // buffer for plotted function

    getscrrowcol(screenrows,screencols);

    size_t rightblank = screencols - calcwidth - 2; // usable space to right of calculator (assuming 1 space on either side of right blank)

//    const static gentype zerogentype(0);
//    const static gentype oneonthree(1.0/3.0);

    int page      = FIRSTSF_PAGE; // select which scientific screen is shown
    int gridvert  = 3; // position on grid (0,0 is top left)
    int gridhoriz = 5; // position on grid (0,0 is top left)
    int refresh   = 1; // set 1 to refresh the screen

    size_t ii;

    enternonblockmode();
    svmclrscr(0);

    int exitnow = 0;

    int isinv       = 0; // is INV modifier on?
    int mempty      = 1; // is there information in memory
    int DRGtype     = 1; // 0 Degrees, 1 Radians, 2 Gradians
    int SDmode      = 0; // is in SD mode?
    int HYPmode     = 0; // is in HYPerbolic mode
    int dataDisplay = 1; // 0 if displaying entryval, 1 if displaying data
    int isdmsmode   = 0; // 0 for normal, 1 for display in DMS mode
    int isah        = 0; // 0 for normal, 1 for alternative hand forms
    int isew        = 0; // 0 for normal, 1 for elementwise forms

    double xmin = 0; // xmin for plotting
    double xmax = 1; // xmax for plotting
    double ymin = 1; // ymin for plotting
    double ymax = 0; // ymax for plotting

    int plotmode = 0; // 0 no plot, 1 fn is not finalised, so replot two per second
    gentype plotfn;
    time_used start_time = TIMECALL;
    time_used curr_time = start_time;

    std::string entryval;

    gentype memdata(0);
    gentype SDsum(0);
    gentype SDsumsq(0);
    gentype SDprod(1);
    Vector<gentype> SDdata;
    int SDcnt = 0;

    gentype iii(0);
    gentype testM;
    double tr;

    calcState tempnest;

    Stack<calcState> theCalcNest; // Calculator state
    theCalcNest.push(tempnest);

    int dummyi;
    gentype tempXY;
    std::string tempot;
    int tempft = -1;
    std::string tempfn("           ");

    while ( !exitnow )
    {
        if      ( gridhoriz < 0 ) { gridhoriz = 5; page = ( gridvert < 3 ) ? ( ( page <= FIRSTSF_PAGE ) ? LASTSF_PAGE  : page-1 ) : page; }
        else if ( gridhoriz > 5 ) { gridhoriz = 0; page = ( gridvert < 3 ) ? ( ( page >= LASTSF_PAGE  ) ? FIRSTSF_PAGE : page+1 ) : page; }

        if      ( gridvert < 0 ) { gridvert = 6; }
        else if ( gridvert > 6 ) { gridvert = 0; }

        curr_time = TIMECALL;
        double timetakensec = TIMEDIFFSEC(curr_time,start_time);

        if ( plotmode && ( timetakensec > PLOTREPTIME ) )
        {
            // Plot function again (display version only)

            std::string fname;
            std::string dname;

            gentype fn = plotfn;

            std::string pre = "genplot";
            std::string post = ".gen";

            getUniqueFile(fname,pre,post);
            getUniqueFile(dname,pre,post);

            genplotit(xmin,xmax,ymin,ymax,fname,dname,0,fn,0); // to display

            std::string resname = fname+".txt";

            // text version now in file resname

            std::ifstream resfile(resname);

            int ij;
            size_t kl;
            char buffer[2048];
            std::string bufferb;

            for ( ij = 0 ; ij < NUMPLOTLINES ; ij++ )
            {
                buffer[0] = '\0';

                resfile.getline(buffer,2000);

                bufferb = buffer;

                for ( kl = 0 ; kl < bufferb.length() ; kl++ )
                {
                    if ( !isprint(bufferb[kl]) )
                    {
                        bufferb[kl] = ' ';
                    }
                }

                if ( bufferb.length() <= rightblank )
                {
                    rightplot[ij] = bufferb;
                }

                else
                {
                    rightplot[ij] = bufferb.substr(0,rightblank);
                }
            }

            resfile.close();
            refresh = 1;

            std::string delstringd = "rm "+resname;

            svm_system(delstringd.c_str());

            start_time = TIMECALL;
        }

        if ( refresh )
        {
//          mempty = ( memdata == zerogentype ) ? 1 : 0;
          mempty = ( memdata == 0.0_gent ) ? 1 : 0;

          refresh = 0;

          svmcurs(0,0);

          std::string datadisp;
          std::string modedisp;

          std::stringstream ss;

          if ( dataDisplay == 0 )
          {
              datadisp = entryval;
          }

/*
          else if ( GETX.isValError() )
          {
              gentype tempx = GETX;

              theCalcNest.resize(0);
              theCalcNest.push(tempnest);

              GETX = tempx;

              datadisp = "E";
          }
*/

          else if ( isdmsmode && GETX.isCastableToRealWithoutLoss() )
          {
              double secval = (double) GETX;
              int sgnval = ( secval < 0 ) ? -1 : +1;

              secval = ( sgnval < 0 ) ? -secval : secval;

              // Note rounding that is required for some reason

              int degval = (int) secval; secval -= degval; secval *= 60; secval += 1e-7/60; // (1e-7/60 chosen so that it doesn't get displayed by %.6f format)
              int minval = (int) secval; secval -= minval; secval *= 60;

              char degstr[256];
              char minstr[256];
              char secstr[256];

              sprintf(degstr,"%d",  degval);
              sprintf(minstr,"%d",  minval);
              sprintf(secstr,"%.6f",secval);

              datadisp = ( sgnval == -1 ) ? "-" : "";

              datadisp += degstr; datadisp += " ' ";
              datadisp += minstr; datadisp += " ' ";
              datadisp += secstr;
          }

          else if ( GETX.isValEqn() )
          {
              datadisp = GETX.cast_string();
          }

          else
          {
              datadisp = (const std::string &) GETX;
          }

          for ( ii = 0 ; ii < datadisp.size() ; ii++ )
          {
              datadisp[ii] = ( ( datadisp[ii] == '\t' ) ? ' ' : datadisp[ii] );
              datadisp[ii] = ( ( datadisp[ii] == '\n' ) ? ' ' : datadisp[ii] );
          }

          if ( datadisp.size() < 3*datawidth )
          {
              datadisp.insert(0,(3*datawidth)-datadisp.size(),' ');
          }

          else if ( datadisp.size() > 3*datawidth )
          {
              datadisp = datadisp.substr(0,(3*datawidth)-5);
              datadisp += ".....";
          }

          std::string datadispa = datadisp.substr(0,datawidth);
          std::string datadispb = datadisp.substr(datawidth,datawidth);
          std::string datadispc = datadisp.substr(2*datawidth,datawidth);

          std::string topop = calcNest.optype.accessTop();

          while ( topop.size() < 4 )
          {
              topop += " ";
          }

          std::string fncallname;
          std::string fnhelptext;

          std::string helpstring;

          // get fncallname

          {
             if ( ( gridvert == 3 ) && ( gridhoriz == 4 ) && !isinv ) { /* C  */ fnhelptext = "Clear immediate data."; }
        else if ( ( gridvert == 3 ) && ( gridhoriz == 5 )           ) { /* AC */ fnhelptext = "Clear all.";            }

        // State control

        else if ( ( gridvert == 0 ) && ( gridhoriz == 0 )                                             ) { /* INV */ fnhelptext = "Set/unset inverse modifier.";                   }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 1 ) &&                                   !isinv ) { /* DRG */ fnhelptext = "Cycle angle mode (degrees/radians/gradians).";  }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 1 ) &&                                    isinv ) { /* SD  */ fnhelptext = "Set/unset standard deviation mode.";            }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 2 ) && ( page == MYCALCSF_PAGE      )           ) { /* HYP */ fnhelptext = "Set/unset hyperbolic mode for trig functions."; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 2 ) && ( page == OBSCURETRIGI__PAGE )           ) { /* HYP */ fnhelptext = "Set/unset hyperbolic mode for trig functions."; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 2 ) && ( page == OBSCURETRIGII_PAGE )           ) { /* HYP */ fnhelptext = "Set/unset hyperbolic mode for trig functions."; }

        // Display mode and dms functions

        else if ( ( gridvert == 1 ) && ( gridhoriz == 2 ) && ( page == MYCALCSF_PAGE      ) &&  isinv ) { /* <-- */ fnhelptext = "Set/unset display in degrees-minutes-seconds mode."; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 2 ) && ( page == OBSCURETRIGI__PAGE ) &&  isinv ) { /* <-- */ fnhelptext = "Set/unset display in degrees-minutes-seconds mode."; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 2 ) && ( page == OBSCURETRIGII_PAGE ) &&  isinv ) { /* <-- */ fnhelptext = "Set/unset display in degrees-minutes-seconds mode."; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 2 ) && ( page == MYCALCSF_PAGE      ) && !isinv ) { /* .'" */ fnhelptext = "Data entry in degrees-minutes-seconds mode.";        }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 2 ) && ( page == OBSCURETRIGI__PAGE ) && !isinv ) { /* .'" */ fnhelptext = "Data entry in degrees-minutes-seconds mode.";        }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 2 ) && ( page == OBSCURETRIGII_PAGE ) && !isinv ) { /* .'" */ fnhelptext = "Data entry in degrees-minutes-seconds mode.";        }

        // Simple memory adjustment - uses UPDATE_EVAL_OP as these evaluate expression before operation

        else if ( ( gridvert == 6 ) && ( gridhoriz == 5 ) &&                                 !isinv && !SDmode ) { /* M+   */ fnhelptext = "Add to memory.";        }
        else if ( ( gridvert == 6 ) && ( gridhoriz == 5 ) &&                                  isinv && !SDmode ) { /* M-   */ fnhelptext = "Subtract from memory."; }
        else if ( ( gridvert == 6 ) && ( gridhoriz == 5 ) &&                                 !isinv &&  SDmode ) { /* M+   */ fnhelptext = "Add to dataset.";       }
        else if ( ( gridvert == 6 ) && ( gridhoriz == 5 ) &&                                  isinv &&  SDmode ) { /* xdel */ fnhelptext = "Remove from dataset.";  }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == TESTFUNCIII_PAGE ) &&  isinv            ) { /* M=   */ fnhelptext = "Set memory.";           }

        // Memory in and memory reset

        else if ( ( gridvert == 2 ) && ( gridhoriz == 4 ) && !isinv && !SDmode ) { /* Min */ fnhelptext = "Memory in.";                 }
        else if ( ( gridvert == 2 ) && ( gridhoriz == 5 ) && !isinv && !SDmode ) { /* MR  */ fnhelptext = "Memory reset.";              }
        else if ( ( gridvert == 2 ) && ( gridhoriz == 4 ) &&  isinv && !SDmode ) { /* ah  */ fnhelptext = "Toggle anionic handedness."; }
        else if ( ( gridvert == 2 ) && ( gridhoriz == 5 ) &&  isinv && !SDmode ) { /* ew  */ fnhelptext = "Toggle elementwise forms.";  }
        else if ( ( gridvert == 2 ) && ( gridhoriz == 1 ) && !isinv && !SDmode ) { /* X-Y */ fnhelptext = "Exchange X and Y.";          }
        else if ( ( gridvert == 2 ) && ( gridhoriz == 1 ) &&  isinv && !SDmode ) { /* X-M */ fnhelptext = "Exchange X and M.";          }

        // Complex, Quaternion, Octionion, Anion

        else if ( ( gridvert == 3 ) && ( gridhoriz == 0 ) && !isinv ) { /* i */ fnhelptext = "Complex imaginary i."; }
        else if ( ( gridvert == 4 ) && ( gridhoriz == 0 ) && !isinv ) { /* I */ fnhelptext = "Quaternion imaginary I."; }
        else if ( ( gridvert == 5 ) && ( gridhoriz == 0 ) && !isinv ) { /* J */ fnhelptext = "Quaternion imaginary J."; }
        else if ( ( gridvert == 6 ) && ( gridhoriz == 0 ) && !isinv ) { /* K */ fnhelptext = "Quaternion imaginary K."; }
        else if ( ( gridvert == 3 ) && ( gridhoriz == 0 ) &&  isinv ) { /* l */ fnhelptext = "Octonion imaginary l."; }
        else if ( ( gridvert == 4 ) && ( gridhoriz == 0 ) &&  isinv ) { /* m */ fnhelptext = "Octonion imaginary m."; }
        else if ( ( gridvert == 5 ) && ( gridhoriz == 0 ) &&  isinv ) { /* n */ fnhelptext = "Octonion imaginary n."; }
        else if ( ( gridvert == 6 ) && ( gridhoriz == 0 ) &&  isinv ) { /* o */ fnhelptext = "Octonion imaginary o."; }
        else if ( ( gridvert == 3 ) && ( gridhoriz == 1 ) &&  isinv ) { /* p */ fnhelptext = "Octonion imaginary p."; }
        else if ( ( gridvert == 4 ) && ( gridhoriz == 1 ) &&  isinv ) { /* q */ fnhelptext = "Octonion imaginary q."; }
        else if ( ( gridvert == 5 ) && ( gridhoriz == 1 ) &&  isinv ) { /* r */ fnhelptext = "Octonion imaginary r."; }

        // SD memory

        else if ( ( gridvert == 2 ) && ( gridhoriz == 0 ) && SDmode && !isinv ) { /* sum x^2   */ fnhelptext = "Sum of squares.";            }
        else if ( ( gridvert == 2 ) && ( gridhoriz == 1 ) && SDmode && !isinv ) { /* sum x     */ fnhelptext = "Sum.";                       }
        else if ( ( gridvert == 2 ) && ( gridhoriz == 2 ) && SDmode && !isinv ) { /* n         */ fnhelptext = "Number of elements.";        }
        else if ( ( gridvert == 2 ) && ( gridhoriz == 3 ) && SDmode && !isinv ) { /* xbar      */ fnhelptext = "Mean.";                      }
        else if ( ( gridvert == 2 ) && ( gridhoriz == 4 ) && SDmode && !isinv ) { /* sigma_n   */ fnhelptext = "Standard deviation.";        }
        else if ( ( gridvert == 2 ) && ( gridhoriz == 5 ) && SDmode && !isinv ) { /* sigma_n-1 */ fnhelptext = "Sample standard deviation."; }
        else if ( ( gridvert == 2 ) && ( gridhoriz == 0 ) && SDmode &&  isinv ) { /* prod x^2  */ fnhelptext = "Product of squares.";        }
        else if ( ( gridvert == 2 ) && ( gridhoriz == 1 ) && SDmode &&  isinv ) { /* prod x    */ fnhelptext = "Product.";                   }
        else if ( ( gridvert == 2 ) && ( gridhoriz == 2 ) && SDmode &&  isinv ) { /* argmedian */ fnhelptext = "Index of median.";           }
        else if ( ( gridvert == 2 ) && ( gridhoriz == 3 ) && SDmode &&  isinv ) { /* median    */ fnhelptext = "Median.";                    }
        else if ( ( gridvert == 2 ) && ( gridhoriz == 4 ) && SDmode &&  isinv ) { /* range     */ fnhelptext = "Range.";                     }
        else if ( ( gridvert == 2 ) && ( gridhoriz == 5 ) && SDmode &&  isinv ) { /* midrange  */ fnhelptext = "Midrange.";                  }

        // Simple unary operators

        else if ( ( gridvert == 2 ) && ( gridhoriz == 0 ) &&                                !SDmode && !isinv ) { /* 1/x  */ fncallname = "inv";   }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 0 ) &&                                           !isinv ) { /* +-   */ fncallname = "neg";   }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 3 ) && ( page == ABSANGARG_PAGE  ) &&             isinv ) { /* conj */ fncallname = "conj";  }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == COMBMAXMIN_PAGE ) &&             isinv ) { /* T    */ fncallname = "trans"; }

        // Logs and exponents

        else if ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == MYCALCSF_PAGE ) && !isinv && !isah && !HYPmode ) { /* ln    */ fncallname = "log";   }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == MYCALCSF_PAGE ) && !isinv && !isah && !HYPmode ) { /* log   */ fncallname = "log10"; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == MYCALCSF_PAGE ) && !isinv &&  isah && !HYPmode ) { /* Ln    */ fncallname = "Log";   }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == MYCALCSF_PAGE ) && !isinv &&  isah && !HYPmode ) { /* Log   */ fncallname = "Log10"; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == MYCALCSF_PAGE ) &&  isinv &&          !HYPmode ) { /* e^x   */ fncallname = "exp";   }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == MYCALCSF_PAGE ) &&  isinv &&          !HYPmode ) { /* 10^x  */ fncallname = "tenup"; }

        // Trig functions

        else if ( ( gridvert == 1 ) && ( gridhoriz == 3 ) && ( page == MYCALCSF_PAGE      ) && !isinv && !HYPmode ) { /* sin     */ fncallname = "sin";     }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 4 ) && ( page == MYCALCSF_PAGE      ) && !isinv && !HYPmode ) { /* cos     */ fncallname = "cos";     }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 5 ) && ( page == MYCALCSF_PAGE      ) && !isinv && !HYPmode ) { /* tan     */ fncallname = "tan";     }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == OBSCURETRIGI__PAGE ) && !isinv && !HYPmode ) { /* cosec   */ fncallname = "cosec";   }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == OBSCURETRIGI__PAGE ) && !isinv && !HYPmode ) { /* sec     */ fncallname = "sec";     }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == OBSCURETRIGI__PAGE ) && !isinv && !HYPmode ) { /* cot     */ fncallname = "cot";     }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 3 ) && ( page == OBSCURETRIGI__PAGE ) && !isinv && !HYPmode ) { /* vers    */ fncallname = "vers";    }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 4 ) && ( page == OBSCURETRIGI__PAGE ) && !isinv && !HYPmode ) { /* covers  */ fncallname = "covers";  }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 5 ) && ( page == OBSCURETRIGI__PAGE ) && !isinv && !HYPmode ) { /* hav     */ fncallname = "hav";     }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == OBSCURETRIGII_PAGE ) && !isinv && !HYPmode ) { /* exsec   */ fncallname = "exsec";   }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == OBSCURETRIGII_PAGE ) && !isinv && !HYPmode ) { /* excosec */ fncallname = "excosec"; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == OBSCURETRIGII_PAGE ) && !isinv && !HYPmode ) { /* cas     */ fncallname = "castrg";  }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 5 ) && ( page == OBSCURETRIGII_PAGE ) && !isinv && !HYPmode ) { /* casc    */ fncallname = "casctrg"; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 4 ) && ( page == OBSCURETRIGII_PAGE ) &&  isinv && !HYPmode ) { /* gd      */ fncallname = "gd";      }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 3 ) && ( page == OBSCURETRIGII_PAGE ) && !isinv && !HYPmode ) { /* sinc    */ fncallname = "sinc";    }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 3 ) && ( page == OBSCURETRIGII_PAGE ) &&  isinv && !HYPmode ) { /* cosc    */ fncallname = "cosc";    }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 4 ) && ( page == OBSCURETRIGII_PAGE ) && !isinv && !HYPmode ) { /* tanc    */ fncallname = "tanc";    }

        // Inverse trig functions

        else if ( ( gridvert == 1 ) && ( gridhoriz == 3 ) && ( page == MYCALCSF_PAGE      ) &&  isinv && !HYPmode && !isah ) { /* asin     */ fncallname = "asin";     }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 4 ) && ( page == MYCALCSF_PAGE      ) &&  isinv && !HYPmode && !isah ) { /* acos     */ fncallname = "acos";     }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 3 ) && ( page == MYCALCSF_PAGE      ) &&  isinv && !HYPmode &&  isah ) { /* Asin     */ fncallname = "Asin";     }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 4 ) && ( page == MYCALCSF_PAGE      ) &&  isinv && !HYPmode &&  isah ) { /* Acos     */ fncallname = "Acos";     }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 5 ) && ( page == MYCALCSF_PAGE      ) &&  isinv && !HYPmode          ) { /* atan     */ fncallname = "atan";     }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == OBSCURETRIGI__PAGE ) &&  isinv && !HYPmode && !isah ) { /* acosec   */ fncallname = "acosec";   }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == OBSCURETRIGI__PAGE ) &&  isinv && !HYPmode && !isah ) { /* asec     */ fncallname = "asec";     }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == OBSCURETRIGI__PAGE ) &&  isinv && !HYPmode &&  isah ) { /* Acosec   */ fncallname = "Acosec";   }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == OBSCURETRIGI__PAGE ) &&  isinv && !HYPmode &&  isah ) { /* Asec     */ fncallname = "Asec";     }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == OBSCURETRIGI__PAGE ) &&  isinv && !HYPmode          ) { /* acot     */ fncallname = "acot";     }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 3 ) && ( page == OBSCURETRIGI__PAGE ) &&  isinv && !HYPmode && !isah ) { /* avers    */ fncallname = "avers";    }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 4 ) && ( page == OBSCURETRIGI__PAGE ) &&  isinv && !HYPmode && !isah ) { /* acovers  */ fncallname = "acovers";  }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 5 ) && ( page == OBSCURETRIGI__PAGE ) &&  isinv && !HYPmode && !isah ) { /* ahav     */ fncallname = "ahav";     }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == OBSCURETRIGII_PAGE ) &&  isinv && !HYPmode && !isah ) { /* aexsec   */ fncallname = "aexsec";   }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == OBSCURETRIGII_PAGE ) &&  isinv && !HYPmode && !isah ) { /* aexcosec */ fncallname = "aexcosec"; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == OBSCURETRIGII_PAGE ) &&  isinv && !HYPmode && !isah ) { /* acas     */ fncallname = "acastrg";  }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 5 ) && ( page == OBSCURETRIGII_PAGE ) &&  isinv && !HYPmode && !isah ) { /* acasc    */ fncallname = "acasctrg"; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 4 ) && ( page == OBSCURETRIGII_PAGE ) &&  isinv &&  HYPmode && !isah ) { /* agd      */ fncallname = "agd";      }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 3 ) && ( page == OBSCURETRIGI__PAGE ) &&  isinv && !HYPmode &&  isah ) { /* Avers    */ fncallname = "Avers";    }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 4 ) && ( page == OBSCURETRIGI__PAGE ) &&  isinv && !HYPmode &&  isah ) { /* Acovers  */ fncallname = "Acovers";  }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 5 ) && ( page == OBSCURETRIGI__PAGE ) &&  isinv && !HYPmode &&  isah ) { /* Ahav     */ fncallname = "Ahav";     }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == OBSCURETRIGII_PAGE ) &&  isinv && !HYPmode &&  isah ) { /* Aexsec   */ fncallname = "Aexsec";   }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == OBSCURETRIGII_PAGE ) &&  isinv && !HYPmode &&  isah ) { /* Aexcosec */ fncallname = "Aexcosec"; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == OBSCURETRIGII_PAGE ) &&  isinv && !HYPmode &&  isah ) { /* Acas     */ fncallname = "Acastrg";  }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 5 ) && ( page == OBSCURETRIGII_PAGE ) &&  isinv && !HYPmode &&  isah ) { /* Acasc    */ fncallname = "Acasctrg"; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 4 ) && ( page == OBSCURETRIGII_PAGE ) &&  isinv &&  HYPmode &&  isah ) { /* Agd      */ fncallname = "Agd";      }

        // Hyperbolic functions

        else if ( ( gridvert == 1 ) && ( gridhoriz == 3 ) && ( page == MYCALCSF_PAGE      ) && !isinv &&  HYPmode ) { /* sinh     */ fncallname = "sinh";     }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 4 ) && ( page == MYCALCSF_PAGE      ) && !isinv &&  HYPmode ) { /* cosh     */ fncallname = "cosh";     }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 5 ) && ( page == MYCALCSF_PAGE      ) && !isinv &&  HYPmode ) { /* tanh     */ fncallname = "tanh";     }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == OBSCURETRIGI__PAGE ) && !isinv &&  HYPmode ) { /* cosech   */ fncallname = "cosech";   }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == OBSCURETRIGI__PAGE ) && !isinv &&  HYPmode ) { /* sech     */ fncallname = "sech";     }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == OBSCURETRIGI__PAGE ) && !isinv &&  HYPmode ) { /* coth     */ fncallname = "coth";     }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 3 ) && ( page == OBSCURETRIGI__PAGE ) && !isinv &&  HYPmode ) { /* versh    */ fncallname = "versh";    }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 4 ) && ( page == OBSCURETRIGI__PAGE ) && !isinv &&  HYPmode ) { /* coversh  */ fncallname = "coversh";  }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 5 ) && ( page == OBSCURETRIGI__PAGE ) && !isinv &&  HYPmode ) { /* havh     */ fncallname = "havh";     }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == OBSCURETRIGII_PAGE ) && !isinv &&  HYPmode ) { /* exsech   */ fncallname = "exsech";   }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == OBSCURETRIGII_PAGE ) && !isinv &&  HYPmode ) { /* excosech */ fncallname = "excosech"; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == OBSCURETRIGII_PAGE ) && !isinv &&  HYPmode ) { /* cash     */ fncallname = "cashyp";   }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 5 ) && ( page == OBSCURETRIGII_PAGE ) && !isinv &&  HYPmode ) { /* casch    */ fncallname = "caschyp";  }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 3 ) && ( page == OBSCURETRIGII_PAGE ) && !isinv &&  HYPmode ) { /* sinhc    */ fncallname = "sinhc";    }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 3 ) && ( page == OBSCURETRIGII_PAGE ) &&  isinv &&  HYPmode ) { /* coshc    */ fncallname = "coshc";    }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 4 ) && ( page == OBSCURETRIGII_PAGE ) && !isinv &&  HYPmode ) { /* tanhc    */ fncallname = "tanhc";    }

        // Inverse hyperbolic functions
        // NOTE: have to break else-if sequence because studio c++ "blocks nested too deeply"

             if ( ( gridvert == 1 ) && ( gridhoriz == 3 ) && ( page == MYCALCSF_PAGE      ) &&  isinv &&  HYPmode          ) { /* asinh     */ fncallname = "asinh";     }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 4 ) && ( page == MYCALCSF_PAGE      ) &&  isinv &&  HYPmode && !isah ) { /* acosh     */ fncallname = "acosh";     }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 5 ) && ( page == MYCALCSF_PAGE      ) &&  isinv &&  HYPmode && !isah ) { /* atanh     */ fncallname = "atanh";     }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 4 ) && ( page == MYCALCSF_PAGE      ) &&  isinv &&  HYPmode &&  isah ) { /* Acosh     */ fncallname = "Acosh";     }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 5 ) && ( page == MYCALCSF_PAGE      ) &&  isinv &&  HYPmode &&  isah ) { /* Atanh     */ fncallname = "Atanh";     }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == OBSCURETRIGI__PAGE ) &&  isinv &&  HYPmode          ) { /* acosech   */ fncallname = "acosech";   }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == OBSCURETRIGI__PAGE ) &&  isinv &&  HYPmode && !isah ) { /* asech     */ fncallname = "asech";     }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == OBSCURETRIGI__PAGE ) &&  isinv &&  HYPmode && !isah ) { /* acoth     */ fncallname = "acoth";     }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 3 ) && ( page == OBSCURETRIGI__PAGE ) &&  isinv &&  HYPmode && !isah ) { /* aversh    */ fncallname = "aversh";    }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == OBSCURETRIGI__PAGE ) &&  isinv &&  HYPmode &&  isah ) { /* Asech     */ fncallname = "Asech";     }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == OBSCURETRIGI__PAGE ) &&  isinv &&  HYPmode &&  isah ) { /* Acoth     */ fncallname = "Acoth";     }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 3 ) && ( page == OBSCURETRIGI__PAGE ) &&  isinv &&  HYPmode &&  isah ) { /* Aversh    */ fncallname = "Aversh";    }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 4 ) && ( page == OBSCURETRIGI__PAGE ) &&  isinv &&  HYPmode          ) { /* acovrsh   */ fncallname = "acovrsh";   }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 5 ) && ( page == OBSCURETRIGI__PAGE ) &&  isinv &&  HYPmode && !isah ) { /* ahavh     */ fncallname = "ahavh";     }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == OBSCURETRIGII_PAGE ) &&  isinv &&  HYPmode && !isah ) { /* aexsech   */ fncallname = "aexsech";   }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 5 ) && ( page == OBSCURETRIGI__PAGE ) &&  isinv &&  HYPmode &&  isah ) { /* Ahavh     */ fncallname = "Ahavh";     }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == OBSCURETRIGII_PAGE ) &&  isinv &&  HYPmode &&  isah ) { /* Aexsech   */ fncallname = "Aexsech";   }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == OBSCURETRIGII_PAGE ) &&  isinv &&  HYPmode          ) { /* aexcosech */ fncallname = "aexcosech"; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == OBSCURETRIGII_PAGE ) &&  isinv &&  HYPmode && !isah ) { /* acash     */ fncallname = "acashyp";   }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 5 ) && ( page == OBSCURETRIGII_PAGE ) &&  isinv &&  HYPmode && !isah ) { /* acasch    */ fncallname = "acaschyp";  }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == OBSCURETRIGII_PAGE ) &&  isinv &&  HYPmode &&  isah ) { /* Acash     */ fncallname = "Acashyp";   }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 5 ) && ( page == OBSCURETRIGII_PAGE ) &&  isinv &&  HYPmode &&  isah ) { /* Acasch    */ fncallname = "Acaschyp";  }

        // Complex functions

        else if ( ( gridvert == 1 ) && ( gridhoriz == 2 ) && ( page == ABSANGARG_PAGE ) && !isinv          ) { /* Re      */ fncallname = "real";          }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 2 ) && ( page == ABSANGARG_PAGE ) &&  isinv          ) { /* Im      */ fncallname = "imag";          }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == ABSANGARG_PAGE ) && !isinv          ) { /* arg     */ fncallname = "arg";           }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == ABSANGARG_PAGE ) &&  isinv          ) { /* angle   */ fncallname = "angle";         }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 2 ) && ( page == ABSANGARG_PAGE ) && !isinv && !isew ) { /* abs0    */ fncallname = "abs0";          }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 2 ) && ( page == ABSANGARG_PAGE ) &&  isinv && !isew ) { /* abs1    */ fncallname = "abs1";          }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == ABSANGARG_PAGE ) && !isinv && !isew ) { /* abs2    */ fncallname = "abs2";          }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == ABSANGARG_PAGE ) && !isinv && !isew ) { /* absinf  */ fncallname = "absinf";        }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 2 ) && ( page == ABSANGARG_PAGE ) && !isinv &&  isew ) { /* eabs0   */ fncallname = "eabs0";         }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 2 ) && ( page == ABSANGARG_PAGE ) &&  isinv &&  isew ) { /* eabs1   */ fncallname = "eabs1";         }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == ABSANGARG_PAGE ) && !isinv &&  isew ) { /* eabs2   */ fncallname = "eabs2";         }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == ABSANGARG_PAGE ) && !isinv &&  isew ) { /* eabsinf */ fncallname = "eabsinf";       }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 2 ) && ( page == ODDITIES_PAGE  ) && !isinv          ) { /* [x,y]   */ fncallname = "commutate";     }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 2 ) && ( page == ODDITIES_PAGE  ) &&  isinv          ) { /* {x,y}   */ fncallname = "anticommutate"; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 3 ) && ( page == ODDITIES_PAGE  ) && !isinv          ) { /* [x,y,z] */ fncallname = "associate";     }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 3 ) && ( page == ODDITIES_PAGE  ) &&  isinv          ) { /* {x,y,z} */ fncallname = "antiassociate"; }

        // Integer stuff

        else if ( ( gridvert == 1 ) && ( gridhoriz == 3 ) && ( page == ABSANGARG_PAGE ) && !isinv ) { /* rint  */ fncallname = "rint";  }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 4 ) && ( page == ABSANGARG_PAGE ) && !isinv ) { /* floor */ fncallname = "floor"; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 4 ) && ( page == ABSANGARG_PAGE ) &&  isinv ) { /* ceil  */ fncallname = "ceil";  }

        // Matrix operations

        else if ( ( gridvert == 1 ) && ( gridhoriz == 2 ) && ( page == ADVANCEDSFI_PAGE ) && !isinv ) { /* det   */ fncallname = "det";   }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 2 ) && ( page == ADVANCEDSFI_PAGE ) &&  isinv ) { /* trace */ fncallname = "trace"; }

        // Distributions

        else if ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == ODDITIES_PAGE ) && !isinv ) { /* normDistr */ fncallname = "normDistr"; }

        // Derivatives

        else if ( ( gridvert == 0 ) && ( gridhoriz == 2 ) && ( page == VARDERIV_PAGE ) &&  isinv ) { /* d/dx */ fnhelptext = "Symbolic derivative with respect to x."; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == VARDERIV_PAGE ) &&  isinv ) { /* d/dy */ fnhelptext = "Symbolic derivative with respect to y."; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == VARDERIV_PAGE ) &&  isinv ) { /* d/dz */ fnhelptext = "Symbolic derivative with respect to z."; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == VARDERIV_PAGE ) &&  isinv ) { /* d/dv */ fnhelptext = "Symbolic derivative with respect to v."; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 2 ) && ( page == VARDERIV_PAGE ) &&  isinv ) { /* d/dw */ fnhelptext = "Symbolic derivative with respect to w."; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 3 ) && ( page == VARDERIV_PAGE ) &&  isinv ) { /* d/dg */ fnhelptext = "Symbolic derivative with respect to g."; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 4 ) && ( page == VARDERIV_PAGE ) &&  isinv ) { /* d/dh */ fnhelptext = "Symbolic derivative with respect to h."; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 5 ) && ( page == VARDERIV_PAGE ) &&  isinv ) { /* d/du */ fnhelptext = "Symbolic derivative with respect to u."; }

        // Misc operations

        else if ( ( gridvert == 1 ) && ( gridhoriz == 0 ) &&                                               isinv && !isah ) { /* cbrt       */ fncallname = "cbrt";          }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 1 ) &&                                              !isinv && !isah ) { /* sqrt       */ fncallname = "sqrt";          }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 0 ) &&                                               isinv &&  isah ) { /* Cbrt       */ fncallname = "Cbrt";          }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 1 ) &&                                              !isinv &&  isah ) { /* Sqrt       */ fncallname = "Sqrt";          }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 1 ) &&                                               isinv          ) { /* x^2        */ fnhelptext = "Evaluate x*x."; }
        else if ( ( gridvert == 2 ) && ( gridhoriz == 0 ) &&                                   !SDmode &&  isinv          ) { /* x!         */ fncallname = "fact";          }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 2 ) && ( page == COMBMAXMIN_PAGE    ) &&            !isinv          ) { /* fact       */ fncallname = "fact";          }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == ABSANGARG_PAGE     ) &&             isinv          ) { /* sgn        */ fncallname = "sgn";           }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == ADVANCEDSFI_PAGE   ) &&            !isinv          ) { /* erf        */ fncallname = "erf";           }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == ADVANCEDSFI_PAGE   ) &&             isinv          ) { /* erfc       */ fncallname = "erfc";          }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 2 ) && ( page == ADVANCEDSFI_PAGE   ) &&            !isinv          ) { /* sigm       */ fncallname = "sigm";          }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 2 ) && ( page == ADVANCEDSFI_PAGE   ) &&             isinv && !isah ) { /* asigm      */ fncallname = "asigm";         }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 2 ) && ( page == ADVANCEDSFI_PAGE   ) &&             isinv &&  isah ) { /* Asigm      */ fncallname = "Asigm";         }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == ADVANCEDSFI_PAGE   ) &&            !isinv          ) { /* lambertW   */ fncallname = "lambertW";      }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == ADVANCEDSFI_PAGE   ) &&             isinv          ) { /* lambertWx  */ fncallname = "lambertWx";     }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == ADVANCEDSFI_PAGE   ) &&            !isinv          ) { /* gamma      */ fncallname = "gamma";         }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == ADVANCEDSFI_PAGE   ) &&             isinv          ) { /* lngamma    */ fncallname = "lngamma";       }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 3 ) && ( page == ADVANCEDSFI_PAGE   ) &&            !isinv          ) { /* psi        */ fncallname = "psi";           }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 4 ) && ( page == ADVANCEDSFI_PAGE   ) &&            !isinv          ) { /* dawson     */ fncallname = "dawson";        }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 4 ) && ( page == ADVANCEDSFI_PAGE   ) &&             isinv          ) { /* zeta       */ fncallname = "zeta";          }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == COMBMAXMIN_PAGE    ) && !isew   &&  isinv          ) { /* diracDelta */ fncallname = "diracDelta";    }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == COMBMAXMIN_PAGE    ) &&  isew   &&  isinv          ) { /* ediracDelta*/ fncallname = "ediracDelta";   }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 3 ) && ( page == COMBMAXMIN_PAGE    ) &&            !isinv          ) { /* sf         */ fncallname = "sf";            }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 3 ) && ( page == COMBMAXMIN_PAGE    ) &&             isinv          ) { /* psf        */ fncallname = "psf";           }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 2 ) && ( page == COMBMAXMIN_PAGE    ) &&             isinv          ) { /* dfact      */ fncallname = "dfact";         }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == COMBMAXMIN_PAGE    ) &&            !isinv          ) { /* tfact      */ fncallname = "tfact";         }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == COMBMAXMIN_PAGE    ) &&             isinv          ) { /* subfact    */ fncallname = "subfact";       }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 4 ) && ( page == COMBMAXMIN_PAGE    ) &&            !isinv          ) { /* argmax     */ fncallname = "argmax";        }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 4 ) && ( page == COMBMAXMIN_PAGE    ) &&             isinv          ) { /* argmin     */ fncallname = "argmin";        }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 5 ) && ( page == COMBMAXMIN_PAGE    ) &&            !isinv          ) { /* max        */ fncallname = "max";           }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 5 ) && ( page == COMBMAXMIN_PAGE    ) &&             isinv          ) { /* min        */ fncallname = "min";           }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 2 ) && ( page == ODDITIES_PAGE      ) &&            !isinv          ) { /* sum        */ fncallname = "sum";           }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 2 ) && ( page == ODDITIES_PAGE      ) &&             isinv && !isah ) { /* prod       */ fncallname = "prod";          }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 2 ) && ( page == ODDITIES_PAGE      ) &&             isinv &&  isah ) { /* Prod       */ fncallname = "Prod";          }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 4 ) && ( page == ODDITIES_PAGE      ) &&            !isinv          ) { /* mean       */ fncallname = "mean";          }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 4 ) && ( page == ODDITIES_PAGE      ) &&             isinv          ) { /* median     */ fncallname = "median";        }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 5 ) && ( page == ODDITIES_PAGE      ) &&            !isinv          ) { /* argmedian  */ fncallname = "argmedian";     }

        // Random numbers
        // NOTE: have to break else-if sequence because studio c++ "blocks nested too deeply"

             if ( ( gridvert == 0 ) && ( gridhoriz == 2 ) && ( page == DISTRIBI___PAGE ) && !isinv ) { /* Chi-squared */ fnhelptext = "Generate random number from Chi-squared distribution.";       }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == DISTRIBI___PAGE ) && !isinv ) { /* Cauchy      */ fnhelptext = "Generate random number from Cauchy distribution.";            }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == DISTRIBI___PAGE ) && !isinv ) { /* Fisher-F    */ fnhelptext = "Generate random number from Fisher-F distribution.";          }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == DISTRIBI___PAGE ) && !isinv ) { /* Student-t   */ fnhelptext = "Generate random number from Student-t distribution.";         }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 2 ) && ( page == DISTRIBI___PAGE ) && !isinv ) { /* Exponential */ fnhelptext = "Generate random number from Exponential distribution.";       }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 3 ) && ( page == DISTRIBI___PAGE ) && !isinv ) { /* +Binomial   */ fnhelptext = "Generate random number from positive Binomial distribution."; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 4 ) && ( page == DISTRIBI___PAGE ) && !isinv ) { /* -Binomial   */ fnhelptext = "Generate random number from negative Binomial distribution."; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 5 ) && ( page == DISTRIBI___PAGE ) && !isinv ) { /* Geometric   */ fnhelptext = "Generate random number from Geometric distribution.";         }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 2 ) && ( page == DISTRIBI___PAGE ) &&  isinv ) { /* n.randc     */ fnhelptext = "Generate random number from Chi-squared distribution.";       }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == DISTRIBI___PAGE ) &&  isinv ) { /* n.randt     */ fnhelptext = "Generate random number from Fisher-F distribution.";          }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 2 ) && ( page == DISTRIBI___PAGE ) &&  isinv ) { /* p.rande     */ fnhelptext = "Generate random number from Exponential distribution.";       }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 5 ) && ( page == DISTRIBI___PAGE ) &&  isinv ) { /* p.randg     */ fnhelptext = "Generate random number from Geometric distribution.";         }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 2 ) && ( page == DISTRIBII__PAGE ) && !isinv ) { /* Log-normal  */ fnhelptext = "Generate random number from Log-normal distribution.";        }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == DISTRIBII__PAGE ) && !isinv ) { /* p.Bernoulli */ fnhelptext = "Generate random number from Bernoulli distribution.";         }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == DISTRIBII__PAGE ) && !isinv ) { /* Uniform     */ fnhelptext = "Generate random number from Uniform distribution.";           }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == DISTRIBII__PAGE ) && !isinv ) { /* Poisson     */ fnhelptext = "Generate random number from Poisson distribution.";           }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 2 ) && ( page == DISTRIBII__PAGE ) && !isinv ) { /* Gamma       */ fnhelptext = "Generate random number from Gamma distribution.";             }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 3 ) && ( page == DISTRIBII__PAGE ) && !isinv ) { /* Weibull     */ fnhelptext = "Generate random number from Weibull distribution.";           }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 4 ) && ( page == DISTRIBII__PAGE ) && !isinv ) { /* Extreme-val */ fnhelptext = "Generate random number from Extreme-value distribution.";     }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 5 ) && ( page == DISTRIBII__PAGE ) && !isinv ) { /* Normal      */ fnhelptext = "Generate random number from Normal distribution.";            }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == DISTRIBII__PAGE ) &&  isinv ) { /* irand       */ fnhelptext = "Generate integer random number (uniformly).";                 }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == DISTRIBII__PAGE ) &&  isinv ) { /* m.randp     */ fnhelptext = "Generate random number from Poisson distribution.";           }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 2 ) && ( page == DISTRIBIII_PAGE ) && !isinv ) { /* Rademacher  */ fnhelptext = "Generate random number from Rademacher distribution.";        }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 2 ) && ( page == DISTRIBIII_PAGE ) &&  isinv ) { /* p.randr     */ fnhelptext = "Generate random number from Rademacher distribution.";        }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 2 ) && ( page == DISTRIBII__PAGE ) &&  isinv ) { /* m.randl.s   */ fnhelptext = "Generate random number from log-normal distribution.";        }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == DISTRIBII__PAGE ) &&  isinv ) { /* a.randu.b   */ fnhelptext = "Generate random number from uniform distribution.";           }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == DISTRIBI___PAGE ) &&  isinv ) { /* a.randC.b   */ fnhelptext = "Generate random number from Cauchy distribution.";            }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == DISTRIBI___PAGE ) &&  isinv ) { /* m.randf.n   */ fnhelptext = "Generate random number from Fisher F-distribution.";          }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 3 ) && ( page == DISTRIBI___PAGE ) &&  isinv ) { /* t.randb.p   */ fnhelptext = "Generate random number from Binomial distribution.";          }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 4 ) && ( page == DISTRIBI___PAGE ) &&  isinv ) { /* k.randB.p   */ fnhelptext = "Generate random number from Negative binomial distribution."; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 2 ) && ( page == DISTRIBII__PAGE ) &&  isinv ) { /* a.randG.p   */ fnhelptext = "Generate random number from Gamma distribution.";             }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 3 ) && ( page == DISTRIBII__PAGE ) &&  isinv ) { /* a.randw.b   */ fnhelptext = "Generate random number from Weibull distribution.";           }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 4 ) && ( page == DISTRIBII__PAGE ) &&  isinv ) { /* a.randx.b   */ fnhelptext = "Generate random number from Extreme-value distribution.";     }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 5 ) && ( page == DISTRIBII__PAGE ) &&  isinv ) { /* a.randn.s   */ fnhelptext = "Generate random number from Normal distribution.";            }

        // Logic functions

        else if ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == LOGIC_PAGE ) && !isinv          ) { /* lnot */ fncallname = "lnot";  }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == LOGIC_PAGE ) &&  isinv          ) { /* lis  */ fncallname = "lis";   }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 2 ) && ( page == LOGIC_PAGE ) && !isinv && !isew ) { /* gt   */ fncallname = "gt";    }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 2 ) && ( page == LOGIC_PAGE ) &&  isinv && !isew ) { /* le   */ fncallname = "le";    }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == LOGIC_PAGE ) && !isinv && !isew ) { /* lt   */ fncallname = "lt";    }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == LOGIC_PAGE ) &&  isinv && !isew ) { /* ge   */ fncallname = "ge";    }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == LOGIC_PAGE ) && !isinv && !isew ) { /* eq   */ fncallname = "eq";    }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == LOGIC_PAGE ) &&  isinv && !isew ) { /* ne   */ fncallname = "ne";    }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 2 ) && ( page == LOGIC_PAGE ) && !isinv &&  isew ) { /* egt  */ fncallname = "egt";   }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 2 ) && ( page == LOGIC_PAGE ) &&  isinv &&  isew ) { /* ele  */ fncallname = "ele";   }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == LOGIC_PAGE ) && !isinv &&  isew ) { /* elt  */ fncallname = "elt";   }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == LOGIC_PAGE ) &&  isinv &&  isew ) { /* ege  */ fncallname = "ege";   }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == LOGIC_PAGE ) && !isinv &&  isew ) { /* eeq  */ fncallname = "eeq";   }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == LOGIC_PAGE ) &&  isinv &&  isew ) { /* ene  */ fncallname = "ene";   }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 2 ) && ( page == LOGIC_PAGE ) && !isinv          ) { /* and  */ fncallname = "land";  }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 2 ) && ( page == LOGIC_PAGE ) &&  isinv          ) { /* nand */ fncallname = "lnand"; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 3 ) && ( page == LOGIC_PAGE ) && !isinv          ) { /* or   */ fncallname = "lor";   }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 3 ) && ( page == LOGIC_PAGE ) &&  isinv          ) { /* nor  */ fncallname = "lnor";  }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 4 ) && ( page == LOGIC_PAGE ) && !isinv          ) { /* xor  */ fncallname = "lxor";  }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 4 ) && ( page == LOGIC_PAGE ) &&  isinv          ) { /* xand */ fncallname = "lxand"; }

        // Test functions

        else if ( ( gridvert == 0 ) && ( gridhoriz == 2 ) && ( page == FTYPE_PAGE ) && !isinv ) { /* isnan    */ fncallname = "isvnan";   }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 2 ) && ( page == FTYPE_PAGE ) &&  isinv ) { /* isinf    */ fncallname = "isinf";    }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == FTYPE_PAGE ) && !isinv ) { /* ispinf   */ fncallname = "ispinf";   }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == FTYPE_PAGE ) &&  isinv ) { /* isninf   */ fncallname = "isninf";   }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == FTYPE_PAGE ) && !isinv ) { /* isnull   */ fncallname = "isnull";   }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 2 ) && ( page == FTYPE_PAGE ) && !isinv ) { /* isint    */ fncallname = "isint";    }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 2 ) && ( page == FTYPE_PAGE ) &&  isinv ) { /* isnull   */ fncallname = "isnull";   }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 3 ) && ( page == FTYPE_PAGE ) && !isinv ) { /* isvector */ fncallname = "isvector"; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 3 ) && ( page == FTYPE_PAGE ) &&  isinv ) { /* ismatrix */ fncallname = "ismatrix"; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 4 ) && ( page == FTYPE_PAGE ) && !isinv ) { /* isreal   */ fncallname = "isreal";   }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 4 ) && ( page == FTYPE_PAGE ) &&  isinv ) { /* iscomp   */ fncallname = "isanion";  }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 5 ) && ( page == FTYPE_PAGE ) && !isinv ) { /* isstring */ fncallname = "isstring"; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 5 ) && ( page == FTYPE_PAGE ) &&  isinv ) { /* iserror  */ fncallname = "iserror";  }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == FTYPE_PAGE ) &&  isinv ) { /* size     */ fncallname = "size";     }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == FTYPE_PAGE ) && !isinv ) { /* numRows  */ fncallname = "numRows";  }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == FTYPE_PAGE ) &&  isinv ) { /* numCols  */ fncallname = "numCols";  }

        // Time functions

        else if ( ( gridvert == 0 ) && ( gridhoriz == 2 ) && ( page == TIME_PAGE ) && !isinv ) { /* clkyear */ fncallname = "clkyear";  }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 2 ) && ( page == TIME_PAGE ) &&  isinv ) { /* clkmon  */ fncallname = "clkmon";   }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == TIME_PAGE ) && !isinv ) { /* clkday  */ fncallname = "clkday";   }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == TIME_PAGE ) &&  isinv ) { /* clkhour */ fncallname = "clkhour";  }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == TIME_PAGE ) && !isinv ) { /* clkmin  */ fncallname = "clkmin";   }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == TIME_PAGE ) &&  isinv ) { /* clksec  */ fncallname = "clksec";   }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == TIME_PAGE ) && !isinv ) { /* tnow    */ fncallname = "tnow";     }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == TIME_PAGE ) &&  isinv ) { /* tnow    */ fncallname = "tnow";     }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 2 ) && ( page == TIME_PAGE ) && !isinv ) { /* clkyear */ fncallname = "clkyear";  }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 2 ) && ( page == TIME_PAGE ) &&  isinv ) { /* clkmon  */ fncallname = "clkmon";   }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 3 ) && ( page == TIME_PAGE ) && !isinv ) { /* clkday  */ fncallname = "clkday";   }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 3 ) && ( page == TIME_PAGE ) &&  isinv ) { /* clkhour */ fncallname = "clkhour";  }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 4 ) && ( page == TIME_PAGE ) && !isinv ) { /* clkmin  */ fncallname = "clkmin";   }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 4 ) && ( page == TIME_PAGE ) &&  isinv ) { /* clksec  */ fncallname = "clksec";   }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 5 ) && ( page == TIME_PAGE ) && !isinv ) { /* tnow    */ fnhelptext = "Function to draw analog clock."; }

        // Binary functions

        else if ( ( gridvert == 5 ) && ( gridhoriz == 4 ) &&                                  isinv                      ) { /* x RtoP y  */ fnhelptext = "Rectangular to polar form.";  }
        else if ( ( gridvert == 5 ) && ( gridhoriz == 5 ) &&                                  isinv                      ) { /* x PtoR y  */ fnhelptext = "Polar to rectangular form.";  }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == ODDITIES_PAGE    ) &&  isinv             && !isah ) { /* polyDistr */ fncallname = "polyDistr";                   }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == ODDITIES_PAGE    ) &&  isinv             &&  isah ) { /* PolyDistr */ fncallname = "PolyDistr";                   }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 3 ) && ( page == ADVANCEDSFI_PAGE ) &&  isinv                      ) { /* psi       */ fncallname = "psi_n";                       }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 5 ) && ( page == ADVANCEDSFI_PAGE ) && !isinv                      ) { /* gami      */ fncallname = "gami";                        }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 5 ) && ( page == ADVANCEDSFI_PAGE ) &&  isinv                      ) { /* gamic     */ fncallname = "gamic";                       }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 5 ) && ( page == ABSANGARG_PAGE   ) && !isinv                      ) { /* w bern y  */ fncallname = "bern";                        }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 5 ) && ( page == ABSANGARG_PAGE   ) &&  isinv                      ) { /* x outer y */ fncallname = "outerProd";                   }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 2 ) && ( page == COMBMAXMIN_PAGE  ) && !isinv                      ) { /* nPr       */ fncallname = "perm";                        }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 2 ) && ( page == COMBMAXMIN_PAGE  ) &&  isinv                      ) { /* nCr       */ fncallname = "comb";                        }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == COMBMAXMIN_PAGE  ) && !isinv             && !isew ) { /* KronDelta */ fncallname = "kronDelta";                   }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == COMBMAXMIN_PAGE  ) && !isinv             &&  isew ) { /* eKronDelta*/ fncallname = "ekronDelta";                   }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == COMBMAXMIN_PAGE  ) && !isinv                      ) { /* multifact */ fncallname = "multifact";                   }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == ODDITIES_PAGE    ) &&  isinv                      ) { /* I_(n,m)   */ fncallname = "eye";                         }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 2 ) && ( page == VARSET_PAGE      ) && !isinv                      ) { /* x=        */ fnhelptext = "Substitute x in expression."; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == VARSET_PAGE      ) && !isinv                      ) { /* y=        */ fnhelptext = "Substitute y in expression."; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == VARSET_PAGE      ) && !isinv                      ) { /* z=        */ fnhelptext = "Substitute z in expression."; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == VARSET_PAGE      ) && !isinv                      ) { /* v=        */ fnhelptext = "Substitute v in expression."; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 2 ) && ( page == VARSET_PAGE      ) && !isinv                      ) { /* w=        */ fnhelptext = "Substitute w in expression."; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 3 ) && ( page == VARSET_PAGE      ) && !isinv                      ) { /* g=        */ fnhelptext = "Substitute g in expression."; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 4 ) && ( page == VARSET_PAGE      ) && !isinv                      ) { /* h=        */ fnhelptext = "Substitute h in expression."; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 5 ) && ( page == VARSET_PAGE      ) && !isinv                      ) { /* u=        */ fnhelptext = "Substitute u in expression."; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == ABSANGARG_PAGE   ) &&  isinv             && !isew ) { /* a.absp.p  */ fncallname = "absp";  }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == ABSANGARG_PAGE   ) &&  isinv             &&  isew ) { /* a.eabsp.p */ fncallname = "eabsp";  }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == TESTFUNCIII_PAGE ) && !isinv                      ) { /* test #3   */ fnhelptext = "Test function #3.";                    }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 3 ) && ( page == TESTFUNCIII_PAGE ) &&  isinv                      ) { /* DLTZ4     */ fnhelptext = "DLTZ4 multi-objective test function."; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == MYCALCSF_PAGE    ) && !isinv &&  HYPmode          ) { /* logyl     */ fncallname = "logbl"; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == MYCALCSF_PAGE    ) && !isinv &&  HYPmode          ) { /* logyr     */ fncallname = "logbr"; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == MYCALCSF_PAGE    ) && !isinv &&  HYPmode          ) { /* logy      */ fncallname = "logb";  }

        // Binary operators
        // NOTE: have to break else-if sequence because studio c++ "blocks nested too deeply"

             if ( ( gridvert == 3 ) && ( gridhoriz == 4 ) &&                                  isinv                      && !isah ) { /* x|y    */ fncallname = "cayleyDickson"; }
        else if ( ( gridvert == 5 ) && ( gridhoriz == 3 ) &&                                  isinv             && !isew          ) { /* x%y    */ fncallname = "mod";           }
        else if ( ( gridvert == 4 ) && ( gridhoriz == 4 ) &&                                  isinv             && !isew          ) { /* x*>y   */ fncallname = "rmul";          }
        else if ( ( gridvert == 4 ) && ( gridhoriz == 5 ) &&                                  isinv             && !isew          ) { /* x\y    */ fncallname = "rdiv";          }
        else if ( ( gridvert == 6 ) && ( gridhoriz == 4 ) &&                                  isinv             && !isew          ) { /* x//y   */ fncallname = "idiv";          }
        else if ( ( gridvert == 4 ) && ( gridhoriz == 4 ) &&                                 !isinv             && !isew          ) { /* x*y    */ fncallname = "mul";           }
        else if ( ( gridvert == 4 ) && ( gridhoriz == 5 ) &&                                 !isinv             && !isew          ) { /* x/y    */ fncallname = "div";           }
        else if ( ( gridvert == 5 ) && ( gridhoriz == 3 ) &&                                  isinv             &&  isew          ) { /* x.%y   */ fncallname = "emod";           }
        else if ( ( gridvert == 4 ) && ( gridhoriz == 4 ) &&                                  isinv             &&  isew          ) { /* x.*>y  */ fncallname = "ermul";          }
        else if ( ( gridvert == 4 ) && ( gridhoriz == 5 ) &&                                  isinv             &&  isew          ) { /* x.\y   */ fncallname = "erdiv";          }
        else if ( ( gridvert == 6 ) && ( gridhoriz == 4 ) &&                                  isinv             &&  isew          ) { /* x.//y  */ fncallname = "eidiv";          }
        else if ( ( gridvert == 4 ) && ( gridhoriz == 4 ) &&                                 !isinv             &&  isew          ) { /* x.*y   */ fncallname = "emul";           }
        else if ( ( gridvert == 4 ) && ( gridhoriz == 5 ) &&                                 !isinv             &&  isew          ) { /* x./y   */ fncallname = "ediv";           }
        else if ( ( gridvert == 5 ) && ( gridhoriz == 4 ) &&                                 !isinv                               ) { /* x+y    */ fncallname = "add";           }
        else if ( ( gridvert == 5 ) && ( gridhoriz == 5 ) &&                                 !isinv                               ) { /* x-y    */ fncallname = "sub";           }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == MYCALCSF_PAGE    ) && !isinv && !HYPmode && !isew && !isah ) { /* x^y    */ fncallname = "pow";           }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == MYCALCSF_PAGE    ) &&  isinv &&  HYPmode && !isew && !isah ) { /* x^y    */ fncallname = "pow";           }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == MYCALCSF_PAGE    ) &&  isinv &&  HYPmode && !isew && !isah ) { /* x^<y   */ fncallname = "powl";          }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == MYCALCSF_PAGE    ) &&  isinv &&  HYPmode && !isew && !isah ) { /* x^>y   */ fncallname = "powr";          }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == MYCALCSF_PAGE    ) && !isinv && !HYPmode &&  isew && !isah ) { /* x.^y   */ fncallname = "epow";          }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == MYCALCSF_PAGE    ) &&  isinv &&  HYPmode &&  isew && !isah ) { /* x.^y   */ fncallname = "epow";          }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == MYCALCSF_PAGE    ) &&  isinv &&  HYPmode &&  isew && !isah ) { /* x.^<y  */ fncallname = "epowl";         }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == MYCALCSF_PAGE    ) &&  isinv &&  HYPmode &&  isew && !isah ) { /* x.^>y  */ fncallname = "epowr";         }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == MYCALCSF_PAGE    ) &&  isinv && !HYPmode          && !isah ) { /* x^/y   */ fncallname = "nthrt";         }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == MYCALCSF_PAGE    ) && !isinv && !HYPmode && !isew &&  isah ) { /* x^^y   */ fncallname = "Pow";           }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == MYCALCSF_PAGE    ) &&  isinv &&  HYPmode && !isew &&  isah ) { /* x^^y   */ fncallname = "Pow";           }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == MYCALCSF_PAGE    ) &&  isinv &&  HYPmode && !isew &&  isah ) { /* x^^<y  */ fncallname = "Powl";          }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == MYCALCSF_PAGE    ) &&  isinv &&  HYPmode && !isew &&  isah ) { /* x^^>y  */ fncallname = "Powr";          }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == MYCALCSF_PAGE    ) && !isinv && !HYPmode &&  isew &&  isah ) { /* x.^^y  */ fncallname = "Epow";          }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == MYCALCSF_PAGE    ) &&  isinv &&  HYPmode &&  isew &&  isah ) { /* x.^^y  */ fncallname = "Epow";          }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == MYCALCSF_PAGE    ) &&  isinv &&  HYPmode &&  isew &&  isah ) { /* x.^^<y */ fncallname = "Epowl";         }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == MYCALCSF_PAGE    ) &&  isinv &&  HYPmode &&  isew &&  isah ) { /* x.^^>y */ fncallname = "Epowr";         }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == MYCALCSF_PAGE    ) &&  isinv && !HYPmode          &&  isah ) { /* x^^/y  */ fncallname = "Nthrt";         }

        // Evaluation and brackets

        else if ( ( gridvert == 6 ) && ( gridhoriz == 4 ) && !isinv  ) { fnhelptext = "Evaluate result."; }
        else if ( ( gridvert == 2 ) && ( gridhoriz == 2 ) && !SDmode ) { fnhelptext = "Left bracket.";    }
        else if ( ( gridvert == 2 ) && ( gridhoriz == 3 ) && !SDmode ) { fnhelptext = "Right bracket";    }

        // Data entry

        else if ( ( gridvert == 6 ) && ( gridhoriz == 3 ) && !isinv && ( entryval.size() != 0 ) ) { fnhelptext = "E";  }
        else if ( ( gridvert == 6 ) && ( gridhoriz == 3 )                                       ) { fnhelptext = "pi"; }

        else if ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == ODDITIES_PAGE ) && !isinv ) { fnhelptext = "Null.";            }
        else if ( ( gridvert == 6 ) && ( gridhoriz == 1 )                              &&  isinv ) { fnhelptext = "Not-a-Number.";    }
        else if ( ( gridvert == 6 ) && ( gridhoriz == 2 )                              &&  isinv ) { fnhelptext = "Infinity.";        }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == ODDITIES_PAGE ) && !isinv ) { fnhelptext = "Euler's constant"; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == ODDITIES_PAGE ) &&  isinv ) { fnhelptext = "Time.";            }
          }

          if ( fncallname.size() )
          {
              fnhelptext = getfndescrip(fncallname);

              helpstring =  fncallname;
              helpstring += ": ";
              helpstring += fnhelptext;
          }

          else
          {
              helpstring = fnhelptext;
          }

          std::string helptexta;
          std::string helptextb;
          std::string helptextc;
          std::string helptextd;

          if ( helpstring.size() <= rightblank )
          {
              helptexta = helpstring;
          }

          else
          {
              helptexta = helpstring.substr(0,rightblank);

              helpstring = helpstring.substr(rightblank,helpstring.size()-rightblank);

              if ( helpstring.size() <= rightblank )
              {
                  helptextb = helpstring;
              }

              else
              {
                  helptextb = helpstring.substr(0,rightblank);

                  helpstring = helpstring.substr(rightblank,helpstring.size()-rightblank);

                  if ( helpstring.size() <= rightblank )
                  {
                      helptextc = helpstring;
                  }

                  else
                  {
                      helptextc = helpstring.substr(0,rightblank);

                      helpstring = helpstring.substr(rightblank,helpstring.size()-rightblank);

                      if ( helpstring.size() <= rightblank )
                      {
                          helptextd = helpstring;
                      }

                      else
                      {
                          helptextd = helpstring.substr(0,rightblank-3);
                          helptextd += "...";
                      }
                  }
              }
          }

          size_t htasize = helptexta.size();
          size_t htbsize = helptextb.size();
          size_t htcsize = helptextc.size();
          size_t htdsize = helptextd.size();

          if ( htasize < rightblank )
          {
              helptexta.insert(htasize,rightblank-htasize,' ');
          }

          if ( htbsize < rightblank )
          {
              helptextb.insert(htbsize,rightblank-htbsize,' ');
          }

          if ( htcsize < rightblank )
          {
              helptextc.insert(htcsize,rightblank-htcsize,' ');
          }

          if ( htdsize < rightblank )
          {
              helptextd.insert(htdsize,rightblank-htdsize,' ');
          }

          modedisp += ( isew             ? "E"    : " "    ); modedisp += "  ";
          modedisp += ( isah             ? "A"    : " "    ); modedisp += "  ";
          modedisp += ( isinv            ? "INV"  : "   "  ); modedisp += "  ";
          modedisp += ( HYPmode          ? "H"    : " "    ); modedisp += "   ";
          modedisp += ( !mempty          ? "M"    : " "    ); modedisp += "  ";
          modedisp += ( calcNest.isK     ? "K"    : " "    ); modedisp += "   ";
          modedisp += ( ( DRGtype == 0 ) ? "DEG"  : "   "  ); modedisp += "  ";
          modedisp += ( ( DRGtype == 1 ) ? "RAD"  : "   "  ); modedisp += "  ";
          modedisp += ( ( DRGtype == 2 ) ? "GRA"  : "   "  ); modedisp += "   ";
          modedisp += ( SDmode           ? "SD"   : "  "   ); modedisp += "   ";
          modedisp += ( !dataDisplay     ? "EDIT" : "    " ); modedisp += "   ";
          modedisp += calcNest.fnname.accessTop();            modedisp += "  ";
          modedisp += topop;

//FIXME: eps_comm, eps_assoc            (4) - quaternary and higher order functions
//FIXME - do these as operators on vectors!
//FIXME - add "wrap in vector" function x -> [ x ]
//
//FIXME: have different min/max for x in (argument) and x display (output)

          outstreamunlogged() << "+---------------------------------------------------------------------------+\n";
          outstreamunlogged() << "|  +---------------------------------------------------------------------+  |\n";
          outstreamunlogged() << "|  | " << datadispa <<                                                 " |  | " << helptexta << "\n";
          outstreamunlogged() << "|  | " << datadispb <<                                                 " |  | " << helptextb << "\n";
          outstreamunlogged() << "|  | " << datadispc <<                                                 " |  | " << helptextc << "\n";
          outstreamunlogged() << "|  | " << modedisp <<                                                  " |  | " << helptextd << "\n";
          outstreamunlogged() << "|  +---------------------------------------------------------------------+  |\n";
          outstreamunlogged() << "|  Controls: arrows, space select, Q quit, P plot, just type (~ for space)  |\n";
          outstreamunlogged() << "|                                                                           |\n";

          if ( ( page == MYCALCSF_PAGE ) && !isew && !isah && !HYPmode )
          {
              outstreamunlogged() << "|<     INV   SD   D-R-G        HYP    |   log     |   ln      |   x^y      >| " << rightplot[0]  << "\n";
              outstreamunlogged() << "|<  .........-+-.........   ......... | ......... | ......... | .........  >| " << rightplot[1]  << "\n";
              outstreamunlogged() << "|<  .........   .........   ......... |   10^x    |   e^x     |   x^1/y    >| " << rightplot[2]  << "\n";
              outstreamunlogged() << "|< -----------+-----------+-----------+-----------+-----------+----------- >| " << rightplot[3]  << "\n";
              outstreamunlogged() << "|<  +/-  cbrt | sqrt  x^2 | .'\"   <-- |    sin    |    cos    |    tan     >| " << rightplot[4]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... | ......... | ......... | ......... | .........  >| " << rightplot[5]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... | ......... |   asin    |   acos    |   atan     >| " << rightplot[6]  << "\n";
          }

          else if ( ( page == MYCALCSF_PAGE ) && !isew && !isah && HYPmode )
          {
              outstreamunlogged() << "|<     INV   SD   D-R-G        HYP    |   logbl   |   logbr   |   logb     >| " << rightplot[0]  << "\n";
              outstreamunlogged() << "|<  .........-+-.........   ......... | ......... | ......... | .........  >| " << rightplot[1]  << "\n";
              outstreamunlogged() << "|<  .........   .........   ......... |   x^<y    |   x^>y    |   x^y      >| " << rightplot[2]  << "\n";
              outstreamunlogged() << "|< -----------+-----------+-----------+-----------+-----------+----------- >| " << rightplot[3]  << "\n";
              outstreamunlogged() << "|<  +/-  cbrt | sqrt  x^2 | .'\"   <-- |    sinh   |    cosh   |    tanh    >| " << rightplot[4]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... | ......... | ......... | ......... | .........  >| " << rightplot[5]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... | ......... |   asinh   |   acosh   |   atanh    >| " << rightplot[6]  << "\n";
          }

          else if ( ( page == MYCALCSF_PAGE ) && isew && !isah && !HYPmode )
          {
              outstreamunlogged() << "|<     INV   SD   D-R-G        HYP    |   log     |   ln      |   x.^y     >| " << rightplot[0]  << "\n";
              outstreamunlogged() << "|<  .........-+-.........   ......... | ......... | ......... | .........  >| " << rightplot[1]  << "\n";
              outstreamunlogged() << "|<  .........   .........   ......... |   10^x    |   e^x     |   x^1/y    >| " << rightplot[2]  << "\n";
              outstreamunlogged() << "|< -----------+-----------+-----------+-----------+-----------+----------- >| " << rightplot[3]  << "\n";
              outstreamunlogged() << "|<  +/-  cbrt | sqrt  x^2 | .'\"   <-- |    sin    |    cos    |    tan     >| " << rightplot[4]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... | ......... | ......... | ......... | .........  >| " << rightplot[5]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... | ......... |   asin    |   acos    |   atan     >| " << rightplot[6]  << "\n";
          }

          else if ( ( page == MYCALCSF_PAGE ) && isew && !isah && HYPmode )
          {
              outstreamunlogged() << "|<     INV   SD   D-R-G        HYP    |   logyl   |   logyr   |   logy     >| " << rightplot[0]  << "\n";
              outstreamunlogged() << "|<  .........-+-.........   ......... | ......... | ......... | .........  >| " << rightplot[1]  << "\n";
              outstreamunlogged() << "|<  .........   .........   ......... |   x.^<y   |   x.^>y   |   x.^y     >| " << rightplot[2]  << "\n";
              outstreamunlogged() << "|< -----------+-----------+-----------+-----------+-----------+----------- >| " << rightplot[3]  << "\n";
              outstreamunlogged() << "|<  +/-  cbrt | sqrt  x^2 | .'\"   <-- |    sinh   |    cosh   |    tanh    >| " << rightplot[4]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... | ......... | ......... | ......... | .........  >| " << rightplot[5]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... | ......... |   asinh   |   acosh   |   atanh    >| " << rightplot[6]  << "\n";
          }

          else if ( ( page == MYCALCSF_PAGE ) && !isew && isah && !HYPmode )
          {
              outstreamunlogged() << "|<     INV   SD   D-R-G        HYP    |   Log     |   Ln      |   x^^y     >| " << rightplot[0]  << "\n";
              outstreamunlogged() << "|<  .........-+-.........   ......... | ......... | ......... | .........  >| " << rightplot[1]  << "\n";
              outstreamunlogged() << "|<  .........   .........   ......... |   10^x    |   e^x     |   x^^/y    >| " << rightplot[2]  << "\n";
              outstreamunlogged() << "|< -----------+-----------+-----------+-----------+-----------+----------- >| " << rightplot[3]  << "\n";
              outstreamunlogged() << "|<  +/-  Cbrt | Sqrt  x^2 | .'\"   <-- |    sin    |    cos    |    tan     >| " << rightplot[4]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... | ......... | ......... | ......... | .........  >| " << rightplot[5]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... | ......... |   Asin    |   Acos    |   atan     >| " << rightplot[6]  << "\n";
          }

          else if ( ( page == MYCALCSF_PAGE ) && !isew && isah && HYPmode )
          {
              outstreamunlogged() << "|<     INV   SD   D-R-G        HYP    |   Logyl   |   Logyr   |   Logy     >| " << rightplot[0]  << "\n";
              outstreamunlogged() << "|<  .........-+-.........   ......... | ......... | ......... | .........  >| " << rightplot[1]  << "\n";
              outstreamunlogged() << "|<  .........   .........   ......... |   x^^<y   |   x^^>y   |   x^^y     >| " << rightplot[2]  << "\n";
              outstreamunlogged() << "|< -----------+-----------+-----------+-----------+-----------+----------- >| " << rightplot[3]  << "\n";
              outstreamunlogged() << "|<  +/-  Cbrt | Sqrt  x^2 | .'\"   <-- |    sinh   |    cosh   |    tanh    >| " << rightplot[4]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... | ......... | ......... | ......... | .........  >| " << rightplot[5]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... | ......... |   asinh   |   Acosh   |   Atanh    >| " << rightplot[6]  << "\n";
          }

          else if ( ( page == MYCALCSF_PAGE ) && isew && isah && !HYPmode )
          {
              outstreamunlogged() << "|<     INV   SD   D-R-G        HYP    |   Log     |   Ln      |   x.^^y    >| " << rightplot[0]  << "\n";
              outstreamunlogged() << "|<  .........-+-.........   ......... | ......... | ......... | .........  >| " << rightplot[1]  << "\n";
              outstreamunlogged() << "|<  .........   .........   ......... |   10^x    |   e^x     |   x^^/y    >| " << rightplot[2]  << "\n";
              outstreamunlogged() << "|< -----------+-----------+-----------+-----------+-----------+----------- >| " << rightplot[3]  << "\n";
              outstreamunlogged() << "|<  +/-  Cbrt | Sqrt  x^2 | .'\"   <-- |    sin    |    cos    |    tan     >| " << rightplot[4]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... | ......... | ......... | ......... | .........  >| " << rightplot[5]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... | ......... |   Asin    |   Acos    |   atan     >| " << rightplot[6]  << "\n";
          }

          else if ( ( page == MYCALCSF_PAGE ) && isew && isah && HYPmode )
          {
              outstreamunlogged() << "|<     INV   SD   D-R-G        HYP    |   Logyl   |   Logyr   |   Logy     >| " << rightplot[0]  << "\n";
              outstreamunlogged() << "|<  .........-+-.........   ......... | ......... | ......... | .........  >| " << rightplot[1]  << "\n";
              outstreamunlogged() << "|<  .........   .........   ......... |   x.^^<y  |   x.^^>y  |   x.^^y    >| " << rightplot[2]  << "\n";
              outstreamunlogged() << "|< -----------+-----------+-----------+-----------+-----------+----------- >| " << rightplot[3]  << "\n";
              outstreamunlogged() << "|<  +/-  Cbrt | Sqrt  x^2 | .'\"   <-- |    sinh   |    cosh   |    tanh    >| " << rightplot[4]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... | ......... | ......... | ......... | .........  >| " << rightplot[5]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... | ......... |   asinh   |   Acosh   |   Atanh    >| " << rightplot[6]  << "\n";
          }

          else if ( ( page == OBSCURETRIGI__PAGE ) && !isah && !HYPmode )
          {
              outstreamunlogged() << "|<     INV   SD   D-R-G        HYP    |   cosec   |    sec    |    cot     >| " << rightplot[0]  << "\n";
              outstreamunlogged() << "|<  .........-+-.........   ......... | ......... | ......... | .........  >| " << rightplot[1]  << "\n";
              outstreamunlogged() << "|<  .........   .........   ......... |  acosec   |   asec    |   acot     >| " << rightplot[2]  << "\n";
              outstreamunlogged() << "|< -----------+-----------+-----------+-----------+-----------+----------- >| " << rightplot[3]  << "\n";
              outstreamunlogged() << "|<  +/-  cbrt | sqrt  x^2 | .'\"   <-- |   vers    |   covers  |    hav     >| " << rightplot[4]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... | ......... | ......... | ......... | .........  >| " << rightplot[5]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... | ......... |  avers    |  acovers  |   ahav     >| " << rightplot[6]  << "\n";
          }

          else if ( ( page == OBSCURETRIGI__PAGE ) && !isah && HYPmode )
          {
              outstreamunlogged() << "|<     INV   SD   D-R-G        HYP    |   cosech  |    sech   |    coth    >| " << rightplot[0]  << "\n";
              outstreamunlogged() << "|<  .........-+-.........   ......... | ......... | ......... | .........  >| " << rightplot[1]  << "\n";
              outstreamunlogged() << "|<  .........   .........   ......... |  acosech  |   asech   |   acoth    >| " << rightplot[2]  << "\n";
              outstreamunlogged() << "|< -----------+-----------+-----------+-----------+-----------+----------- >| " << rightplot[3]  << "\n";
              outstreamunlogged() << "|<  +/-  cbrt | sqrt  x^2 | .'\"   <-- |   versh   |   coversh |    havh    >| " << rightplot[4]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... | ......... | ......... | ......... | .........  >| " << rightplot[5]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... | ......... |  aversh   |  acoversh |   ahavh    >| " << rightplot[6]  << "\n";
          }

          else if ( ( page == OBSCURETRIGI__PAGE ) && isah && !HYPmode )
          {
              outstreamunlogged() << "|<     INV   SD   D-R-G        HYP    |   cosec   |    sec    |    cot     >| " << rightplot[0]  << "\n";
              outstreamunlogged() << "|<  .........-+-.........   ......... | ......... | ......... | .........  >| " << rightplot[1]  << "\n";
              outstreamunlogged() << "|<  .........   .........   ......... |  Acosec   |   Asec    |   acot     >| " << rightplot[2]  << "\n";
              outstreamunlogged() << "|< -----------+-----------+-----------+-----------+-----------+----------- >| " << rightplot[3]  << "\n";
              outstreamunlogged() << "|<  +/-  Cbrt | Sqrt  x^2 | .'\"   <-- |   vers    |   covers  |    hav     >| " << rightplot[4]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... | ......... | ......... | ......... | .........  >| " << rightplot[5]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... | ......... |  Avers    |  Acovers  |   Ahav     >| " << rightplot[6]  << "\n";
          }

          else if ( ( page == OBSCURETRIGI__PAGE ) && isah && HYPmode )
          {
              outstreamunlogged() << "|<     INV   SD   D-R-G        HYP    |   cosech  |    sech   |    coth    >| " << rightplot[0]  << "\n";
              outstreamunlogged() << "|<  .........-+-.........   ......... | ......... | ......... | .........  >| " << rightplot[1]  << "\n";
              outstreamunlogged() << "|<  .........   .........   ......... |  acosech  |   Asech   |   Acoth    >| " << rightplot[2]  << "\n";
              outstreamunlogged() << "|< -----------+-----------+-----------+-----------+-----------+----------- >| " << rightplot[3]  << "\n";
              outstreamunlogged() << "|<  +/-  Cbrt | Sqrt  x^2 | .'\"   <-- |   versh   |   coversh |    havh    >| " << rightplot[4]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... | ......... | ......... | ......... | .........  >| " << rightplot[5]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... | ......... |  Aversh   |  acoversh |   Ahavh    >| " << rightplot[6]  << "\n";
          }

          else if ( ( page == OBSCURETRIGII_PAGE ) && !isah && !HYPmode )
          {
              outstreamunlogged() << "|<     INV   SD   D-R-G        HYP    |   exsec   |  excosec  |    cas     >| " << rightplot[0]  << "\n";
              outstreamunlogged() << "|<  .........-+-.........   ......... | ......... | ......... | .........  >| " << rightplot[1]  << "\n";
              outstreamunlogged() << "|<  .........   .........   ......... |  aexsec   | aexcosec  |   acas     >| " << rightplot[2]  << "\n";
              outstreamunlogged() << "|< -----------+-----------+-----------+-----------+-----------+----------- >| " << rightplot[3]  << "\n";
              outstreamunlogged() << "|<  +/-  cbrt | sqrt  x^2 | .'\"   <-- |   sinc    |   tanc    |   casc     >| " << rightplot[4]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... | ......... | ......... | ......... | .........  >| " << rightplot[5]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... | ......... |   cosc    |     gd    |  acasc     >| " << rightplot[6]  << "\n";
          }

          else if ( ( page == OBSCURETRIGII_PAGE ) && !isah && HYPmode )
          {
              outstreamunlogged() << "|<     INV   SD   D-R-G        HYP    |   exsech  |  excosech |    cash    >| " << rightplot[0]  << "\n";
              outstreamunlogged() << "|<  .........-+-.........   ......... | ......... | ......... | .........  >| " << rightplot[1]  << "\n";
              outstreamunlogged() << "|<  .........   .........   ......... |  aexsech  | aexcosech |   acash    >| " << rightplot[2]  << "\n";
              outstreamunlogged() << "|< -----------+-----------+-----------+-----------+-----------+----------- >| " << rightplot[3]  << "\n";
              outstreamunlogged() << "|<  +/-  cbrt | sqrt  x^2 | .'\"   <-- |   sinhc   |   tanhc   |   casch    >| " << rightplot[4]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... | ......... | ......... | ......... | .........  >| " << rightplot[5]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... | ......... |   coshc   |    agd    |  acasch    >| " << rightplot[6]  << "\n";
          }

          else if ( ( page == OBSCURETRIGII_PAGE ) && isah && !HYPmode )
          {
              outstreamunlogged() << "|<     INV   SD   D-R-G        HYP    |   exsec   |  excosec  |    cas     >| " << rightplot[0]  << "\n";
              outstreamunlogged() << "|<  .........-+-.........   ......... | ......... | ......... | .........  >| " << rightplot[1]  << "\n";
              outstreamunlogged() << "|<  .........   .........   ......... |  Aexsec   | Aexcosec  |   Acas     >| " << rightplot[2]  << "\n";
              outstreamunlogged() << "|< -----------+-----------+-----------+-----------+-----------+----------- >| " << rightplot[3]  << "\n";
              outstreamunlogged() << "|<  +/-  Cbrt | Sqrt  x^2 | .'\"   <-- |   sinc    |   tanc    |   casc    >| " << rightplot[4]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... | ......... | ......... | ......... | .........  >| " << rightplot[5]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... | ......... |   cosc    |     gd    |  Acasc     >| " << rightplot[6]  << "\n";
          }

          else if ( ( page == OBSCURETRIGII_PAGE ) && isah && HYPmode )
          {
              outstreamunlogged() << "|<     INV   SD   D-R-G        HYP    |   exsech  |  excosech |    cash    >| " << rightplot[0]  << "\n";
              outstreamunlogged() << "|<  .........-+-.........   ......... | ......... | ......... | .........  >| " << rightplot[1]  << "\n";
              outstreamunlogged() << "|<  .........   .........   ......... |  Aexsech  | aexcosech |   Acash    >| " << rightplot[2]  << "\n";
              outstreamunlogged() << "|< -----------+-----------+-----------+-----------+-----------+----------- >| " << rightplot[3]  << "\n";
              outstreamunlogged() << "|<  +/-  Cbrt | Sqrt  x^2 | .'\"   <-- |   sinhc   |   tanhc   |   casch    >| " << rightplot[4]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... | ......... | ......... | ......... | .........  >| " << rightplot[5]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... | ......... |   coshc   |    Agd    |  Acasch    >| " << rightplot[6]  << "\n";
          }

          else if ( ( page == ODDITIES_PAGE ) && !isah )
          {
              outstreamunlogged() << "|<     INV   SD   D-R-G   |    sum    |   euler   |   null    | normDistr  >| " << rightplot[0]  << "\n";
              outstreamunlogged() << "|<  .........-+-......... | ......... | ......... | ......... | .........  >| " << rightplot[1]  << "\n";
              outstreamunlogged() << "|<  .........   ......... |   prod    |   time    |  I(n,m)   |x.polyDistr.n| " << rightplot[2]  << "\n";
              outstreamunlogged() << "|< -----------+-----------+-----------+-----------+-----------+----------- >| " << rightplot[3]  << "\n";
              outstreamunlogged() << "|<  +/-  cbrt | sqrt  x^2 |   [x,y]   |  [x,y,z]  |   mean    | argmedian  >| " << rightplot[4]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... | ......... | ......... | ......... | .........  >| " << rightplot[5]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... |   {x,y}   |  {x,y,z}  |  median   | .........  >| " << rightplot[6]  << "\n";
          }

          else if ( ( page == ODDITIES_PAGE ) && isah )
          {
              outstreamunlogged() << "|<     INV   SD   D-R-G   |    sum    |   euler   |   null    | normDistr  >| " << rightplot[0]  << "\n";
              outstreamunlogged() << "|<  .........-+-......... | ......... | ......... | ......... | .........  >| " << rightplot[1]  << "\n";
              outstreamunlogged() << "|<  .........   ......... |   Prod    |   time    |  I(n,m)   |x.PolyDistr.n| " << rightplot[2]  << "\n";
              outstreamunlogged() << "|< -----------+-----------+-----------+-----------+-----------+----------- >| " << rightplot[3]  << "\n";
              outstreamunlogged() << "|<  +/-  Cbrt | Sqrt  x^2 |   [x,y]   |  [x,y,z]  |   mean    | argmedian  >| " << rightplot[4]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... | ......... | ......... | ......... | .........  >| " << rightplot[5]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... |   {x,y}   |  {x,y,z}  |  median   | .........  >| " << rightplot[6]  << "\n";
          }

          else if ( ( page == ABSANGARG_PAGE ) && !isew && !isah )
          {
              outstreamunlogged() << "|<     INV   SD   D-R-G   |  ||.||_0  |  ||.||_2  | ||.||_inf |    arg     >| " << rightplot[0]  << "\n";
              outstreamunlogged() << "|<  .........-+-......... | ......... | ......... | ......... | .........  >| " << rightplot[1]  << "\n";
              outstreamunlogged() << "|<  .........   ......... |  ||.||_1  |  ||.||_p  |   angle   |    sgn     >| " << rightplot[2]  << "\n";
              outstreamunlogged() << "|< -----------+-----------+-----------+-----------+-----------+----------- >| " << rightplot[3]  << "\n";
              outstreamunlogged() << "|<  +/-  cbrt | sqrt  x^2 |    Re     |   rint    |   floor   | w.bern.x   >| " << rightplot[4]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... | ......... | ......... | ......... | .........  >| " << rightplot[5]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... |    Im     |   conj    |   ceil    | x.outer.y  >| " << rightplot[6]  << "\n";
          }

          else if ( ( page == ABSANGARG_PAGE ) && isew && !isah )
          {
              outstreamunlogged() << "|<     INV   SD   D-R-G   | e||.||_0  | e||.||_2  |e||.||_inf |    arg     >| " << rightplot[0]  << "\n";
              outstreamunlogged() << "|<  .........-+-......... | ......... | ......... | ......... | .........  >| " << rightplot[1]  << "\n";
              outstreamunlogged() << "|<  .........   ......... | e||.||_1  | e||.||_p  |  eangle   |    sgn     >| " << rightplot[2]  << "\n";
              outstreamunlogged() << "|< -----------+-----------+-----------+-----------+-----------+----------- >| " << rightplot[3]  << "\n";
              outstreamunlogged() << "|<  +/-  cbrt | sqrt  x^2 |    Re     |   rint    |   floor   | w.bern.x   >| " << rightplot[4]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... | ......... | ......... | ......... | .........  >| " << rightplot[5]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... |    Im     |   conj    |   ceil    | x.outer.y  >| " << rightplot[6]  << "\n";
          }

          else if ( ( page == ABSANGARG_PAGE ) && !isew && isah )
          {
              outstreamunlogged() << "|<     INV   SD   D-R-G   |  ||.||_0  |  ||.||_2  | ||.||_inf |    arg     >| " << rightplot[0]  << "\n";
              outstreamunlogged() << "|<  .........-+-......... | ......... | ......... | ......... | .........  >| " << rightplot[1]  << "\n";
              outstreamunlogged() << "|<  .........   ......... |  ||.||_1  |  ||.||_p  |   angle   |    sgn     >| " << rightplot[2]  << "\n";
              outstreamunlogged() << "|< -----------+-----------+-----------+-----------+-----------+----------- >| " << rightplot[3]  << "\n";
              outstreamunlogged() << "|<  +/-  Cbrt | Sqrt  x^2 |    Re     |   rint    |   floor   | w.bern.x   >| " << rightplot[4]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... | ......... | ......... | ......... | .........  >| " << rightplot[5]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... |    Im     |   conj    |   ceil    | x.outer.y  >| " << rightplot[6]  << "\n";
          }

          else if ( ( page == ABSANGARG_PAGE ) && isew && isah )
          {
              outstreamunlogged() << "|<     INV   SD   D-R-G   | e||.||_0  | e||.||_2  |e||.||_inf |    arg     >| " << rightplot[0]  << "\n";
              outstreamunlogged() << "|<  .........-+-......... | ......... | ......... | ......... | .........  >| " << rightplot[1]  << "\n";
              outstreamunlogged() << "|<  .........   ......... | e||.||_1  | e||.||_p  |  eangle   |    sgn     >| " << rightplot[2]  << "\n";
              outstreamunlogged() << "|< -----------+-----------+-----------+-----------+-----------+----------- >| " << rightplot[3]  << "\n";
              outstreamunlogged() << "|<  +/-  Cbrt | Sqrt  x^2 |    Re     |   rint    |   floor   | w.bern.x   >| " << rightplot[4]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... | ......... | ......... | ......... | .........  >| " << rightplot[5]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... |    Im     |   conj    |   ceil    | x.outer.y  >| " << rightplot[6]  << "\n";
          }

          else if ( ( page == ADVANCEDSFI_PAGE ) && !isah )
          {
              outstreamunlogged() << "|<     INV   SD   D-R-G   |   sigm    |    erf    | lambertW  |   gamma    >| " << rightplot[0]  << "\n";
              outstreamunlogged() << "|<  .........-+-......... | ......... | ......... | ......... | .........  >| " << rightplot[1]  << "\n";
              outstreamunlogged() << "|<  .........   ......... |   asigm   |    erfc   | lambertWx |  lngamma   >| " << rightplot[2]  << "\n";
              outstreamunlogged() << "|< -----------+-----------+-----------+-----------+-----------+----------- >| " << rightplot[3]  << "\n";
              outstreamunlogged() << "|<  +/-  cbrt | sqrt  x^2 |    det    |    psi    |  dawson   | x.gami.a   >| " << rightplot[4]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... | ......... | ......... | ......... | .........  >| " << rightplot[5]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... |     Tr    |  x.psi.n  |   zeta    | x.gamic.a  >| " << rightplot[6]  << "\n";
          }

          else if ( ( page == ADVANCEDSFI_PAGE ) && isah )
          {
              outstreamunlogged() << "|<     INV   SD   D-R-G   |   sigm    |    erf    | lambertW  |   gamma    >| " << rightplot[0]  << "\n";
              outstreamunlogged() << "|<  .........-+-......... | ......... | ......... | ......... | .........  >| " << rightplot[1]  << "\n";
              outstreamunlogged() << "|<  .........   ......... |   Asigm   |    erfc   | lambertWx |  lngamma   >| " << rightplot[2]  << "\n";
              outstreamunlogged() << "|< -----------+-----------+-----------+-----------+-----------+----------- >| " << rightplot[3]  << "\n";
              outstreamunlogged() << "|<  +/-  Cbrt | Sqrt  x^2 |    det    |    psi    |  dawson   | x.gami.a   >| " << rightplot[4]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... | ......... | ......... | ......... | .........  >| " << rightplot[5]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... |     Tr    |  x.psi.n  |   zeta    | x.gamic.a  >| " << rightplot[6]  << "\n";
          }

          else if ( ( page == COMBMAXMIN_PAGE ) && !isew && !isah )
          {
              outstreamunlogged() << "|<     INV   SD   D-R-G   |    x!     |   x!!!    | m_x!!...! |  Kron_ij   >| " << rightplot[0]  << "\n";
              outstreamunlogged() << "|<  .........-+-......... | ......... | ......... | ......... | .........  >| " << rightplot[1]  << "\n";
              outstreamunlogged() << "|<  .........   ......... |    x!!    |    !x     |     T     |   Dirac    >| " << rightplot[2]  << "\n";
              outstreamunlogged() << "|< -----------+-----------+-----------+-----------+-----------+----------- >| " << rightplot[3]  << "\n";
              outstreamunlogged() << "|<  +/-  cbrt | sqrt  x^2 |    nPr    |    sf     |  argmax   |    max     >| " << rightplot[4]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... | ......... | ......... | ......... | .........  >| " << rightplot[5]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... |    nCr    |    psf    |  argmin   |    min     >| " << rightplot[6]  << "\n";
          }

          else if ( ( page == COMBMAXMIN_PAGE ) && isew && !isah )
          {
              outstreamunlogged() << "|<     INV   SD   D-R-G   |    x!     |   x!!!    | m_x!!...! | eKron_ij   >| " << rightplot[0]  << "\n";
              outstreamunlogged() << "|<  .........-+-......... | ......... | ......... | ......... | .........  >| " << rightplot[1]  << "\n";
              outstreamunlogged() << "|<  .........   ......... |    x!!    |    !x     |     T     |  eDirac    >| " << rightplot[2]  << "\n";
              outstreamunlogged() << "|< -----------+-----------+-----------+-----------+-----------+----------- >| " << rightplot[3]  << "\n";
              outstreamunlogged() << "|<  +/-  cbrt | sqrt  x^2 |    nPr    |    sf     |  argmax   |    max     >| " << rightplot[4]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... | ......... | ......... | ......... | .........  >| " << rightplot[5]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... |    nCr    |    psf    |  argmin   |    min     >| " << rightplot[6]  << "\n";
          }

          else if ( ( page == COMBMAXMIN_PAGE ) && !isew && isah )
          {
              outstreamunlogged() << "|<     INV   SD   D-R-G   |    x!     |   x!!!    | m_x!!...! |  Kron_ij   >| " << rightplot[0]  << "\n";
              outstreamunlogged() << "|<  .........-+-......... | ......... | ......... | ......... | .........  >| " << rightplot[1]  << "\n";
              outstreamunlogged() << "|<  .........   ......... |    x!!    |    !x     |     T     |   Dirac    >| " << rightplot[2]  << "\n";
              outstreamunlogged() << "|< -----------+-----------+-----------+-----------+-----------+----------- >| " << rightplot[3]  << "\n";
              outstreamunlogged() << "|<  +/-  Cbrt | Sqrt  x^2 |    nPr    |    sf     |  argmax   |    max     >| " << rightplot[4]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... | ......... | ......... | ......... | .........  >| " << rightplot[5]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... |    nCr    |    psf    |  argmin   |    min     >| " << rightplot[6]  << "\n";
          }

          else if ( ( page == COMBMAXMIN_PAGE ) && isew && isah )
          {
              outstreamunlogged() << "|<     INV   SD   D-R-G   |    x!     |   x!!!    | m_x!!...! | eKron_ij   >| " << rightplot[0]  << "\n";
              outstreamunlogged() << "|<  .........-+-......... | ......... | ......... | ......... | .........  >| " << rightplot[1]  << "\n";
              outstreamunlogged() << "|<  .........   ......... |    x!!    |    !x     |     T     |  eDirac    >| " << rightplot[2]  << "\n";
              outstreamunlogged() << "|< -----------+-----------+-----------+-----------+-----------+----------- >| " << rightplot[3]  << "\n";
              outstreamunlogged() << "|<  +/-  Cbrt | Sqrt  x^2 |    nPr    |    sf     |  argmax   |    max     >| " << rightplot[4]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... | ......... | ......... | ......... | .........  >| " << rightplot[5]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... |    nCr    |    psf    |  argmin   |    min     >| " << rightplot[6]  << "\n";
          }

          else if ( ( page == VARDERIV_PAGE ) && !isah )
          {
              outstreamunlogged() << "|<     INV   SD   D-R-G   |     x     |     y     |     z     |     v      >| " << rightplot[0]  << "\n";
              outstreamunlogged() << "|<  .........-+-......... | ......... | ......... | ......... | .........  >| " << rightplot[1]  << "\n";
              outstreamunlogged() << "|<  .........   ......... |   d/dx    |   d/dy    |   d/dz    |   d/dv     >| " << rightplot[2]  << "\n";
              outstreamunlogged() << "|< -----------+-----------+-----------+-----------+-----------+----------- >| " << rightplot[3]  << "\n";
              outstreamunlogged() << "|<  +/-  cbrt | sqrt  x^2 |     w     |     g     |     h     |     u      >| " << rightplot[4]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... | ......... | ......... | ......... | .........  >| " << rightplot[5]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... |   d/dw    |   d/dg    |   d/dh    |   d/du     >| " << rightplot[6]  << "\n";
          }

          else if ( ( page == VARDERIV_PAGE ) && isah )
          {
              outstreamunlogged() << "|<     INV   SD   D-R-G   |     x     |     y     |     z     |     v      >| " << rightplot[0]  << "\n";
              outstreamunlogged() << "|<  .........-+-......... | ......... | ......... | ......... | .........  >| " << rightplot[1]  << "\n";
              outstreamunlogged() << "|<  .........   ......... |   d/dx    |   d/dy    |   d/dz    |   d/dv     >| " << rightplot[2]  << "\n";
              outstreamunlogged() << "|< -----------+-----------+-----------+-----------+-----------+----------- >| " << rightplot[3]  << "\n";
              outstreamunlogged() << "|<  +/-  Cbrt | Sqrt  x^2 |     w     |     g     |     h     |     u      >| " << rightplot[4]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... | ......... | ......... | ......... | .........  >| " << rightplot[5]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... |   d/dw    |   d/dg    |   d/dh    |   d/du     >| " << rightplot[6]  << "\n";
          }

          else if ( ( page == VARSET_PAGE ) && !isah )
          {
              outstreamunlogged() << "|<     INV   SD   D-R-G   | ... | x = | ... | y = | ... | z = | ... | v =  >| " << rightplot[0]  << "\n";
              outstreamunlogged() << "|<  .........-+-......... | ......... | ......... | ......... | .........  >| " << rightplot[1]  << "\n";
              outstreamunlogged() << "|<  .........   ......... | ......... | ......... | ......... | .........  >| " << rightplot[2]  << "\n";
              outstreamunlogged() << "|< -----------+-----------+-----------+-----------+-----------+----------- >| " << rightplot[3]  << "\n";
              outstreamunlogged() << "|<  +/-  cbrt | sqrt  x^2 | ... | w = | ... | g = | ... | h = | ... | u =  >| " << rightplot[4]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... | ......... | ......... | ......... | .........  >| " << rightplot[5]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... | ......... | ......... | ......... | .........  >| " << rightplot[6]  << "\n";
          }

          else if ( ( page == VARSET_PAGE ) && isah )
          {
              outstreamunlogged() << "|<     INV   SD   D-R-G   | ... | x = | ... | y = | ... | z = | ... | v =  >| " << rightplot[0]  << "\n";
              outstreamunlogged() << "|<  .........-+-......... | ......... | ......... | ......... | .........  >| " << rightplot[1]  << "\n";
              outstreamunlogged() << "|<  .........   ......... | ......... | ......... | ......... | .........  >| " << rightplot[2]  << "\n";
              outstreamunlogged() << "|< -----------+-----------+-----------+-----------+-----------+----------- >| " << rightplot[3]  << "\n";
              outstreamunlogged() << "|<  +/-  Cbrt | Sqrt  x^2 | ... | w = | ... | g = | ... | h = | ... | u =  >| " << rightplot[4]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... | ......... | ......... | ......... | .........  >| " << rightplot[5]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... | ......... | ......... | ......... | .........  >| " << rightplot[6]  << "\n";
          }

          else if ( ( page == TESTFUNCI___PAGE ) && !isah )
          {
              outstreamunlogged() << "|<     INV   SD   D-R-G   | Rastrigin |  Sphere   |   Beale   |   Booth    >| " << rightplot[0]  << "\n";
              outstreamunlogged() << "|<  .........-+-......... | ......... | ......... | ......... | .........  >| " << rightplot[1]  << "\n";
              outstreamunlogged() << "|<  .........   ......... |   Ackley  |Rosnebrock |Goldstein-P|   Bukin    >| " << rightplot[2]  << "\n";
              outstreamunlogged() << "|< -----------+-----------+-----------+-----------+-----------+----------- >| " << rightplot[3]  << "\n";
              outstreamunlogged() << "|<  +/-  cbrt | sqrt  x^2 |Himmelblau |   Easom   | Eggholder | McCormick  >| " << rightplot[4]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... | ......... | ......... | ......... | .........  >| " << rightplot[5]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... |3-hmp-camel|CrossInTray|HolderTable|Schaffer-#2 >| " << rightplot[6]  << "\n";
          }

          else if ( ( page == TESTFUNCI___PAGE ) && isah )
          {
              outstreamunlogged() << "|<     INV   SD   D-R-G   | Rastrigin |  Sphere   |   Beale   |   Booth    >| " << rightplot[0]  << "\n";
              outstreamunlogged() << "|<  .........-+-......... | ......... | ......... | ......... | .........  >| " << rightplot[1]  << "\n";
              outstreamunlogged() << "|<  .........   ......... |   Ackley  |Rosnebrock |Goldstein-P|   Bukin    >| " << rightplot[2]  << "\n";
              outstreamunlogged() << "|< -----------+-----------+-----------+-----------+-----------+----------- >| " << rightplot[3]  << "\n";
              outstreamunlogged() << "|<  +/-  Cbrt | Sqrt  x^2 |Himmelblau |   Easom   | Eggholder | McCormick  >| " << rightplot[4]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... | ......... | ......... | ......... | .........  >| " << rightplot[5]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... |3-hmp-camel|CrossInTray|HolderTable|Schaffer-#2 >| " << rightplot[6]  << "\n";
          }

          else if ( ( page == TESTFUNCII__PAGE ) && !isah )
          {
              outstreamunlogged() << "|<     INV   SD   D-R-G   | Drop-wave |GramancyLee|Langermann | Griewank   >| " << rightplot[0]  << "\n";
              outstreamunlogged() << "|<  .........-+-......... | ......... | ......... | ......... | .........  >| " << rightplot[1]  << "\n";
              outstreamunlogged() << "|<  .........   ......... |Bohachev. 1|Bohachev. 2|Bohachev. 3|Perm. 0,d,1 >| " << rightplot[2]  << "\n";
              outstreamunlogged() << "|< -----------+-----------+-----------+-----------+-----------+----------- >| " << rightplot[3]  << "\n";
              outstreamunlogged() << "|<  +/-  cbrt | sqrt  x^2 |   Levy    | Schwefel  |  Shubert  |  Matyas    >| " << rightplot[4]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... | ......... | ......... | ......... | .........  >| " << rightplot[5]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... | ......... | ......... | ......... | Levi-#13   >| " << rightplot[6]  << "\n";
          }

          else if ( ( page == TESTFUNCII__PAGE ) && isah )
          {
              outstreamunlogged() << "|<     INV   SD   D-R-G   | Drop-wave |GramancyLee|Langermann | Griewank   >| " << rightplot[0]  << "\n";
              outstreamunlogged() << "|<  .........-+-......... | ......... | ......... | ......... | .........  >| " << rightplot[1]  << "\n";
              outstreamunlogged() << "|<  .........   ......... |Bohachev. 1|Bohachev. 2|Bohachev. 3|Perm. 0,d,1 >| " << rightplot[2]  << "\n";
              outstreamunlogged() << "|< -----------+-----------+-----------+-----------+-----------+----------- >| " << rightplot[3]  << "\n";
              outstreamunlogged() << "|<  +/-  Cbrt | Sqrt  x^2 |   Levy    | Schwefel  |  Shubert  |  Matyas    >| " << rightplot[4]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... | ......... | ......... | ......... | .........  >| " << rightplot[5]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... | ......... | ......... | ......... | Levi-#13   >| " << rightplot[6]  << "\n";
          }

          else if ( ( page == TESTFUNCIII_PAGE ) && !isah )
          {
              outstreamunlogged() << "|<     INV   SD   D-R-G   |Schaffer-#4|Stability-1|x.Test#3.A |   DLTZ9    >| " << rightplot[0]  << "\n";
              outstreamunlogged() << "|<  .........-+-......... | ......... | ......... | ......... | .........  >| " << rightplot[1]  << "\n";
              outstreamunlogged() << "|<  .........   ......... |StablinskTa|Stability-2|    M=     |   FON1     >| " << rightplot[2]  << "\n";
              outstreamunlogged() << "|< -----------+-----------+-----------+-----------+-----------+----------- >| " << rightplot[3]  << "\n";
              outstreamunlogged() << "|<  +/-  cbrt | sqrt  x^2 |   DLTZ1   |   DLTZ3   |   DLTZ5   |   DLTZ7    >| " << rightplot[4]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... | ......... | ......... | ......... | .........  >| " << rightplot[5]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... |   DTLZ2   |x.DTLZ4.alp|   DTLZ6   |   DTLZ8    >| " << rightplot[6]  << "\n";
          }

          else if ( ( page == TESTFUNCIII_PAGE ) && isah )
          {
              outstreamunlogged() << "|<     INV   SD   D-R-G   |Schaffer-#4|Stability-1|x.Test#3.A |   DLTZ9    >| " << rightplot[0]  << "\n";
              outstreamunlogged() << "|<  .........-+-......... | ......... | ......... | ......... | .........  >| " << rightplot[1]  << "\n";
              outstreamunlogged() << "|<  .........   ......... |StablinskTa|Stability-2|    M=     |   FON1     >| " << rightplot[2]  << "\n";
              outstreamunlogged() << "|< -----------+-----------+-----------+-----------+-----------+----------- >| " << rightplot[3]  << "\n";
              outstreamunlogged() << "|<  +/-  Cbrt | Sqrt  x^2 |   DLTZ1   |   DLTZ3   |   DLTZ5   |   DLTZ7    >| " << rightplot[4]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... | ......... | ......... | ......... | .........  >| " << rightplot[5]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... |   DTLZ2   |x.DTLZ4.alp|   DTLZ6   |   DTLZ8    >| " << rightplot[6]  << "\n";
          }

          else if ( ( page == TESTFUNCIV__PAGE ) && !isah )
          {
              outstreamunlogged() << "|<     INV   SD   D-R-G   |   SCH1    |           |           |            >| " << rightplot[0]  << "\n";
              outstreamunlogged() << "|<  .........-+-......... | ......... | ......... | ......... | .........  >| " << rightplot[1]  << "\n";
              outstreamunlogged() << "|<  .........   ......... |   SCH2    | ......... | ......... | .........  >| " << rightplot[2]  << "\n";
              outstreamunlogged() << "|< -----------+-----------+-----------+-----------+-----------+----------- >| " << rightplot[3]  << "\n";
              outstreamunlogged() << "|<  +/-  cbrt | sqrt  x^2 |           |           |           |            >| " << rightplot[4]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... | ......... | ......... | ......... | .........  >| " << rightplot[5]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... | ......... | ......... | ......... | .........  >| " << rightplot[6]  << "\n";
          }

          else if ( ( page == TESTFUNCIV__PAGE ) && isah )
          {
              outstreamunlogged() << "|<     INV   SD   D-R-G   |   SCH1    |           |           |            >| " << rightplot[0]  << "\n";
              outstreamunlogged() << "|<  .........-+-......... | ......... | ......... | ......... | .........  >| " << rightplot[1]  << "\n";
              outstreamunlogged() << "|<  .........   ......... |   SCH2    | ......... | ......... | .........  >| " << rightplot[2]  << "\n";
              outstreamunlogged() << "|< -----------+-----------+-----------+-----------+-----------+----------- >| " << rightplot[3]  << "\n";
              outstreamunlogged() << "|<  +/-  Cbrt | Sqrt  x^2 |           |           |           |            >| " << rightplot[4]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... | ......... | ......... | ......... | .........  >| " << rightplot[5]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... | ......... | ......... | ......... | .........  >| " << rightplot[6]  << "\n";
          }

          else if ( ( page == DISTRIBI___PAGE ) && !isah )
          {
              outstreamunlogged() << "|<     INV   SD   D-R-G   |Chi-squared|  Cauchy   | Fisher-F  | Student-t  >| " << rightplot[0]  << "\n";
              outstreamunlogged() << "|<  .........-+-......... | ......... | ......... | ......... | .........  >| " << rightplot[1]  << "\n";
              outstreamunlogged() << "|<  .........   ......... | n.randc   | a.randC.b | m.randf.n | n.randt    >| " << rightplot[2]  << "\n";
              outstreamunlogged() << "|< -----------+-----------+-----------+-----------+-----------+----------- >| " << rightplot[3]  << "\n";
              outstreamunlogged() << "|<  +/-  cbrt | sqrt  x^2 |Exponential| +Binomial | -Binomial | Geometric  >| " << rightplot[4]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... | ......... | ......... | ......... | .........  >| " << rightplot[5]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... | p.rande   | t.randb.p | k.randB.p | p.randg    >| " << rightplot[6]  << "\n";
          }

          else if ( ( page == DISTRIBI___PAGE ) && isah )
          {
              outstreamunlogged() << "|<     INV   SD   D-R-G   |Chi-squared|  Cauchy   | Fisher-F  | Student-t  >| " << rightplot[0]  << "\n";
              outstreamunlogged() << "|<  .........-+-......... | ......... | ......... | ......... | .........  >| " << rightplot[1]  << "\n";
              outstreamunlogged() << "|<  .........   ......... | n.randc   | a.randC.b | m.randf.n | n.randt    >| " << rightplot[2]  << "\n";
              outstreamunlogged() << "|< -----------+-----------+-----------+-----------+-----------+----------- >| " << rightplot[3]  << "\n";
              outstreamunlogged() << "|<  +/-  Cbrt | Sqrt  x^2 |Exponential| +Binomial | -Binomial | Geometric  >| " << rightplot[4]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... | ......... | ......... | ......... | .........  >| " << rightplot[5]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... | p.rande   | t.randb.p | k.randB.p | p.randg    >| " << rightplot[6]  << "\n";
          }

          else if ( ( page == DISTRIBII__PAGE ) && !isah )
          {
              outstreamunlogged() << "|<     INV   SD   D-R-G   |Log-normal |p Bernoulli|  Uniform  |  Poisson   >| " << rightplot[0]  << "\n";
              outstreamunlogged() << "|<  .........-+-......... | ......... | ......... | ......... | .........  >| " << rightplot[1]  << "\n";
              outstreamunlogged() << "|<  .........   ......... | n.randl.s |   irand   | p.randu.b | m.randp    >| " << rightplot[2]  << "\n";
              outstreamunlogged() << "|< -----------+-----------+-----------+-----------+-----------+----------- >| " << rightplot[3]  << "\n";
              outstreamunlogged() << "|<  +/-  cbrt | sqrt  x^2 |   Gamma   |  Weibull  |Extreme-val|  Normal    >| " << rightplot[4]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... | ......... | ......... | ......... | .........  >| " << rightplot[5]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... | a.randG.b | a.randw.b | a.randx.b | m.randn.s  >| " << rightplot[6]  << "\n";
          }

          else if ( ( page == DISTRIBII__PAGE ) && isah )
          {
              outstreamunlogged() << "|<     INV   SD   D-R-G   |Log-normal |p Bernoulli|  Uniform  |  Poisson   >| " << rightplot[0]  << "\n";
              outstreamunlogged() << "|<  .........-+-......... | ......... | ......... | ......... | .........  >| " << rightplot[1]  << "\n";
              outstreamunlogged() << "|<  .........   ......... | n.randl.s |   irand   | p.randu.b | m.randp    >| " << rightplot[2]  << "\n";
              outstreamunlogged() << "|< -----------+-----------+-----------+-----------+-----------+----------- >| " << rightplot[3]  << "\n";
              outstreamunlogged() << "|<  +/-  Cbrt | Sqrt  x^2 |   Gamma   |  Weibull  |Extreme-val|  Normal    >| " << rightplot[4]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... | ......... | ......... | ......... | .........  >| " << rightplot[5]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... | a.randG.b | a.randw.b | a.randx.b | m.randn.s  >| " << rightplot[6]  << "\n";
          }

          else if ( ( page == DISTRIBIII_PAGE ) && !isah )
          {
              outstreamunlogged() << "|<     INV   SD   D-R-G   |Rademacher |           |           |            >| " << rightplot[0]  << "\n";
              outstreamunlogged() << "|<  .........-+-......... | ......... | ......... | ......... | .........  >| " << rightplot[1]  << "\n";
              outstreamunlogged() << "|<  .........   ......... | p.randr   | ......... | ......... | .........  >| " << rightplot[2]  << "\n";
              outstreamunlogged() << "|< -----------+-----------+-----------+-----------+-----------+----------- >| " << rightplot[3]  << "\n";
              outstreamunlogged() << "|<  +/-  cbrt | sqrt  x^2 |           |           |           |            >| " << rightplot[4]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... | ......... | ......... | ......... | .........  >| " << rightplot[5]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... | ......... | ......... | ......... | .........  >| " << rightplot[6]  << "\n";
          }

          else if ( ( page == DISTRIBIII_PAGE ) && isah )
          {
              outstreamunlogged() << "|<     INV   SD   D-R-G   |Rademacher |           |           |            >| " << rightplot[0]  << "\n";
              outstreamunlogged() << "|<  .........-+-......... | ......... | ......... | ......... | .........  >| " << rightplot[1]  << "\n";
              outstreamunlogged() << "|<  .........   ......... | p.randr   | ......... | ......... | .........  >| " << rightplot[2]  << "\n";
              outstreamunlogged() << "|< -----------+-----------+-----------+-----------+-----------+----------- >| " << rightplot[3]  << "\n";
              outstreamunlogged() << "|<  +/-  Cbrt | Sqrt  x^2 |           |           |           |            >| " << rightplot[4]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... | ......... | ......... | ......... | .........  >| " << rightplot[5]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... | ......... | ......... | ......... | .........  >| " << rightplot[6]  << "\n";
          }

          else if ( ( page == LOGIC_PAGE ) && !isew && !isah )
          {
              outstreamunlogged() << "|<     INV   SD   D-R-G   |    x>y    |    x<y    |   x==y    |    not     >| " << rightplot[0]  << "\n";
              outstreamunlogged() << "|<  .........-+-......... | ......... | ......... | ......... | .........  >| " << rightplot[1]  << "\n";
              outstreamunlogged() << "|<  .........   ......... |   x<=y    |   x>=y    |   x!=y    |    is      >| " << rightplot[2]  << "\n";
              outstreamunlogged() << "|< -----------+-----------+-----------+-----------+-----------+----------- >| " << rightplot[3]  << "\n";
              outstreamunlogged() << "|<  +/-  cbrt | sqrt  x^2 |    and    |     or    |    xor    |            >| " << rightplot[4]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... | ......... | ......... | ......... | .........  >| " << rightplot[5]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... |   nand    |    nor    |   xand    | .........  >| " << rightplot[6]  << "\n";
          }

          else if ( ( page == LOGIC_PAGE ) && isew && !isah )
          {
              outstreamunlogged() << "|<     INV   SD   D-R-G   |   x.>y    |   x.<y    |  x.==y    |    not     >| " << rightplot[0]  << "\n";
              outstreamunlogged() << "|<  .........-+-......... | ......... | ......... | ......... | .........  >| " << rightplot[1]  << "\n";
              outstreamunlogged() << "|<  .........   ......... |  x.<=y    |  x.>=y    |  x.!=y    |    is      >| " << rightplot[2]  << "\n";
              outstreamunlogged() << "|< -----------+-----------+-----------+-----------+-----------+----------- >| " << rightplot[3]  << "\n";
              outstreamunlogged() << "|<  +/-  cbrt | sqrt  x^2 |    and    |     or    |    xor    |            >| " << rightplot[4]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... | ......... | ......... | ......... | .........  >| " << rightplot[5]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... |   nand    |    nor    |   xand    | .........  >| " << rightplot[6]  << "\n";
          }

          else if ( ( page == LOGIC_PAGE ) && !isew && isah )
          {
              outstreamunlogged() << "|<     INV   SD   D-R-G   |    x>y    |    x<y    |   x==y    |    not     >| " << rightplot[0]  << "\n";
              outstreamunlogged() << "|<  .........-+-......... | ......... | ......... | ......... | .........  >| " << rightplot[1]  << "\n";
              outstreamunlogged() << "|<  .........   ......... |   x<=y    |   x>=y    |   x!=y    |    is      >| " << rightplot[2]  << "\n";
              outstreamunlogged() << "|< -----------+-----------+-----------+-----------+-----------+----------- >| " << rightplot[3]  << "\n";
              outstreamunlogged() << "|<  +/-  Cbrt | Sqrt  x^2 |    and    |     or    |    xor    |            >| " << rightplot[4]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... | ......... | ......... | ......... | .........  >| " << rightplot[5]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... |   nand    |    nor    |   xand    | .........  >| " << rightplot[6]  << "\n";
          }

          else if ( ( page == LOGIC_PAGE ) && isew && isah )
          {
              outstreamunlogged() << "|<     INV   SD   D-R-G   |   x.>y    |   x.<y    |  x.==y    |    not     >| " << rightplot[0]  << "\n";
              outstreamunlogged() << "|<  .........-+-......... | ......... | ......... | ......... | .........  >| " << rightplot[1]  << "\n";
              outstreamunlogged() << "|<  .........   ......... |  x.<=y    |  x.>=y    |  x.!=y    |    is      >| " << rightplot[2]  << "\n";
              outstreamunlogged() << "|< -----------+-----------+-----------+-----------+-----------+----------- >| " << rightplot[3]  << "\n";
              outstreamunlogged() << "|<  +/-  Cbrt | Sqrt  x^2 |    and    |     or    |    xor    |            >| " << rightplot[4]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... | ......... | ......... | ......... | .........  >| " << rightplot[5]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... |   nand    |    nor    |   xand    | .........  >| " << rightplot[6]  << "\n";
          }

          else if ( ( page == FTYPE_PAGE ) && !isah )
          {
              outstreamunlogged() << "|<     INV   SD   D-R-G   |   isnan   |  ispinf   |  isnull   |   nrows    >| " << rightplot[0]  << "\n";
              outstreamunlogged() << "|<  .........-+-......... | ......... | ......... | ......... | .........  >| " << rightplot[1]  << "\n";
              outstreamunlogged() << "|<  .........   ......... |   isinf   |  isninf   |  size     |   ncols    >| " << rightplot[2]  << "\n";
              outstreamunlogged() << "|< -----------+-----------+-----------+-----------+-----------+----------- >| " << rightplot[3]  << "\n";
              outstreamunlogged() << "|<  +/-  cbrt | sqrt  x^2 |   isint   |   isvec   |  isReal   |   isstr    >| " << rightplot[4]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... | ......... | ......... | ......... | .........  >| " << rightplot[5]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... |   isnull  |   ismat   |  isComp   |   iserr    >| " << rightplot[6]  << "\n";
          }

          else if ( ( page == FTYPE_PAGE ) && isah )
          {
              outstreamunlogged() << "|<     INV   SD   D-R-G   |   isnan   |  ispinf   |  isnull   |   nrows    >| " << rightplot[0]  << "\n";
              outstreamunlogged() << "|<  .........-+-......... | ......... | ......... | ......... | .........  >| " << rightplot[1]  << "\n";
              outstreamunlogged() << "|<  .........   ......... |   isinf   |  isninf   |  size     |   ncols    >| " << rightplot[2]  << "\n";
              outstreamunlogged() << "|< -----------+-----------+-----------+-----------+-----------+----------- >| " << rightplot[3]  << "\n";
              outstreamunlogged() << "|<  +/-  Cbrt | Sqrt  x^2 |   isint   |   isvec   |  isReal   |   isstr    >| " << rightplot[4]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... | ......... | ......... | ......... | .........  >| " << rightplot[5]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... |   isnull  |   ismat   |  isComp   |   iserr    >| " << rightplot[6]  << "\n";
          }

          else if ( ( page == TIME_PAGE ) && !isah )
          {
              outstreamunlogged() << "|<     INV   SD   D-R-G   |  clkyear  |  clkday   |  clkmin   |   tnow     >| " << rightplot[0]  << "\n";
              outstreamunlogged() << "|<  .........-+-......... | ......... | ......... | ......... | .........  >| " << rightplot[1]  << "\n";
              outstreamunlogged() << "|<  .........   ......... |  clkmon   |  clkhour  |  clksec   |   tnow()   >| " << rightplot[2]  << "\n";
              outstreamunlogged() << "|< -----------+-----------+-----------+-----------+-----------+----------- >| " << rightplot[3]  << "\n";
              outstreamunlogged() << "|<  +/-  cbrt | sqrt  x^2 | clkyear() | clkday()  | clkmin()  |   CLOCK    >| " << rightplot[4]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... | ......... | ......... | ......... | .........  >| " << rightplot[5]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... | clkmon()  | clkhour() | clksec()  | .........  >| " << rightplot[6]  << "\n";
          }

          else if ( ( page == TIME_PAGE ) && isah )
          {
              outstreamunlogged() << "|<     INV   SD   D-R-G   |  clkyear  |  clkday   |  clkmin   |   tnow     >| " << rightplot[0]  << "\n";
              outstreamunlogged() << "|<  .........-+-......... | ......... | ......... | ......... | .........  >| " << rightplot[1]  << "\n";
              outstreamunlogged() << "|<  .........   ......... |  clkmon   |  clkhour  |  clksec   |   tnow()   >| " << rightplot[2]  << "\n";
              outstreamunlogged() << "|< -----------+-----------+-----------+-----------+-----------+----------- >| " << rightplot[3]  << "\n";
              outstreamunlogged() << "|<  +/-  Cbrt | Sqrt  x^2 | clkyear() | clkday()  | clkmin()  |   CLOCK    >| " << rightplot[4]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... | ......... | ......... | ......... | .........  >| " << rightplot[5]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... | clkmon()  | clkhour() | clksec()  | .........  >| " << rightplot[6]  << "\n";
          }

          if ( isew && !isah )
          {
              outstreamunlogged() << "|< -----------+-----------+-----------+-----------+-----------+----------- >| " << rightplot[7]  << "\n";
              outstreamunlogged() << "|<  1./x   x! | X-Y   X-M |    [(-----6-----)]    |  Min  ah  |  MR   ew   >| " << rightplot[8]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... | .........   ......... | ......... | .........  >| " << rightplot[9]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... | .........   ......... | ......... | .........  >| " << rightplot[10] << "\n";
//              outstreamunlogged() << "|<   sum x^2      sum x         n          xbar      sigma n    sigma n-1  >| " << rightplot[0]  << "\n";
              outstreamunlogged() << "|<sum x^2 prod|sum x  prod|n argmedian|xbar median|sig_n range|sig_n-1 midr>| " << rightplot[11] << "\n";
              outstreamunlogged() << "|                                                                           | " << rightplot[12] << "\n";
              outstreamunlogged() << "|   +-------+   +-------+   +-------+   +-------+   +-------+   +-------+   | " << rightplot[13] << "\n";
              outstreamunlogged() << "|   |       |   |       |   |       |   |       |   |       |   |       |   | " << rightplot[14] << "\n";
              outstreamunlogged() << "|   |   i   |   |   7   |   |   8   |   |   9   |   |   C   |   |   AC  |   | " << rightplot[15] << "\n";
              outstreamunlogged() << "|   |       |   |       |   |       |   |       |   |       |   |       |   | " << rightplot[16] << "\n";
              outstreamunlogged() << "|   +-- l --+   +-- p --+   +-- [ --+   +-- ] --+   +-- | --+   +--SAC--+   | " << rightplot[17] << "\n";
              outstreamunlogged() << "|   +-------+   +-------+   +-------+   +-------+   +-------+   +-------+   | " << rightplot[18] << "\n";
              outstreamunlogged() << "|   |       |   |       |   |       |   |       |   |       |   |       |   | " << rightplot[19] << "\n";
              outstreamunlogged() << "|   |   I   |   |   4   |   |   5   |   |   6   |   |  .*   |   |  ./   |   | " << rightplot[20] << "\n";
              outstreamunlogged() << "|   |       |   |       |   |       |   |       |   |       |   |       |   | " << rightplot[21] << "\n";
              outstreamunlogged() << "|   +-- m --+   +-- q --+   +-- ( --+   +-- ) --+   +--.*>--+   +--.\\ --+   | " << rightplot[22] << "\n";
              outstreamunlogged() << "|   +-------+   +-------+   +-------+   +-------+   +-------+   +-------+   | " << rightplot[23] << "\n";
              outstreamunlogged() << "|   |       |   |       |   |       |   |       |   |       |   |       |   | " << rightplot[24] << "\n";
              outstreamunlogged() << "|   |   J   |   |   1   |   |   2   |   |   3   |   |   +   |   |   -   |   | " << rightplot[25] << "\n";
              outstreamunlogged() << "|   |       |   |       |   |       |   |       |   |       |   |       |   | " << rightplot[26] << "\n";
              outstreamunlogged() << "|   +-- n --+   +-- r --+   +-- ; --+   +--.% --+   +-R-->P-+   +-P-->R-+   | " << rightplot[27] << "\n";
              outstreamunlogged() << "|   +-------+   +-------+   +-------+   +-------+   +-------+   +-------+   |\n";
              outstreamunlogged() << "|   |       |   |       |   |       |   |       |   |       |   |       |   |\n";
              outstreamunlogged() << "|   |   K   |   |   0   |   |   .   |   |  EXP  |   |   =   |   |   M+  |   |\n";
              outstreamunlogged() << "|   |       |   |       |   |       |   |       |   | (ret) |   |       |   |\n";
              outstreamunlogged() << "|   +-- o --+   +--nan--+   +--inf--+   +--pi --+   +-eidiv-+   +M-,xDEL+   |\n";
              outstreamunlogged() << "|                                                                           |\n";
              outstreamunlogged() << "+---------------------------------------------------------------------------+\n";
          }

          else if ( !isew && !isah )
          {
              outstreamunlogged() << "|< -----------+-----------+-----------+-----------+-----------+----------- >| " << rightplot[7]  << "\n";
              outstreamunlogged() << "|<  1/x    x! | X-Y   X-M |    [(-----6-----)]    |  Min  ah  |  MR   ew   >| " << rightplot[8]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... | .........   ......... | ......... | .........  >| " << rightplot[9]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... | .........   ......... | ......... | .........  >| " << rightplot[10] << "\n";
//              outstreamunlogged() << "|<   sum x^2      sum x         n          xbar      sigma n    sigma n-1  >| " << rightplot[0]  << "\n";
              outstreamunlogged() << "|<sum x^2 prod|sum x  prod|n argmedian|xbar median|sig_n range|sig_n-1 midr>| " << rightplot[11] << "\n";
              outstreamunlogged() << "|                                                                           | " << rightplot[12] << "\n";
              outstreamunlogged() << "|   +-------+   +-------+   +-------+   +-------+   +-------+   +-------+   | " << rightplot[13] << "\n";
              outstreamunlogged() << "|   |       |   |       |   |       |   |       |   |       |   |       |   | " << rightplot[14] << "\n";
              outstreamunlogged() << "|   |   i   |   |   7   |   |   8   |   |   9   |   |   C   |   |   AC  |   | " << rightplot[15] << "\n";
              outstreamunlogged() << "|   |       |   |       |   |       |   |       |   |       |   |       |   | " << rightplot[16] << "\n";
              outstreamunlogged() << "|   +-- l --+   +-- p --+   +-- [ --+   +-- ] --+   +-- | --+   +--SAC--+   | " << rightplot[17] << "\n";
              outstreamunlogged() << "|   +-------+   +-------+   +-------+   +-------+   +-------+   +-------+   | " << rightplot[18] << "\n";
              outstreamunlogged() << "|   |       |   |       |   |       |   |       |   |       |   |       |   | " << rightplot[19] << "\n";
              outstreamunlogged() << "|   |   I   |   |   4   |   |   5   |   |   6   |   |   *   |   |   /   |   | " << rightplot[20] << "\n";
              outstreamunlogged() << "|   |       |   |       |   |       |   |       |   |       |   |       |   | " << rightplot[21] << "\n";
              outstreamunlogged() << "|   +-- m --+   +-- q --+   +-- ( --+   +-- ) --+   +--*> --+   +-- \\ --+   | " << rightplot[22] << "\n";
              outstreamunlogged() << "|   +-------+   +-------+   +-------+   +-------+   +-------+   +-------+   | " << rightplot[23] << "\n";
              outstreamunlogged() << "|   |       |   |       |   |       |   |       |   |       |   |       |   | " << rightplot[24] << "\n";
              outstreamunlogged() << "|   |   J   |   |   1   |   |   2   |   |   3   |   |   +   |   |   -   |   | " << rightplot[25] << "\n";
              outstreamunlogged() << "|   |       |   |       |   |       |   |       |   |       |   |       |   | " << rightplot[26] << "\n";
              outstreamunlogged() << "|   +-- n --+   +-- r --+   +-- ; --+   +-- % --+   +-R-->P-+   +-P-->R-+   | " << rightplot[27] << "\n";
              outstreamunlogged() << "|   +-------+   +-------+   +-------+   +-------+   +-------+   +-------+   |\n";
              outstreamunlogged() << "|   |       |   |       |   |       |   |       |   |       |   |       |   |\n";
              outstreamunlogged() << "|   |   K   |   |   0   |   |   .   |   |  EXP  |   |   =   |   |   M+  |   |\n";
              outstreamunlogged() << "|   |       |   |       |   |       |   |       |   | (ret) |   |       |   |\n";
              outstreamunlogged() << "|   +-- o --+   +--nan--+   +--inf--+   +--pi --+   +-idiv--+   +M-,xDEL+   |\n";
              outstreamunlogged() << "|                                                                           |\n";
              outstreamunlogged() << "+---------------------------------------------------------------------------+\n";
          }

          else if ( isew && isah )
          {
              outstreamunlogged() << "|< -----------+-----------+-----------+-----------+-----------+----------- >| " << rightplot[7]  << "\n";
              outstreamunlogged() << "|<  1./x   x! | X-Y   X-M |    [(-----6-----)]    |  Min  ah  |  MR   ew   >| " << rightplot[8]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... | .........   ......... | ......... | .........  >| " << rightplot[9]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... | .........   ......... | ......... | .........  >| " << rightplot[10] << "\n";
//              outstreamunlogged() << "|<   sum x^2      sum x         n          xbar      sigma n    sigma n-1  >| " << rightplot[0]  << "\n";
              outstreamunlogged() << "|<sum x^2 prod|sum x  prod|n argmedian|xbar median|sig_n range|sig_n-1 midr>| " << rightplot[11] << "\n";
              outstreamunlogged() << "|                                                                           | " << rightplot[12] << "\n";
              outstreamunlogged() << "|   +-------+   +-------+   +-------+   +-------+   +-------+   +-------+   | " << rightplot[13] << "\n";
              outstreamunlogged() << "|   |       |   |       |   |       |   |       |   |       |   |       |   | " << rightplot[14] << "\n";
              outstreamunlogged() << "|   |   i   |   |   7   |   |   8   |   |   9   |   |   C   |   |   AC  |   | " << rightplot[15] << "\n";
              outstreamunlogged() << "|   |       |   |       |   |       |   |       |   |       |   |       |   | " << rightplot[16] << "\n";
              outstreamunlogged() << "|   +-- l --+   +-- p --+   +-- [ --+   +-- ] --+   +--|@ --+   +--SAC--+   | " << rightplot[17] << "\n";
              outstreamunlogged() << "|   +-------+   +-------+   +-------+   +-------+   +-------+   +-------+   | " << rightplot[18] << "\n";
              outstreamunlogged() << "|   |       |   |       |   |       |   |       |   |       |   |       |   | " << rightplot[19] << "\n";
              outstreamunlogged() << "|   |   I   |   |   4   |   |   5   |   |   6   |   |  .*   |   |  ./   |   | " << rightplot[20] << "\n";
              outstreamunlogged() << "|   |       |   |       |   |       |   |       |   |       |   |       |   | " << rightplot[21] << "\n";
              outstreamunlogged() << "|   +-- m --+   +-- q --+   +-- ( --+   +-- ) --+   +--.*>--+   +--.\\ --+   | " << rightplot[22] << "\n";
              outstreamunlogged() << "|   +-------+   +-------+   +-------+   +-------+   +-------+   +-------+   | " << rightplot[23] << "\n";
              outstreamunlogged() << "|   |       |   |       |   |       |   |       |   |       |   |       |   | " << rightplot[24] << "\n";
              outstreamunlogged() << "|   |   J   |   |   1   |   |   2   |   |   3   |   |   +   |   |   -   |   | " << rightplot[25] << "\n";
              outstreamunlogged() << "|   |       |   |       |   |       |   |       |   |       |   |       |   | " << rightplot[26] << "\n";
              outstreamunlogged() << "|   +-- n --+   +-- r --+   +-- ; --+   +--.% --+   +-R-->P-+   +-P-->R-+   | " << rightplot[27] << "\n";
              outstreamunlogged() << "|   +-------+   +-------+   +-------+   +-------+   +-------+   +-------+   |\n";
              outstreamunlogged() << "|   |       |   |       |   |       |   |       |   |       |   |       |   |\n";
              outstreamunlogged() << "|   |   K   |   |   0   |   |   .   |   |  EXP  |   |   =   |   |   M+  |   |\n";
              outstreamunlogged() << "|   |       |   |       |   |       |   |       |   | (ret) |   |       |   |\n";
              outstreamunlogged() << "|   +-- o --+   +--nan--+   +--inf--+   +--pi --+   +-eidiv-+   +M-,xDEL+   |\n";
              outstreamunlogged() << "|                                                                           |\n";
              outstreamunlogged() << "+---------------------------------------------------------------------------+\n";
          }

          else if ( !isew && isah )
          {
              outstreamunlogged() << "|< -----------+-----------+-----------+-----------+-----------+----------- >| " << rightplot[7]  << "\n";
              outstreamunlogged() << "|<  1/x    x! | X-Y   X-M |    [(-----6-----)]    |  Min  ah  |  MR   ew   >| " << rightplot[8]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... | .........   ......... | ......... | .........  >| " << rightplot[9]  << "\n";
              outstreamunlogged() << "|<  ......... | ......... | .........   ......... | ......... | .........  >| " << rightplot[10] << "\n";
//              outstreamunlogged() << "|<   sum x^2      sum x         n          xbar      sigma n    sigma n-1  >| " << rightplot[0]  << "\n";
              outstreamunlogged() << "|<sum x^2 prod|sum x  prod|n argmedian|xbar median|sig_n range|sig_n-1 midr>| " << rightplot[11] << "\n";
              outstreamunlogged() << "|                                                                           | " << rightplot[12] << "\n";
              outstreamunlogged() << "|   +-------+   +-------+   +-------+   +-------+   +-------+   +-------+   | " << rightplot[13] << "\n";
              outstreamunlogged() << "|   |       |   |       |   |       |   |       |   |       |   |       |   | " << rightplot[14] << "\n";
              outstreamunlogged() << "|   |   i   |   |   7   |   |   8   |   |   9   |   |   C   |   |   AC  |   | " << rightplot[15] << "\n";
              outstreamunlogged() << "|   |       |   |       |   |       |   |       |   |       |   |       |   | " << rightplot[16] << "\n";
              outstreamunlogged() << "|   +-- l --+   +-- p --+   +-- [ --+   +-- ] --+   +--|@ --+   +--SAC--+   | " << rightplot[17] << "\n";
              outstreamunlogged() << "|   +-------+   +-------+   +-------+   +-------+   +-------+   +-------+   | " << rightplot[18] << "\n";
              outstreamunlogged() << "|   |       |   |       |   |       |   |       |   |       |   |       |   | " << rightplot[19] << "\n";
              outstreamunlogged() << "|   |   I   |   |   4   |   |   5   |   |   6   |   |   *   |   |   /   |   | " << rightplot[20] << "\n";
              outstreamunlogged() << "|   |       |   |       |   |       |   |       |   |       |   |       |   | " << rightplot[21] << "\n";
              outstreamunlogged() << "|   +-- m --+   +-- q --+   +-- ( --+   +-- ) --+   +--*> --+   +-- \\ --+   | " << rightplot[22] << "\n";
              outstreamunlogged() << "|   +-------+   +-------+   +-------+   +-------+   +-------+   +-------+   | " << rightplot[23] << "\n";
              outstreamunlogged() << "|   |       |   |       |   |       |   |       |   |       |   |       |   | " << rightplot[24] << "\n";
              outstreamunlogged() << "|   |   J   |   |   1   |   |   2   |   |   3   |   |   +   |   |   -   |   | " << rightplot[25] << "\n";
              outstreamunlogged() << "|   |       |   |       |   |       |   |       |   |       |   |       |   | " << rightplot[26] << "\n";
              outstreamunlogged() << "|   +-- n --+   +-- r --+   +-- ; --+   +-- % --+   +-R-->P-+   +-P-->R-+   | " << rightplot[27] << "\n";
              outstreamunlogged() << "|   +-------+   +-------+   +-------+   +-------+   +-------+   +-------+   |\n";
              outstreamunlogged() << "|   |       |   |       |   |       |   |       |   |       |   |       |   |\n";
              outstreamunlogged() << "|   |   K   |   |   0   |   |   .   |   |  EXP  |   |   =   |   |   M+  |   |\n";
              outstreamunlogged() << "|   |       |   |       |   |       |   |       |   | (ret) |   |       |   |\n";
              outstreamunlogged() << "|   +-- o --+   +--nan--+   +--inf--+   +--pi --+   +-idiv--+   +M-,xDEL+   |\n";
              outstreamunlogged() << "|                                                                           |\n";
              outstreamunlogged() << "+---------------------------------------------------------------------------+\n";
          }

          int linenum = 10 + ( ( gridvert < 3 ) ? (4*gridvert) : (15+(5*(gridvert-3))) );
          int colnum  = 6 + (12*gridhoriz);

          svmcurs(linenum,colnum);
          outstreamunlogged() << "#####" << std::endl << std::flush;
        }

        int keypress = svm_getch_nonblock();

        // Keys

        // Moving around keyboard, exit

        if ( ( keypress == '\0' ) || ( keypress == -1 ) )
        {
            /* nop */ ;
        }

        else if ( keypress == 'Q' ) { /* exit  */ exitnow = 1;              }
        else if ( keypress == -37 ) { /* left  */ gridhoriz--; refresh = 1; }
        else if ( keypress == -39 ) { /* right */ gridhoriz++; refresh = 1; }
        else if ( keypress == -38 ) { /* up    */ gridvert--;  refresh = 1; }
        else if ( keypress == -40 ) { /* down  */ gridvert++;  refresh = 1; }

        // Clear and reset

        else if ( ( ( gridvert == 3 ) && ( gridhoriz == 4 ) && !isinv && ( keypress == ' ' ) ) || ( keypress == 1 ) || ( keypress == 27 ) )
        {
            /* C */

            // ESC: keypress == 1 or 27

            dataDisplay = 1;
            entryval    = "";
            GETX        = 0;
            refresh     = 1;
            isdmsmode = 0;

            calcNest.whichassoc = 0;
            calcNest.whichdms   = 0;
            calcNest.oplastkey  = 0;
        }

        else if ( ( gridvert == 3 ) && ( gridhoriz == 5 ) && ( keypress == ' ' ) )
        {
            /* AC and SAC */

            if ( SDmode && isinv )
            {
                SDsum   = 0;
                SDsumsq = 0;
                SDcnt   = 0;
                SDprod  = 1;
                SDdata.resize(0);
            }

            isinv   = 0;
            isah    = 0;
            isew    = 0;
            HYPmode = 0;

            theCalcNest.resize(0);
            theCalcNest.push(tempnest);

            dataDisplay = 1;
            entryval    = "";
            GETX        = 0;
            GETY        = 0;
            refresh     = 1;

            isdmsmode = 0;
        }

        // State control

        else if ( ( gridvert == 0 ) && ( gridhoriz == 0 ) &&                                                        ( keypress == ' ' ) ) { /* INV */ isinv = isinv ? 0 : 1; refresh = 1; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 1 ) &&                                   !isinv &&            ( keypress == ' ' ) ) { /* DRG */ DRGtype = DRGtype ? ( ( DRGtype == 1 ) ? 2 : 0 ) : 1; refresh = 1; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 1 ) &&                                    isinv &&            ( keypress == ' ' ) ) { /* SD  */ SDmode = SDmode ? 0 : 1; isinv = 0; if ( !SDmode ) { SDsum = 0; SDsumsq = 0; SDcnt = 0; SDprod = 1; SDdata.resize(0); } refresh = 1; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 2 ) && ( page == MYCALCSF_PAGE      ) &&                      ( keypress == ' ' ) ) { /* HYP */ HYPmode = HYPmode ? 0 : 1; refresh = 1; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 2 ) && ( page == OBSCURETRIGI__PAGE ) &&                      ( keypress == ' ' ) ) { /* HYP */ HYPmode = HYPmode ? 0 : 1; refresh = 1; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 2 ) && ( page == OBSCURETRIGII_PAGE ) &&                      ( keypress == ' ' ) ) { /* HYP */ HYPmode = HYPmode ? 0 : 1; refresh = 1; }
        else if ( ( gridvert == 2 ) && ( gridhoriz == 4 )                                   &&  isinv && !SDmode && ( keypress == ' ' ) ) { /* ah  */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; isah = isah ? 0 : 1; isinv = 0; HYPmode = 0; refresh = 1; }
        else if ( ( gridvert == 2 ) && ( gridhoriz == 5 )                                   &&  isinv && !SDmode && ( keypress == ' ' ) ) { /* ew  */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; isew = isew ? 0 : 1; isinv = 0; HYPmode = 0; refresh = 1; }

        // Display mode and dms functions

        else if ( ( gridvert == 1 ) && ( gridhoriz == 2 ) && ( page == MYCALCSF_PAGE      ) &&  isinv && ( keypress == ' ' ) ) { /* <-- */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX.finalise(); isdmsmode = isdmsmode ? 0 : 1; isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 2 ) && ( page == OBSCURETRIGI__PAGE ) &&  isinv && ( keypress == ' ' ) ) { /* <-- */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX.finalise(); isdmsmode = isdmsmode ? 0 : 1; isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 2 ) && ( page == OBSCURETRIGII_PAGE ) &&  isinv && ( keypress == ' ' ) ) { /* <-- */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX.finalise(); isdmsmode = isdmsmode ? 0 : 1; isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 2 ) && ( page == MYCALCSF_PAGE      ) && !isinv && ( keypress == ' ' ) ) { /* .'" */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX.finalise(); calcNest.dmsaccum = ( calcNest.whichdms == 0 ) ? GETX : ( ( calcNest.whichdms == 1 ) ? (calcNest.dmsaccum+(GETX/60.0)) : (calcNest.dmsaccum+(GETX/3600.0)) ); GETX = calcNest.dmsaccum; calcNest.whichdms = ( calcNest.whichdms < 2 ) ? calcNest.whichdms+1 : 0; isinv = 0; HYPmode = 0; refresh = 1; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 2 ) && ( page == OBSCURETRIGI__PAGE ) && !isinv && ( keypress == ' ' ) ) { /* .'" */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX.finalise(); calcNest.dmsaccum = ( calcNest.whichdms == 0 ) ? GETX : ( ( calcNest.whichdms == 1 ) ? (calcNest.dmsaccum+(GETX/60.0)) : (calcNest.dmsaccum+(GETX/3600.0)) ); GETX = calcNest.dmsaccum; calcNest.whichdms = ( calcNest.whichdms < 2 ) ? calcNest.whichdms+1 : 0; isinv = 0; HYPmode = 0; refresh = 1; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 2 ) && ( page == OBSCURETRIGII_PAGE ) && !isinv && ( keypress == ' ' ) ) { /* .'" */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX.finalise(); calcNest.dmsaccum = ( calcNest.whichdms == 0 ) ? GETX : ( ( calcNest.whichdms == 1 ) ? (calcNest.dmsaccum+(GETX/60.0)) : (calcNest.dmsaccum+(GETX/3600.0)) ); GETX = calcNest.dmsaccum; calcNest.whichdms = ( calcNest.whichdms < 2 ) ? calcNest.whichdms+1 : 0; isinv = 0; HYPmode = 0; refresh = 1; isdmsmode = 0; }

        // Simple memory adjustment - uses UPDATE_EVAL_OP as these evaluate expression before operation

        else if ( ( gridvert == 6 ) && ( gridhoriz == 5 ) &&                                 !isinv && !SDmode && ( keypress == ' ' ) ) { /* M+      */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; UPDATE_EVAL_OP; memdata += GETX; memdata.finalise(); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 6 ) && ( gridhoriz == 5 ) &&                                  isinv && !SDmode && ( keypress == ' ' ) ) { /* M-      */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; UPDATE_EVAL_OP; memdata -= GETX; memdata.finalise(); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 6 ) && ( gridhoriz == 5 ) &&                                 !isinv &&  SDmode && ( keypress == ' ' ) ) { /* M+      */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; UPDATE_EVAL_OP; SDdata.append(SDdata.size(),GETX); SDsum += GETX; SDsumsq += (GETX)*(GETX); SDprod *= GETX; ++SDcnt; SDsum.finalise(); SDsumsq.finalise(); SDprod.finalise(); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 6 ) && ( gridhoriz == 5 ) &&                                  isinv &&  SDmode && ( keypress == ' ' ) ) { /* xdel M- */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; UPDATE_EVAL_OP; SDdata.append(SDdata.size(),-GETX); SDsum -= GETX; SDsumsq -= (GETX)*(GETX); SDprod /= GETX; SDsum.finalise(); SDsumsq.finalise(); SDprod.finalise(); --SDcnt; isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == TESTFUNCIII_PAGE ) &&  isinv &&            ( keypress == ' ' ) ) { /* M=      */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; UPDATE_EVAL_OP; testM = GETX; testM.finalise(); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }

        // Memory in and memory reset

        else if ( ( gridvert == 2 ) && ( gridhoriz == 4 ) && !isinv && !SDmode && ( keypress == ' ' ) ) { /* Min */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; memdata = GETX; isinv = 0; HYPmode = 0; refresh = 1; }
        else if ( ( gridvert == 2 ) && ( gridhoriz == 5 ) && !isinv && !SDmode && ( keypress == ' ' ) ) { /* MR  */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = memdata; isinv = 0; HYPmode = 0; refresh = 1; }
        else if ( ( gridvert == 2 ) && ( gridhoriz == 1 ) && !isinv && !SDmode && ( keypress == ' ' ) ) { /* X-Y */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; qswap(GETX,GETY);    isinv = 0; HYPmode = 0; refresh = 1; }
        else if ( ( gridvert == 2 ) && ( gridhoriz == 1 ) &&  isinv && !SDmode && ( keypress == ' ' ) ) { /* X-M */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; qswap(GETX,memdata); isinv = 0; HYPmode = 0; refresh = 1; }

        // SD memory

        else if ( ( gridvert == 2 ) && ( gridhoriz == 0 ) && SDmode && !isinv && ( keypress == ' ' ) ) { /* sum x^2   */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = SDsumsq;                                                                                           isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; calcNest.whichassoc = 0; isdmsmode = 0; }
        else if ( ( gridvert == 2 ) && ( gridhoriz == 1 ) && SDmode && !isinv && ( keypress == ' ' ) ) { /* sum x     */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = SDsum;                                                                                             isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; calcNest.whichassoc = 0; isdmsmode = 0; }
        else if ( ( gridvert == 2 ) && ( gridhoriz == 2 ) && SDmode && !isinv && ( keypress == ' ' ) ) { /* n         */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = SDcnt;                                                                                             isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; calcNest.whichassoc = 0; isdmsmode = 0; }
        else if ( ( gridvert == 2 ) && ( gridhoriz == 3 ) && SDmode && !isinv && ( keypress == ' ' ) ) { /* xbar      */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = SDsum*(1.0/SDcnt);                                                                                 isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; calcNest.whichassoc = 0; isdmsmode = 0; }
        else if ( ( gridvert == 2 ) && ( gridhoriz == 4 ) && SDmode && !isinv && ( keypress == ' ' ) ) { /* sigma_n   */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = sqrt((SDsumsq*(1.0/SDcnt))-((SDsum*(1.0/SDcnt))*(SDsum*(1.0/SDcnt))));                             isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; calcNest.whichassoc = 0; isdmsmode = 0; }
        else if ( ( gridvert == 2 ) && ( gridhoriz == 5 ) && SDmode && !isinv && ( keypress == ' ' ) ) { /* sigma_n-1 */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = (sqrt((SDsumsq*(1.0/SDcnt))-((SDsum*(1.0/SDcnt))*(SDsum*(1.0/SDcnt)))))*sqrt(SDcnt)/sqrt(SDcnt-1); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; calcNest.whichassoc = 0; isdmsmode = 0; }
        else if ( ( gridvert == 2 ) && ( gridhoriz == 0 ) && SDmode &&  isinv && ( keypress == ' ' ) ) { /* prod x^2  */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = SDprod*SDprod;                                                                                     isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; calcNest.whichassoc = 0; isdmsmode = 0; }
        else if ( ( gridvert == 2 ) && ( gridhoriz == 1 ) && SDmode &&  isinv && ( keypress == ' ' ) ) { /* prod x    */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = SDprod;                                                                                            isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; calcNest.whichassoc = 0; isdmsmode = 0; }
        else if ( ( gridvert == 2 ) && ( gridhoriz == 2 ) && SDmode &&  isinv && ( keypress == ' ' ) ) { /* argmedian */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; median(SDdata,GETX.force_int());                                                                          isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; calcNest.whichassoc = 0; isdmsmode = 0; }
        else if ( ( gridvert == 2 ) && ( gridhoriz == 3 ) && SDmode &&  isinv && ( keypress == ' ' ) ) { /* median    */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = median(SDdata,dummyi);                                                                             isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; calcNest.whichassoc = 0; isdmsmode = 0; }
        else if ( ( gridvert == 2 ) && ( gridhoriz == 4 ) && SDmode &&  isinv && ( keypress == ' ' ) ) { /* range     */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = (max(SDdata,dummyi)-min(SDdata,dummyi));                                                           isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; calcNest.whichassoc = 0; isdmsmode = 0; }
        else if ( ( gridvert == 2 ) && ( gridhoriz == 5 ) && SDmode &&  isinv && ( keypress == ' ' ) ) { /* midrange  */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = (max(SDdata,dummyi)+min(SDdata,dummyi))/2.0;                                                       isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; calcNest.whichassoc = 0; isdmsmode = 0; }

        // Simple unary operators

        else if ( ( gridvert == 2 ) && ( gridhoriz == 0 ) &&                                !SDmode && !isinv && !isew && ( keypress == ' ' ) ) { /* 1/x  */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX.inverse();   isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 2 ) && ( gridhoriz == 0 ) &&                                !SDmode && !isinv &&  isew && ( keypress == ' ' ) ) { /* 1/x  */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = einv(GETX);   isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 0 ) &&                                           !isinv          && ( keypress == ' ' ) ) { /* +-   */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX.negate();    isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 3 ) && ( page == ABSANGARG_PAGE  ) &&             isinv          && ( keypress == ' ' ) ) { /* conj */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX.conj();      isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == COMBMAXMIN_PAGE ) &&             isinv          && ( keypress == ' ' ) ) { /* T    */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX.transpose(); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }

        // Logs and exponents

        else if ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == MYCALCSF_PAGE ) && !isinv && !HYPmode && !isah && ( keypress == ' ' ) ) { /* ln    */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = log(GETX);   isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == MYCALCSF_PAGE ) && !isinv && !HYPmode && !isah && ( keypress == ' ' ) ) { /* log   */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = log10(GETX); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == MYCALCSF_PAGE ) && !isinv && !HYPmode &&  isah && ( keypress == ' ' ) ) { /* Ln    */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = Log(GETX);   isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == MYCALCSF_PAGE ) && !isinv && !HYPmode &&  isah && ( keypress == ' ' ) ) { /* Log   */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = Log10(GETX); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == MYCALCSF_PAGE ) &&  isinv && !HYPmode &&          ( keypress == ' ' ) ) { /* exp   */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = exp(GETX);   isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == MYCALCSF_PAGE ) &&  isinv && !HYPmode &&          ( keypress == ' ' ) ) { /* 10^x  */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = tenup(GETX); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }

        // Trig functions

        else if ( ( gridvert == 1 ) && ( gridhoriz == 3 ) && ( page == MYCALCSF_PAGE      ) && !isinv && !HYPmode && ( keypress == ' ' ) ) { /* sin     */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = sin    (PUTINRAD(GETX)); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 4 ) && ( page == MYCALCSF_PAGE      ) && !isinv && !HYPmode && ( keypress == ' ' ) ) { /* cos     */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = cos    (PUTINRAD(GETX)); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 5 ) && ( page == MYCALCSF_PAGE      ) && !isinv && !HYPmode && ( keypress == ' ' ) ) { /* tan     */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = tan    (PUTINRAD(GETX)); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == OBSCURETRIGI__PAGE ) && !isinv && !HYPmode && ( keypress == ' ' ) ) { /* cosec   */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = cosec  (PUTINRAD(GETX)); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == OBSCURETRIGI__PAGE ) && !isinv && !HYPmode && ( keypress == ' ' ) ) { /* sec     */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = sec    (PUTINRAD(GETX)); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == OBSCURETRIGI__PAGE ) && !isinv && !HYPmode && ( keypress == ' ' ) ) { /* cot     */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = cot    (PUTINRAD(GETX)); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 3 ) && ( page == OBSCURETRIGI__PAGE ) && !isinv && !HYPmode && ( keypress == ' ' ) ) { /* vers    */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = vers   (PUTINRAD(GETX)); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 4 ) && ( page == OBSCURETRIGI__PAGE ) && !isinv && !HYPmode && ( keypress == ' ' ) ) { /* covers  */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = covers (PUTINRAD(GETX)); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 5 ) && ( page == OBSCURETRIGI__PAGE ) && !isinv && !HYPmode && ( keypress == ' ' ) ) { /* hav     */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = hav    (PUTINRAD(GETX)); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == OBSCURETRIGII_PAGE ) && !isinv && !HYPmode && ( keypress == ' ' ) ) { /* exsec   */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = exsec  (PUTINRAD(GETX)); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == OBSCURETRIGII_PAGE ) && !isinv && !HYPmode && ( keypress == ' ' ) ) { /* excosec */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = excosec(PUTINRAD(GETX)); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == OBSCURETRIGII_PAGE ) && !isinv && !HYPmode && ( keypress == ' ' ) ) { /* cas     */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = castrg (PUTINRAD(GETX)); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 5 ) && ( page == OBSCURETRIGII_PAGE ) && !isinv && !HYPmode && ( keypress == ' ' ) ) { /* casc    */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = casctrg(PUTINRAD(GETX)); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 4 ) && ( page == OBSCURETRIGII_PAGE ) &&  isinv && !HYPmode && ( keypress == ' ' ) ) { /* gd      */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = PUTINDRG(gd     (GETX)); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 3 ) && ( page == OBSCURETRIGII_PAGE ) && !isinv && !HYPmode && ( keypress == ' ' ) ) { /* sinc    */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = sinc   (PUTINRAD(GETX)); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 3 ) && ( page == OBSCURETRIGII_PAGE ) &&  isinv && !HYPmode && ( keypress == ' ' ) ) { /* cosc    */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = cosc   (PUTINRAD(GETX)); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 4 ) && ( page == OBSCURETRIGII_PAGE ) && !isinv && !HYPmode && ( keypress == ' ' ) ) { /* tanc    */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = tanc   (PUTINRAD(GETX)); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }

        // Inverse trig functions

        else if ( ( gridvert == 1 ) && ( gridhoriz == 3 ) && ( page == MYCALCSF_PAGE      ) &&  isinv && !HYPmode && !isah && ( keypress == ' ' ) ) { /* asin     */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = PUTINDRG(asin    (GETX)); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 4 ) && ( page == MYCALCSF_PAGE      ) &&  isinv && !HYPmode && !isah && ( keypress == ' ' ) ) { /* acos     */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = PUTINDRG(acos    (GETX)); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 3 ) && ( page == MYCALCSF_PAGE      ) &&  isinv && !HYPmode &&  isah && ( keypress == ' ' ) ) { /* Asin     */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = PUTINDRG(Asin    (GETX)); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 4 ) && ( page == MYCALCSF_PAGE      ) &&  isinv && !HYPmode &&  isah && ( keypress == ' ' ) ) { /* Acos     */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = PUTINDRG(Acos    (GETX)); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 5 ) && ( page == MYCALCSF_PAGE      ) &&  isinv && !HYPmode &&          ( keypress == ' ' ) ) { /* atan     */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = PUTINDRG(atan    (GETX)); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == OBSCURETRIGI__PAGE ) &&  isinv && !HYPmode && !isah && ( keypress == ' ' ) ) { /* acosec   */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = PUTINDRG(acosec  (GETX)); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == OBSCURETRIGI__PAGE ) &&  isinv && !HYPmode && !isah && ( keypress == ' ' ) ) { /* asec     */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = PUTINDRG(asec    (GETX)); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == OBSCURETRIGI__PAGE ) &&  isinv && !HYPmode &&  isah && ( keypress == ' ' ) ) { /* Acosec   */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = PUTINDRG(Acosec  (GETX)); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == OBSCURETRIGI__PAGE ) &&  isinv && !HYPmode &&  isah && ( keypress == ' ' ) ) { /* Asec     */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = PUTINDRG(Asec    (GETX)); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == OBSCURETRIGI__PAGE ) &&  isinv && !HYPmode &&          ( keypress == ' ' ) ) { /* acot     */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = PUTINDRG(acot    (GETX)); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 3 ) && ( page == OBSCURETRIGI__PAGE ) &&  isinv && !HYPmode && !isah && ( keypress == ' ' ) ) { /* avers    */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = PUTINDRG(avers   (GETX)); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 4 ) && ( page == OBSCURETRIGI__PAGE ) &&  isinv && !HYPmode && !isah && ( keypress == ' ' ) ) { /* acovers  */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = PUTINDRG(acovers (GETX)); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 5 ) && ( page == OBSCURETRIGI__PAGE ) &&  isinv && !HYPmode && !isah && ( keypress == ' ' ) ) { /* ahav     */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = PUTINDRG(ahav    (GETX)); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == OBSCURETRIGII_PAGE ) &&  isinv && !HYPmode && !isah && ( keypress == ' ' ) ) { /* aexsec   */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = PUTINDRG(aexsec  (GETX)); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == OBSCURETRIGII_PAGE ) &&  isinv && !HYPmode && !isah && ( keypress == ' ' ) ) { /* aexcosec */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = PUTINDRG(aexcosec(GETX)); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == OBSCURETRIGII_PAGE ) &&  isinv && !HYPmode && !isah && ( keypress == ' ' ) ) { /* acas     */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = PUTINDRG(acastrg (GETX)); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 5 ) && ( page == OBSCURETRIGII_PAGE ) &&  isinv && !HYPmode && !isah && ( keypress == ' ' ) ) { /* acasc    */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = PUTINDRG(acasctrg(GETX)); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 3 ) && ( page == OBSCURETRIGI__PAGE ) &&  isinv && !HYPmode &&  isah && ( keypress == ' ' ) ) { /* Avers    */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = PUTINDRG(Avers   (GETX)); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 4 ) && ( page == OBSCURETRIGI__PAGE ) &&  isinv && !HYPmode &&  isah && ( keypress == ' ' ) ) { /* Acovers  */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = PUTINDRG(Acovers (GETX)); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 5 ) && ( page == OBSCURETRIGI__PAGE ) &&  isinv && !HYPmode &&  isah && ( keypress == ' ' ) ) { /* Ahav     */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = PUTINDRG(Ahav    (GETX)); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == OBSCURETRIGII_PAGE ) &&  isinv && !HYPmode &&  isah && ( keypress == ' ' ) ) { /* Aexsec   */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = PUTINDRG(Aexsec  (GETX)); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == OBSCURETRIGII_PAGE ) &&  isinv && !HYPmode &&  isah && ( keypress == ' ' ) ) { /* Aexcosec */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = PUTINDRG(Aexcosec(GETX)); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == OBSCURETRIGII_PAGE ) &&  isinv && !HYPmode &&  isah && ( keypress == ' ' ) ) { /* Acas     */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = PUTINDRG(Acastrg (GETX)); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 5 ) && ( page == OBSCURETRIGII_PAGE ) &&  isinv && !HYPmode &&  isah && ( keypress == ' ' ) ) { /* Acasc    */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = PUTINDRG(Acasctrg(GETX)); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 4 ) && ( page == OBSCURETRIGII_PAGE ) &&  isinv &&  HYPmode && !isah && ( keypress == ' ' ) ) { /* agd      */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = agd(PUTINRAD     (GETX)); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 4 ) && ( page == OBSCURETRIGII_PAGE ) &&  isinv &&  HYPmode &&  isah && ( keypress == ' ' ) ) { /* Agd      */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = Agd(PUTINRAD     (GETX)); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }

        // Hyperbolic functions

        else if ( ( gridvert == 1 ) && ( gridhoriz == 3 ) && ( page == MYCALCSF_PAGE      ) && !isinv &&  HYPmode && ( keypress == ' ' ) ) { /* sinh     */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = sinh    (GETX); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 4 ) && ( page == MYCALCSF_PAGE      ) && !isinv &&  HYPmode && ( keypress == ' ' ) ) { /* cosh     */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = cosh    (GETX); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 5 ) && ( page == MYCALCSF_PAGE      ) && !isinv &&  HYPmode && ( keypress == ' ' ) ) { /* tanh     */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = tanh    (GETX); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == OBSCURETRIGI__PAGE ) && !isinv &&  HYPmode && ( keypress == ' ' ) ) { /* cosech   */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = cosech  (GETX); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == OBSCURETRIGI__PAGE ) && !isinv &&  HYPmode && ( keypress == ' ' ) ) { /* sech     */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = sech    (GETX); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == OBSCURETRIGI__PAGE ) && !isinv &&  HYPmode && ( keypress == ' ' ) ) { /* coth     */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = coth    (GETX); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 3 ) && ( page == OBSCURETRIGI__PAGE ) && !isinv &&  HYPmode && ( keypress == ' ' ) ) { /* versh    */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = versh   (GETX); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 4 ) && ( page == OBSCURETRIGI__PAGE ) && !isinv &&  HYPmode && ( keypress == ' ' ) ) { /* coversh  */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = coversh (GETX); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 5 ) && ( page == OBSCURETRIGI__PAGE ) && !isinv &&  HYPmode && ( keypress == ' ' ) ) { /* havh     */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = havh    (GETX); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == OBSCURETRIGII_PAGE ) && !isinv &&  HYPmode && ( keypress == ' ' ) ) { /* exsech   */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = exsech  (GETX); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == OBSCURETRIGII_PAGE ) && !isinv &&  HYPmode && ( keypress == ' ' ) ) { /* excosech */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = excosech(GETX); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == OBSCURETRIGII_PAGE ) && !isinv &&  HYPmode && ( keypress == ' ' ) ) { /* cash     */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = cashyp  (GETX); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 5 ) && ( page == OBSCURETRIGII_PAGE ) && !isinv &&  HYPmode && ( keypress == ' ' ) ) { /* casch    */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = caschyp (GETX); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 3 ) && ( page == OBSCURETRIGII_PAGE ) && !isinv &&  HYPmode && ( keypress == ' ' ) ) { /* sinhc    */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = sinhc   (GETX); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 3 ) && ( page == OBSCURETRIGII_PAGE ) &&  isinv &&  HYPmode && ( keypress == ' ' ) ) { /* coshc    */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = coshc   (GETX); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 4 ) && ( page == OBSCURETRIGII_PAGE ) && !isinv &&  HYPmode && ( keypress == ' ' ) ) { /* tanhc    */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = tanhc   (GETX); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }

        // Inverse hyperbolic functions
        // NOTE: have to break else-if sequence because studio c++ "blocks nested too deeply"

             if ( refresh ) { ; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 3 ) && ( page == MYCALCSF_PAGE      ) &&  isinv &&  HYPmode &&          ( keypress == ' ' ) ) { /* asinh     */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = asinh    (GETX); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 4 ) && ( page == MYCALCSF_PAGE      ) &&  isinv &&  HYPmode && !isah && ( keypress == ' ' ) ) { /* acosh     */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = acosh    (GETX); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 5 ) && ( page == MYCALCSF_PAGE      ) &&  isinv &&  HYPmode && !isah && ( keypress == ' ' ) ) { /* atanh     */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = atanh    (GETX); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 4 ) && ( page == MYCALCSF_PAGE      ) &&  isinv &&  HYPmode &&  isah && ( keypress == ' ' ) ) { /* Acosh     */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = Acosh    (GETX); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 5 ) && ( page == MYCALCSF_PAGE      ) &&  isinv &&  HYPmode &&  isah && ( keypress == ' ' ) ) { /* Atanh     */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = Atanh    (GETX); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == OBSCURETRIGI__PAGE ) &&  isinv &&  HYPmode &&          ( keypress == ' ' ) ) { /* acosech   */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = acosech  (GETX); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == OBSCURETRIGI__PAGE ) &&  isinv &&  HYPmode && !isah && ( keypress == ' ' ) ) { /* asech     */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = asech    (GETX); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == OBSCURETRIGI__PAGE ) &&  isinv &&  HYPmode && !isah && ( keypress == ' ' ) ) { /* acoth     */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = acoth    (GETX); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 3 ) && ( page == OBSCURETRIGI__PAGE ) &&  isinv &&  HYPmode && !isah && ( keypress == ' ' ) ) { /* aversh    */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = aversh   (GETX); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == OBSCURETRIGI__PAGE ) &&  isinv &&  HYPmode &&  isah && ( keypress == ' ' ) ) { /* Asech     */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = Asech    (GETX); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == OBSCURETRIGI__PAGE ) &&  isinv &&  HYPmode &&  isah && ( keypress == ' ' ) ) { /* Acoth     */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = Acoth    (GETX); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 3 ) && ( page == OBSCURETRIGI__PAGE ) &&  isinv &&  HYPmode &&  isah && ( keypress == ' ' ) ) { /* Aversh    */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = Aversh   (GETX); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 4 ) && ( page == OBSCURETRIGI__PAGE ) &&  isinv &&  HYPmode &&          ( keypress == ' ' ) ) { /* acovrsh   */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = acovrsh  (GETX); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 5 ) && ( page == OBSCURETRIGI__PAGE ) &&  isinv &&  HYPmode && !isah && ( keypress == ' ' ) ) { /* ahavh     */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = ahavh    (GETX); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == OBSCURETRIGII_PAGE ) &&  isinv &&  HYPmode && !isah && ( keypress == ' ' ) ) { /* aexsech   */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = aexsech  (GETX); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 5 ) && ( page == OBSCURETRIGI__PAGE ) &&  isinv &&  HYPmode &&  isah && ( keypress == ' ' ) ) { /* Ahavh     */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = Ahavh    (GETX); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == OBSCURETRIGII_PAGE ) &&  isinv &&  HYPmode &&  isah && ( keypress == ' ' ) ) { /* Aexsech   */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = Aexsech  (GETX); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == OBSCURETRIGII_PAGE ) &&  isinv &&  HYPmode &&          ( keypress == ' ' ) ) { /* aexcosech */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = aexcosech(GETX); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == OBSCURETRIGII_PAGE ) &&  isinv &&  HYPmode && !isah && ( keypress == ' ' ) ) { /* acash     */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = acashyp  (GETX); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 5 ) && ( page == OBSCURETRIGII_PAGE ) &&  isinv &&  HYPmode && !isah && ( keypress == ' ' ) ) { /* acasch    */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = acaschyp (GETX); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == OBSCURETRIGII_PAGE ) &&  isinv &&  HYPmode &&  isah && ( keypress == ' ' ) ) { /* Acash     */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = Acashyp  (GETX); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 5 ) && ( page == OBSCURETRIGII_PAGE ) &&  isinv &&  HYPmode &&  isah && ( keypress == ' ' ) ) { /* Acasch    */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = Acaschyp (GETX); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }

        // Complex functions

        else if ( ( gridvert == 1 ) && ( gridhoriz == 2 ) && ( page == ABSANGARG_PAGE ) && !isinv &&          ( keypress == ' ' ) ) { /* Re      */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = real  (GETX); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 2 ) && ( page == ABSANGARG_PAGE ) &&  isinv &&          ( keypress == ' ' ) ) { /* Im      */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = imag  (GETX); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == ABSANGARG_PAGE ) && !isinv &&          ( keypress == ' ' ) ) { /* arg     */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = arg   (GETX); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == ABSANGARG_PAGE ) &&  isinv && !isew && ( keypress == ' ' ) ) { /* angle   */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = angle (GETX); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 2 ) && ( page == ABSANGARG_PAGE ) && !isinv && !isew && ( keypress == ' ' ) ) { /* abs0    */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = abs0  (GETX); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 2 ) && ( page == ABSANGARG_PAGE ) &&  isinv && !isew && ( keypress == ' ' ) ) { /* abs1    */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = abs1  (GETX); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == ABSANGARG_PAGE ) && !isinv && !isew && ( keypress == ' ' ) ) { /* abs2    */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = abs2  (GETX); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == ABSANGARG_PAGE ) && !isinv && !isew && ( keypress == ' ' ) ) { /* absinf  */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = absinf(GETX); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == ABSANGARG_PAGE ) &&  isinv &&  isew && ( keypress == ' ' ) ) { /* eangle  */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = eangle (GETX); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 2 ) && ( page == ABSANGARG_PAGE ) && !isinv &&  isew && ( keypress == ' ' ) ) { /* eabs0   */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = eabs0  (GETX); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 2 ) && ( page == ABSANGARG_PAGE ) &&  isinv &&  isew && ( keypress == ' ' ) ) { /* eabs1   */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = eabs1  (GETX); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == ABSANGARG_PAGE ) && !isinv &&  isew && ( keypress == ' ' ) ) { /* eabs2   */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = eabs2  (GETX); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == ABSANGARG_PAGE ) && !isinv &&  isew && ( keypress == ' ' ) ) { /* eabsinf */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = eabsinf(GETX); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }

        // Integer stuff

        else if ( ( gridvert == 1 ) && ( gridhoriz == 3 ) && ( page == ABSANGARG_PAGE ) && !isinv && ( keypress == ' ' ) ) { /* rint  */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = rint (GETX); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 4 ) && ( page == ABSANGARG_PAGE ) && !isinv && ( keypress == ' ' ) ) { /* floor */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = floor(GETX); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 4 ) && ( page == ABSANGARG_PAGE ) &&  isinv && ( keypress == ' ' ) ) { /* ceil  */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = ceil (GETX); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }

        // Matrix operations

        else if ( ( gridvert == 1 ) && ( gridhoriz == 2 ) && ( page == ADVANCEDSFI_PAGE ) && !isinv && ( keypress == ' ' ) ) { /* det   */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = det  (GETX); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 2 ) && ( page == ADVANCEDSFI_PAGE ) &&  isinv && ( keypress == ' ' ) ) { /* trace */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = trace(GETX); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }

        // Distributions

        else if ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == ODDITIES_PAGE ) && !isinv && ( keypress == ' ' ) ) { /* normDistr */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = normDistr(GETX); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }

        // Derivatives

        else if ( ( gridvert == 0 ) && ( gridhoriz == 2 ) && ( page == VARDERIV_PAGE ) &&  isinv && ( keypress == ' ' ) ) { /* d/dx */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX.realDeriv(0,0); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == VARDERIV_PAGE ) &&  isinv && ( keypress == ' ' ) ) { /* d/dy */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX.realDeriv(0,1); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == VARDERIV_PAGE ) &&  isinv && ( keypress == ' ' ) ) { /* d/dz */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX.realDeriv(0,2); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == VARDERIV_PAGE ) &&  isinv && ( keypress == ' ' ) ) { /* d/dv */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX.realDeriv(0,3); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 2 ) && ( page == VARDERIV_PAGE ) &&  isinv && ( keypress == ' ' ) ) { /* d/dw */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX.realDeriv(0,5); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 3 ) && ( page == VARDERIV_PAGE ) &&  isinv && ( keypress == ' ' ) ) { /* d/dg */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX.realDeriv(0,5); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 4 ) && ( page == VARDERIV_PAGE ) &&  isinv && ( keypress == ' ' ) ) { /* d/dh */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX.realDeriv(42,42); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 5 ) && ( page == VARDERIV_PAGE ) &&  isinv && ( keypress == ' ' ) ) { /* d/du */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX.realDeriv(1,1); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }

        // Misc operations
        // NOTE: have to break else-if sequence because studio c++ "blocks nested too deeply"

             if ( refresh ) { ; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 1 ) &&                                              !isinv && !isah &&          ( keypress == ' ' ) ) { /* sqrt       */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = sqrt      (GETX);      isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 0 ) &&                                               isinv && !isah &&          ( keypress == ' ' ) ) { /* cbrt       */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = cbrt      (GETX);      isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 1 ) &&                                              !isinv &&  isah &&          ( keypress == ' ' ) ) { /* Sqrt       */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = Sqrt      (GETX);      isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 0 ) &&                                               isinv &&  isah &&          ( keypress == ' ' ) ) { /* Cbrt       */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = Cbrt      (GETX);      isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 1 ) &&                                               isinv &&                   ( keypress == ' ' ) ) { /* x^2        */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = mul       (GETX,GETX); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 2 ) && ( gridhoriz == 0 ) &&                                   !SDmode &&  isinv &&                   ( keypress == ' ' ) ) { /* x!         */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = fact      (GETX);      isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 2 ) && ( page == COMBMAXMIN_PAGE    ) &&            !isinv &&                   ( keypress == ' ' ) ) { /* fact       */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = fact      (GETX);      isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == ABSANGARG_PAGE     ) &&             isinv &&                   ( keypress == ' ' ) ) { /* sgn        */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = sgn       (GETX);      isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == ADVANCEDSFI_PAGE   ) &&            !isinv &&                   ( keypress == ' ' ) ) { /* erf        */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = erf       (GETX);      isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == ADVANCEDSFI_PAGE   ) &&             isinv &&                   ( keypress == ' ' ) ) { /* erfc       */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = erfc      (GETX);      isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 2 ) && ( page == ADVANCEDSFI_PAGE   ) &&            !isinv &&                   ( keypress == ' ' ) ) { /* sigm       */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = sigm      (GETX);      isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 2 ) && ( page == ADVANCEDSFI_PAGE   ) &&             isinv && !isah &&          ( keypress == ' ' ) ) { /* asigm      */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = asigm     (GETX);      isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 2 ) && ( page == ADVANCEDSFI_PAGE   ) &&             isinv &&  isah &&          ( keypress == ' ' ) ) { /* Asigm      */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = Asigm     (GETX);      isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == ADVANCEDSFI_PAGE   ) &&            !isinv &&                   ( keypress == ' ' ) ) { /* lambertW   */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = lambertW  (GETX);      isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == ADVANCEDSFI_PAGE   ) &&             isinv &&                   ( keypress == ' ' ) ) { /* lambertWx  */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = lambertWx (GETX);      isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == ADVANCEDSFI_PAGE   ) &&            !isinv &&                   ( keypress == ' ' ) ) { /* gamma      */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = gamma     (GETX);      isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == ADVANCEDSFI_PAGE   ) &&             isinv &&                   ( keypress == ' ' ) ) { /* lngamma    */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = lngamma   (GETX);      isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 3 ) && ( page == ADVANCEDSFI_PAGE   ) &&            !isinv &&                   ( keypress == ' ' ) ) { /* psi        */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = psi       (GETX);      isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 4 ) && ( page == ADVANCEDSFI_PAGE   ) &&            !isinv &&                   ( keypress == ' ' ) ) { /* dawson     */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = dawson    (GETX);      isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 4 ) && ( page == ADVANCEDSFI_PAGE   ) &&             isinv &&                   ( keypress == ' ' ) ) { /* zeta       */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = zeta      (GETX);      isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == COMBMAXMIN_PAGE    ) &&             isinv &&          !isew && ( keypress == ' ' ) ) { /* diracDelta */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = diracDelta(GETX);      isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == COMBMAXMIN_PAGE    ) &&             isinv &&           isew && ( keypress == ' ' ) ) { /* ediracDelta*/ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = ediracDelta(GETX);      isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 3 ) && ( page == COMBMAXMIN_PAGE    ) &&            !isinv &&                   ( keypress == ' ' ) ) { /* sf         */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = sf        (GETX);      isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 3 ) && ( page == COMBMAXMIN_PAGE    ) &&             isinv &&                   ( keypress == ' ' ) ) { /* psf        */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = psf       (GETX);      isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 2 ) && ( page == COMBMAXMIN_PAGE    ) &&             isinv &&                   ( keypress == ' ' ) ) { /* dfact      */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = dfact     (GETX);      isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == COMBMAXMIN_PAGE    ) &&            !isinv &&                   ( keypress == ' ' ) ) { /* tfact      */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = tfact     (GETX);      isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == COMBMAXMIN_PAGE    ) &&             isinv &&                   ( keypress == ' ' ) ) { /* subfact    */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = subfact   (GETX);      isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 4 ) && ( page == COMBMAXMIN_PAGE    ) &&            !isinv &&                   ( keypress == ' ' ) ) { /* argmax     */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = argmax    (GETX);      isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 4 ) && ( page == COMBMAXMIN_PAGE    ) &&             isinv &&                   ( keypress == ' ' ) ) { /* argmin     */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = argmin    (GETX);      isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 5 ) && ( page == COMBMAXMIN_PAGE    ) &&            !isinv &&                   ( keypress == ' ' ) ) { /* max        */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = max       (GETX);      isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 5 ) && ( page == COMBMAXMIN_PAGE    ) &&             isinv &&                   ( keypress == ' ' ) ) { /* min        */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = min       (GETX);      isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 2 ) && ( page == ODDITIES_PAGE      ) &&            !isinv &&                   ( keypress == ' ' ) ) { /* sum        */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = sum       (GETX);      isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 2 ) && ( page == ODDITIES_PAGE      ) &&             isinv && !isah          && ( keypress == ' ' ) ) { /* prod       */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = prod      (GETX);      isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 2 ) && ( page == ODDITIES_PAGE      ) &&             isinv &&  isah          && ( keypress == ' ' ) ) { /* Prod       */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = Prod      (GETX);      isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 4 ) && ( page == ODDITIES_PAGE      ) &&            !isinv &&                   ( keypress == ' ' ) ) { /* mean       */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = mean      (GETX);      isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 4 ) && ( page == ODDITIES_PAGE      ) &&             isinv &&                   ( keypress == ' ' ) ) { /* median     */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = median    (GETX);      isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 5 ) && ( page == ODDITIES_PAGE      ) &&            !isinv &&                   ( keypress == ' ' ) ) { /* argmedian  */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = argmedian (GETX);      isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }

        // Test functions

        else if ( ( gridvert == 0 ) && ( gridhoriz == 2 ) && ( page == TESTFUNCI___PAGE ) && !isinv && ( keypress == ' ' ) ) { /* Rastringin    */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; iii = 1;  GETX = testfn    (iii,GETX);                 isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 2 ) && ( page == TESTFUNCI___PAGE ) &&  isinv && ( keypress == ' ' ) ) { /* Ackley        */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; iii = 2;  GETX = testfn    (iii,GETX);                 isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == TESTFUNCI___PAGE ) && !isinv && ( keypress == ' ' ) ) { /* Sphere        */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; iii = 3;  GETX = testfn    (iii,GETX);                 isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == TESTFUNCI___PAGE ) &&  isinv && ( keypress == ' ' ) ) { /* Rosenbrock    */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; iii = 4;  GETX = testfn    (iii,GETX);                 isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == TESTFUNCI___PAGE ) && !isinv && ( keypress == ' ' ) ) { /* Beale         */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; iii = 5;  GETX = testfn    (iii,GETX);                 isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == TESTFUNCI___PAGE ) &&  isinv && ( keypress == ' ' ) ) { /* Goldstein-P   */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; iii = 6;  GETX = testfn    (iii,GETX);                 isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == TESTFUNCI___PAGE ) && !isinv && ( keypress == ' ' ) ) { /* Booth         */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; iii = 7;  GETX = testfn    (iii,GETX);                 isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == TESTFUNCI___PAGE ) &&  isinv && ( keypress == ' ' ) ) { /* Bukin         */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; iii = 8;  GETX = testfn    (iii,GETX);                 isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 1 ) && ( page == TESTFUNCI___PAGE ) && !isinv && ( keypress == ' ' ) ) { /* Matyas        */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; iii = 9;  GETX = testfn    (iii,GETX);                 isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 1 ) && ( page == TESTFUNCI___PAGE ) &&  isinv && ( keypress == ' ' ) ) { /* Levi          */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; iii = 10; GETX = testfn    (iii,GETX);                 isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 2 ) && ( page == TESTFUNCI___PAGE ) && !isinv && ( keypress == ' ' ) ) { /* Himmelblau    */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; iii = 11; GETX = testfn    (iii,GETX);                 isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 2 ) && ( page == TESTFUNCI___PAGE ) &&  isinv && ( keypress == ' ' ) ) { /* 3-hump-camel  */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; iii = 12; GETX = testfn    (iii,GETX);                 isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 3 ) && ( page == TESTFUNCI___PAGE ) && !isinv && ( keypress == ' ' ) ) { /* Easom         */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; iii = 13; GETX = testfn    (iii,GETX);                 isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 3 ) && ( page == TESTFUNCI___PAGE ) &&  isinv && ( keypress == ' ' ) ) { /* Cross-in-tray */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; iii = 14; GETX = testfn    (iii,GETX);                 isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 4 ) && ( page == TESTFUNCI___PAGE ) && !isinv && ( keypress == ' ' ) ) { /* Eggholder     */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; iii = 15; GETX = testfn    (iii,GETX);                 isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 4 ) && ( page == TESTFUNCI___PAGE ) &&  isinv && ( keypress == ' ' ) ) { /* Holder-table  */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; iii = 16; GETX = testfn    (iii,GETX);                 isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 5 ) && ( page == TESTFUNCI___PAGE ) && !isinv && ( keypress == ' ' ) ) { /* McCormick     */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; iii = 17; GETX = testfn    (iii,GETX);                 isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 5 ) && ( page == TESTFUNCI___PAGE ) &&  isinv && ( keypress == ' ' ) ) { /* Schaffer-#2   */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; iii = 18; GETX = testfn    (iii,GETX);                 isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }


        else if ( ( gridvert == 0 ) && ( gridhoriz == 2 ) && ( page == TESTFUNCI___PAGE ) && !isinv && ( keypress == ' ' ) ) { /* Rastringin    */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; iii = 1;  GETX = testfn    (iii,GETX);                 isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 2 ) && ( page == TESTFUNCI___PAGE ) &&  isinv && ( keypress == ' ' ) ) { /* Ackley        */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; iii = 2;  GETX = testfn    (iii,GETX);                 isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == TESTFUNCI___PAGE ) && !isinv && ( keypress == ' ' ) ) { /* Sphere        */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; iii = 3;  GETX = testfn    (iii,GETX);                 isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == TESTFUNCI___PAGE ) &&  isinv && ( keypress == ' ' ) ) { /* Rosenbrock    */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; iii = 4;  GETX = testfn    (iii,GETX);                 isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == TESTFUNCI___PAGE ) && !isinv && ( keypress == ' ' ) ) { /* Beale         */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; iii = 5;  GETX = testfn    (iii,GETX);                 isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == TESTFUNCI___PAGE ) &&  isinv && ( keypress == ' ' ) ) { /* Goldstein-P   */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; iii = 6;  GETX = testfn    (iii,GETX);                 isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == TESTFUNCI___PAGE ) && !isinv && ( keypress == ' ' ) ) { /* Booth         */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; iii = 7;  GETX = testfn    (iii,GETX);                 isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == TESTFUNCI___PAGE ) &&  isinv && ( keypress == ' ' ) ) { /* Bukin         */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; iii = 8;  GETX = testfn    (iii,GETX);                 isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 2 ) && ( page == TESTFUNCI___PAGE ) && !isinv && ( keypress == ' ' ) ) { /* Himmelblau    */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; iii = 11; GETX = testfn    (iii,GETX);                 isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 2 ) && ( page == TESTFUNCI___PAGE ) &&  isinv && ( keypress == ' ' ) ) { /* 3-hump-camel  */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; iii = 12; GETX = testfn    (iii,GETX);                 isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 3 ) && ( page == TESTFUNCI___PAGE ) && !isinv && ( keypress == ' ' ) ) { /* Easom         */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; iii = 13; GETX = testfn    (iii,GETX);                 isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 3 ) && ( page == TESTFUNCI___PAGE ) &&  isinv && ( keypress == ' ' ) ) { /* Cross-in-tray */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; iii = 14; GETX = testfn    (iii,GETX);                 isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 4 ) && ( page == TESTFUNCI___PAGE ) && !isinv && ( keypress == ' ' ) ) { /* Eggholder     */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; iii = 15; GETX = testfn    (iii,GETX);                 isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 4 ) && ( page == TESTFUNCI___PAGE ) &&  isinv && ( keypress == ' ' ) ) { /* Holder-table  */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; iii = 16; GETX = testfn    (iii,GETX);                 isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 5 ) && ( page == TESTFUNCI___PAGE ) && !isinv && ( keypress == ' ' ) ) { /* McCormick     */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; iii = 17; GETX = testfn    (iii,GETX);                 isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 5 ) && ( page == TESTFUNCI___PAGE ) &&  isinv && ( keypress == ' ' ) ) { /* Schaffer-#2   */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; iii = 18; GETX = testfn    (iii,GETX);                 isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 2 ) && ( page == TESTFUNCII__PAGE ) && !isinv && ( keypress == ' ' ) ) { /* Drop-Wave     */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; iii = 24; GETX = testfn    (iii,GETX);                 isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == TESTFUNCII__PAGE ) && !isinv && ( keypress == ' ' ) ) { /* Gramancy+Lee  */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; iii = 25; GETX = testfn    (iii,GETX);                 isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == TESTFUNCII__PAGE ) && !isinv && ( keypress == ' ' ) ) { /* Langermann    */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; iii = 26; GETX = testfn    (iii,GETX);                 isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == TESTFUNCII__PAGE ) && !isinv && ( keypress == ' ' ) ) { /* Griewank      */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; iii = 27; GETX = testfn    (iii,GETX);                 isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 2 ) && ( page == TESTFUNCII__PAGE ) && !isinv && ( keypress == ' ' ) ) { /* Levy          */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; iii = 28; GETX = testfn    (iii,GETX);                 isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 3 ) && ( page == TESTFUNCII__PAGE ) && !isinv && ( keypress == ' ' ) ) { /* Schwefel      */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; iii = 29; GETX = testfn    (iii,GETX);                 isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 4 ) && ( page == TESTFUNCII__PAGE ) && !isinv && ( keypress == ' ' ) ) { /* Shubert       */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; iii = 30; GETX = testfn    (iii,GETX);                 isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 5 ) && ( page == TESTFUNCII__PAGE ) && !isinv && ( keypress == ' ' ) ) { /* Matyas        */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; iii = 9;  GETX = testfn    (iii,GETX);                 isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 2 ) && ( page == TESTFUNCII__PAGE ) &&  isinv && ( keypress == ' ' ) ) { /* Bohachevsky 1 */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; iii = 31; GETX = testfn    (iii,GETX);                 isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == TESTFUNCII__PAGE ) &&  isinv && ( keypress == ' ' ) ) { /* Bohachevsky 2 */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; iii = 32; GETX = testfn    (iii,GETX);                 isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == TESTFUNCII__PAGE ) &&  isinv && ( keypress == ' ' ) ) { /* Bohachevsky 3 */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; iii = 33; GETX = testfn    (iii,GETX);                 isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == TESTFUNCII__PAGE ) &&  isinv && ( keypress == ' ' ) ) { /* Perm. 0,d,1   */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; iii = 34; GETX = testfn    (iii,GETX);                 isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 5 ) && ( page == TESTFUNCII__PAGE ) &&  isinv && ( keypress == ' ' ) ) { /* Levi          */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; iii = 10; GETX = testfn    (iii,GETX);                 isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 2 ) && ( page == TESTFUNCIII_PAGE ) && !isinv && ( keypress == ' ' ) ) { /* Schaffer-#4   */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; iii = 19; GETX = testfn    (iii,GETX);                 isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 2 ) && ( page == TESTFUNCIII_PAGE ) &&  isinv && ( keypress == ' ' ) ) { /* Stablinski-Ta */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; iii = 20; GETX = testfn    (iii,GETX);                 isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == TESTFUNCIII_PAGE ) && !isinv && ( keypress == ' ' ) ) { /* Stability-1   */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; iii = 21; GETX = testfn    (iii,GETX);                 isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == TESTFUNCIII_PAGE ) &&  isinv && ( keypress == ' ' ) ) { /* Stability-2   */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; iii = 22; GETX = testfn    (iii,GETX);                 isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == TESTFUNCIII_PAGE ) && !isinv && ( keypress == ' ' ) ) { /* DLTZ9         */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; iii = 9;  GETX = partestfn (iii,testM,GETX);           isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == TESTFUNCIII_PAGE ) &&  isinv && ( keypress == ' ' ) ) { /* FON1          */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; iii = 10; GETX = partestfn (iii,testM,GETX);           isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 2 ) && ( page == TESTFUNCIII_PAGE ) && !isinv && ( keypress == ' ' ) ) { /* DLTZ1         */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; iii = 1;  GETX = partestfn (iii,testM,GETX);           isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 2 ) && ( page == TESTFUNCIII_PAGE ) &&  isinv && ( keypress == ' ' ) ) { /* DLTZ2         */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; iii = 2;  GETX = partestfn (iii,testM,GETX);           isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 3 ) && ( page == TESTFUNCIII_PAGE ) && !isinv && ( keypress == ' ' ) ) { /* DLTZ3         */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; iii = 3;  GETX = partestfn (iii,testM,GETX);           isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 4 ) && ( page == TESTFUNCIII_PAGE ) && !isinv && ( keypress == ' ' ) ) { /* DLTZ5         */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; iii = 5;  GETX = partestfn (iii,testM,GETX);           isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 4 ) && ( page == TESTFUNCIII_PAGE ) &&  isinv && ( keypress == ' ' ) ) { /* DLTZ6         */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; iii = 6;  GETX = partestfn (iii,testM,GETX);           isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 5 ) && ( page == TESTFUNCIII_PAGE ) && !isinv && ( keypress == ' ' ) ) { /* DLTZ7         */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; iii = 7;  GETX = partestfn (iii,testM,GETX);           isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 5 ) && ( page == TESTFUNCIII_PAGE ) &&  isinv && ( keypress == ' ' ) ) { /* DLTZ8         */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; iii = 8;  GETX = partestfn (iii,testM,GETX);           isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 2 ) && ( page == TESTFUNCIV__PAGE ) && !isinv && ( keypress == ' ' ) ) { /* SCH1          */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; iii = 11; GETX = partestfn (iii,testM,GETX);           isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 2 ) && ( page == TESTFUNCIV__PAGE ) &&  isinv && ( keypress == ' ' ) ) { /* SCH2          */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; iii = 12; GETX = partestfn (iii,testM,GETX);           isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }

        // Random numbers
        // NOTE: have to break else-if sequence because studio c++ "blocks nested too deeply"

             if ( refresh ) { ; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 2 ) && ( page == DISTRIBI___PAGE ) && !isinv && ( keypress == ' ' ) ) { /* Chi-squared */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = randcfill(tr);               isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == DISTRIBI___PAGE ) && !isinv && ( keypress == ' ' ) ) { /* Cauchy      */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = randCfill(tr);               isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == DISTRIBI___PAGE ) && !isinv && ( keypress == ' ' ) ) { /* Fisher-F    */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = randffill(tr);               isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == DISTRIBI___PAGE ) && !isinv && ( keypress == ' ' ) ) { /* Student-t   */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = randtfill(tr);               isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 2 ) && ( page == DISTRIBI___PAGE ) && !isinv && ( keypress == ' ' ) ) { /* Exponential */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = randEfill(tr);               isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 3 ) && ( page == DISTRIBI___PAGE ) && !isinv && ( keypress == ' ' ) ) { /* +Binomial   */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = randbfill(tr);               isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 4 ) && ( page == DISTRIBI___PAGE ) && !isinv && ( keypress == ' ' ) ) { /* -Binomial   */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = randBfill(tr);               isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 5 ) && ( page == DISTRIBI___PAGE ) && !isinv && ( keypress == ' ' ) ) { /* Geometric   */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = randgfill(tr);               isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 2 ) && ( page == DISTRIBI___PAGE ) &&  isinv && ( keypress == ' ' ) ) { /* n.randc     */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = randcfill(tr,(double) GETX); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == DISTRIBI___PAGE ) &&  isinv && ( keypress == ' ' ) ) { /* n.randt     */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = randtfill(tr,(double) GETX); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 2 ) && ( page == DISTRIBI___PAGE ) &&  isinv && ( keypress == ' ' ) ) { /* p.rande     */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = randefill(tr,(double) GETX); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 5 ) && ( page == DISTRIBI___PAGE ) &&  isinv && ( keypress == ' ' ) ) { /* p.randg     */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = randgfill(tr,(double) GETX); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 2 ) && ( page == DISTRIBII__PAGE ) && !isinv && ( keypress == ' ' ) ) { /* Log-normal  */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = randlfill(tr);               isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == DISTRIBII__PAGE ) && !isinv && ( keypress == ' ' ) ) { /* p.Bernoulli */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = randEfill(tr,(double) GETX); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == DISTRIBII__PAGE ) && !isinv && ( keypress == ' ' ) ) { /* Uniform     */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = randufill(tr);               isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == DISTRIBII__PAGE ) && !isinv && ( keypress == ' ' ) ) { /* Poisson     */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = randpfill(tr);               isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 2 ) && ( page == DISTRIBII__PAGE ) && !isinv && ( keypress == ' ' ) ) { /* Gamma       */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = randGfill(tr);               isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 3 ) && ( page == DISTRIBII__PAGE ) && !isinv && ( keypress == ' ' ) ) { /* Weibull     */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = randwfill(tr);               isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 4 ) && ( page == DISTRIBII__PAGE ) && !isinv && ( keypress == ' ' ) ) { /* Extreme-val */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = randxfill(tr);               isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 5 ) && ( page == DISTRIBII__PAGE ) && !isinv && ( keypress == ' ' ) ) { /* Normal      */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = randnfill(tr);               isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == DISTRIBII__PAGE ) &&  isinv && ( keypress == ' ' ) ) { /* irand       */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = rand();                  isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == DISTRIBII__PAGE ) &&  isinv && ( keypress == ' ' ) ) { /* m.randp     */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = randpfill(tr,(double) GETX); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 2 ) && ( page == DISTRIBIII_PAGE ) && !isinv && ( keypress == ' ' ) ) { /* Rademacher  */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = randrfill(tr);               isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 2 ) && ( page == DISTRIBIII_PAGE ) &&  isinv && ( keypress == ' ' ) ) { /* p.randr     */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = randrfill(tr,(double) GETX); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }

        // Logic functions

        else if ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == LOGIC_PAGE ) && !isinv && ( keypress == ' ' ) ) { /* lnot */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = lnot(GETX); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == LOGIC_PAGE ) &&  isinv && ( keypress == ' ' ) ) { /* lis  */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = lis (GETX); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }

        // Test functions

        else if ( ( gridvert == 0 ) && ( gridhoriz == 2 ) && ( page == FTYPE_PAGE ) && !isinv && ( keypress == ' ' ) ) { /* isnan    */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = isvnan  (GETX); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 2 ) && ( page == FTYPE_PAGE ) &&  isinv && ( keypress == ' ' ) ) { /* isinf    */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = isinf   (GETX); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == FTYPE_PAGE ) && !isinv && ( keypress == ' ' ) ) { /* ispinf   */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = ispinf  (GETX); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == FTYPE_PAGE ) &&  isinv && ( keypress == ' ' ) ) { /* isninf   */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = isninf  (GETX); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == FTYPE_PAGE ) && !isinv && ( keypress == ' ' ) ) { /* isnull   */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = isnull  (GETX); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 2 ) && ( page == FTYPE_PAGE ) && !isinv && ( keypress == ' ' ) ) { /* isint    */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = isint   (GETX); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 2 ) && ( page == FTYPE_PAGE ) &&  isinv && ( keypress == ' ' ) ) { /* isnull   */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = isnull  (GETX); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 3 ) && ( page == FTYPE_PAGE ) && !isinv && ( keypress == ' ' ) ) { /* isvector */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = isvector(GETX); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 3 ) && ( page == FTYPE_PAGE ) &&  isinv && ( keypress == ' ' ) ) { /* ismatrix */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = ismatrix(GETX); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 4 ) && ( page == FTYPE_PAGE ) && !isinv && ( keypress == ' ' ) ) { /* isreal   */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = isreal  (GETX); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 4 ) && ( page == FTYPE_PAGE ) &&  isinv && ( keypress == ' ' ) ) { /* iscomp   */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = isanion (GETX); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 5 ) && ( page == FTYPE_PAGE ) && !isinv && ( keypress == ' ' ) ) { /* isstring */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = isstring(GETX); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 1 ) && ( gridhoriz == 5 ) && ( page == FTYPE_PAGE ) &&  isinv && ( keypress == ' ' ) ) { /* iserror  */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = iserror (GETX); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == FTYPE_PAGE ) &&  isinv && ( keypress == ' ' ) ) { /* size     */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = size    (GETX); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == FTYPE_PAGE ) && !isinv && ( keypress == ' ' ) ) { /* numRows  */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = numRows (GETX); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }
        else if ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == FTYPE_PAGE ) &&  isinv && ( keypress == ' ' ) ) { /* numCols  */ calcNest.oplastkey = 0;  UPDATE_PREPRE_OP; GETX = numCols (GETX); isinv = 0; HYPmode = 0; refresh = 1; calcNest.whichdms = 0; isdmsmode = 0; }

        // Binary functions

        else if ( ( ( ( gridvert == 5 ) && ( gridhoriz == 4 ) &&                                  isinv                      ) ||   /* x RtoP y  */
                    ( ( gridvert == 5 ) && ( gridhoriz == 5 ) &&                                  isinv                      ) ||   /* x PtoR y  */
                    ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == ODDITIES_PAGE    ) &&  isinv                      ) ||   /* polyDistr */
                    ( ( gridvert == 1 ) && ( gridhoriz == 3 ) && ( page == ADVANCEDSFI_PAGE ) &&  isinv                      ) ||   /* psi       */
                    ( ( gridvert == 1 ) && ( gridhoriz == 5 ) && ( page == ADVANCEDSFI_PAGE ) && !isinv                      ) ||   /* gami      */
                    ( ( gridvert == 1 ) && ( gridhoriz == 5 ) && ( page == ADVANCEDSFI_PAGE ) &&  isinv                      ) ||   /* gamic     */
                    ( ( gridvert == 1 ) && ( gridhoriz == 5 ) && ( page == ABSANGARG_PAGE   ) && !isinv                      ) ||   /* w bern y  */
                    ( ( gridvert == 1 ) && ( gridhoriz == 5 ) && ( page == ABSANGARG_PAGE   ) &&  isinv                      ) ||   /* x outer y */
                    ( ( gridvert == 1 ) && ( gridhoriz == 2 ) && ( page == COMBMAXMIN_PAGE  ) && !isinv                      ) ||   /* nPr       */
                    ( ( gridvert == 1 ) && ( gridhoriz == 2 ) && ( page == COMBMAXMIN_PAGE  ) &&  isinv                      ) ||   /* nCr       */
                    ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == COMBMAXMIN_PAGE  ) && !isinv             && !isew ) ||   /* KronDelta */
                    ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == COMBMAXMIN_PAGE  ) && !isinv             &&  isew ) ||   /* eKronDelta*/
                    ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == COMBMAXMIN_PAGE  ) && !isinv                      ) ||   /* multifact */
                    ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == ODDITIES_PAGE    ) &&  isinv                      ) ||   /* I_(n,m)   */
                    ( ( gridvert == 0 ) && ( gridhoriz == 2 ) && ( page == VARSET_PAGE      ) && !isinv                      ) ||   /* x=        */
                    ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == VARSET_PAGE      ) && !isinv                      ) ||   /* y=        */
                    ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == VARSET_PAGE      ) && !isinv                      ) ||   /* z=        */
                    ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == VARSET_PAGE      ) && !isinv                      ) ||   /* v=        */
                    ( ( gridvert == 1 ) && ( gridhoriz == 2 ) && ( page == VARSET_PAGE      ) && !isinv                      ) ||   /* w=        */
                    ( ( gridvert == 1 ) && ( gridhoriz == 3 ) && ( page == VARSET_PAGE      ) && !isinv                      ) ||   /* g=        */
                    ( ( gridvert == 1 ) && ( gridhoriz == 4 ) && ( page == VARSET_PAGE      ) && !isinv                      ) ||   /* h=        */
                    ( ( gridvert == 1 ) && ( gridhoriz == 5 ) && ( page == VARSET_PAGE      ) && !isinv                      ) ||   /* u=        */
                    ( ( gridvert == 0 ) && ( gridhoriz == 2 ) && ( page == DISTRIBII__PAGE  ) &&  isinv                      ) ||   /* m.randl.s */
                    ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == DISTRIBII__PAGE  ) &&  isinv                      ) ||   /* a.randu.b */
                    ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == DISTRIBI___PAGE  ) &&  isinv                      ) ||   /* a.randC.b */
                    ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == DISTRIBI___PAGE  ) &&  isinv                      ) ||   /* m.randf.n */
                    ( ( gridvert == 1 ) && ( gridhoriz == 3 ) && ( page == DISTRIBI___PAGE  ) &&  isinv                      ) ||   /* t.randb.p */
                    ( ( gridvert == 1 ) && ( gridhoriz == 4 ) && ( page == DISTRIBI___PAGE  ) &&  isinv                      ) ||   /* k.randB.p */
                    ( ( gridvert == 1 ) && ( gridhoriz == 2 ) && ( page == DISTRIBII__PAGE  ) &&  isinv                      ) ||   /* a.randG.p */
                    ( ( gridvert == 1 ) && ( gridhoriz == 3 ) && ( page == DISTRIBII__PAGE  ) &&  isinv                      ) ||   /* a.randw.b */
                    ( ( gridvert == 1 ) && ( gridhoriz == 4 ) && ( page == DISTRIBII__PAGE  ) &&  isinv                      ) ||   /* a.randx.b */
                    ( ( gridvert == 1 ) && ( gridhoriz == 5 ) && ( page == DISTRIBII__PAGE  ) &&  isinv                      ) ||   /* a.randn.s */
                    ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == ABSANGARG_PAGE   ) &&  isinv             && !isew ) ||   /* a.absp.p  */
                    ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == ABSANGARG_PAGE   ) &&  isinv             &&  isew ) ||   /* a.eabsp.p */
                    ( ( gridvert == 1 ) && ( gridhoriz == 2 ) && ( page == LOGIC_PAGE       ) && !isinv                      ) ||   /* and       */
                    ( ( gridvert == 1 ) && ( gridhoriz == 2 ) && ( page == LOGIC_PAGE       ) &&  isinv                      ) ||   /* nand      */
                    ( ( gridvert == 1 ) && ( gridhoriz == 3 ) && ( page == LOGIC_PAGE       ) && !isinv                      ) ||   /* or        */
                    ( ( gridvert == 1 ) && ( gridhoriz == 3 ) && ( page == LOGIC_PAGE       ) &&  isinv                      ) ||   /* nor       */
                    ( ( gridvert == 1 ) && ( gridhoriz == 4 ) && ( page == LOGIC_PAGE       ) && !isinv                      ) ||   /* xor       */
                    ( ( gridvert == 1 ) && ( gridhoriz == 4 ) && ( page == LOGIC_PAGE       ) &&  isinv                      ) ||   /* xand      */
                    ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == TESTFUNCIII_PAGE ) && !isinv                      ) ||   /* test #3   */
                    ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == MYCALCSF_PAGE    ) && !isinv &&  HYPmode          ) ||   /* logyl     */
                    ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == MYCALCSF_PAGE    ) && !isinv &&  HYPmode          ) ||   /* logyr     */
                    ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == MYCALCSF_PAGE    ) && !isinv &&  HYPmode          ) ||   /* logy      */
                    ( ( gridvert == 1 ) && ( gridhoriz == 2 ) && ( page == ODDITIES_PAGE    ) && !isinv                      ) ||   /* commutate */
                    ( ( gridvert == 1 ) && ( gridhoriz == 2 ) && ( page == ODDITIES_PAGE    ) &&  isinv                      ) ||   /* anticommu */
                    ( ( gridvert == 1 ) && ( gridhoriz == 3 ) && ( page == ODDITIES_PAGE    ) && !isinv                      ) ||   /* associate */
                    ( ( gridvert == 1 ) && ( gridhoriz == 3 ) && ( page == ODDITIES_PAGE    ) &&  isinv                      ) ||   /* antiassoc */
                    ( ( gridvert == 1 ) && ( gridhoriz == 3 ) && ( page == TESTFUNCIII_PAGE ) &&  isinv                      )      /* DLTZ4     */ ) && ( keypress == ' ' ) )
        {
            if      ( ( gridvert == 5 ) && ( gridhoriz == 4 ) &&                                  isinv                      ) { /* x RtoP y  */ calcNest.fnname.push("RtoP       "); calcNest.fntype.push(1);  }
            else if ( ( gridvert == 5 ) && ( gridhoriz == 5 ) &&                                  isinv                      ) { /* x PtoR y  */ calcNest.fnname.push("PtoR       "); calcNest.fntype.push(2);  }
            else if ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == ODDITIES_PAGE    ) &&  isinv                      ) { /* polyDistr */ calcNest.fnname.push("polyDistr  "); calcNest.fntype.push(3);  }
            else if ( ( gridvert == 1 ) && ( gridhoriz == 3 ) && ( page == ADVANCEDSFI_PAGE ) &&  isinv                      ) { /* psi       */ calcNest.fnname.push("psi        "); calcNest.fntype.push(4);  }
            else if ( ( gridvert == 1 ) && ( gridhoriz == 5 ) && ( page == ADVANCEDSFI_PAGE ) && !isinv                      ) { /* gami      */ calcNest.fnname.push("gami       "); calcNest.fntype.push(5);  }
            else if ( ( gridvert == 1 ) && ( gridhoriz == 5 ) && ( page == ADVANCEDSFI_PAGE ) &&  isinv                      ) { /* gamic     */ calcNest.fnname.push("gamic      "); calcNest.fntype.push(6);  }
            else if ( ( gridvert == 1 ) && ( gridhoriz == 5 ) && ( page == ABSANGARG_PAGE   ) && !isinv                      ) { /* w bern y  */ calcNest.fnname.push("bern       "); calcNest.fntype.push(7);  }
            else if ( ( gridvert == 1 ) && ( gridhoriz == 2 ) && ( page == COMBMAXMIN_PAGE  ) && !isinv                      ) { /* nPr       */ calcNest.fnname.push("nPr        "); calcNest.fntype.push(8);  }
            else if ( ( gridvert == 1 ) && ( gridhoriz == 2 ) && ( page == COMBMAXMIN_PAGE  ) &&  isinv                      ) { /* nCr       */ calcNest.fnname.push("nCr        "); calcNest.fntype.push(9);  }
            else if ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == COMBMAXMIN_PAGE  ) && !isinv             && !isew ) { /* Kron.Delt */ calcNest.fnname.push("KronDelta  "); calcNest.fntype.push(10); }
            else if ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == COMBMAXMIN_PAGE  ) && !isinv             &&  isew ) { /* eKron.Delt*/ calcNest.fnname.push("eKronDelta "); calcNest.fntype.push(54); }
            else if ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == COMBMAXMIN_PAGE  ) && !isinv                      ) { /* multifact */ calcNest.fnname.push("multifact  "); calcNest.fntype.push(11); }
            else if ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == ODDITIES_PAGE    ) &&  isinv                      ) { /* I_(n,m)   */ calcNest.fnname.push("I          "); calcNest.fntype.push(12); }
            else if ( ( gridvert == 0 ) && ( gridhoriz == 2 ) && ( page == VARSET_PAGE      ) && !isinv                      ) { /* x=        */ calcNest.fnname.push("x=         "); calcNest.fntype.push(13); }
            else if ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == VARSET_PAGE      ) && !isinv                      ) { /* y=        */ calcNest.fnname.push("y=         "); calcNest.fntype.push(14); }
            else if ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == VARSET_PAGE      ) && !isinv                      ) { /* z=        */ calcNest.fnname.push("z=         "); calcNest.fntype.push(15); }
            else if ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == VARSET_PAGE      ) && !isinv                      ) { /* v=        */ calcNest.fnname.push("v=         "); calcNest.fntype.push(16); }
            else if ( ( gridvert == 1 ) && ( gridhoriz == 2 ) && ( page == VARSET_PAGE      ) && !isinv                      ) { /* w=        */ calcNest.fnname.push("w=         "); calcNest.fntype.push(17); }
            else if ( ( gridvert == 1 ) && ( gridhoriz == 3 ) && ( page == VARSET_PAGE      ) && !isinv                      ) { /* g=        */ calcNest.fnname.push("g=         "); calcNest.fntype.push(18); }
            else if ( ( gridvert == 0 ) && ( gridhoriz == 2 ) && ( page == DISTRIBII__PAGE  ) &&  isinv                      ) { /* m.randl.s */ calcNest.fnname.push("randl      "); calcNest.fntype.push(19); }
            else if ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == DISTRIBI___PAGE  ) &&  isinv                      ) { /* a.randC.b */ calcNest.fnname.push("randC      "); calcNest.fntype.push(20); }
            else if ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == DISTRIBI___PAGE  ) &&  isinv                      ) { /* m.randf.n */ calcNest.fnname.push("randf      "); calcNest.fntype.push(21); }
            else if ( ( gridvert == 1 ) && ( gridhoriz == 3 ) && ( page == DISTRIBI___PAGE  ) &&  isinv                      ) { /* t.randb.p */ calcNest.fnname.push("randb      "); calcNest.fntype.push(22); }
            else if ( ( gridvert == 1 ) && ( gridhoriz == 4 ) && ( page == DISTRIBI___PAGE  ) &&  isinv                      ) { /* k.randB.p */ calcNest.fnname.push("randB      "); calcNest.fntype.push(23); }
            else if ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == DISTRIBII__PAGE  ) &&  isinv                      ) { /* a.randu.b */ calcNest.fnname.push("randu      "); calcNest.fntype.push(24); }
            else if ( ( gridvert == 1 ) && ( gridhoriz == 2 ) && ( page == DISTRIBII__PAGE  ) &&  isinv                      ) { /* a.randG.p */ calcNest.fnname.push("randG      "); calcNest.fntype.push(25); }
            else if ( ( gridvert == 1 ) && ( gridhoriz == 3 ) && ( page == DISTRIBII__PAGE  ) &&  isinv                      ) { /* a.randw.b */ calcNest.fnname.push("randw      "); calcNest.fntype.push(26); }
            else if ( ( gridvert == 1 ) && ( gridhoriz == 4 ) && ( page == DISTRIBII__PAGE  ) &&  isinv                      ) { /* a.randx.b */ calcNest.fnname.push("randx      "); calcNest.fntype.push(27); }
            else if ( ( gridvert == 1 ) && ( gridhoriz == 5 ) && ( page == DISTRIBII__PAGE  ) &&  isinv                      ) { /* a.randn.s */ calcNest.fnname.push("randn      "); calcNest.fntype.push(28); }
            else if ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == ABSANGARG_PAGE   ) &&  isinv             && !isew ) { /* a.absp.p  */ calcNest.fnname.push("absp       "); calcNest.fntype.push(29); }
            else if ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == ABSANGARG_PAGE   ) &&  isinv             &&  isew ) { /* a.eabsp.p */ calcNest.fnname.push("eabsp      "); calcNest.fntype.push(55); }
            else if ( ( gridvert == 1 ) && ( gridhoriz == 2 ) && ( page == LOGIC_PAGE       ) && !isinv                      ) { /* and       */ calcNest.fnname.push("and        "); calcNest.fntype.push(36); }
            else if ( ( gridvert == 1 ) && ( gridhoriz == 2 ) && ( page == LOGIC_PAGE       ) &&  isinv                      ) { /* nand      */ calcNest.fnname.push("nand       "); calcNest.fntype.push(37); }
            else if ( ( gridvert == 1 ) && ( gridhoriz == 3 ) && ( page == LOGIC_PAGE       ) && !isinv                      ) { /* or        */ calcNest.fnname.push("or         "); calcNest.fntype.push(38); }
            else if ( ( gridvert == 1 ) && ( gridhoriz == 3 ) && ( page == LOGIC_PAGE       ) &&  isinv                      ) { /* nor       */ calcNest.fnname.push("nor        "); calcNest.fntype.push(39); }
            else if ( ( gridvert == 1 ) && ( gridhoriz == 4 ) && ( page == LOGIC_PAGE       ) && !isinv                      ) { /* xor       */ calcNest.fnname.push("xor        "); calcNest.fntype.push(40); }
            else if ( ( gridvert == 1 ) && ( gridhoriz == 4 ) && ( page == LOGIC_PAGE       ) &&  isinv                      ) { /* xand      */ calcNest.fnname.push("xand       "); calcNest.fntype.push(41); }
            else if ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == TESTFUNCIII_PAGE ) && !isinv                      ) { /* test #3   */ calcNest.fnname.push("test#3     "); calcNest.fntype.push(42); }
            else if ( ( gridvert == 1 ) && ( gridhoriz == 3 ) && ( page == TESTFUNCIII_PAGE ) &&  isinv                      ) { /* DLTZ4     */ calcNest.fnname.push("DLTZ4      "); calcNest.fntype.push(43); }
            else if ( ( gridvert == 1 ) && ( gridhoriz == 4 ) && ( page == VARSET_PAGE      ) && !isinv                      ) { /* h=        */ calcNest.fnname.push("h=         "); calcNest.fntype.push(44); }
            else if ( ( gridvert == 1 ) && ( gridhoriz == 5 ) && ( page == ABSANGARG_PAGE   ) &&  isinv                      ) { /* x outer y */ calcNest.fnname.push("outer      "); calcNest.fntype.push(45); }
            else if ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == MYCALCSF_PAGE    ) && !isinv &&  HYPmode          ) { /* logyl     */ calcNest.fnname.push("logyl      "); calcNest.fntype.push(46); }
            else if ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == MYCALCSF_PAGE    ) && !isinv &&  HYPmode          ) { /* logyr     */ calcNest.fnname.push("logyr      "); calcNest.fntype.push(48); }
            else if ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == MYCALCSF_PAGE    ) && !isinv &&  HYPmode          ) { /* logy      */ calcNest.fnname.push("logy       "); calcNest.fntype.push(50); }
            else if ( ( gridvert == 1 ) && ( gridhoriz == 2 ) && ( page == ODDITIES_PAGE    ) && !isinv                      ) { /* commutate */ calcNest.fnname.push("[x,y]      "); calcNest.fntype.push(52); }
            else if ( ( gridvert == 1 ) && ( gridhoriz == 2 ) && ( page == ODDITIES_PAGE    ) &&  isinv                      ) { /* anticommu */ calcNest.fnname.push("{x,y}      "); calcNest.fntype.push(53); }
            else if ( ( gridvert == 1 ) && ( gridhoriz == 5 ) && ( page == VARSET_PAGE      ) && !isinv                      ) { /* u=        */ calcNest.fnname.push("u=         "); calcNest.fntype.push(56); }

            else if ( ( gridvert == 1 ) && ( gridhoriz == 3 ) && ( page == ODDITIES_PAGE ) && !isinv )
            {
                /* associate */

//FIXME: error if whichassoc = 1 and previous push wasn't 1000
                calcNest.fnname.push("[x,y,z]    ");
                calcNest.fntype.push(1000);
                calcNest.whichassoc++;
            }

            else if ( ( gridvert == 1 ) && ( gridhoriz == 3 ) && ( page == ODDITIES_PAGE ) &&  isinv )
            {
                /* anticommu */

//FIXME: error if whichassoc = 1 and previous push wasn't 1001
                calcNest.fnname.push("{x,y,z}    ");
                calcNest.fntype.push(1001);
                calcNest.whichassoc++;
            }

            // For these we need to full evaluate the current
            // expression then start on a fresh one.

            UPDATE_PREPRE_OP;
            UPDATE_EVAL_OP;

            isinv     = 0;
            HYPmode   = 0;
            refresh   = 1;
            isdmsmode = 0;

            gentype xval = GETX;

            calcNest.oplastkey = 0;
            calcNest.isK       = 0;
            calcNest.argKset   = 0;
            calcNest.whichdms  = 0;

            calcNest.XYdata.push(xval);
            calcNest.optype.push(tempot);
        }

        // Binary operators

        else if ( ( ( ( gridvert == 3 ) && ( gridhoriz == 4 ) &&                               isinv                               ) || /* x|y    */
                    ( ( gridvert == 5 ) && ( gridhoriz == 3 ) &&                               isinv                               ) || /* x%y    */
                    ( ( gridvert == 4 ) && ( gridhoriz == 4 ) &&                               isinv                               ) || /* x*>y   */
                    ( ( gridvert == 4 ) && ( gridhoriz == 5 ) &&                               isinv                               ) || /* x\y    */
                    ( ( gridvert == 6 ) && ( gridhoriz == 4 ) &&                               isinv                               ) || /* x//y   */
                    ( ( gridvert == 4 ) && ( gridhoriz == 4 ) &&                              !isinv                               ) || /* x*y    */
                    ( ( gridvert == 4 ) && ( gridhoriz == 5 ) &&                              !isinv                               ) || /* x/y    */
                    ( ( gridvert == 5 ) && ( gridhoriz == 4 ) &&                              !isinv                               ) || /* x+y    */
                    ( ( gridvert == 5 ) && ( gridhoriz == 5 ) &&                              !isinv                               ) || /* x-y    */
                    ( ( gridvert == 0 ) && ( gridhoriz == 2 ) && ( page == LOGIC_PAGE    ) && !isinv && !isew                      ) || /* >      */
                    ( ( gridvert == 0 ) && ( gridhoriz == 2 ) && ( page == LOGIC_PAGE    ) &&  isinv && !isew                      ) || /* <=     */
                    ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == LOGIC_PAGE    ) && !isinv && !isew                      ) || /* <      */
                    ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == LOGIC_PAGE    ) &&  isinv && !isew                      ) || /* >=     */
                    ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == LOGIC_PAGE    ) && !isinv && !isew                      ) || /* ==     */
                    ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == LOGIC_PAGE    ) &&  isinv && !isew                      ) || /* ~=     */
                    ( ( gridvert == 0 ) && ( gridhoriz == 2 ) && ( page == LOGIC_PAGE    ) && !isinv &&  isew                      ) || /* .>     */
                    ( ( gridvert == 0 ) && ( gridhoriz == 2 ) && ( page == LOGIC_PAGE    ) &&  isinv &&  isew                      ) || /* .<=    */
                    ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == LOGIC_PAGE    ) && !isinv &&  isew                      ) || /* .<     */
                    ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == LOGIC_PAGE    ) &&  isinv &&  isew                      ) || /* .>=    */
                    ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == LOGIC_PAGE    ) && !isinv &&  isew                      ) || /* .==    */
                    ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == LOGIC_PAGE    ) &&  isinv &&  isew                      ) || /* .~=    */
                    ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == MYCALCSF_PAGE ) && !isinv && !isew && !isah && !HYPmode ) || /* x^y    */
                    ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == MYCALCSF_PAGE ) &&  isinv && !isew && !isah &&  HYPmode ) || /* x^y    */
                    ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == MYCALCSF_PAGE ) &&  isinv && !isew && !isah &&  HYPmode ) || /* x^<y   */
                    ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == MYCALCSF_PAGE ) &&  isinv && !isew && !isah &&  HYPmode ) || /* x^>y   */
                    ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == MYCALCSF_PAGE ) && !isinv &&  isew && !isah && !HYPmode ) || /* x.^y   */
                    ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == MYCALCSF_PAGE ) &&  isinv &&  isew && !isah &&  HYPmode ) || /* x.^y   */
                    ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == MYCALCSF_PAGE ) &&  isinv &&  isew && !isah &&  HYPmode ) || /* x.^<y  */
                    ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == MYCALCSF_PAGE ) &&  isinv &&  isew && !isah &&  HYPmode ) || /* x.^>y  */
                    ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == MYCALCSF_PAGE ) &&  isinv &&          !isah && !HYPmode ) || /* x^/y   */
                    ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == MYCALCSF_PAGE ) && !isinv && !isew &&  isah && !HYPmode ) || /* x^^y   */
                    ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == MYCALCSF_PAGE ) &&  isinv && !isew &&  isah &&  HYPmode ) || /* x^^y   */
                    ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == MYCALCSF_PAGE ) &&  isinv && !isew &&  isah &&  HYPmode ) || /* x^^<y  */
                    ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == MYCALCSF_PAGE ) &&  isinv && !isew &&  isah &&  HYPmode ) || /* x^^>y  */
                    ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == MYCALCSF_PAGE ) && !isinv &&  isew &&  isah && !HYPmode ) || /* x.^^y  */
                    ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == MYCALCSF_PAGE ) &&  isinv &&  isew &&  isah &&  HYPmode ) || /* x.^^y  */
                    ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == MYCALCSF_PAGE ) &&  isinv &&  isew &&  isah &&  HYPmode ) || /* x.^^<y */
                    ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == MYCALCSF_PAGE ) &&  isinv &&  isew &&  isah &&  HYPmode ) || /* x.^^>y */
                    ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == MYCALCSF_PAGE ) &&  isinv &&           isah && !HYPmode )    /* x^^/y  */ ) && ( keypress == ' ' ) )
        {
            std::string newoptype; // need to detect double-press (repeat of K) operations

            /* Binary ops */

            if      ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == MYCALCSF_PAGE ) && !isinv && !HYPmode && !isew && !isah ) { /* x^y    */ newoptype = "^";    }
            else if ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == MYCALCSF_PAGE ) &&  isinv &&  HYPmode && !isew && !isah ) { /* x^y    */ newoptype = "^";    }
            else if ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == MYCALCSF_PAGE ) &&  isinv &&  HYPmode && !isew && !isah ) { /* x^<y   */ newoptype = "^<";   }
            else if ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == MYCALCSF_PAGE ) &&  isinv &&  HYPmode && !isew && !isah ) { /* x^>y   */ newoptype = "^>";   }
            else if ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == MYCALCSF_PAGE ) && !isinv && !HYPmode &&  isew && !isah ) { /* x.^y   */ newoptype = ".^";   }
            else if ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == MYCALCSF_PAGE ) &&  isinv &&  HYPmode &&  isew && !isah ) { /* x.^y   */ newoptype = ".^";   }
            else if ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == MYCALCSF_PAGE ) &&  isinv &&  HYPmode &&  isew && !isah ) { /* x.^<y  */ newoptype = ".^<";  }
            else if ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == MYCALCSF_PAGE ) &&  isinv &&  HYPmode &&  isew && !isah ) { /* x.^>y  */ newoptype = ".^>";  }
            else if ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == MYCALCSF_PAGE ) &&  isinv && !HYPmode          && !isah ) { /* x^/y   */ newoptype = "^/";   }
            else if ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == MYCALCSF_PAGE ) && !isinv && !HYPmode && !isew &&  isah ) { /* x^^y   */ newoptype = "^^";   }
            else if ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == MYCALCSF_PAGE ) &&  isinv &&  HYPmode && !isew &&  isah ) { /* x^^y   */ newoptype = "^^";   }
            else if ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == MYCALCSF_PAGE ) &&  isinv &&  HYPmode && !isew &&  isah ) { /* x^^<y  */ newoptype = "^^<";  }
            else if ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == MYCALCSF_PAGE ) &&  isinv &&  HYPmode && !isew &&  isah ) { /* x^^>y  */ newoptype = "^^>";  }
            else if ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == MYCALCSF_PAGE ) && !isinv && !HYPmode &&  isew &&  isah ) { /* x.^^y  */ newoptype = ".^^";  }
            else if ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == MYCALCSF_PAGE ) &&  isinv &&  HYPmode &&  isew &&  isah ) { /* x.^^y  */ newoptype = ".^^";  }
            else if ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == MYCALCSF_PAGE ) &&  isinv &&  HYPmode &&  isew &&  isah ) { /* x.^^<y */ newoptype = ".^^<"; }
            else if ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == MYCALCSF_PAGE ) &&  isinv &&  HYPmode &&  isew &&  isah ) { /* x.^^>y */ newoptype = ".^^>"; }
            else if ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == MYCALCSF_PAGE ) &&  isinv && !HYPmode          &&  isah ) { /* x^^/y  */ newoptype = "^^/";  }
            else if ( ( gridvert == 0 ) && ( gridhoriz == 2 ) && ( page == LOGIC_PAGE    ) && !isinv             && !isew          ) { /* x>y    */ newoptype = ">";    }
            else if ( ( gridvert == 0 ) && ( gridhoriz == 2 ) && ( page == LOGIC_PAGE    ) &&  isinv             && !isew          ) { /* x<=y   */ newoptype = "<=";   }
            else if ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == LOGIC_PAGE    ) && !isinv             && !isew          ) { /* x<y    */ newoptype = "<";    }
            else if ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == LOGIC_PAGE    ) &&  isinv             && !isew          ) { /* x>=y   */ newoptype = ">=";   }
            else if ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == LOGIC_PAGE    ) && !isinv             && !isew          ) { /* x==y   */ newoptype = "==";   }
            else if ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == LOGIC_PAGE    ) &&  isinv             && !isew          ) { /* x~=y   */ newoptype = "~=";   }
            else if ( ( gridvert == 0 ) && ( gridhoriz == 2 ) && ( page == LOGIC_PAGE    ) && !isinv             &&  isew          ) { /* x.>y   */ newoptype = ".>";   }
            else if ( ( gridvert == 0 ) && ( gridhoriz == 2 ) && ( page == LOGIC_PAGE    ) &&  isinv             &&  isew          ) { /* x.<=y  */ newoptype = ".<=";  }
            else if ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == LOGIC_PAGE    ) && !isinv             &&  isew          ) { /* x.<y   */ newoptype = ".<";   }
            else if ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == LOGIC_PAGE    ) &&  isinv             &&  isew          ) { /* x.>=y  */ newoptype = ".>=";  }
            else if ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == LOGIC_PAGE    ) && !isinv             &&  isew          ) { /* x.==y  */ newoptype = ".==";  }
            else if ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == LOGIC_PAGE    ) &&  isinv             &&  isew          ) { /* x.~=y  */ newoptype = ".~=";  }
            else if ( ( gridvert == 5 ) && ( gridhoriz == 3 ) &&                               isinv             && !isew          ) { /* x%y    */ newoptype = "%";    }
            else if ( ( gridvert == 4 ) && ( gridhoriz == 4 ) &&                               isinv             && !isew          ) { /* x*>y   */ newoptype = "*>";   }
            else if ( ( gridvert == 5 ) && ( gridhoriz == 3 ) &&                               isinv             &&  isew          ) { /* x.%y   */ newoptype = ".%";   }
            else if ( ( gridvert == 4 ) && ( gridhoriz == 4 ) &&                               isinv             &&  isew          ) { /* x.*>y  */ newoptype = ".*>";  }
            else if ( ( gridvert == 4 ) && ( gridhoriz == 5 ) &&                               isinv             && !isew          ) { /* x\y    */ newoptype = "\\";   }
            else if ( ( gridvert == 4 ) && ( gridhoriz == 5 ) &&                               isinv             &&  isew          ) { /* x.\y   */ newoptype = ".\\";  }
            else if ( ( gridvert == 4 ) && ( gridhoriz == 4 ) &&                              !isinv             && !isew          ) { /* x*y    */ newoptype = "*";    }
            else if ( ( gridvert == 4 ) && ( gridhoriz == 4 ) &&                              !isinv             &&  isew          ) { /* x.*y   */ newoptype = ".*";   }
            else if ( ( gridvert == 4 ) && ( gridhoriz == 5 ) &&                              !isinv             && !isew          ) { /* x/y    */ newoptype = "/";    }
            else if ( ( gridvert == 4 ) && ( gridhoriz == 5 ) &&                              !isinv             &&  isew          ) { /* x./y   */ newoptype = "./";   }
            else if ( ( gridvert == 6 ) && ( gridhoriz == 4 ) &&                               isinv             && !isew          ) { /* x//y   */ newoptype = "//";   }
            else if ( ( gridvert == 6 ) && ( gridhoriz == 4 ) &&                               isinv             &&  isew          ) { /* x.//y  */ newoptype = ".//";  }
            else if ( ( gridvert == 5 ) && ( gridhoriz == 4 ) &&                              !isinv                               ) { /* x+y    */ newoptype = "+";    }
            else if ( ( gridvert == 5 ) && ( gridhoriz == 5 ) &&                              !isinv                               ) { /* x-y    */ newoptype = "-";    }
            else if ( ( gridvert == 3 ) && ( gridhoriz == 4 ) &&                               isinv                      && !isah ) { /* x|y    */ newoptype = "|";    }
            else if ( ( gridvert == 3 ) && ( gridhoriz == 4 ) &&                               isinv                      &&  isah ) { /* x|@y   */ newoptype = "|@";   }

            if ( calcNest.oplastkey )
            {
                if ( ( newoptype == calcNest.optype.accessTop() ) && ( calcNest.XYdata.size() == 3 ) )
                {
                    isinv     = 0;
                    HYPmode   = 0;
                    refresh   = 1;
                    isdmsmode = 0;

                    calcNest.isK      = calcNest.isK ? 0 : 1;
                    calcNest.argKset  = 0;
                    calcNest.whichdms = 0;
                }

                else
                {
                    calcNest.optype.pop();
                    calcNest.optype.push(newoptype);

                    isinv     = 0;
                    HYPmode   = 0;
                    refresh   = 1;
                    isdmsmode = 0;

                    calcNest.isK      = 0;
                    calcNest.argKset  = 0;
                    calcNest.whichdms = 0;
                }
            }

            else
            {
                calcNest.oplastkey = 1;

                isinv     = 0;
                HYPmode   = 0;
                refresh   = 1;
                isdmsmode = 0;

                UPDATE_PREPRE_OP;
                UPDATE_PREEVAL_OP(newoptype); // unroll as far as practical to keep display current given latest operation

                gentype xval = GETX;

                calcNest.isK      = 0;
                calcNest.argKset  = 0;
                calcNest.whichdms = 0;

                calcNest.XYdata.push(xval);
                calcNest.optype.push(newoptype);
                calcNest.fntype.push(tempft);
                calcNest.fnname.push(tempfn);
            }
        }

        // Evaluate

        else if ( ( ( gridvert == 6 ) && ( gridhoriz == 4 ) && !isinv && ( keypress == ' ' ) ) || ( keypress == 10 ) )
        {
            calcNest.oplastkey  = 0;
            calcNest.whichdms   = 0;

            int secondeval = dataDisplay;

            UPDATE_PREPRE_OP;
            UPDATE_EVAL_OP;

            if ( secondeval )
            {
                GETX.finalise();
            }

            calcNest.whichassoc = 0;

            isinv     = 0;
            HYPmode   = 0;
            refresh   = 1;
            isdmsmode = 0;
        }

        // Plot

        else if ( keypress == 'P' )
        {
            // evaluate

            calcNest.oplastkey  = 0;
            calcNest.whichdms   = 0;

            UPDATE_PREPRE_OP;
            UPDATE_EVAL_OP;

            calcNest.whichassoc = 0;

            isinv     = 0;
            HYPmode   = 0;
            refresh   = 1;
            isdmsmode = 0;

            // plot

            std::string fname;
            std::string dname;

            gentype fn = GETX;

            plotmode = ( (fn.isValEqn()) & 4 );
            plotfn = fn;

            std::string pre = "genplot";
            std::string post = ".gen";

            getUniqueFile(fname,pre,post);
            getUniqueFile(dname,pre,post);

            genplotit(xmin,xmax,ymin,ymax,fname,dname,0,fn,0); // to display
#ifndef USE_MEX
            genplotit(xmin,xmax,ymin,ymax,fname,dname,2,fn,0); // to save
#endif

            std::string resname = fname+".txt";

            // text version now in file resname

            std::ifstream resfile(resname);

            int ij;
            size_t kl;
            char buffer[2048];
            std::string bufferb;

            for ( ij = 0 ; ij < NUMPLOTLINES ; ij++ )
            {
                buffer[0] = '\0';

                resfile.getline(buffer,2000);

                bufferb = buffer;

                for ( kl = 0 ; kl < bufferb.length() ; kl++ )
                {
                    if ( !isprint(bufferb[kl]) )
                    {
                        bufferb[kl] = ' ';
                    }
                }

                if ( bufferb.length() <= rightblank )
                {
                    rightplot[ij] = bufferb;
                }

                else
                {
                    rightplot[ij] = bufferb.substr(0,rightblank);
                }
            }

            resfile.close();

            refresh   = 1;
        }

        // Left bracket

        else if ( ( gridvert == 2 ) && ( gridhoriz == 2 ) && !SDmode && ( keypress == ' ' ) )
        {
            theCalcNest.push(tempnest);

            refresh   = 1;
            isdmsmode = 0;
        }

        // Right bracket

        else if ( ( gridvert == 2 ) && ( gridhoriz == 3 ) && !SDmode && ( keypress == ' ' ) )
        {
            calcNest.oplastkey = 0;

            // Evaluate result

            UPDATE_PREPRE_OP;
            UPDATE_EVAL_OP;

            // Save result

            gentype tempres = GETX;

            // Pop state off stack to restore previous state

            if ( theCalcNest.size() > 1 )
            {
                theCalcNest.pop();
            }

            // Put result in new state

            GETX = tempres;

            // dms evaluation if required

            if ( calcNest.whichdms )
            {
                calcNest.dmsaccum = ( calcNest.whichdms == 0 ) ? GETX : ( ( calcNest.whichdms == 1 ) ? (calcNest.dmsaccum+(GETX/60.0)) : (calcNest.dmsaccum+(GETX/3600.0)) );
                GETX = calcNest.dmsaccum;
                calcNest.whichdms = ( calcNest.whichdms < 2 ) ? calcNest.whichdms+1 : 0;
            }

            // Basic stuff

            refresh   = 1;
            isdmsmode = 0;
        }

        // Data entry

        else if ( ( ( gridvert >= 3 ) && ( gridvert <= 6 ) && ( gridhoriz >= 0 ) && ( gridhoriz <= 3 ) && ( keypress == ' ' ) ) ||
                  ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == ODDITIES_PAGE ) && !isinv && ( keypress == ' ' ) ) ||
                  ( ( gridvert == 0 ) && ( gridhoriz == 2 ) && ( page == VARDERIV_PAGE ) && !isinv && ( keypress == ' ' ) ) ||
                  ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == VARDERIV_PAGE ) && !isinv && ( keypress == ' ' ) ) ||
                  ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == VARDERIV_PAGE ) && !isinv && ( keypress == ' ' ) ) ||
                  ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == VARDERIV_PAGE ) && !isinv && ( keypress == ' ' ) ) ||
                  ( ( gridvert == 1 ) && ( gridhoriz == 2 ) && ( page == VARDERIV_PAGE ) && !isinv && ( keypress == ' ' ) ) ||
                  ( ( gridvert == 1 ) && ( gridhoriz == 3 ) && ( page == VARDERIV_PAGE ) && !isinv && ( keypress == ' ' ) ) ||
                  ( ( gridvert == 1 ) && ( gridhoriz == 4 ) && ( page == VARDERIV_PAGE ) && !isinv && ( keypress == ' ' ) ) ||
                  ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == ODDITIES_PAGE ) && !isinv && ( keypress == ' ' ) ) ||
                  ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == ODDITIES_PAGE ) &&  isinv && ( keypress == ' ' ) ) ||
                  ( ( gridvert == 0 ) && ( gridhoriz == 2 ) && ( page == TIME_PAGE     ) && !isinv && ( keypress == ' ' ) ) ||
                  ( ( gridvert == 0 ) && ( gridhoriz == 2 ) && ( page == TIME_PAGE     ) &&  isinv && ( keypress == ' ' ) ) ||
                  ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == TIME_PAGE     ) && !isinv && ( keypress == ' ' ) ) ||
                  ( ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == TIME_PAGE     ) &&  isinv && ( keypress == ' ' ) ) ||
                  ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == TIME_PAGE     ) && !isinv && ( keypress == ' ' ) ) ||
                  ( ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == TIME_PAGE     ) &&  isinv && ( keypress == ' ' ) ) ||
                  ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == TIME_PAGE     ) && !isinv && ( keypress == ' ' ) ) ||
                  ( ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == TIME_PAGE     ) &&  isinv && ( keypress == ' ' ) ) ||
                  ( ( gridvert == 1 ) && ( gridhoriz == 2 ) && ( page == TIME_PAGE     ) && !isinv && ( keypress == ' ' ) ) ||
                  ( ( gridvert == 1 ) && ( gridhoriz == 2 ) && ( page == TIME_PAGE     ) &&  isinv && ( keypress == ' ' ) ) ||
                  ( ( gridvert == 1 ) && ( gridhoriz == 3 ) && ( page == TIME_PAGE     ) && !isinv && ( keypress == ' ' ) ) ||
                  ( ( gridvert == 1 ) && ( gridhoriz == 3 ) && ( page == TIME_PAGE     ) &&  isinv && ( keypress == ' ' ) ) ||
                  ( ( gridvert == 1 ) && ( gridhoriz == 4 ) && ( page == TIME_PAGE     ) && !isinv && ( keypress == ' ' ) ) ||
                  ( ( gridvert == 1 ) && ( gridhoriz == 4 ) && ( page == TIME_PAGE     ) &&  isinv && ( keypress == ' ' ) ) ||
                  ( ( gridvert == 1 ) && ( gridhoriz == 5 ) && ( page == TIME_PAGE     ) && !isinv && ( keypress == ' ' ) )    )
                  //( keypress == 8 ) )
        {
            calcNest.oplastkey = 0;

            std::string clockfunc = "ifthenelse(x<.25,[ sin(2*pi*4*x) cos(2*pi*4*x) ],ifthenelse(x<.5,(x-0.25)*2*[ sin(clkhour()*2*pi/12) cos(clkhour()*2*pi/12) ],ifthenelse(x<.75,(x-0.5)*3.9*[ sin(clkmin()*2*pi/60) cos(clkmin()*2*pi/60) ],(x-0.75)*3.1*[ sin(clksec()*2*pi/60) cos(clksec()*2*pi/60) ])))";

            UPDATE_PRE_EDIT;

            bool isempty = !entryval.size() || ( entryval == "0" );
            bool isfirst = !entryval.size() || isbeg(entryval[entryval.size()-1]);

/*
            if ( keypress == 8 )
            {
                // backspace pressed

                if ( !dataDisplay && entryval.size() )
                {
                    entryval = entryval.substr(0,entryval.size()-1);
                }
            }
*/

                 if ( !isinv && ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == ODDITIES_PAGE ) && ( isempty || !isfirst ) ) { GETX     = "null";     dataDisplay = 1; }
            else if (  isinv && ( gridvert == 6 ) && ( gridhoriz == 1 )                              && ( isempty || !isfirst ) ) { GETX     = "nan";      dataDisplay = 1; }
            else if (  isinv && ( gridvert == 6 ) && ( gridhoriz == 2 )                              && ( isempty || !isfirst ) ) { GETX     = "inf";      dataDisplay = 1; }
            else if ( !isinv && ( gridvert == 6 ) && ( gridhoriz == 3 )                              && ( isempty || !isfirst ) ) { entryval = "pi";                        }
            else if (  isinv && ( gridvert == 6 ) && ( gridhoriz == 3 )                              && ( isempty || !isfirst ) ) { entryval = "pi";                        }
            else if ( !isinv && ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == ODDITIES_PAGE ) && ( isempty || !isfirst ) ) { entryval = "euler";                     }
            else if (  isinv && ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == ODDITIES_PAGE ) && ( isempty || !isfirst ) ) { GETX     = tnow();     dataDisplay = 1; }
            else if ( !isinv && ( gridvert == 0 ) && ( gridhoriz == 2 ) && ( page == TIME_PAGE     ) && ( isempty || !isfirst ) ) { GETX     = clkyear();  dataDisplay = 1; }
            else if (  isinv && ( gridvert == 0 ) && ( gridhoriz == 2 ) && ( page == TIME_PAGE     ) && ( isempty || !isfirst ) ) { GETX     = clkmon();   dataDisplay = 1; }
            else if ( !isinv && ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == TIME_PAGE     ) && ( isempty || !isfirst ) ) { GETX     = clkday();   dataDisplay = 1; }
            else if (  isinv && ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == TIME_PAGE     ) && ( isempty || !isfirst ) ) { GETX     = clkhour();  dataDisplay = 1; }
            else if ( !isinv && ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == TIME_PAGE     ) && ( isempty || !isfirst ) ) { GETX     = clkmin();   dataDisplay = 1; }
            else if (  isinv && ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == TIME_PAGE     ) && ( isempty || !isfirst ) ) { GETX     = clksec();   dataDisplay = 1; }
            else if ( !isinv && ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == TIME_PAGE     ) && ( isempty || !isfirst ) ) { GETX     = tnow();     dataDisplay = 1; }
            else if (  isinv && ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == TIME_PAGE     ) && ( isempty || !isfirst ) ) { entryval = "tnow";                      }
            else if ( !isinv && ( gridvert == 1 ) && ( gridhoriz == 2 ) && ( page == TIME_PAGE     ) && ( isempty || !isfirst ) ) { entryval = "clkyear";                   }
            else if (  isinv && ( gridvert == 1 ) && ( gridhoriz == 2 ) && ( page == TIME_PAGE     ) && ( isempty || !isfirst ) ) { entryval = "clkmon";                    }
            else if ( !isinv && ( gridvert == 1 ) && ( gridhoriz == 3 ) && ( page == TIME_PAGE     ) && ( isempty || !isfirst ) ) { entryval = "clkday";                    }
            else if (  isinv && ( gridvert == 1 ) && ( gridhoriz == 3 ) && ( page == TIME_PAGE     ) && ( isempty || !isfirst ) ) { entryval = "clkhour";                   }
            else if ( !isinv && ( gridvert == 1 ) && ( gridhoriz == 4 ) && ( page == TIME_PAGE     ) && ( isempty || !isfirst ) ) { entryval = "clkmin";                    }
            else if (  isinv && ( gridvert == 1 ) && ( gridhoriz == 4 ) && ( page == TIME_PAGE     ) && ( isempty || !isfirst ) ) { entryval = "clksec";                    }
            else if ( !isinv && ( gridvert == 1 ) && ( gridhoriz == 5 ) && ( page == TIME_PAGE     ) && ( isempty || !isfirst ) ) { entryval += clockfunc;                  }

            else if ( !isinv && ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == ODDITIES_PAGE ) ) { entryval += "null";                            }
            else if (  isinv && ( gridvert == 6 ) && ( gridhoriz == 1 )                              ) { entryval += "nan";                             }
            else if (  isinv && ( gridvert == 6 ) && ( gridhoriz == 2 )                              ) { entryval += "inf";                             }
            else if ( !isinv && ( gridvert == 6 ) && ( gridhoriz == 3 )                              ) { entryval += "pi";                              }
            else if (  isinv && ( gridvert == 6 ) && ( gridhoriz == 3 )                              ) { entryval += "pi";                              }
            else if ( !isinv && ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == ODDITIES_PAGE ) ) { entryval += "euler";                           }
            else if (  isinv && ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == ODDITIES_PAGE ) ) { entryval += ((const std::string &) tnow());    }
            else if ( !isinv && ( gridvert == 0 ) && ( gridhoriz == 2 ) && ( page == TIME_PAGE     ) ) { entryval += ((const std::string &) clkyear()); }
            else if (  isinv && ( gridvert == 0 ) && ( gridhoriz == 2 ) && ( page == TIME_PAGE     ) ) { entryval += ((const std::string &) clkmon());  }
            else if ( !isinv && ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == TIME_PAGE     ) ) { entryval += ((const std::string &) clkday());  }
            else if (  isinv && ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == TIME_PAGE     ) ) { entryval += ((const std::string &) clkhour()); }
            else if ( !isinv && ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == TIME_PAGE     ) ) { entryval += ((const std::string &) clkmin());  }
            else if (  isinv && ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == TIME_PAGE     ) ) { entryval += ((const std::string &) clksec());  }
            else if ( !isinv && ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == TIME_PAGE     ) ) { entryval += ((const std::string &) tnow());    }
            else if (  isinv && ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == TIME_PAGE     ) ) { entryval += "tnow";                            }
            else if ( !isinv && ( gridvert == 1 ) && ( gridhoriz == 2 ) && ( page == TIME_PAGE     ) ) { entryval += "clkyear";                         }
            else if (  isinv && ( gridvert == 1 ) && ( gridhoriz == 2 ) && ( page == TIME_PAGE     ) ) { entryval += "clkmon";                          }
            else if ( !isinv && ( gridvert == 1 ) && ( gridhoriz == 3 ) && ( page == TIME_PAGE     ) ) { entryval += "clkday";                          }
            else if (  isinv && ( gridvert == 1 ) && ( gridhoriz == 3 ) && ( page == TIME_PAGE     ) ) { entryval += "clkhour";                         }
            else if ( !isinv && ( gridvert == 1 ) && ( gridhoriz == 4 ) && ( page == TIME_PAGE     ) ) { entryval += "clkmin";                          }
            else if (  isinv && ( gridvert == 1 ) && ( gridhoriz == 4 ) && ( page == TIME_PAGE     ) ) { entryval += "clksec";                          }
            else if ( !isinv && ( gridvert == 1 ) && ( gridhoriz == 5 ) && ( page == TIME_PAGE     ) ) { entryval += clockfunc;                         }

            else if ( !isinv && ( gridvert == 6 ) && ( gridhoriz == 3 ) && isempty ) { entryval = "0E"; }
            else if ( !isinv && ( gridvert == 3 ) && ( gridhoriz == 0 ) && isempty ) { entryval = "1i"; }
            else if ( !isinv && ( gridvert == 4 ) && ( gridhoriz == 0 ) && isempty ) { entryval = "1I"; }
            else if ( !isinv && ( gridvert == 5 ) && ( gridhoriz == 0 ) && isempty ) { entryval = "1J"; }
            else if ( !isinv && ( gridvert == 6 ) && ( gridhoriz == 0 ) && isempty ) { entryval = "1K"; }
            else if (  isinv && ( gridvert == 3 ) && ( gridhoriz == 0 ) && isempty ) { entryval = "1l"; }
            else if (  isinv && ( gridvert == 4 ) && ( gridhoriz == 0 ) && isempty ) { entryval = "1m"; }
            else if (  isinv && ( gridvert == 5 ) && ( gridhoriz == 0 ) && isempty ) { entryval = "1n"; }
            else if (  isinv && ( gridvert == 6 ) && ( gridhoriz == 0 ) && isempty ) { entryval = "1o"; }
            else if (  isinv && ( gridvert == 3 ) && ( gridhoriz == 1 ) && isempty ) { entryval = "1p"; }
            else if (  isinv && ( gridvert == 4 ) && ( gridhoriz == 1 ) && isempty ) { entryval = "1q"; }
            else if (  isinv && ( gridvert == 5 ) && ( gridhoriz == 1 ) && isempty ) { entryval = "1r"; }

            else if ( !isinv && ( gridvert == 6 ) && ( gridhoriz == 3 ) && isfirst ) { entryval += "0E"; }
            else if ( !isinv && ( gridvert == 3 ) && ( gridhoriz == 0 ) && isfirst ) { entryval += "1i"; }
            else if ( !isinv && ( gridvert == 4 ) && ( gridhoriz == 0 ) && isfirst ) { entryval += "1I"; }
            else if ( !isinv && ( gridvert == 5 ) && ( gridhoriz == 0 ) && isfirst ) { entryval += "1J"; }
            else if ( !isinv && ( gridvert == 6 ) && ( gridhoriz == 0 ) && isfirst ) { entryval += "1K"; }
            else if (  isinv && ( gridvert == 3 ) && ( gridhoriz == 0 ) && isfirst ) { entryval += "1l"; }
            else if (  isinv && ( gridvert == 4 ) && ( gridhoriz == 0 ) && isfirst ) { entryval += "1m"; }
            else if (  isinv && ( gridvert == 5 ) && ( gridhoriz == 0 ) && isfirst ) { entryval += "1n"; }
            else if (  isinv && ( gridvert == 6 ) && ( gridhoriz == 0 ) && isfirst ) { entryval += "1o"; }
            else if (  isinv && ( gridvert == 3 ) && ( gridhoriz == 1 ) && isfirst ) { entryval += "1p"; }
            else if (  isinv && ( gridvert == 4 ) && ( gridhoriz == 1 ) && isfirst ) { entryval += "1q"; }
            else if (  isinv && ( gridvert == 5 ) && ( gridhoriz == 1 ) && isfirst ) { entryval += "1r"; }

            // NOTE: have to break else-if sequence because studio c++ "blocks nested too deeply"

                 if ( !isinv && ( gridvert == 6 ) && ( gridhoriz == 3 ) ) { entryval += "E"; }
            else if ( !isinv && ( gridvert == 3 ) && ( gridhoriz == 0 ) ) { entryval += "i"; }
            else if ( !isinv && ( gridvert == 4 ) && ( gridhoriz == 0 ) ) { entryval += "I"; }
            else if ( !isinv && ( gridvert == 5 ) && ( gridhoriz == 0 ) ) { entryval += "J"; }
            else if ( !isinv && ( gridvert == 6 ) && ( gridhoriz == 0 ) ) { entryval += "K"; }
            else if (  isinv && ( gridvert == 3 ) && ( gridhoriz == 0 ) ) { entryval += "l"; }
            else if (  isinv && ( gridvert == 4 ) && ( gridhoriz == 0 ) ) { entryval += "m"; }
            else if (  isinv && ( gridvert == 5 ) && ( gridhoriz == 0 ) ) { entryval += "n"; }
            else if (  isinv && ( gridvert == 6 ) && ( gridhoriz == 0 ) ) { entryval += "o"; }
            else if (  isinv && ( gridvert == 3 ) && ( gridhoriz == 1 ) ) { entryval += "p"; }
            else if (  isinv && ( gridvert == 4 ) && ( gridhoriz == 1 ) ) { entryval += "q"; }
            else if (  isinv && ( gridvert == 5 ) && ( gridhoriz == 1 ) ) { entryval += "r"; }

            else if ( !isinv && ( gridvert == 6 ) && ( gridhoriz == 1 ) ) { entryval += "0"; }
            else if ( !isinv && ( gridvert == 5 ) && ( gridhoriz == 1 ) ) { entryval += "1"; }
            else if ( !isinv && ( gridvert == 5 ) && ( gridhoriz == 2 ) ) { entryval += "2"; }
            else if ( !isinv && ( gridvert == 5 ) && ( gridhoriz == 3 ) ) { entryval += "3"; }
            else if ( !isinv && ( gridvert == 4 ) && ( gridhoriz == 1 ) ) { entryval += "4"; }
            else if ( !isinv && ( gridvert == 4 ) && ( gridhoriz == 2 ) ) { entryval += "5"; }
            else if ( !isinv && ( gridvert == 4 ) && ( gridhoriz == 3 ) ) { entryval += "6"; }
            else if ( !isinv && ( gridvert == 3 ) && ( gridhoriz == 1 ) ) { entryval += "7"; }
            else if ( !isinv && ( gridvert == 3 ) && ( gridhoriz == 2 ) ) { entryval += "8"; }
            else if ( !isinv && ( gridvert == 3 ) && ( gridhoriz == 3 ) ) { entryval += "9"; }
            else if ( !isinv && ( gridvert == 6 ) && ( gridhoriz == 2 ) ) { entryval += "."; }
            else if (  isinv && ( gridvert == 3 ) && ( gridhoriz == 2 ) ) { entryval += "["; }
            else if (  isinv && ( gridvert == 3 ) && ( gridhoriz == 3 ) ) { entryval += "]"; }
            else if (  isinv && ( gridvert == 4 ) && ( gridhoriz == 2 ) ) { entryval += "("; }
            else if (  isinv && ( gridvert == 4 ) && ( gridhoriz == 3 ) ) { entryval += ")"; }
            else if (  isinv && ( gridvert == 5 ) && ( gridhoriz == 2 ) ) { entryval += ";"; }

            else if ( !isinv && ( gridvert == 0 ) && ( gridhoriz == 2 ) && ( page == VARDERIV_PAGE ) && ( isempty || !isfirst ) ) { entryval = "x"; }
            else if ( !isinv && ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == VARDERIV_PAGE ) && ( isempty || !isfirst ) ) { entryval = "y"; }
            else if ( !isinv && ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == VARDERIV_PAGE ) && ( isempty || !isfirst ) ) { entryval = "z"; }
            else if ( !isinv && ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == VARDERIV_PAGE ) && ( isempty || !isfirst ) ) { entryval = "v"; }
            else if ( !isinv && ( gridvert == 1 ) && ( gridhoriz == 2 ) && ( page == VARDERIV_PAGE ) && ( isempty || !isfirst ) ) { entryval = "w"; }
            else if ( !isinv && ( gridvert == 1 ) && ( gridhoriz == 3 ) && ( page == VARDERIV_PAGE ) && ( isempty || !isfirst ) ) { entryval = "g"; }
            else if ( !isinv && ( gridvert == 1 ) && ( gridhoriz == 4 ) && ( page == VARDERIV_PAGE ) && ( isempty || !isfirst ) ) { entryval = "h"; }
            else if ( !isinv && ( gridvert == 1 ) && ( gridhoriz == 5 ) && ( page == VARDERIV_PAGE ) && ( isempty || !isfirst ) ) { entryval = "u"; }

            else if ( !isinv && ( gridvert == 0 ) && ( gridhoriz == 2 ) && ( page == VARDERIV_PAGE ) ) { entryval += "x"; }
            else if ( !isinv && ( gridvert == 0 ) && ( gridhoriz == 3 ) && ( page == VARDERIV_PAGE ) ) { entryval += "y"; }
            else if ( !isinv && ( gridvert == 0 ) && ( gridhoriz == 4 ) && ( page == VARDERIV_PAGE ) ) { entryval += "z"; }
            else if ( !isinv && ( gridvert == 0 ) && ( gridhoriz == 5 ) && ( page == VARDERIV_PAGE ) ) { entryval += "v"; }
            else if ( !isinv && ( gridvert == 1 ) && ( gridhoriz == 2 ) && ( page == VARDERIV_PAGE ) ) { entryval += "w"; }
            else if ( !isinv && ( gridvert == 1 ) && ( gridhoriz == 3 ) && ( page == VARDERIV_PAGE ) ) { entryval += "g"; }
            else if ( !isinv && ( gridvert == 1 ) && ( gridhoriz == 4 ) && ( page == VARDERIV_PAGE ) ) { entryval += "h"; }
            else if ( !isinv && ( gridvert == 1 ) && ( gridhoriz == 5 ) && ( page == VARDERIV_PAGE ) ) { entryval += "u"; }

            isinv     = 0;
            HYPmode   = 0;
            refresh   = 1;
            isdmsmode = 0;
        }

        // Snow crash

        //else if ( ( gridvert == 1 ) && ( gridhoriz > 2 ) && ( page == TESTFUNCIV__PAGE ) && isinv && ( keypress == ' ' ) )
        else if ( keypress == ' ' )
        {
            int iip,jj,kk;

            time_used pstart_time = TIMECALL;
            time_used pcurr_time = pstart_time;
            double ptimetakensec;
            int usleeptime = 100000; //100000;

            keypress = svm_getch_nonblock();

            while ( ( keypress != ' ' ) && ( keypress != 10 ) )
            {
                keypress = svm_getch_nonblock();

                iip = static_cast<int>(rand()%calcwidth); //(datawidth+20);
                jj = static_cast<int>(rand()%calcheight); //dataheight;
                kk = static_cast<int>(rand()%(126-32));

                svmcurs(jj,iip);
                outstreamunlogged() << ((char) (kk+32));

                pcurr_time = TIMECALL;
                ptimetakensec = TIMEDIFFSEC(pcurr_time,pstart_time);

                if ( ptimetakensec < ((double) usleeptime)/1000000 )
                {
                    svm_usleep((int) std::round(((double) usleeptime)-(1000000*((double) ptimetakensec))));
                }

                pstart_time = TIMECALL;
            }

            refresh = 1;
        }

        // Direct data entry

        //else if ( isprint(keypress) && ( keypress != ' ' ) )
        else if ( isprint(keypress) || ( keypress == 9 ) || ( keypress == 8 ) )
        {
            if ( dataDisplay && ( ( keypress == 8 ) || isopstartkey(keypress) ) )
            {
                // If you have data on-screen and press e.g. + then just
                // continue as if this was text (not true for numbers)

                // *******Just like the evaluate function above********

                calcNest.oplastkey  = 0;
                calcNest.whichdms   = 0;

                int secondeval = dataDisplay;

                UPDATE_PREPRE_OP;
                UPDATE_EVAL_OP;

                if ( secondeval )
                {
                    GETX.finalise();
                }

                calcNest.whichassoc = 0;

                isinv     = 0;
                HYPmode   = 0;
                refresh   = 1;
                isdmsmode = 0;

                // ******just like the display routine at the start, minus the faffing around with dms*******

                if ( dataDisplay == 0 )
                {
                    ;
                }

                else if ( GETX.isValEqn() )
                {
                    entryval = GETX.cast_string();
                }

                else
                {
                    entryval = (const std::string &) GETX;
                }

                calcNest.oplastkey = 0; // Trick to set state correctly
                dataDisplay = 0; // Trick to set state correctly
            }

            else
            {
                calcNest.oplastkey = 0;

                UPDATE_PRE_EDIT;
            }

            if ( keypress == '~' )
            {
                // Substitute space

                keypress = ' ';
            }

            else if ( keypress == 9 )
            {
                // Tab pressed

                keypress = '\t';
            }

            if ( keypress == 8 )
            {
                // backspace pressed

                if ( !dataDisplay && entryval.size() )
                {
                    entryval = entryval.substr(0,entryval.size()-1);
                }
            }

            else
            {
                entryval += static_cast<char>(keypress);
            }

            refresh   = 1;
            isdmsmode = 0;
        }

        else
        {
            ; //std::cerr << "Unknown key " << keypress << "\n";
        }
    }

    exitnonblockmode();


/*
    std::string buffer;
    int runagain = 1;

    while ( runagain )
    {
        output << "? ";
        std::getline(input,buffer);

        if ( ( buffer == "?" ) || ( buffer == "help" ) )
        {
            output << "Usage: <exp> - evaluates expression.\n";
            output << "       exit  - quit calculator.\n";
        }

        else if ( ( buffer == "quit" ) || ( buffer == "exit" ) )
        {
            runagain = 0;
        }

        else
        {
            try
            {
                gentype expeval(buffer);
                expeval.finalise();
                output << expeval << "\n";
            }

            catch ( ... )
            {
                output << "Error during evaluation.\n";
            }
        }
    }
*/

    return;
}

// copied from plotml.cc

int genplotit(double xmin, double xmax, double ymin, double ymax,
              const std::string &fname, const std::string &dname, int outformat, const gentype &baseline,
              int usevar)
{
#ifdef USE_MEX
    outformat = 3;
#endif

    NiceAssert( xmin < xmax );

    int indi = ( usevar <= 5 ) ? usevar : 0;
    int indj = ( usevar == 6 ) ? 2 : 0;

    int doline = 1;

    SparseVector<SparseVector<gentype> > evalargs;
    gentype &x = evalargs("&",indj)("&",indi);

    // Create the mean/variance datafile to plot

    std::ofstream dnamefile(dname);

    double xlb = xmin;
    double xub = xmax;
    double ylb = ymin;
    double yub = ymax;

    bool firsttest = true;

    for ( x = xmin ; (double) x <= xmax ; x += (xmax-xmin)/NUMSAMP )
    {
        gentype y = baseline(evalargs);

        y.finalise();

        if ( y.isValVector() )
        {
            if ( ( y.size() == 2 ) && !testisvnan(y(0)) && y(0).isCastableToRealWithoutLoss() && !testisvnan(y(1)) && y(1).isCastableToRealWithoutLoss() )
            {
                dnamefile << ((double) y(0)) << "\t" << ((double) y(1)) << "\n";

                doline = 0;

                xlb = ( firsttest || ( ((double) y(0)) < xlb ) ) ? ((double) y(0)) : xlb;
                xub = ( firsttest || ( ((double) y(0)) > xub ) ) ? ((double) y(0)) : xub;

                ylb = ( firsttest || ( ((double) y(1)) < ylb ) ) ? ((double) y(1)) : ylb;
                yub = ( firsttest || ( ((double) y(1)) > yub ) ) ? ((double) y(1)) : yub;

                firsttest = false;
            }
        }

        else if ( !testisvnan(y) && y.isCastableToRealWithoutLoss() )
        {
            dnamefile << x << "\t" << ((double) y) << "\n";

            ylb = ( firsttest || ( ((double) y) < ylb ) ) ? ((double) y) : ylb;
            yub = ( firsttest || ( ((double) y) > yub ) ) ? ((double) y) : yub;

            firsttest = false;
        }
    }

    if ( xlb == xub )
    {
        xlb -= 1;
        xub += 1;
    }

    if ( ylb == yub )
    {
        ylb -= 1;
        yub += 1;
    }

    dnamefile.close();

    int res = doplot(xlb,xub,ylb,yub,fname,dname,outformat,0,0,doline);

    std::string delstringc = "rm "+dname;

    svm_system(delstringc.c_str());

    return res;
}





















































// Sparsevector specialisations

int disableAltContent(bool justquery, int actuallyForceEnable)
{
    static thread_local int disableAltCont = 0;

    if ( !justquery )
    {
        disableAltCont = actuallyForceEnable ? 0 : 1;
    }

    return disableAltCont;
}

// saves memory by turning off altcontent, at the cost of speed.  Use 1 to force enable instead

template <> gentype &oneProduct(gentype &gres, const SparseVector<gentype> &a)
{
    if      ( a.altcontent   ) { gres = fastoneProduct(a.altcontent,a.indsize());   }
    else if ( a.altcontentsp ) { gres = fastoneProduct(a.altcontentsp,a.indsize()); }
    else                       { oneProductPrelude(gres,a);                         }

    return gres;
}

template <> gentype &oneProductScaled(gentype &gres, const SparseVector<gentype> &a, const SparseVector<gentype> &scale)
{
    if ( a.altcontent && scale.altcontent )
    {
        int dim = a.size();

        dim = ( scale.size() < dim ) ? scale.size() : dim;

        gres = fastoneProduct(a.altcontent,dim,scale.altcontent);
    }

    else
    {
        oneProductScaledPrelude(gres,a,scale);
    }

    return gres;
}

template <> double &oneProductAssumeReal(double &res, const SparseVector<gentype> &a)
{
    if      ( a.altcontent   ) { res = fastoneProduct(a.altcontent,a.indsize());   }
    else if ( a.altcontentsp ) { res = fastoneProduct(a.altcontentsp,a.indsize()); }
    else                       { oneProductAssumeRealPrelude(res,a);               }

    return res;
}

template <> gentype &innerProduct(gentype &gres, const SparseVector<gentype> &a, const SparseVector<gentype> &b)
{
    if ( a.altcontent && b.altcontent )
    {
        int dim = a.indsize();

        dim = ( b.indsize() < dim ) ? b.indsize() : dim;

        gres = fasttwoProduct(a.altcontent,b.altcontent,dim);
    }

    else if ( a.altcontent   && b.altcontentsp ) { gres = fasttwoProductSparse(a.altcontent,  &(a.indref(0)),a.indsize(),b.altcontentsp,&(b.indref(0)),b.indsize()); }
    else if ( a.altcontentsp && b.altcontent   ) { gres = fasttwoProductSparse(a.altcontentsp,&(a.indref(0)),a.indsize(),b.altcontent,  &(b.indref(0)),b.indsize()); }
    else if ( a.altcontentsp && b.altcontentsp ) { gres = fasttwoProductSparse(a.altcontentsp,&(a.indref(0)),a.indsize(),b.altcontentsp,&(b.indref(0)),b.indsize()); }
    else                                         { innerProductPrelude(gres,a,b); }

    return gres;
}

template <> gentype &innerProductScaled(gentype &gres, const SparseVector<gentype> &a, const SparseVector<gentype> &b, const SparseVector<gentype> &scale)
{
    if ( a.altcontent && b.altcontent && scale.altcontent )
    {
        int dim = a.size();

        dim = ( b.size() < dim ) ? b.size() : dim;
        dim = ( scale.size() < dim ) ? scale.size() : dim;

        gres = fasttwoProduct(a.altcontent,b.altcontent,dim,scale.altcontent);
    }

    else
    {
        innerProductScaledPrelude(gres,a,b,scale);
    }

    return gres;
}

template <> gentype &twoProduct(gentype &gres, const SparseVector<gentype> &a, const SparseVector<gentype> &b)
{
    if ( a.altcontent && b.altcontent )
    {
        int dim = a.indsize();

        dim = ( b.indsize() < dim ) ? b.indsize() : dim;

        gres = fasttwoProduct(a.altcontent,b.altcontent,dim);
    }

    else if ( a.altcontent   && b.altcontentsp ) { gres = fasttwoProductSparse(a.altcontent,  &(a.indref(0)),a.indsize(),b.altcontentsp,&(b.indref(0)),b.indsize()); }
    else if ( a.altcontentsp && b.altcontent   ) { gres = fasttwoProductSparse(a.altcontentsp,&(a.indref(0)),a.indsize(),b.altcontent,  &(b.indref(0)),b.indsize()); }
    else if ( a.altcontentsp && b.altcontentsp ) { gres = fasttwoProductSparse(a.altcontentsp,&(a.indref(0)),a.indsize(),b.altcontentsp,&(b.indref(0)),b.indsize()); }
    else                                         { twoProductPrelude(gres,a,b);                                                                                      }

    return gres;
}

template <> gentype &twoProductScaled(gentype &gres, const SparseVector<gentype> &a, const SparseVector<gentype> &b, const SparseVector<gentype> &scale)
{
    if ( a.altcontent && b.altcontent && scale.altcontent )
    {
        int dim = a.size();

        dim = ( b.size() < dim ) ? b.size() : dim;
        dim = ( scale.size() < dim ) ? scale.size() : dim;

        gres = fasttwoProduct(a.altcontent,b.altcontent,dim,scale.altcontent);
    }

    else
    {
        twoProductScaledPrelude(gres,a,b,scale);
    }

    return gres;
}

template <> gentype &innerProductRevConj(gentype &gres, const SparseVector<gentype> &a, const SparseVector<gentype> &b)
{
    if ( a.altcontent && b.altcontent )
    {
        int dim = a.indsize();

        dim = ( b.indsize() < dim ) ? b.indsize() : dim;

        gres = fasttwoProduct(a.altcontent,b.altcontent,dim);
    }

    else if ( a.altcontent   && b.altcontentsp ) { gres = fasttwoProductSparse(a.altcontent,  &(a.indref(0)),a.indsize(),b.altcontentsp,&(b.indref(0)),b.indsize()); }
    else if ( a.altcontentsp && b.altcontent   ) { gres = fasttwoProductSparse(a.altcontentsp,&(a.indref(0)),a.indsize(),b.altcontent,  &(b.indref(0)),b.indsize()); }
    else if ( a.altcontentsp && b.altcontentsp ) { gres = fasttwoProductSparse(a.altcontentsp,&(a.indref(0)),a.indsize(),b.altcontentsp,&(b.indref(0)),b.indsize()); }
    else                                         { innerProductRevConjPrelude(gres,a,b);                                                                             }

    return gres;
}

template <> gentype &innerProductScaledRevConj(gentype &gres, const SparseVector<gentype> &a, const SparseVector<gentype> &b, const SparseVector<gentype> &scale)
{
    if ( a.altcontent && b.altcontent && scale.altcontent )
    {
        int dim = a.size();

        dim = ( b.size() < dim ) ? b.size() : dim;
        dim = ( scale.size() < dim ) ? scale.size() : dim;

        gres = fasttwoProduct(a.altcontent,b.altcontent,dim,scale.altcontent);
    }

    else
    {
        innerProductScaledRevConjPrelude(gres,a,b,scale);
    }

    return gres;
}

template <> double &innerProductAssumeReal(double &res, const SparseVector<gentype> &a, const SparseVector<gentype> &b)
{
    if ( a.altcontent && b.altcontent )
    {
        int dim = a.indsize();

        dim = ( b.indsize() < dim ) ? b.indsize() : dim;

        res = fasttwoProduct(a.altcontent,b.altcontent,dim);
    }

    else if ( a.altcontent   && b.altcontentsp ) { res = fasttwoProductSparse(a.altcontent,  &(a.indref(0)),a.indsize(),b.altcontentsp,&(b.indref(0)),b.indsize()); }
    else if ( a.altcontentsp && b.altcontent   ) { res = fasttwoProductSparse(a.altcontentsp,&(a.indref(0)),a.indsize(),b.altcontent,  &(b.indref(0)),b.indsize()); }
    else if ( a.altcontentsp && b.altcontentsp ) { res = fasttwoProductSparse(a.altcontentsp,&(a.indref(0)),a.indsize(),b.altcontentsp,&(b.indref(0)),b.indsize()); }
    else                                         { innerProductAssumeRealPrelude(res,a,b);                                                                          }

    return res;
}

template <> double &twoProductAssumeReal(double &res, const SparseVector<gentype> &a, const SparseVector<gentype> &b)
{
    if ( a.altcontent && b.altcontent )
    {
        int dim = a.indsize();

        dim = ( b.indsize() < dim ) ? b.indsize() : dim;

        res = fasttwoProduct(a.altcontent,b.altcontent,dim);
    }

    else if ( a.altcontent   && b.altcontentsp ) { res = fasttwoProductSparse(a.altcontent,  &(a.indref(0)),a.indsize(),b.altcontentsp,&(b.indref(0)),b.indsize()); }
    else if ( a.altcontentsp && b.altcontent   ) { res = fasttwoProductSparse(a.altcontentsp,&(a.indref(0)),a.indsize(),b.altcontent,  &(b.indref(0)),b.indsize()); }
    else if ( a.altcontentsp && b.altcontentsp ) { res = fasttwoProductSparse(a.altcontentsp,&(a.indref(0)),a.indsize(),b.altcontentsp,&(b.indref(0)),b.indsize()); }
    else                                         { twoProductAssumeRealPrelude(res,a,b);                                                                            }

    return res;
}

template <> gentype &threeProduct(gentype &gres, const SparseVector<gentype> &a, const SparseVector<gentype> &b, const SparseVector<gentype> &c)
{
    if ( a.altcontent && b.altcontent && c.altcontent )
    {
        int dim = a.size();

        dim = ( b.size() < dim ) ? b.size() : dim;
        dim = ( c.size() < dim ) ? c.size() : dim;

        gres = fastthreeProduct(a.altcontent,b.altcontent,c.altcontent,dim);
    }

    else
    {
        threeProductPrelude(gres,a,b,c);
    }

    return gres;
}

template <> gentype &threeProductScaled(gentype &gres, const SparseVector<gentype> &a, const SparseVector<gentype> &b, const SparseVector<gentype> &c, const SparseVector<gentype> &scale)
{
    if ( a.altcontent && b.altcontent && c.altcontent && scale.altcontent )
    {
        int dim = a.size();

        dim = ( b.size() < dim ) ? b.size() : dim;
        dim = ( c.size() < dim ) ? c.size() : dim;
        dim = ( scale.size() < dim ) ? scale.size() : dim;

        gres = fastthreeProduct(a.altcontent,b.altcontent,c.altcontent,dim,scale.altcontent);
    }

    else
    {
        threeProductScaledPrelude(gres,a,b,c,scale);
    }

    return gres;
}

template <> double &threeProductAssumeReal(double &res, const SparseVector<gentype> &a, const SparseVector<gentype> &b, const SparseVector<gentype> &c)
{
    if ( a.altcontent && b.altcontent && c.altcontent )
    {
        int dim = a.size();

        dim = ( b.size() < dim ) ? b.size() : dim;
        dim = ( c.size() < dim ) ? c.size() : dim;

        res = fastthreeProduct(a.altcontent,b.altcontent,c.altcontent,dim);
    }

    else
    {
        threeProductAssumeRealPrelude(res,a,b,c);
    }

    return res;
}

template <> gentype &fourProduct(gentype &gres, const SparseVector<gentype> &a, const SparseVector<gentype> &b, const SparseVector<gentype> &c, const SparseVector<gentype> &d)
{
    if ( a.altcontent && b.altcontent && c.altcontent && d.altcontent )
    {
        int dim = a.size();

        dim = ( b.size() < dim ) ? b.size() : dim;
        dim = ( c.size() < dim ) ? c.size() : dim;
        dim = ( d.size() < dim ) ? d.size() : dim;

        gres = fastfourProduct(a.altcontent,b.altcontent,c.altcontent,d.altcontent,dim);
    }

    else
    {
        fourProductPrelude(gres,a,b,c,d);
    }

    return gres;
}

template <> gentype &fourProductScaled(gentype &gres, const SparseVector<gentype> &a, const SparseVector<gentype> &b, const SparseVector<gentype> &c, const SparseVector<gentype> &d, const SparseVector<gentype> &scale)
{
    if ( a.altcontent && b.altcontent && c.altcontent && d.altcontent && scale.altcontent )
    {
        int dim = a.size();

        dim = ( b.size() < dim ) ? b.size() : dim;
        dim = ( c.size() < dim ) ? c.size() : dim;
        dim = ( d.size() < dim ) ? d.size() : dim;
        dim = ( scale.size() < dim ) ? scale.size() : dim;

        gres = fastfourProduct(a.altcontent,b.altcontent,c.altcontent,d.altcontent,dim,scale.altcontent);
    }

    else
    {
        fourProductScaledPrelude(gres,a,b,c,d,scale);
    }

    return gres;
}

template <> double &fourProductAssumeReal(double &res, const SparseVector<gentype> &a, const SparseVector<gentype> &b, const SparseVector<gentype> &c, const SparseVector<gentype> &d)
{
    if ( a.altcontent && b.altcontent && c.altcontent && d.altcontent )
    {
        int dim = a.size();

        dim = ( b.size() < dim ) ? b.size() : dim;
        dim = ( c.size() < dim ) ? c.size() : dim;
        dim = ( d.size() < dim ) ? d.size() : dim;

        res = fastfourProduct(a.altcontent,b.altcontent,c.altcontent,d.altcontent,dim);
    }

    else
    {
        fourProductAssumeRealPrelude(res,a,b,c,d);
    }

    return res;
}

template <> SparseVector<gentype> &operator*=(SparseVector<gentype> &left_op, const SparseVector<gentype> &right_op)
{
    if ( left_op.altcontentsp )
    {
        left_op.killaltcontent();
    }

    if ( (left_op.altcontent) && (right_op.altcontent) && ( left_op.size() == right_op.size() ) )
    {
        int dim = left_op.size();

        if ( dim )
        {
            // Note the splitting of data-dependent operations to allow for pipelining of multiplication and assignment operations.

            ((left_op.altcontent))[0] *= ((right_op.altcontent))[0];

            for ( int i = 1 ; i < dim ; ++i )
            {
                (*(left_op.content))("&",i-1) = ((left_op.altcontent))[i-1];
                ((left_op.altcontent))[i] *= ((right_op.altcontent))[i];
            }

            (*(left_op.content))("&",dim-1) = ((left_op.altcontent))[dim-1];

            left_op.resetvecID();
        }
    }

    else if ( (left_op.altcontent) && (right_op.altcontent) && ( left_op.size() < right_op.size() ) )
    {
        int dim = left_op.size();

        if ( dim )
        {
            for ( int i = 0 ; i < dim ; ++i )
            {
                (*(left_op.content))("&",i) = ( ((left_op.altcontent))[i] *= ((right_op.altcontent))[i] );
            }

            left_op.resetvecID();
        }
    }

    else if ( (left_op.altcontent) && (right_op.altcontent) && ( left_op.size() > right_op.size() ) )
    {
        if ( right_op.size() )
        {
            for ( int i = 0 ; i < right_op.size() ; ++i )
            {
                (*(left_op.content))("&",i) = ( ((left_op.altcontent))[i] *= ((right_op.altcontent))[i] );
            }

            left_op.resetvecID();
        }

        // Design decision: rather than wasting time re-sizing, just zero-out what's left

        for ( int i = right_op.size() ; i < left_op.size() ; ++i )
        {
            (*(left_op.content))("&",i) = ( ((left_op.altcontent))[i] *= 0.0 );
        }
    }

    else
    {
        multass(left_op,right_op);
    }

    return left_op;
}

int testisvnan(const gentype &x)
{
    int res = 0;

         if ( x.isValDgraph()  ) { res = testisvnan(x.cast_dgraph(0)); }
    else if ( x.isValSet()     ) { res = testisvnan(x.cast_set(0));    }
    else if ( x.isValMatrix()  ) { res = testisvnan(x.cast_matrix(0)); }
    else if ( x.isValVector()  ) { res = testisvnan(x.cast_vector(0)); }
    else if ( x.isValAnion()   ) { res = testisvnan(x.cast_anion(0));  }
    else if ( x.isValReal()    ) { res = testisvnan(x.cast_double(0)); }
    else                         { res = 0;                            }

    return res;
}

int testisinf(const gentype &x)
{
    int res = 0;

         if ( x.isValDgraph()  ) { res = testisinf(x.cast_dgraph(0)); }
    else if ( x.isValSet()     ) { res = testisinf(x.cast_set(0));    }
    else if ( x.isValMatrix()  ) { res = testisinf(x.cast_matrix(0)); }
    else if ( x.isValVector()  ) { res = testisinf(x.cast_vector(0)); }
    else if ( x.isValAnion()   ) { res = testisinf(x.cast_anion(0));  }
    else if ( x.isValReal()    ) { res = testisinf(x.cast_double(0)); }
    else                         { res = 0;                           }

    return res;
}

int testispinf(const gentype &x)
{
    int res = 0;

         if ( x.isValDgraph()  ) { res = testispinf(x.cast_dgraph(0)); }
    else if ( x.isValSet()     ) { res = testispinf(x.cast_set(0));    }
    else if ( x.isValMatrix()  ) { res = testispinf(x.cast_matrix(0)); }
    else if ( x.isValVector()  ) { res = testispinf(x.cast_vector(0)); }
    else if ( x.isValAnion()   ) { res = testispinf(x.cast_anion(0));  }
    else if ( x.isValReal()    ) { res = testispinf(x.cast_double(0)); }
    else                         { res = 0;                            }

    return res;
}

int testisninf(const gentype &x)
{
    int res = 0;

         if ( x.isValDgraph()  ) { res = testisninf(x.cast_dgraph(0)); }
    else if ( x.isValSet()     ) { res = testisninf(x.cast_set(0));    }
    else if ( x.isValMatrix()  ) { res = testisninf(x.cast_matrix(0)); }
    else if ( x.isValVector()  ) { res = testisninf(x.cast_vector(0)); }
    else if ( x.isValAnion()   ) { res = testisninf(x.cast_anion(0));  }
    else if ( x.isValReal()    ) { res = testisninf(x.cast_double(0)); }
    else                         { res = 0;                            }

    return res;
}



template <>
template <>
Vector<gentype> &Vector<gentype>::castassign(const Vector<double> &src)
{
    NiceAssert( !infsize() );

    if ( imoverhere )
    {
        MEMDEL(imoverhere);
        imoverhere = nullptr;
    }

    if ( src.imoverhere )
    {
        NiceThrow("No");
    }

    else if ( src.infsize() )
    {
        NiceThrow("No");
    }

    else
    {
        {
	    int srcsize = src.size();
	    int i;

            if ( !nbase )
	    {
	        resize(srcsize);

                if ( !(src.base()) && content && src.contentalloced() )
                {
                    if ( src.contentarray_hold() )
                    {
                        // Design decision: preallocation is duplicated

                        content->prealloc(src.contentarray_alloc());
                    }
                }
	    }

            NiceAssert( dsize == srcsize );

    	    //if ( dsize )
	    {
	        for ( i = 0 ; i < dsize ; ++i )
	        {
                    (*this)("&",i) = src.v(i);
                }
	    }
	}
    }

    return *this;
}


template <>
template <>
Vector<double> &Vector<double>::castassign(const Vector<gentype> &src)
{
    NiceAssert( !infsize() );

    if ( imoverhere )
    {
        MEMDEL(imoverhere);
        imoverhere = nullptr;
    }

    if ( src.imoverhere )
    {
        NiceThrow("No");
    }

    else if ( src.infsize() )
    {
        NiceThrow("No");
    }

    else
    {
        {
	    int srcsize = src.size();
	    int i;

            if ( !nbase )
	    {
	        resize(srcsize);

                if ( !(src.base()) && content && src.contentalloced() )
                {
                    if ( src.contentarray_hold() )
                    {
                        // Design decision: preallocation is duplicated

                        content->prealloc(src.contentarray_alloc());
                    }
                }
	    }

            NiceAssert( dsize == srcsize );

    	    //if ( dsize )
	    {
	        for ( i = 0 ; i < dsize ; ++i )
	        {
                    (*this).sv(i,(double) src(i));
                }
	    }
	}
    }

    return *this;
}


template <>
template <>
Vector<gentype> &Vector<gentype>::castassign(const Vector<int> &src)
{
    NiceAssert( !infsize() );

    if ( imoverhere )
    {
        MEMDEL(imoverhere);
        imoverhere = nullptr;
    }

    if ( src.imoverhere )
    {
        NiceThrow("No");
    }

    else if ( src.infsize() )
    {
        NiceThrow("No");
    }

    else
    {
        {
	    int srcsize = src.size();
	    int i;

            if ( !nbase )
	    {
	        resize(srcsize);

                if ( !(src.base()) && content && src.contentalloced() )
                {
                    if ( src.contentarray_hold() )
                    {
                        // Design decision: preallocation is duplicated

                        content->prealloc(src.contentarray_alloc());
                    }
                }
	    }

            NiceAssert( dsize == srcsize );

    	    //if ( dsize )
	    {
	        for ( i = 0 ; i < dsize ; ++i )
	        {
                    (*this)("&",i) = src.v(i);
                }
	    }
	}
    }

    return *this;
}

template <>
template <>
Vector<double> &Vector<double>::castassign(const Vector<int> &src)
{
    NiceAssert( !infsize() );

    if ( imoverhere )
    {
        MEMDEL(imoverhere);
        imoverhere = nullptr;
    }

    if ( src.imoverhere )
    {
        NiceThrow("No");
    }

    else if ( src.infsize() )
    {
        NiceThrow("No");
    }

    else
    {
        {
	    int srcsize = src.size();
	    int i;

            if ( !nbase )
	    {
	        resize(srcsize);

                if ( !(src.base()) && content && src.contentalloced() )
                {
                    if ( src.contentarray_hold() )
                    {
                        // Design decision: preallocation is duplicated

                        content->prealloc(src.contentarray_alloc());
                    }
                }
	    }

            NiceAssert( dsize == srcsize );

    	    //if ( dsize )
	    {
	        for ( i = 0 ; i < dsize ; ++i )
	        {
                    (*this).sv(i,(double) src.v(i));
                }
	    }
	}
    }

    return *this;
}



template <>
template <>
Vector<gentype> &Vector<gentype>::castassign(const Vector<gentype> &src)
{
    return assign(src);
}

template <>
template <>
Vector<gentype> &Vector<gentype>::castassign(const Vector<Vector<int> > &src)
{
    NiceAssert( !infsize() );

    if ( imoverhere )
    {
        MEMDEL(imoverhere);
        imoverhere = nullptr;
    }

    if ( src.imoverhere )
    {
        NiceThrow("No");
    }

    else if ( src.infsize() )
    {
        NiceThrow("No");
    }

    else
    {
        {
	    int srcsize = src.size();
	    int i;

            if ( !nbase )
	    {
	        resize(srcsize);

                if ( !(src.base()) && content && src.contentalloced() )
                {
                    if ( src.contentarray_hold() )
                    {
                        // Design decision: preallocation is duplicated

                        content->prealloc(src.contentarray_alloc());
                    }
                }
	    }

            NiceAssert( dsize == srcsize );

    	    //if ( dsize )
	    {
	        for ( i = 0 ; i < dsize ; ++i )
	        {
                    (*this)("&",i) = src(i);
                }
	    }
	}
    }

    return *this;
}

template <>
template <>
Vector<gentype> &Vector<gentype>::castassign(const Vector<SparseVector<gentype> > &src)
{
    NiceAssert( !infsize() );

    if ( imoverhere )
    {
        MEMDEL(imoverhere);
        imoverhere = nullptr;
    }

    if ( src.imoverhere )
    {
        NiceThrow("No");
    }

    else if ( src.infsize() )
    {
        NiceThrow("No");
    }

    else
    {
        {
	    int srcsize = src.size();
	    int i;

            if ( !nbase )
	    {
	        resize(srcsize);

                if ( !(src.base()) && content && src.contentalloced() )
                {
                    if ( src.contentarray_hold() )
                    {
                        // Design decision: preallocation is duplicated

                        content->prealloc(src.contentarray_alloc());
                    }
                }
	    }

            NiceAssert( dsize == srcsize );

    	    if ( dsize )
	    {

                retVector<gentype> tmpa;

	        for ( i = 0 ; i < dsize ; ++i )
	        {
                    (*this)("&",i) = src(i)(tmpa);
                }
	    }
	}
    }

    return *this;
}

template <>
template <>
Vector<gentype> &Vector<gentype>::castassign(const Vector<Vector<gentype> > &src)
{
    NiceAssert( !infsize() );

    if ( imoverhere )
    {
        MEMDEL(imoverhere);
        imoverhere = nullptr;
    }

    if ( src.imoverhere )
    {
        NiceThrow("No");
    }

    else if ( src.infsize() )
    {
        NiceThrow("No");
    }

    else
    {
        {
	    int srcsize = src.size();
	    int i;

            if ( !nbase )
	    {
	        resize(srcsize);

                if ( !(src.base()) && content && src.contentalloced() )
                {
                    if ( src.contentarray_hold() )
                    {
                        // Design decision: preallocation is duplicated

                        content->prealloc(src.contentarray_alloc());
                    }
                }
	    }

            NiceAssert( dsize == srcsize );

    	    //if ( dsize )
	    {
	        for ( i = 0 ; i < dsize ; ++i )
	        {
                    (*this)("&",i) = src(i);
                }
	    }
	}
    }

    return *this;
}


template <>
template <>
Vector<SparseVector<gentype> >& Vector<SparseVector<gentype> >::castassign(const Vector<SparseVector<gentype> > &src)
{
    return assign(src);
}










template <>
Vector<gentype> &SparseToNonSparse(Vector<gentype> &res, const SparseVector<gentype> &src)
{
    res.zero();

    int size = src.indsize();
    int nns = src.nearnonsparse();
    int prevind = -1;
    int baseind = 0;

    if ( size && nns && src.altcontent )
    {
        res.resize(size);

	for ( int i = 0 ; i < size ; ++i )
	{
            res("&",i).force_double() = src.altcontent[i];
        }
    }

    else if ( size && nns )
    {
        res.resize(size);

	for ( int i = 0 ; i < size ; ++i )
	{
            res.sv(i,src.direcref(i));
        }
    }

    else if ( size )
    {
	int i;

	for ( i = 0 ; i < size ; ++i )
	{
            if ( src.ind(i) == prevind+1 )
            {
                res.append(-1,src.direcref(i));
            }

            else if ( ( baseind < INDF1OFFSTART ) && ( src.ind(i) >= INDF1OFFSTART ) && ( src.ind(i) <= INDF1OFFEND ) )
            {
                baseind = INDF1OFFSTART;

                {
                    const static gentype tmp(":");

                    res.append(-1,tmp);
                }

                for ( int ii = baseind ; ii < src.ind(i) ; ++ii )
                {
                    const static gentype tmp('N');

                    res.append(-1,tmp);
                }

                {
                    res.append(-1,src.direcref(i));
                }
            }

            else if ( ( baseind < INDF2OFFSTART ) && ( src.ind(i) >= INDF2OFFSTART ) && ( src.ind(i) <= INDF2OFFEND ) )
            {
                baseind = INDF2OFFSTART;

                {
                    const static gentype tmp("::");

                    res.append(-1,tmp);
                }

                for ( int ii = baseind ; ii < src.ind(i) ; ++ii )
                {
                    const static gentype tmp('N');

                    res.append(-1,tmp);
                }

                {
                    res.append(-1,src.direcref(i));
                }
            }

            else if ( ( baseind < INDF3OFFSTART ) && ( src.ind(i) >= INDF3OFFSTART ) && ( src.ind(i) <= INDF3OFFEND ) )
            {
                baseind = INDF3OFFSTART;

                {
                    const static gentype tmp(":::");

                    res.append(-1,tmp);
                }

                for ( int ii = baseind ; ii < src.ind(i) ; ++ii )
                {
                    const static gentype tmp('N');

                    res.append(-1,tmp);
                }

                {
                    res.append(-1,src.direcref(i));
                }
            }

            else if ( ( baseind < INDF4OFFSTART ) && ( src.ind(i) >= INDF4OFFSTART ) && ( src.ind(i) <= INDF4OFFEND ) )
            {
                baseind = INDF4OFFSTART;

                {
                    const static gentype tmp("::::");

                    res.append(-1,tmp);
                }

                for ( int ii = baseind ; ii < src.ind(i) ; ++ii )
                {
                    const static gentype tmp('N');

                    res.append(-1,tmp);
                }

                {
                    res.append(-1,src.direcref(i));
                }
            }

            else if ( (src.ind(i)-baseind) >= DEFAULT_TUPLE_INDEX_STEP )
            {
                goover:

                baseind += DEFAULT_TUPLE_INDEX_STEP;

                {
                    const static gentype tmp("~");

                    res.append(-1,tmp);
                }

                if ( (src.ind(i)-baseind) >= DEFAULT_TUPLE_INDEX_STEP )
                {
                    goto goover;
                }

                for ( int ii = baseind ; ii < src.ind(i) ; ++ii )
                {
                    const static gentype tmp('N');

                    res.append(-1,tmp);
                }

                {
                    res.append(-1,src.direcref(i));
                }
            }

            else
            {
                for ( int ii = baseind ; ii < src.ind(i) ; ++ii )
                {
                    const static gentype tmp('N');

                    res.append(-1,tmp);
                }

                {
                    res.append(-1,src.direcref(i));
                }
            }

            prevind = src.ind(i);
	}
    }

    return res;
}



template <>
Vector<gentype> &SparseToNonSparse(Vector<gentype> &res, const SparseVector<double> &src)
{
    res.zero();

    int size = src.indsize();
    int nns = src.nearnonsparse();
    int prevind = -1;
    int baseind = 0;

    if ( size && nns )
    {
        res.resize(size);

	for ( int i = 0 ; i < size ; ++i )
	{
            res("&",i).force_double() = src.direval(i);
        }
    }

    else if ( size )
    {
	int i;

	for ( i = 0 ; i < size ; ++i )
	{
            if ( src.ind(i) == prevind+1 )
            {
                gentype tmp(src.direval(i));

                res.append(-1,tmp);
            }

            else if ( ( baseind < INDF1OFFSTART ) && ( src.ind(i) >= INDF1OFFSTART ) && ( src.ind(i) <= INDF1OFFEND ) )
            {
                baseind = INDF1OFFSTART;

                {
                    const static gentype tmp(":");

                    res.append(-1,tmp);
                }

                for ( int ii = baseind ; ii < src.ind(i) ; ++ii )
                {
                    const static gentype tmp('N');

                    res.append(-1,tmp);
                }

                {
                    gentype tmp(src.direval(i));

                    res.append(-1,tmp);
                }
            }

            else if ( ( baseind < INDF2OFFSTART ) && ( src.ind(i) >= INDF2OFFSTART ) && ( src.ind(i) <= INDF2OFFEND ) )
            {
                baseind = INDF2OFFSTART;

                {
                    const static gentype tmp("::");

                    res.append(-1,tmp);
                }

                for ( int ii = baseind ; ii < src.ind(i) ; ++ii )
                {
                    const static gentype tmp('N');

                    res.append(-1,tmp);
                }

                {
                    gentype tmp(src.direval(i));

                    res.append(-1,tmp);
                }
            }

            else if ( ( baseind < INDF3OFFSTART ) && ( src.ind(i) >= INDF3OFFSTART ) && ( src.ind(i) <= INDF3OFFEND ) )
            {
                baseind = INDF3OFFSTART;

                {
                    const static gentype tmp(":::");

                    res.append(-1,tmp);
                }

                for ( int ii = baseind ; ii < src.ind(i) ; ++ii )
                {
                    const static gentype tmp('N');

                    res.append(-1,tmp);
                }

                {
                    gentype tmp(src.direval(i));

                    res.append(-1,tmp);
                }
            }

            else if ( ( baseind < INDF4OFFSTART ) && ( src.ind(i) >= INDF4OFFSTART ) && ( src.ind(i) <= INDF4OFFEND ) )
            {
                baseind = INDF4OFFSTART;

                {
                    const static gentype tmp("::::");

                    res.append(-1,tmp);
                }

                for ( int ii = baseind ; ii < src.ind(i) ; ++ii )
                {
                    const static gentype tmp('N');

                    res.append(-1,tmp);
                }

                {
                    gentype tmp(src.direval(i));

                    res.append(-1,tmp);
                }
            }

            else if ( (src.ind(i)-baseind) >= DEFAULT_TUPLE_INDEX_STEP )
            {
                goover:

                baseind += DEFAULT_TUPLE_INDEX_STEP;

                {
                    const static gentype tmp("~");

                    res.append(-1,tmp);
                }

                if ( (src.ind(i)-baseind) >= DEFAULT_TUPLE_INDEX_STEP )
                {
                    goto goover;
                }

                for ( int ii = baseind ; ii < src.ind(i) ; ++ii )
                {
                    const static gentype tmp('N');

                    res.append(-1,tmp);
                }

                {
                    gentype tmp(src.direval(i));

                    res.append(-1,tmp);
                }
            }

            else
            {
                for ( int ii = baseind ; ii < src.ind(i) ; ++ii )
                {
                    const static gentype tmp('N');

                    res.append(-1,tmp);
                }

                {
                    gentype tmp(src.direval(i));

                    res.append(-1,tmp);
                }
            }

            prevind = src.ind(i);
	}
    }

    return res;
}























































