
//FIXME: dense derivatives/integrals need to be defined for *all* kernels if isprod set - 1xxx and 2xxx
//FIXME: for calcDenseDerivPair and calcDenseIntPair have dim arg, and extra pairs if dim = 1
//                       (also return symmetry argument to say if negate or don't negate)
//FIXME: define a related kernel for integral, one for derivative

 //     8  | Rational quadratic     | ( 1 + d/(2*r0*r0*r1) )^(-r1)                         (was 1 - d/(d+r0))
 //     9  | Multiquadratic%        | sqrt( d/(r0.r0) + r1^2 )
 //    10  | Inverse multiquadric   | 1/sqrt( d/(r0.r0) + r1^2 )
 //    11  | Circular*              | 2/pi * arccos(-sqrt(d)/r0) - 2/pi * sqrt(d)/r0 * sqrt(1 - d/r0^2)
 //    12  | Sperical+              | 1 - 3/2 * sqrt(d)/r0 + 1/2 * sqrt(d)^3/r0^3
 //    13  | Wave                   | sinc(sqrt(d)/r0)
 //    14  | Power                  | -sqrt(d/(r0.r0))^r1
 //    15  | Log#                   | -log(sqrt(d/(r0.r0))^r1 + 1)
 //    18  | Bessel^                | J_(i0+1) ( r1.sqrt(d)/r0) ) / ( (sqrt(d)/r0)^(-i0.(r1+1)) )
 //    19  | Cauchy                 | 1/(1+(d/(r0.r0)))
 //    23  | Generalised T-student  | 1/(1+(sqrt(d)/r0)^r1)
 //    25  | Weak fourier           | pi.cosh(pi-(sqrt(d)/r0))
 //    26  | Thin spline 1          | ((d/r0)^(r1+0.5))
 //    27  | Thin spline 2          | ((d/r0)^r1).ln(sqrt(d/r0))
 //    33  | Uniform                | 1/(2.r0) ( 1 if real(sqrt(d)) < r0, 0 otherwise )
 //    34  | Triangular             | (1-sqrt(d)/r0)/r0 if real(sqrt(d)) < r0, 0 otherwise )
 //    35  | Even-integer Matern    | ((2^(1-i0))/gamma(i0)).((sqrt(2.i0).sqrt(d)/r0)^i0).K_r1(sqrt(2.i0).sqrt(d)/r0)
 //    37  | Half-integer Matern    | exp(-(sqrt(2.(i0+1/2))/r0).sqrt(d)) . (gamma(i0+1)/gamma((2.i0)+1)) . sum_{i=0,1,...,i0}( ((i0+1)!/(i!.(i0-i)!)) . pow((sqrt(8.(i0+1/2))/r0).sqrt(d),i0-i) )
 //    40  | 5/2-Matern             | (1+((sqrt(5)/r0).sqrt(d))+((5/(3.r0*r0))*d)) . exp(-(sqrt(5)/r0).sqrt(d))
 //    47  | Sinc Kernel (Tobar)    | sinc(sqrt(d)/r0).cos(2*pi*sqrt(d)/(r0.r1))
 //    49  | Gaussian Harmonic      | (1-r2)/(1-r2.exp(-d/(2.r0.r0)-r1))

//FIXME: do dense integral/derivative versions

 //    16  | Spline                 | prod_k ( 1 + (x_k/r0).(y_k/r0) + (x_k/r0).(y_k/r0).min(x_k/r0,y_k/r0) - ((x_k/r0+y_k/r0).min(x_k/r0,y_k/r0)^2)/2 + (min(x_k/r0,y_k/r0)^3)/3 )
 //    17  | B-Spline               | sum_k B_(2i0+1)(x_k/r0-y_k/r0)
 //    20  | Chi-square             | 1 - sum_k (2((x_k/r0).(y_k/r0)))/(x_k/r0+y_k/r0)
 //    21  | Histogram              | sum_k min(x_k/r0,y_k/r0)
 //    22  | Generalised histogram  | sum_k min(|x_k/r0|^r1,|y_k/r0|^r2)
 //    36  | Weiner                 | prod_i min(x_i/r0,y_i/r0)








//FIXME phantomxyzxyz - search and fixed inner normalisation (if xnorm is zero this means vector is zero, so remove from calculation altogether!)
                
/*
TO DO: have outer layer vector of gradient_order/direction pairs and weights, this defines an operator that applies to each variable in K, constructing a matrix kernel
K evaluation seems to return appropriate matrices
require farfar zero, then increment
scale up to largest order? (block diagonal?)

if farfar present:

A.(([ff'].[d])K) -> (A.[ff';ff';...]).[d].K

xaignorefarfar = 1 is the same as removing it, so no need to adjust x
xagradordadd = amount to be added to xagradOrder, use this rather than modify x
*/


//TO DO: need gradients for all KK1,KK2,KK3,KK4,KK6,KKm for at least two xagradOrder non-zero
//can do this easily enough for strictly inner-product kernels by direct-producting onto the result of K2 differentiation, so that must suffice for now

//TO DO: for non-mercer kernels, have krein-rectified mercer counterparts

//FIXME: setRandFeats needs draw NRFF variant

//FIXME: test gradient implementation

//FIXME: implement gradients and rank constraints on dK d2K etc forms
//FIXME: to do this, need to fix yyycK2 implementation to call further down the tree for d..K..del.. gradients

//FIXME: kernel chains, pass pxyprod in
//FIXME: kernel inheritance for K1,K3,Km odd
//FIXME: complex kernels for K1,K3,Km odd
//FIXME: kernel8xx for K1,K3,Km odd
//FIXME: do magterm for m != 2 + everything other than the most basic LL2,dLL2 functionality




//
// Basic kernel class
//
// Version: 7
// Date: 08/04/2016
// Written by: Alistair Shilton (AlShilton@gmail.com)
// Copyright: all rights reserved
//

//NB - to add new kernel definitions search for ADDHERE
//KERNELSHERE - labels where kernel is actually evaluated


#ifndef _mercer_h
#define _mercer_h

#include <stdio.h>
#include <stdlib.h>
#include <iostream>
#include <string.h>
#include <math.h>
#ifdef ENABLE_THREADS
#include <atomic>
#include <mutex>
#endif
#include "qswapbase.hpp"
#include "gentype.hpp"
#include "vector.hpp"
#include "sparsevector.hpp"
#include "matrix.hpp"
#include "numbase.hpp"
#include "mlcommon.hpp"



typedef const char * charptr;


//#define NUMMLINSTANCES             1024
#define STARTMLID 256

#define DEFAULTZEROPOINT -1.0

#define DEFAULT_VECT_INDEX -4
#define VECINFOSCRATCHSIZE 4*DEFAULT_NUM_TUPLES


#define DEFAULT_NUMKERNSAMP 10



// Note on kernel numbering
//
// In the 0-999 range:
//
// 0  -99  are regular kernels (which may or may not be Mercer)
// 100-199 are 0/1 neural network kernels (monotonic increasing functions of
//         x'y typically but not always with outputs ranging 0 to 1)
// 200-299 are -1/+1 neural network kernels (monotonic increasing functions of
//         x/y typically but not always with outputs ranging -1 to 1)
// 300-399 distance kernels (return -1/2 ||x-y|| for different norms).  Used
//         by KNN for example.
//
// 400-449 monotonic density kernels of the form prod_k f(x_k-y_k), where f
//         is monotonic increasing, 0 < f(x) < 1, and f(0) = 1/2
// 450-499 monotonic density kernels of the form prod_k f(x_k-y_k), where f
//         is monotonic decreasing, 0 < f(x) < 1, and f(0) = 1/2
//         (as per 400-449 but with x/y order reversed)
//
// 500-549 monotonic dense derivatives of kernels 400-449 - that is,
//         prod_k f'(x_k-y_k), where f' is the derivative of monotonic function
//         f for corresponding monotonic density kernel
// 550-599 monotonic dense derivatives of kernels 450-499 - that is,
//         prod_k f'(x_k-y_k), where f' is the derivative of monotonic function
//         f for corresponding monotonic density kernel
//
// 600-649 monotonic density kernels of the form prod_k f(x_k-y_k), where f
//         is monotonic increasing, -1 < f(x) < 1, and f(0) = 0
// 650-699 monotonic density kernels of the form prod_k f(x_k-y_k), where f
//         is monotonic decreasing, -1 < f(x) < 1, and f(0) = 0
//
// 700-749 monotonic dense derivatives of kernels 600-649 - that is,
//         prod_k f'(x_k-y_k), where f' is the derivative of monotonic function
//         f for corresponding monotonic density kernel
// 750-799 monotonic dense derivatives of kernels 650-699 - that is,
//         prod_k f'(x_k-y_k), where f' is the derivative of monotonic function
//         f for corresponding monotonic density kernel
//
// 800-899 use altcallback to evaluate kernel
//         f for corresponding monotonic density kernel
//
// 1xxx: dense derivative version (at least in the isprod case)
// 2xxx: dense integral version (at least in the isprod case)




//
// Kernel Descriptions
// ===================
//
// rj = real constant j
// ij = integer constant j
// var(0,0) (x) = a = x'x
// var(0,1) (y) = b = y'y
// var(0,2) (z) = z = x'y
// var(0,3) = d = ||x-y||_2^2 = a+b-2*z
// (var(0,3) is substituted out for var(0,0)+var(0,1)-2*var(0,2) at end)
//
//KERNELSHERE - labels where kernel is actually evaluated
//
//- r0 should be lengthscale always but isn't for these kernels
//
// Number | Name                   | K(x,y)
// -------+------------------------+------------------------------
//     0  | Constant               | r1
//     1  | Linear                 | z/(r0.r0)
//     2  | Polynomial             | ( r1 + z/(r0.r0) )^i0
//     3  | Gaussian***            | exp(-d/(2.r0.r0)-r1)
//     4  | Laplacian***           | exp(-sqrt(d)/r0-r1)
//     5  | Polynoise***           | exp(-sqrt(d)^r1/(r1*r0^r1)-r2)
//     6  | ANOVA                  | sum_k exp(-r4*((x_k/r0)^r1-(y_k/r0)^r1)^r2)^r3
//     7  | Sigmoid#               | tanh( z/(r0.r0) + r1 )
//     8  | Rational quadratic     | ( 1 + d/(2*r0*r0*r1) )^(-r1)                         (was 1 - d/(d+r0))
//     9  | Multiquadratic%        | sqrt( d/(r0.r0) + r1^2 )
//    10  | Inverse multiquadric   | 1/sqrt( d/(r0.r0) + r1^2 )
//    11  | Circular*              | 2/pi * arccos(-sqrt(d)/r0) - 2/pi * sqrt(d)/r0 * sqrt(1 - d/r0^2)
//    12  | Sperical+              | 1 - 3/2 * sqrt(d)/r0 + 1/2 * sqrt(d)^3/r0^3
//    13  | Wave                   | sinc(sqrt(d)/r0)
//    14  | Power                  | -sqrt(d/(r0.r0))^r1
//    15  | Log#                   | -log(sqrt(d/(r0.r0))^r1 + 1)
//    16  | Spline                 | prod_k ( 1 + (x_k/r0).(y_k/r0) + (x_k/r0).(y_k/r0).min(x_k/r0,y_k/r0) - ((x_k/r0+y_k/r0).min(x_k/r0,y_k/r0)^2)/2 + (min(x_k/r0,y_k/r0)^3)/3 )
//    17  | B-Spline               | sum_k B_(2i0+1)(x_k/r0-y_k/r0)
//    18  | Bessel^                | J_(i0+1) ( r1.sqrt(d)/r0) ) / ( (sqrt(d)/r0)^(-i0.(r1+1)) )
//    19  | Cauchy                 | 1/(1+(d/(r0.r0)))
//    20  | Chi-square             | 1 - sum_k (2((x_k/r0).(y_k/r0)))/(x_k/r0+y_k/r0)
//    21  | Histogram              | sum_k min(x_k/r0,y_k/r0)
//    22  | Generalised histogram  | sum_k min(|x_k/r0|^r1,|y_k/r0|^r2)
//    23  | Generalised T-student  | 1/(1+(sqrt(d)/r0)^r1)
//    24  | Vovk's real            | (1-((z/(r0.r0))^i0))/(1-(z/(r0.r0)))
//    25  | Weak fourier           | pi.cosh(pi-(sqrt(d)/r0))
//    26  | Thin spline 1          | ((d/r0)^(r1+0.5))
//    27  | Thin spline 2          | ((d/r0)^r1).ln(sqrt(d/r0))
//    28  | Generic                | (user defined)
//    29  | Arc-cosine~            | (1/pi) (r0.sqrt(a))^i0 (r0.sqrt(b))^i0 Jn(arccos(z/(sqrt(a).sqrt(b))))
//    30  | Chaotic logistic       | <phi_{sigma,n}(x/r0),phi_{sigma,n}(y/r0)>
//    31  | Summed chaotic logistic| sum_{0,n} Kn(x,y)
//    32  | Diagonal               | r1 if i == j >= 0, 0 otherwise
//    33  | Uniform                | 1/(2.r0) ( 1 if real(sqrt(d)) < r0, 0 otherwise )
//    34  | Triangular             | (1-sqrt(d)/r0)/r0 if real(sqrt(d)) < r0, 0 otherwise )
//    35  | Even-integer Matern    | ((2^(1-i0))/gamma(i0)).((sqrt(2.i0).sqrt(d)/r0)^i0).K_r1(sqrt(2.i0).sqrt(d)/r0)
//    36  | Weiner                 | prod_i min(x_i/r0,y_i/r0)
//    37  | Half-integer Matern    | exp(-(sqrt(2.(i0+1/2))/r0).sqrt(d)) . (gamma(i0+1)/gamma((2.i0)+1)) . sum_{i=0,1,...,i0}( ((i0+1)!/(i!.(i0-i)!)) . pow((sqrt(8.(i0+1/2))/r0).sqrt(d),i0-i) )
//    38  | 1/2-Matern             | exp(-sqrt(d)/r0)
//    39  | 3/2-Matern             | (1+((sqrt(3)/r0).sqrt(d))) . exp(-(sqrt(3)/r0).sqrt(d))
//    40  | 5/2-Matern             | (1+((sqrt(5)/r0).sqrt(d))+((5/(3.r0*r0))*d)) . exp(-(sqrt(5)/r0).sqrt(d))
//    41  | RBF-rescale            | exp(log(z)/(2.r0.r0))
//    42  | Inverse Gudermannian   | igd(z/(r0.r0))
//    43  | Log ratio              | log((1+z/(r0.r0))/(1-z/(r0.r0)))
//    44  | Exponential***         | exp(z/(r0.r0)-r1)
//    45  | Hyperbolic sine        | sinh(z/(r0.r0))
//    46  | Hyperbolic cosine      | cosh(z/(r0.r0))
//    47  | Sinc Kernel (Tobar)    | sinc(sqrt(d)/r0).cos(2*pi*sqrt(d)/(r0.r1))
//    48  | LUT kernel             | r1((int) x, (int) y) if r1 is a matrix, otherwise (r1 if x != y, 1 if x == y)
//    49  | Gaussian Harmonic      | (1-r2)/(1-r2.exp(-d/(2.r0.r0)-r1))
//    50  | Alt arc-cosine         | pi - arccos(z/r0.r0)
//    51  | Vovk-like              | 1/(2-(z/r0.r0))
//    52  | Radius (see Bock)      | ((a.b)^(1/m))/(r0.r0) (just use a normalised linear kernel for the angular kernel).
//    53  | Radius (see Bock)      | (((1-(1-a^r1)^r2).(1-(1-b^r1)^r2))^(1/m))/(r0.r0) (just use a normalised linear kernel for the angular kernel).
//        |                        |
//   100  | Linear 0/1             | z/(r0*r0)
//   101  | Logistic 0/1           | 1/(1+exp(-z/(r0*r0)))
//   102  | Generalised logstic 0/1| 1/(1+r1*exp(-r2*(z-r3)/(r0*r0)))^(1/r2)
//   103  | Heavyside 0/1          | 0 if real(z) < 0, 1 otherwise
//   104  | ReLU 0/1               | 0 if real(z) < 0, z/(r0*r0) otherwise
//   105  | Softplus 0/1           | ln(r1+exp(z/(r0*r0)))
//   106  | Leaky ReLU 0/1         | r1*z/(r0*r0) if real(z) < 0, z/(r0*r0) otherwise
//        |                        |
//   200  | Linear -1/1            | z/(r0*r0)-1
//   201  | Logistic -1/1          | 2/(1+exp(-z/(r0*r0))) - 1
//   202  | Generalised logstc -1/1| 2/(1+r1*exp(-r2*(z-r3)/(r0*r0)))^(1/r2) - 1
//   203  | Heavyside -1/1         | -1 if real(z) < 0, 1 otherwise
//   204  | Relu -1/1              | -1 if real(z) < 0, z/(r0*r0)-1 otherwise
//   205  | Softplus -1/1          | 2.ln(r1+exp(z/(r0*r0))) - 1
//        |                        |
//   300  | Euclidean distance$    | -1/2 d/(r0.r0)
//   301  | 1-norm distance$       | -1/2 ||x-y||_1^2/(r0.r0)
//   302  | inf-norm distance$     | -1/2 ||x-y||_inf^2/(r0.r0)
//   303  | 0-norm distance$       | -1/2 ||x-y||_0^2/(r0.r0)
//   304  | r0-norm distance$      | -1/2 ||x-y||_real(r1)^2/(r0.r0)
//        |                        |
//   400  | Monotnic 0/1 dense 1   | (K600(x,y)+1)/2
//   401  | Monotnic 0/1 dense 2   | (K601(x,y)+1)/2
//   402  | Monotnic 0/1 dense 3   | (K602(x,y)+1)/2
//   403  | Monotnic 0/1 dense 4   | (K603(x,y)+1)/2
//   404  | Monotnic 0/1 dense 5   | (K604(x,y)+1)/2
//        |                        |
//   450  | Monotnic 0/1 dense 1rev| (K650(x,y)+1)/2
//   451  | Monotnic 0/1 dense 2rev| (K651(x,y)+1)/2
//   452  | Monotnic 0/1 dense 3rev| (K652(x,y)+1)/2
//   453  | Monotnic 0/1 dense 4rev| (K653(x,y)+1)/2
//   454  | Monotnic 0/1 dense 5rev| (K654(x,y)+1)/2
//        |                        |
//   500  | Monot dense deriv 1&   | K700(x,y)/2
//   501  | Monot dense deriv 2&   | K701(x,y)/2
//   502  | Monot dense deriv 3&'  | K702(x,y)/2
//   503  | Monot dense deriv 4&'  | K703(x,y)/2
//   504  | Monot dense deriv 5&'  | K704(x,y)/2
//        |                        |
//   550  | Monot dens deriv 1rev& | K750(x,y)/2
//   551  | Monot dens deriv 2rev& | K751(x,y)/2
//   552  | Monot dens deriv 3rev&`| K752(x,y)/2
//   553  | Monot dens deriv 5rev&`| K753(x,y)/2
//   554  | Monot dens deriv 5rev&`| K754(x,y)/2
//        |                        |
//   600  | Monot. -1/+1 density 1 | prod_k ( 2/(1+exp(-(x_k-y_k)/r0)) - r1 )
//   601  | Monot. -1/+1 density 2 | prod_k ( erf((x_k-y_k)/r0 - r1 )
//   602  | Monot. -1/+1 density 3 | 2/(1+exp(-min_k(x_k-y_k)/r0)) - r1
//   603  | Monot. -1/+1 density 4 | -1 if real(min_k(x_k-y_k)) < 0, 1 otherwise
//   604  | Monot. -1/+1 density 5 | max_k(x_k-y_k)/r0
//        |                        |
//   650  | Monot. -1/+1 dense 1rev| K600(y,x)
//   651  | Monot. -1/+1 dense 2rev| K601(y,x)
//   652  | Monot. -1/+1 dense 3rev| K602(y,x)
//   653  | Monot. -1/+1 dense 4rev| K603(y,x)
//   654  | Monot. -1/+1 dense 5rev| K604(y,x)
//        |                        |
//   700  | Mon -1+1 dens deriv 1& | prod_k ( (2/r0).exp(-(x_k-y_k)/r0)/(1+exp(-(x_k-y_k)/r0))^2 )
//   701  | Mon -1+1 dens deriv 2& | prod_k ((2/r0)/sqrt(pi))*exp(-((x_k-y_k)/r0)^2)
//   702  | Mon -1+1 dens deriv 3&'| (2/r0).exp(-min_k(x_k-y_k)/r0)/((1+exp(-max_k(x_k-y_k)/r0))^2)
//   703  | Mon -1+1 dens deriv 4&'| 0
//   704  | Mon -1+1 dens deriv 5&'| 1/r0
//        |                        |
//   750  | Mon dens+- deriv 1rev& | -K700(y,x)
//   751  | Mon dens+- deriv 2rev& | -K701(y,x)
//   752  | Mon dens+- deriv 3rev&`| -K702(y,x)
//   753  | Mon dens+- deriv 5rev&`| -K703(y,x)
//   754  | Mon dens+- deriv 5rev&`| -K704(y,x)
//        |                        |
//   8xx  | altcallback kernel eval| Uses altcallback to evaluate kernel.  Assumed symmetric
//        |                        |
//  1003  | Gaussian dense deriv   | exp(-r1).prod_k d/dx_k exp(-(x_k-y_k)^2/(2.r0.r0)) = exp(-r1).prod_k (-(x_k-y_k)/(r0.r0)) exp(-(x_k-y_k)^2/(2.r0.r0))
//        | (Dense deriv of RBF 3) |  = exp(-d/(2.r0.r0)-r1). prod_k ((x_k-y_k)/(r0.r0))
//  1038  | 1/2-Matern dense deriv | d/dx_0 exp(-|x_0-y_0|/r0)
//        | (isprod only)          |  = -sgn(x_0-y_0)/r0 exp(-|x_0-y_0|/r0)
//  1039  | 3/2-Matern dense deriv | d/dx_0 (1+((sqrt(3)/r0).|x_0-y_0|)) . exp(-(sqrt(3)/r0).|x_0-y_0|)
//        | (isprod only)          |  =                                 (sqrt(3)/r0) . sgn(x_0-y_0) . exp(-(sqrt(3)/r0).|x_0-y_0|)
//        |                        |    -(1+((sqrt(3)/r0).|x_0-y_0|)) . (sqrt(3)/r0) . sgn(x_0-y_0) . exp(-(sqrt(3)/r0).|x_0-y_0|)
//        |                        |  = -(sqrt(3)/r0) . sgn(x_0-y_0) . exp(-(sqrt(3)/r0).|x_0-y_0|) . (1+((sqrt(3)/r0).|x_0-y_0|))
//        |                        |
//  2003  | Gaussian Dense Ingegral| exp(-r1).prod_k int_{x=-inf}^{x_k} exp(-(x-y_k)^2/(2.r0.r0)) dx
//        | (Dense integ of RBF 3) |  = exp(-r1).prod_k int_{x=-inf}^{x_k-y_k} exp(-(x/(sqrt(2).r0))^2) dx
//        |                        |  = exp(-r1).prod_k sqrt(2).r_0 int_{x=-inf}^{x_k-y_k} exp(-(x/(sqrt(2).r0))^2) d(x/sqrt(2).r_0)
//        |                        |  = exp(-r1).prod_k sqrt(2).r_0 sqrt(pi)/2 2/sqrt(pi) int_{x=-inf}^{(x_k-y_k)/(sqrt(2).r0)} exp(-x^2) dx
//        |                        |  = exp(-r1).prod_k sqrt(pi/2).r_0 ( 1 + erf((x_k-y_k)/(sqrt(2).r0)) )
//  2038  | 1/2-Matern dense integ | int_{-inf}^{x_0} exp(-|z-y_0|/r0) dz
//        | (isprod only)          |  = int_{-inf}^{x_0-y_0} exp(-|z|/r0) dz
//        |                        | if x_0<y_0: = int_{-inf}^{x_0-y_0} exp(z/r0) dz
//        |                        |             = r0 . ( exp((x_0-y_0)/r0) - exp(-inf) )
//        |                        |             = r0 . exp((x_0-y_0)/r0)
//        |                        |             = r0 . exp(-|x_0-y_0|/r0)
//        |                        | if x_0>y_0: = int_{-inf}^0 exp(z/r0) + inf_0^{x_0-y_0} exp(-z/r0) dz
//        |                        |             = r0 . ( exp(0) - exp(-inf) ) - r0 . ( exp(-(x_0-y_0)/r0) - exp(0) )
//        |                        |             = r0 . ( 2 - exp(-|x_0-y_0|/r0) )
//  2039  | 3/2-Matern dense integ | int_{-inf}^{x_0} (1+((sqrt(3)/r0).|x-y_0|)) . exp(-(sqrt(3)/r0).|z-y_0|) dz
//        | (isprod only)          |  = int_{-inf}^{x_0} exp(-(sqrt(3)/r0).|z-y_0|) dz
//        |                        |  + int_{-inf}^{x_0} ((sqrt(3)/r0).|z-y_0|) . exp(-(sqrt(3)/r0).|z-y_0|) dz
//        |                        |  = int_{-inf}^{x_0} exp(-(sqrt(3)/r0).|z-y_0|) dz
//        |                        |  + int_{-inf}^{x_0-y_0} ((sqrt(3)/r0).|z|) . exp(-(sqrt(3)/r0).|z|) dz
//        |                        |  = int_{-inf}^{x_0} exp(-(sqrt(3)/r0).|z-y_0|) dz
//        |                        |  + (r0/sqrt(3)) . int_{-inf}^{(sqrt(3)/r0).(x_0-y_0)} |z|.exp(-|z|) dz
//        |                        | if x_0<y_0: = (r0/sqrt(3)) . exp(-(sqrt(3)/r0).|x_0-y_0|)
//        |                        |             - (r0/sqrt(3)) . int_{-inf}^{-(sqrt(3)/r0).|x_0-y_0|} (-|z|).exp(-|z|) dz
//        |                        |             = (r0/sqrt(3)) . exp(-(sqrt(3)/r0).|x_0-y_0|)
//        |                        |             + (r0/sqrt(3)) . int_{-inf}^{-(sqrt(3)/r0).|x_0-y_0|} (-|z|).exp(-|z|) d(-|z|)
//        |                        |             = (r0/sqrt(3)) . exp(-(sqrt(3)/r0).|x_0-y_0|)
//        |                        |             + (r0/sqrt(3)) . int_{-inf}^{-(sqrt(3)/r0).|x_0-y_0|} z.exp(z) dz
//        |                        |             = (r0/sqrt(3)) . exp(-(sqrt(3)/r0).|x_0-y_0|)
//        |                        |             + (r0/sqrt(3)) . ( (-(sqrt(3)/r0).|x_0-y_0|-1).exp(-(sqrt(3)/r0).|x_0-y_0|) )
//        |                        |             = (r0/sqrt(3)) . exp(-(sqrt(3)/r0).|x_0-y_0|)
//        |                        |             - (r0/sqrt(3)) . (sqrt(3)/r0) . |x_0-y_0| . exp(-(sqrt(3)/r0).|x_0-y_0|) )
//        |                        |             - (r0/sqrt(3)) . exp(-(sqrt(3)/r0).|x_0-y_0|)
//        |                        |             = -|x_0-y_0| . exp(-(sqrt(3)/r0).|x_0-y_0|) )
//        |                        | if x_0>y_0: = (r0/sqrt(3)) . ( 2 - exp(-(sqrt(3)/r0).|x_0-y_0|) )
//        |                        |             - (r0/sqrt(3)) . int_{-inf}^{0} (-|z|).exp(-|z|) dz
//        |                        |             - (r0/sqrt(3)) . int_{0}^{(sqrt(3)/r0).|x_0-y_0|} (-|z|).exp(-|z|) dz
//        |                        |             = (r0/sqrt(3)) . ( 2 - exp(-(sqrt(3)/r0).|x_0-y_0|) )
//        |                        |             + (r0/sqrt(3)) . int_{-inf}^{0} (-|z|).exp(-|z|) d(-|z|)
//        |                        |             + (r0/sqrt(3)) . int_{0}^{(sqrt(3)/r0).|x_0-y_0|} (-z).exp(-z) d(-z)
//        |                        |             = (r0/sqrt(3)) . ( 2 - exp(-(sqrt(3)/r0).|x_0-y_0|) )
//        |                        |             + (r0/sqrt(3)) . int_{-inf}^{0} z.exp(z) dz
//        |                        |             + (r0/sqrt(3)) . int_{0}^{-(sqrt(3)/r0).|x_0-y_0|} z.exp(z) dz
//        |                        |             = (r0/sqrt(3)) . ( 2 - exp(-(sqrt(3)/r0).|x_0-y_0|) )
//        |                        |             + (r0/sqrt(3)) . ( (0-1).exp(0) - (-inf-1).exp(-inf) )
//        |                        |             + (r0/sqrt(3)) . ( ( -(sqrt(3)/r0).|x_0-y_0| - 1 ).exp(-(sqrt(3)/r0).|x_0-y_0|) - (0-1).exp(0) )
//        |                        |             = (r0/sqrt(3)) . ( 2 - exp(-(sqrt(3)/r0).|x_0-y_0|) )
//        |                        |             - (r0/sqrt(3))
//        |                        |             + (r0/sqrt(3)) . ( ( -(sqrt(3)/r0).|x_0-y_0| - 1 ).exp(-(sqrt(3)/r0).|x_0-y_0|) )
//        |                        |             + (r0/sqrt(3))
//        |                        |             = (r0/sqrt(3)) . ( 2 - exp(-(sqrt(3)/r0).|x_0-y_0|) )
//        |                        |             - (r0/sqrt(3)) . ( ( (sqrt(3)/r0).|x_0-y_0| + 1 ).exp(-(sqrt(3)/r0).|x_0-y_0|) )
//        |                        |             = (r0/sqrt(3)) . 2
//        |                        |             - (r0/sqrt(3)) . exp(-(sqrt(3)/r0).|x_0-y_0|)
//        |                        |             - (r0/sqrt(3)) . ( (sqrt(3)/r0).|x_0-y_0| ) . exp(-(sqrt(3)/r0).|x_0-y_0|)
//        |                        |             - (r0/sqrt(3)) . exp(-(sqrt(3)/r0).|x_0-y_0|)
//        |                        |             = (r0/sqrt(3)) . ( 2 - ( ( 2 + ( (sqrt(3)/r0).|x_0-y_0| ) ) . exp(-(sqrt(3)/r0).|x_0-y_0|) ) )
//
// FIXME: x39 seem patently wrong!
//
// Notes: % non-mercer
//        * only positive definite in R^2
//        + only positive definite in R^3
//        # conditionally positive definite
//        ^ not yet implemented
//        ~ see Youngmin Cho, Lawrence K. Saul - Kernel Methods for Deep
//          Learning
//        $ note that K(x,x) + K(y,y) - 2.K(x,y) = ||x-y||_q^2 (q is relevant
//          norm)
//        & These are kernels 4xx with d/dx0 d/dx1 ... applied
//        ` See design decision in dense derivative
//        @ These are kernels 6xx with d/dx0 d/dx1 ... applied
//
// where: - B_i(z) = (1/i!) sum_{j=0 to i+1} (i+1)choose(j) (-1)^j max(0,(z + (i+1)/2 - j))^i
//        - Jn(x) = sin^(2n+1) (-1/sin(x) d/dx)^n (pi-x)/sin(x)
//        - phi_{sigma,n}(x) = phi_sigma(phi_sigma(...phi_sigma(x)))
//          (n repeats)
//        - phi_sigma(x) = ( sigma.x_0.(1-x_0) sigma.x_1.(1-x_1) ... )
//        - Kn is the Chaotic Logistic Kernel (case 30)
//        - K_r0 is the modified Bessel function
//        - If r1 = 3/2 the Matern kernel is
//          K(x,y) = ( 1 + sqrt(3).||x-y||/r0 ) exp(-sqrt(3).||x-y||/r0)
//          If r1 = 5/2 the Matern kernel is
//          K(x,y) = ( 1 + sqrt(5).||x-y||/r0 + 5.||x-y||^2/(3.r0^2) ) exp(-sqrt(5).||x-y||/r0)
//
// Generic kernel:
//
// Treating r10 as a function (which it is), evaluate:
//
// K(x,y) = r10(varxy)
//
// where varxy is:
//
// varxy(0,0) = m
// varxy(0,1) = x'y
// varxy(0,2) = y'x
// varxy(0,3) = (x-y)'(x-y)
// varxy(1,i) = ri (as is, not evaluated in any way, including r10)
// varxy(2,i) = Ki(x,y)  (evaluated on an is-used basis)
// varxy(3,.) = x
// varxy(4,.) = y
//
// Note that varxy(2,i) must be referenced directly or it will not
// be evaluated a-priori, leading to the wrong result.  So for example
// sum_i var(2,i) will not work.
//
// Note also that only x and y are available here
//
//
// Fourier transforms to be implemented for random sampling (non-unitary, angular frequency):
//
// 1-d:  K(x,x') = k(x-x')
//       k(y) = nu int_-inf^inf f(w) exp(-i yw) dw
//
// Number | Name                   | nu                        | f(w)
// -------+------------------------+---------------------------+--------------------------
//   ...  | ...                    | ...                       | ...
//     3  | Gaussian               | exp(-r1).2.pi             | r0/sqrt(2.pi).exp(-(1/2).(r0.r0.w.w))   (Normal distribution, a = mu = 0, b = sigma = 1/r0)
//     4  | Laplacian              | exp(-r1).2.pi             | r0/(pi.( 1 + r0.r0.w^2 ))               (Cauchy distribution, a = 0, b = 1/r0)
//   ...  | ...                    | ...                       | ...
//    13  | Wave (sinc)            | 2pi                       | r0/2pi rect(r0.w/(2*pi)) = 1 if |r0.w/(2*pi)| \leq 1/2, 0 otherwise  (Uniform distribution with a = -pi/r0, b = pi/r0)
//   ...  | ...                    | ...                       | ...
//    19  | Cauchy                 | pi                        | r0.exp(-r0.sqrt(d))                                                  (Exponential distribution, b = lambda = r0)


//
// Real constant derivatives
// =========================
//
//KERNELSHERE - labels where kernel is actually evaluated
//
// ... means calculate on the fly (if possible)
//
// Number | Name                   | K(x,y)
// -------+------------------------+------------------------------
//     0  | Constant               | ( 0 )
//        |                        | ( 1 )
//     1  | Linear                 | ( -2.z/(r0.r0.r0))
//     2  | Polynomial             | ( -2.i0.(x'y)/(r0.r0.r0) * ( r1 + x'y/(r0.r0) )^(i0-1) )
//        |                        | (    i0.                 * ( r1 + x'y/(r0.r0) )^(i0-1) )
//     3  | Gaussian               | ( (d/(r0*r0*r0)).exp(-d/(2*r0*r0)-r1) )
//     4  | Laplacian              | ( (sqrt(d)/(r0*r0)).exp(sqrt(d)/r0-r1) )
//     5  | Polynoise              | ( (sqrt(d)^r1)/(r0^(r1+1))                                                           exp(-sqrt(d)^r1/(r1*r0^r1)-r2) )
//        |                        | ( ( ((sqrt(d)^r1)/((r1^2).(r0^r1))) - (log(sqrt(d)/r0)/r1).exp(r1.log(sqrt(d)/r0)) ) exp(-sqrt(d)^r1/(r1*r0^r1)-r2) )
//     6  | ANOVA                  | ...
//     7  | Sigmoid                | ( -2.z/(r0.r0.r0) sech^2 ( z/(r0.r0) + r1 ) )
//        |                        | (                 sech^2 ( z/(r0.r0) + r1 ) )
//     8  | Rational quadratic     | ...                   (was ( d/((d+r0)^2) ))
//     9  | Multiquadratic         | ( -(2.d/(r0.r0.r0))/sqrt(d/(r0.r0)+r1^2) )
//        |                        | (                r1/sqrt(d/(r0.r0)+r1^2) )
//    10  | Inverse multiquadric   | ( (2.d/(r0.r0.r0))/(sqrt(d/(r0.r0)+r1^2))^3 )
//        |                        | (              -r1/(sqrt(d/(r0.r0)+r1^2))^3 )
//    11  | Circular               | ( -4/pi  (||x-y||^3/r0^3)/sqrt(1-(d/r0^2))  1/r0 )
//    12  | Sperical               | ( 3/2 (1-(d/r0^2)) sqrt(d)/r0^2 )
//    13  | Wave                   | ( -1/r0 ( cos(d/r0) - sinc(d/r0) ) )
//    14  | Power                  | ...
//    15  | Log                    | ...
//    16  | Spline                 | ...
//    17  | B-Spline               | ...
//    18  | Bessel                 | Not currently implemented
//    19  | Cauchy                 | ...
//    20  | Chi-square             | ...
//    21  | Histogram              | ...
//    22  | Generalised histogram  | ...
//    23  | Generalised T-student  | ...
//    24  | Vovk's real            | ...
//    25  | Weak fourier           | ...
//    26  | Thin spline 1          | ...
//    27  | Thin spline 2          | ...
//    28  | Generic                | ...
//    29  | Arc-cosine             | ...
//    30  | Chaotic logistic       | ...
//    31  | Summed chaotic logistic| ()
//    32  | Diagonal               |
//    33  | Uniform                | ...
//    34  | Triangular             | ...
//    35  | Matern                 | Not currently implemented
//    36  | Weiner                 | (-K/(r0.r0))
//    37  | Half-integer Matern    | ...
//    38  | 1/2-Matern             | ...
//    39  | 3/2-Matern             | ...
//    40  | 5/2-Matern             | ...
//    41  | RBF-rescale            | ...
//    42  | Inverse Gudermannian   | ...
//    43  | Log ratio              | ...
//    44  | Exponential            | ...
//    45  | Hyperbolic sine        | ...
//    46  | Hyperbolic cosine      | ...
//    47  | Sinc Kernel (Tobar)    | ...
//    48  | LUT kernel             | ...
//    49  | Gaussian Harmonic      | ...
//    50  | Alt arc-cosine         | Not implemented
//    51  | Vovk-like              | Not implemented
//    52  | Radius (see Bock)      | Not implemented
//    53  | Radius (see Bock)      | Not implemented
//        |                        |
//   100  | Linear 0/1             | ...
//   101  | Logistic 0/1           | ...
//   102  | Generalised logstic 0/1| ...
//   103  | Heavyside 0/1          | ( 0 )
//   104  | Rectifier 0/1          | ...
//   105  | Softplus 0/1           | ...
//   106  | Leaky rectifier 0/1    | ...
//        |                        |
//   200  | Linear -1/1            | ...
//   201  | Logistic -1/1          | ...
//   202  | Generalised logstc -1/1| ...
//   203  | Heavyside -1/1         | ( 0 )
//   204  | Rectifier -1/1         | ...
//   205  | Softplus -1/1          | ...
//        |                        |
//   300  | Euclidean distance$    | ...
//   301  | 1-norm distance$       | ...
//   302  | inf-norm distance$     | ...
//   304  | 0-norm distance$       | ...
//   305  | r0-norm distance$      | ...
//        |                        |
//   400  | Monotnic 0/1 dense 1   | ...
//   401  | Monotnic 0/1 dense 2   | ...
//   402  | Monotnic 0/1 dense 3   | ...
//   403  | Monotnic 0/1 dense 4   | ...
//   404  | Monotnic 0/1 dense 5   | ...
//        |                        |
//   450  | Monotnic 0/1 dense 1rev| ...
//   451  | Monotnic 0/1 dense 2rev| ...
//   452  | Monotnic 0/1 dense 3rev| ...
//   453  | Monotnic 0/1 dense 4rev| ...
//   454  | Monotnic 0/1 dense 5rev| ...
//        |                        |
//   500  | Monot dense deriv 1&   | ...
//   501  | Monot dense deriv 2&   | ...
//   502  | Monot dense deriv 3&`  | ...
//   503  | Monot dense deriv 4&`  | ...
//   504  | Monot dense deriv 5&`  | ...
//        |                        |
//   550  | Monot dens deriv 1rev&`| ...
//   551  | Monot dens deriv 2rev&`| ...
//   552  | Monot dens deriv 3rev&`| ...
//   553  | Monot dens deriv 4rev&`| ...
//   554  | Monot dens deriv 5rev&`| ...
//        |                        |
//   600  | Monotnic 0/1 dense 1   | ...
//   601  | Monotnic 0/1 dense 2   | ...
//   602  | Monotnic 0/1 dense 3   | ...
//   603  | Monotnic 0/1 dense 4   | ...
//   604  | Monotnic 0/1 dense 5   | ...
//        |                        |
//   650  | Monotnic 0/1 dense 1rev| ...
//   651  | Monotnic 0/1 dense 2rev| ...
//   652  | Monotnic 0/1 dense 3rev| ...
//   653  | Monotnic 0/1 dense 4rev| ...
//   654  | Monotnic 0/1 dense 5rev| ...
//        |                        |
//   700  | Monot dense deriv 1&   | ...
//   701  | Monot dense deriv 2&   | ...
//   702  | Monot dense deriv 3&`  | ...
//   703  | Monot dense deriv 4&`  | ...
//   704  | Monot dense deriv 5&`  | ...
//        |                        |
//   750  | Monot dens deriv 1rev&`| ...
//   751  | Monot dens deriv 2rev&`| ...
//   752  | Monot dens deriv 3rev&`| ...
//   753  | Monot dens deriv 4rev&`| ...
//   754  | Monot dens deriv 5rev&`| ...
//        |                        |
//   800  | altcallback kernel eval| ()
//        |                        |
//  1003  | Gaussian Dense Deriv   | Not implemented
//        |                        |
//  2003  | Gaussian Dense Int     | Not implemented
//


//
// Kernels derivatives
// ===================
//
//KERNELSHERE - labels where kernel is actually evaluated
//
// Number | Name                   | dK(x,y)/dz
// -------+------------------------+------------------------------
//     0  | Constant               | 0
//     1  | Linear                 | 1/(r0*r0)
//     2  | Polynomial             | i0/(r0.r0) * ( r1 + z/(r0.r0) )^(i0-1)
//     3  | Gaussian               | K(x,y)/(r0*r0)
//     4  | Laplacian              | K(x,y)/(r0*sqrt(d))
//        |                        | (arbitrarily 1 if x == y in line with RBF)
//     5  | Polynoise              | K(x,y) * ((sqrt(d)^(r1-2))/(r0^r1))
//        |                        | (arbitrarily 1 if x == y in line with RBF)
//     6  | ANOVA                  | ...
//     7  | Sigmoid                | 1/(r0.r0) * sech^2( z/(r0.r0) + r1 )
//     8  | Rational quadratic     | -(1/(2*r0*r0)).( 1 + d/(2*r0*r0*r1) )^(-r1-1)             was 2.r0/((d+r0)^2)
//     9  | Multiquadratic%        | -(1/(r0.r0))/K(x,y)
//    10  | Inverse multiquadric   | (1/(r0.r0)).K(x,y)^3
//    11  | Circular               | -4/(pi*r0^2) ( sqrt(diffis/(r0^2-diffis)) )
//    12  | Sperical               | 1 - 3/2 * sqrt(d)/r0 + 1/2 * sqrt(d)^3/r0^3
//    13  | Wave                   | -2 (cos(sqrt(d)/r0) - sinc(sqrt(d)/r0))/sqrt(d)/r0 1/(2*r0^2*sqrt(d)/r0)
//    14  | Power                  | (r1 * (d/(r0.r0))^((r1/2)-1))/(r0.r0)
//    15  | Log#                   | (r1 * ((d/(r0.r0))^((r1/2)-1))/d^(r0/2) + 1))/(r0.r0)
//    16  | Spline                 | ...
//    17  | B-Spline               | ...
//    18  | Bessel^                | Not currently implemented
//    19  | Cauchy                 | 2/(r0.r0) * K(x,y)^2
//    20  | Chi-square             | ...
//    21  | Histogram              | ...
//    22  | Generalised histogram  | ...
//    23  | Generalised T-student  | ...
//    24  | Vovk's real            | ( ( -i0.((z/(r0.r0))^(i0-1)) + (1-((z/(r0.r0))^i0))/(1-(z/(r0.r0))) )/(1-(z/(r0.r0))) )/(r0.r0)
//        |                        | (ill-defined at z = 1)
//    25  | Weak fourier           | pi/r0 * sinh(pi-sqrt(d)/r0) / sqrt(d)
//    26  | Thin spline 1          | -2/r0 * (r1+0.5) * (d/r0)^(r1-0.5)
//    27  | Thin spline 2          | -(2.r1)/r0 * ( (d/r0)^r1 * ln(sqrt(d/r0)) + 1/2 ) / (d/r0)
//    28  | Generic                | ...
//    29  | Arc-cosine*            | ...
//    30  | Chaotic logistic       | ...
//    31  | Summed chaotic logistic| ...
//    32  | Diagonal               | ...
//    33  | Uniform                | 0.0
//    34  | Triangular             | (1-real(sqrt(d))/r0)/r0 if real(sqrt(d)) < r0, 0 otherwise )
//    35  | Matern^                | Not currently implemented
//    36  | Weiner                 | ...
//    37  | Half-integer Matern    | Gradient not currently implemented
//    38  | 1/2-Matern             | Gradient not currently implemented
//    39  | 3/2-Matern             | Gradient not currently implemented
//    40  | 5/2-Matern             | Gradient not currently implemented
//    41  | RBF-rescale            | Gradient not currently implemented
//    42  | Inverse Gudermannian   | (1/(r0.r0)) sec^2(z/(r0.r0)) / ( 1 - tan^2(z/(r0.r0)) )
//    43  | Log ratio              | -(1/(r0.r0))^2/(1-z/(r0.r0))^2
//    44  | Exponential            | exp(z/(r0.r0)-r1)/(r0.r0)
//    45  | Hyperbolic sine        | sinh(z/(r0.r0))/(r0.r0)
//    46  | Hyperbolic cosine      | cosh(z/(r0.r0))/(r0.r0)
//    47  | Sinc Kernel (Tobar)    | ...
//    48  | LUT kernel             | ...
//    49  | Gaussian Harmonic      | ...
//    50  | Alt arc-cosine         | 1/(r0.r0.sqrt(1-(z/r0.r0)^2))
//    51  | Vovk-like              | 1/r0.r0.(2-(z/r0.r0))^2
//    52  | Radius (see Bock)      | Not implemented
//    53  | Radius (see Bock)      | Not implemented
//        |                        |
//   100  | Linear 0/1             | 1
//   101  | Logistic 0/1           | (K(x,y).(1-K(x,y)))/(r0*r0)
//   102  | Generalised logstic 0/1| (K(x,y).(1-K(x,y)^r2))/(r0*r0)
//   103  | Heavyside 0/1          | 0.0
//   104  | Rectifier 0/1          | 0 if real(z) < 0, 1/(r0*r0) otherwise
//   105  | Softplus 0/1           | (exp(r0*z)/(r1+exp(r0*z)))/(r0*r0)
//   106  | Leaky Rectifier 0/1    | r1/(r0*r0) if real(z) < 0, 1/(r0*r0) otherwise
//        |                        |
//   200  | Linear -1/1            | 1
//   201  | Logistic -1/1          | ((1-K(x,y)).(1+K(x,y))/2)/(r0*r0)
//   202  | Generalised logstc -1/1| 2.((1-K102(x,y)^r2).K102(x,y))/(r0*r0)
//   203  | Heavyside -1/1         | 0
//   204  | Rectifier -1/1         | 0 if real(z) < 0, 1/(r0*r0) otherwise
//   205  | Softplus -1/1          | 2.(exp(r0.z)/(r1+exp(r0.z)))/(r0*r0)
//        |                        |
//   300  | Euclidean distance     | ...
//   301  | 1-norm distance        | ...
//   302  | inf-norm distance      | ...
//   304  | 0-norm distance        | ...
//   305  | r0-norm distance       | ...
//        |                        |
//   400  | Monotnic 0/1 dense 1   | ...
//   401  | Monotnic 0/1 dense 2   | ...
//   402  | Monotnic 0/1 dense 3   | ...
//   403  | Monotnic 0/1 dense 4   | ...
//   404  | Monotnic 0/1 dense 5   | ...
//        |                        |
//   450  | Monotnic 0/1 dense 1rev| ...
//   451  | Monotnic 0/1 dense 2rev| ...
//   452  | Monotnic 0/1 dense 3rev| ...
//   453  | Monotnic 0/1 dense 4rev| ...
//   454  | Monotnic 0/1 dense 5rev| ...
//        |                        |
//   500  | Monot dense deriv 1    | ...
//   501  | Monot dense deriv 2    | ...
//   502  | Monot dense deriv 3    | ...
//   503  | Monot dense deriv 4    | 0
//   504  | Monot dense deriv 5    | 0
//        |                        |
//   550  | Monot dense deriv 1    | ...
//   551  | Monot dense deriv 2    | ...
//   552  | Monot dens deriv 3rev  | ...
//   553  | Monot dens deriv 4rev  | 0
//   554  | Monot dens deriv 5rev  | 0
//        |                        |
//   600  | Monotnic 0/1 dense 1   | ...
//   601  | Monotnic 0/1 dense 2   | ...
//   602  | Monotnic 0/1 dense 3   | ...
//   603  | Monotnic 0/1 dense 4   | ...
//   604  | Monotnic 0/1 dense 5   | ...
//        |                        |
//   650  | Monotnic 0/1 dense 1rev| ...
//   651  | Monotnic 0/1 dense 2rev| ...
//   652  | Monotnic 0/1 dense 3rev| ...
//   653  | Monotnic 0/1 dense 4rev| ...
//   654  | Monotnic 0/1 dense 5rev| ...
//        |                        |
//   700  | Monot dense deriv 1    | ...
//   701  | Monot dense deriv 2    | ...
//   702  | Monot dense deriv 3    | ...
//   703  | Monot dense deriv 4    | 0
//   704  | Monot dense deriv 5    | 0
//        |                        |
//   750  | Monot dense deriv 1    | ...
//   751  | Monot dense deriv 2    | ...
//   752  | Monot dens deriv 3rev  | ...
//   753  | Monot dens deriv 4rev  | 0
//   754  | Monot dens deriv 5rev  | 0
//        |                        |
//   800  | altcallback kernel eval| not defined
//        |                        |
//  1003  | Gaussian Dense Deriv   | Not implemented
//        |                        |
//  2003  | Gaussian Dense Integ   | Not implemented

// Notes: * The derivative of the arc-cosine kernel is not implemented
//          (although the arc-cosine kernel itself is).
//        ^ not yet implemented
//
//
// Working:
// ========
//
// OLD Case 8: Rational quadratic kernel:
// OLD
// OLD K(x,y) = 1 - ||x-y||^2/(||x-y||^2+r0)
// OLD        = 1 - ( a + b - 2z )/(( a + b - 2z )+r0)
// OLD
// OLD dK/dz = 2/((a+b-2z)+r0)  -  2.(a+b-2z)/(((a+b-2z)+r0)*((a+b-2z)+r0))
// OLD       = 2.( ((a+b-2z)+r0) - (a+b-2z) )/(((a+b-2z)+r0)*((a+b-2z)+r0))
// OLD       = 2.r0/(((a+b-2z)+r0)*((a+b-2z)+r0))
// OLD       = 2.r0/((diffis+r0)*(diffis+r0))
//
// Case 11: Circular kernel (ONLY POS DEFINITE IN R^2):
//
// K(x,y) = 2/pi * arccos(-||x-y||/r0) - 2/pi * ||x-y||/r0 * sqrt(1 - ||x-y||^2/r0^2)
//        = 2/pi * arccos(-sqrt(a+b-2z)/r0) - 2/pi * sqrt(a+b-2z)/r0 * sqrt(1 - (a+b-2z)/r0^2)
//
// q = diffis/r0^2
//
// K(diffis) = 2/pi * arccos(-sqrt(q))
//           - 2/pi * sqrt(q) * sqrt(1-q)
//
//           = 2/pi * ( arccos(-sqrt(q))
//                    - sqrt(q) * sqrt(1-q) )
//
// dK/dq = 2/pi * ( -1/2 * 1/sqrt(q) * -1/sqrt(1-q)
//                - 1/2 * 1/sqrt(q) * sqrt(1-q)
//                - sqrt(q) * -1/2 * 1/sqrt(1-q) )
//
//            = 2/pi * ( 1/2 * 1/sqrt(q) * 1/sqrt(1-q)
//                     - 1/2 * 1/sqrt(q) * sqrt(1-q)
//                     + 1/2 * sqrt(q) * 1/sqrt(1-q) )
//
//            = 1/pi * (       * 1/sqrt(q) * 1/sqrt(1-q)
//                     - (1-q) * 1/sqrt(q) * 1/sqrt(1-q)
//                     + q     * 1/sqrt(q) * 1/sqrt(1-q) )
//
//            = 2/pi * ( q * 1/sqrt(q) * 1/sqrt(1-q) )
//
//            = 2/pi * ( sqrt(q)/sqrt(1-q) )
//
// dK/dz = dK/dq * dq/ddiffis * ddiffis/dz
//       = dK/dq * 1/r0^2 * -2
//       = -2/r0^2 dK/dq
//       = -4/(pi*r0^2) ( sqrt(q)/sqrt(1-q) )
//       = -4/(pi*r0^2) ( sqrt(diffis)/sqrt(r0^2-diffis) )
//       = -4/(pi*r0^2) ( sqrt(diffis/(r0^2-diffis)) )
//
// Case 12: Spherical kernel (ONLY POS DEFINITE IN R^3):
//
// K(x,y) = 1 - 3/2 * ||x-y||/r0 + 1/2 * ||x-y||^3/r0^3
//        = 1 - 3/2 * sqrt( x'x + y'y - 2x'y )/r0 + 1/2 * ( x'x + y'y - 2x'y )^(3/2)/r0^3
//
// K(diffis) = 1 - 3/2 * sqrt(diffis)/r0 + 1/2 * sqrt(diffis)^3/r0^3
//
// dK/ddiffis = -3/2 1/2 1/sqrt(diffis) 1/r0 + 1/2 3/2 sqrt(diffis) 1/r0^3
// dK/ddiffis = -3/(4*r0) 1/sqrt(diffis) + 3/(4*r0^3) sqrt(diffis)
// dK/dz = -2 dK/ddiffis
//       = 3/(2*r0) 1/sqrt(diffis) - 3/(2*r0^3) sqrt(diffis)
//       = 3/(2*r0^3) ( r0*r0/sqrt(diffis) - sqrt(diffis) )
//
// Case 13: Wave kernel:
//
// K(x,y) = (r0/||x-y||).sin(||x-y||/r0)
//        = sinc(||x-y||/r0)
//        = (r0/sqrt( x'x + y'y - 2x'y )).sin(sqrt( x'x + y'y - 2x'y )/r0)
//
// K(diffis) = (r0/sqrt(diffis)).sin(sqrt(diffis)/r0)
//
// q = sqrt(diffis)/r0
//
// K(q) = sin(q)/q
//
// dK/dq = cos(q)/q - sin(q)/q^2
//       = (cos(q) - sin(q)/q)/q
//       = (cos(q) - sinc(q))/q
//
// dq/ddiffis = 1/(2*r0) * 1/sqrt(diffis)
//            = 1/(2*r0^2) * r0/sqrt(diffis)
//            = 1/(2*r0^2*q)
//
// ddiffis/dz = -2
//
// dK/dz = dK/dq dq/ddiffis ddiffis/dz
//       = -2 (cos(sqrt(diffis)/r0) - sinc(sqrt(diffis)/r0))/sqrt(diffis)/r0 1/(2*r0^2*sqrt(diffis)/r0)
//
// Case 19: Cauchy kernel:
//
// K(x,y) = 1/(1+((||x-y||^2)/r0))
//        = 1/(1+(( x'x + y'y - 2x'y )/r0))
//        = 1/(1 + ((a+b-2z)/r0) )
//
// dK/dz = d/dz 1/(1 + ((a+b-2z)/r0) )
//       = 2/r0 * 1/(1 + ((a+b-2z)/r0) )^2
//       = 2/r0 * K(diffis)^2
//
// Case 23: Generalised T-Student kernel:
//
// K(x,y) = 1/(1+(||x-y||/r0)^r1)
//        = 1/(1+(( x'x + y'y - 2x'y )/r0)^r1)
//        = 1/(1+ ((a+b-2z)/r0)^r1 )
//
// dK/dz = (2.r1/r0) * ((a+b-2z)/r0)^(r1-1)/(1+ ((a+b-2z)/r0)^r1 )^2
//       = (2.r1/r0) * diffis^(r1-1) * K(diffis)^2
//
// Case 24: Vovk's real polynomial:
//
// K(x,y) = (1-((x'y)^i0))/(1-(x'y))
//        = (1-(z^i0))/(1-z)
// (0 as z->1)
//
// dK/dz =  -i0.(z^(i0-1))/(1-z) + (1-(z^i0))/((1-z)^2)
// dK/dz =  ( -i0.(z^(i0-1)) + (1-(z^i0))/(1-z) )/(1-z)
// (ill-defined as z->1, so don't try)
//
// Case 25: Weak fourier kernel:
//
// K(x,y) = pi.cosh(pi-(||x-y||/r0))
//        = pi.cosh(pi-(sqrt(x'x + y'y - 2x'y)/r0))
//
// K(diffis) = pi.cosh(pi-sqrt(diffis)/r0)
//
// dK/ddiffis = pi * sinh(pi-sqrt(diffis)/r0) * -1/r0 * 1/2 * 1/sqrt(diffis)
//            = -pi/(2*r0) * sinh(pi-sqrt(diffis)/r0) / sqrt(diffis)
//
// dK/dz  = dK/ddiffis ddiffis/dz = -2 dK/ddiffis
//        = pi/r0 * sinh(pi-sqrt(diffis)/r0) / sqrt(diffis)
//
// Case 26: Thin spline (1):
//
// K(x,y) = ((||x-y||^2/r0)^(r1+0.5))
//        = (((x'x + y'y - 2x'y)/r0)^(r1+0.5))
//
// K(diffis) = (diffis/r0)^(r1+0.5)
//
// dK/ddiffis = 1/r0 * (r1+0.5) * (diffis/r0)^(r1-0.5)
//
// Case 27: Thin spline (2):
//
// K(x,y) = ((||x-y||^2/r0)^r1).ln(sqrt(||x-y||^2/r0))
//        = (((x'x + y'y - 2x'y)/r0)^r1).ln(sqrt((x'x + y'y - 2x'y)/r0))
//
// q = diffis/r0
//
// K(q) = (q^r1).ln(sqrt(q))
//
// dK/dq = r1 * q^(r1-1) * ln(sqrt(q))
//       + r1 * 1/sqrt(q) * 1/2 * 1/sqrt(q)
//       = r1 * ( q^(r1-1) * ln(sqrt(q)) + 1/2q )
//       = r1 * ( q^r1 * ln(sqrt(q)) + 1/2 ) / q
//
// dK/dz = dK/dq * dq/ddiffis * ddiffis/dz
//       = dK/dq * 1/r0 * -2
//       = -2/r0 dK/dq
//       = -(2.r1)/r0 * ( (d/r0)^r1 * ln(sqrt(d/r0)) + 1/2 ) / (d/r0)
//
// Case 29: Arccosine:
//
// K(x,y) = (1/pi) r0^2 ||x||^i0 ||y||^i0 Jn(arccos(x'y/(||x||.||y||)))
//        = (1/pi) r0^2 sqrt(a,b)^i0 Jn(arccos(z/sqrt(a.b)))
//
// dK/dz = (1/pi) r0^2 sqrt(a.b)^i0 dJn/dtheta(arccos(z/sqrt(a.b))) 1/sqrt(1-(z^2/(a.b))) 1/sqrt(a.b)
//       = (1/pi) r0^2 sqrt(a.b)^(i0-1) dJn/dtheta(arccos(z/sqrt(a.b))) 1/sqrt(1-(z^2/(a.b)))
//
// let q = z/sqrt(a.b)
//
// dK/dz = (1/pi) r0^2 sqrt(a.b)^(i0-1)/sqrt(1-q^2) dJn/dtheta(arccos(q))
//
// dK/da = (1/pi) r0^2 sqrt(b)^i0 Jn(arccos(z/sqrt(a.b)))
//
//FIXME: finish this derivation, implement it
//
// Case 34: Triangular kernel
//
// K(x,y) = (1-||x-y||/r0)/r0 if real(||x-y||) < r0, 0 otherwise )
//        = (1-sqrt(d)/r0)/r0 if real(sqrt(d)) < r0, 0 otherwise )
//
// dK/dz = -2 dK/dd
//       = -2 -1/2r0 1/sqrt(d) 1/r0 if real(sqrt(d)) < r0, 0 otherwise
//       = 1/r0^2 1/sqrt(d) if real(sqrt(d)) < r0, 0 otherwise
//
// Case 501:
//
// K(d) = ((1.r0/sqrt(pi))^k)*exp(-r0*d)
//
// dK/dd = -r0.((1.r0/sqrt(pi))^k)*exp(-r0*d)
// dK/dz = -2 dK/dd = 2.r0.K(x,y)
//
// Case 701:
//
// K(d) = ((2.r0/sqrt(pi))^k)*exp(-r0*d)
//
// dK/dz = 2.r0.K(x,y)

// Second-order kernel derivatives
//
// q = a+b-2z
//
// Let e,f = a,b,z
//
// d2K/dede = d/de ( dK/de )
//          = dq/de d/dq ( dq/de dK/dq )
//          = dq/de ( de/dq d/de dq/de ) dK/dq + dq/de kq/de d2K/dqdq
//          = dq/de de/dq d2q/dede dK/dq + dq/de dq/de d2K/dqdq
//          = dq/de dq/de d2K/dqdq
//          = dz/de dz/de d2K/dzdz
//
// d2K/dedf = d/de ( dK/df )
//          = dq/de d/dq ( dq/df dK/dq )
//          = dq/de ( df/dq d/df dq/df ) dK/dq + dq/de dq/df d2K/dqdq
//          = dq/de df/dq d2q/dfdf dK/dq + dq/de dq/df d2K/dqdq
//          = dq/de dq/df d2K/dqdq
//          = dz/de dz/df d2K/dzdz
//
// So: need only /dqdq and /dzdz variants, rest can be calculated from that
//
//KERNELSHERE - labels where kernel is actually evaluated
//
// Number | Name                   | d2K(x,y)/dz2
// -------+------------------------+------------------------------
//     0  | Constant               | 0
//     1  | Linear                 | 0
//     2  | Polynomial             | i0.(i0-1)/(r0.r0.r0.r0) * ( r1 + z/(r0.r0) )^(i0-2)
//     3  | Gaussian               | K(x,y)/(r0*r0*r0*r0)
//     4  | Laplacian              | Not currently implemented
//     5  | Polynoise              | Not currently implemented
//     6  | ANOVA                  | ...
//     7  | Sigmoid                | Not currently implemented
//     8  | Rational quadratic     | Not currently implemented
//     9  | Multiquadratic%        | Not currently implemented
//    10  | Inverse multiquadric   | Not currently implemented
//    11  | Circular               | Not currently implemented
//    12  | Sperical               | Not currently implemented
//    13  | Wave                   | Not currently implemented
//    14  | Power                  | Not currently implemented
//    15  | Log#                   | Not currently implemented
//    16  | Spline                 | ...
//    17  | B-Spline               | ...
//    18  | Bessel^                | Not currently implemented
//    19  | Cauchy                 | Not currently implemented
//    20  | Chi-square             | ...
//    21  | Histogram              | ...
//    22  | Generalised histogram  | ...
//    23  | Generalised T-student  | Not currently implemented
//    24  | Vovk's real            | Not currently implemented
//    25  | Weak fourier           | Not currently implemented
//    26  | Thin spline 1          | Not currently implemented
//    27  | Thin spline 2          | Not currently implemented
//    28  | Generic                | ...
//    29  | Arc-cosine*            | ...
//    30  | Chaotic logistic       | ...
//    31  | Summed chaotic logistic| ...
//    32  | Diagonal               | 0
//    33  | Uniform                | 0
//    34  | Triangular             | Not currently implemented
//    35  | Matern^                | Not currently implemented
//    36  | Weiner                 | ...
//        |                        |
//   100  | Linear 0/1             | 0
//   101  | Logistic 0/1           | Not currently implemented
//   102  | Generalised logstic 0/1| Not currently implemented
//   103  | Heavyside 0/1          | 0
//   104  | Rectifier 0/1          | 0
//   105  | Softplus 0/1           | Not currently implemented
//   106  | Leaky rectifier 0/1    | 0
//        |                        |
//   200  | Linear -1/1            | 0
//   201  | Logistic -1/1          | Not currently implemented
//   202  | Generalised logstc -1/1| Not currently implemented
//   203  | Heavyside -1/1         | 0
//   204  | Rectifier -1/1         | 0
//   205  | Softplus -1/1          | Not currently implemented
//        |                        |
//   300  | Euclidean distance     | ...
//   301  | 1-norm distance        | ...
//   302  | inf-norm distance      | ...
//   304  | 0-norm distance        | ...
//   305  | r0-norm distance       | ...
//        |                        |
//   400  | Monotnic 0/1 dense 1   | ...
//   401  | Monotnic 0/1 dense 2   | ...
//   402  | Monotnic 0/1 dense 3   | ...
//   403  | Monotnic 0/1 dense 4   | ...
//   404  | Monotnic 0/1 dense 5   | ...
//        |                        |
//   450  | Monotnic 0/1 dense 1rev| ...
//   451  | Monotnic 0/1 dense 2rev| ...
//   452  | Monotnic 0/1 dense 3rev| ...
//   453  | Monotnic 0/1 dense 4rev| ...
//   454  | Monotnic 0/1 dense 5rev| ...
//        |                        |
//   500  | Monot dense deriv 1    | ...
//   501  | Monot dense deriv 2    | ...
//   502  | Monot dense deriv 3    | ...
//   503  | Monot dense deriv 4    | 0
//   504  | Monot dense deriv 5    | 0
//        |                        |
//   550  | Monot dense deriv 1    | ...
//   551  | Monot dense deriv 2    | ...
//   552  | Monot dens deriv 3rev  | ...
//   553  | Monot dens deriv 4rev  | 0
//   554  | Monot dens deriv 5rev  | 0
//        |                        |
//   600  | Monotnic 0/1 dense 1   | ...
//   601  | Monotnic 0/1 dense 2   | ...
//   602  | Monotnic 0/1 dense 3   | ...
//   603  | Monotnic 0/1 dense 4   | ...
//   604  | Monotnic 0/1 dense 5   | ...
//        |                        |
//   650  | Monotnic 0/1 dense 1rev| ...
//   651  | Monotnic 0/1 dense 2rev| ...
//   652  | Monotnic 0/1 dense 3rev| ...
//   653  | Monotnic 0/1 dense 4rev| ...
//   654  | Monotnic 0/1 dense 5rev| ...
//        |                        |
//   700  | Monot dense deriv 1    | ...
//   701  | Monot dense deriv 2    | ...
//   702  | Monot dense deriv 3    | ...
//   703  | Monot dense deriv 4    | 0
//   704  | Monot dense deriv 5    | 0
//        |                        |
//   750  | Monot dense deriv 1    | ...
//   751  | Monot dense deriv 2    | ...
//   752  | Monot dens deriv 3rev  | ...
//   753  | Monot dens deriv 4rev  | 0
//   754  | Monot dens deriv 5rev  | 0
//        |                        |
//   800  | altcallback kernel eval| not defined




#define BADZEROTOL 1e-12
#define BADVARTOL 1e-3

class MercerKernel;

inline std::ostream &operator<<(std::ostream &output, const MercerKernel &src );
inline std::istream &operator>>(std::istream &input,        MercerKernel &dest);

int operator==(const MercerKernel &leftop, const MercerKernel &rightop);






#define DEFAULT_XPROD_SIZE 2

class vecInfoBase;


inline void qswap(vecInfoBase &a, vecInfoBase &b);
inline void qswap(const vecInfoBase *&a, const vecInfoBase *&b);
inline void qswap(vecInfoBase *&a, vecInfoBase *&b);

inline vecInfoBase &setident (vecInfoBase &a);
inline vecInfoBase &setzero  (vecInfoBase &a);
inline vecInfoBase &setposate(vecInfoBase &a);
inline vecInfoBase &setnegate(vecInfoBase &a);
inline vecInfoBase &setconj  (vecInfoBase &a);
inline vecInfoBase &setrand  (vecInfoBase &a);

inline vecInfoBase *&setident (vecInfoBase *&a);
inline vecInfoBase *&setzero  (vecInfoBase *&a);
inline vecInfoBase *&setposate(vecInfoBase *&a);
inline vecInfoBase *&setnegate(vecInfoBase *&a);
inline vecInfoBase *&setconj  (vecInfoBase *&a);
inline vecInfoBase *&setrand  (vecInfoBase *&a);

inline const vecInfoBase *&setident (const vecInfoBase *&a);
inline const vecInfoBase *&setzero  (const vecInfoBase *&a);
inline const vecInfoBase *&setposate(const vecInfoBase *&a);
inline const vecInfoBase *&setnegate(const vecInfoBase *&a);
inline const vecInfoBase *&setconj  (const vecInfoBase *&a);
inline const vecInfoBase *&setrand  (const vecInfoBase *&a);

OVERLAYMAKEFNVECTOR(vecInfoBase)
OVERLAYMAKEFNVECTOR(Vector<vecInfoBase>)
OVERLAYMAKEFNVECTOR(SparseVector<vecInfoBase>)

class vecInfoBase
{
public:

    explicit vecInfoBase()
    {
        // Initialise values such that any normalisation has no effect

        xhalfmprod.resize(DEFAULT_XPROD_SIZE/2);

        xiseqn = 0;

//        xmean   = 0.0;
//        xmedian = 0.0;
//        xsqmean = 0.0;
//        xvari   = 1.0;
//        xstdev  = 1.0;
//        xmax    = 1.0;
//        xmin    = 0.0;
//        xrange  = 1.0;
//        xmaxabs = 1.0;

        xhalfinda = &xhalfindb;
        xhalfindb = &xhalfmprod;

        xusize = 1;

        hasbeenset = 0;
    }

    vecInfoBase(const vecInfoBase &src)
    {
        xhalfinda = &xhalfindb;
        xhalfindb = &xhalfmprod;

        *this = src;
    }

    vecInfoBase &operator=(const vecInfoBase &src)
    {
        xhalfmprod = src.xhalfmprod;

        xiseqn = src.xiseqn;

//        xmean   = src.xmean;
//        xmedian = src.xmedian;
//        xsqmean = src.xsqmean;
//        xvari   = src.xvari;
//        xstdev  = src.xstdev;
//        xmax    = src.xmax;
//        xmin    = src.xmin;
//        xrange  = src.xrange;
//        xmaxabs = src.xmaxabs;

        xusize = src.xusize;

        hasbeenset = src.hasbeenset;

        return *this;
    }

    Vector<gentype> xhalfmprod;

    int xiseqn;

//    gentype xmean;
//    gentype xmedian;
//    gentype xsqmean;
//    gentype xvari;
//    gentype xstdev;
//    gentype xmax;
//    gentype xmin;
//    gentype xrange;
//    gentype xmaxabs;

    int xusize;

    Vector<gentype> **xhalfinda;
    Vector<gentype> *xhalfindb;

    int hasbeenset;
};

inline vecInfoBase &setident (vecInfoBase &a) { NiceThrow("no"); return a; }
inline vecInfoBase &setposate(vecInfoBase &a) { return a; }
inline vecInfoBase &setnegate(vecInfoBase &a) { NiceThrow("bleh"); return a; }
inline vecInfoBase &setconj  (vecInfoBase &a) { NiceThrow("blit"); return a; }
inline vecInfoBase &setrand  (vecInfoBase &a) { NiceThrow("OK, rand"); return a; }

inline vecInfoBase *&setident (vecInfoBase *&a) { NiceThrow("no"); return a; }
inline vecInfoBase *&setzero  (vecInfoBase *&a) { return a = nullptr; }
inline vecInfoBase *&setposate(vecInfoBase *&a) { return a; }
inline vecInfoBase *&setnegate(vecInfoBase *&a) { NiceThrow("bleh"); return a; }
inline vecInfoBase *&setconj  (vecInfoBase *&a) { NiceThrow("blit"); return a; }
inline vecInfoBase *&setrand  (vecInfoBase *&a) { NiceThrow("OK, rand"); return a; }

inline const vecInfoBase *&setident (const vecInfoBase *&a) { NiceThrow("no"); return a; }
inline const vecInfoBase *&setzero  (const vecInfoBase *&a) { return a = nullptr; }
inline const vecInfoBase *&setposate(const vecInfoBase *&a) { return a; }
inline const vecInfoBase *&setnegate(const vecInfoBase *&a) { NiceThrow("bleh"); return a; }
inline const vecInfoBase *&setconj  (const vecInfoBase *&a) { NiceThrow("blit"); return a; }
inline const vecInfoBase *&setrand  (const vecInfoBase *&a) { NiceThrow("OK, rand"); return a; }

inline vecInfoBase &setzero(vecInfoBase &a)
{
    a.xhalfmprod.resize(DEFAULT_XPROD_SIZE/2);

    a.xiseqn = 0;

//    a.xmean   = 0.0;
//    a.xmedian = 0.0;
//    a.xsqmean = 0.0;
//    a.xvari   = 1.0;
//    a.xstdev  = 1.0;
//    a.xmax    = 1.0;
//    a.xmin    = 0.0;
//    a.xrange  = 1.0;
//    a.xmaxabs = 1.0;

    a.xhalfinda = &(a.xhalfindb);
    a.xhalfindb = &(a.xhalfmprod);

    a.xusize = 1;

    a.hasbeenset = 0;

    return a;
}

inline void qswap(const vecInfoBase *&a, const vecInfoBase *&b)
{
    const vecInfoBase *c(a); a = b; b = c;
}

inline void qswap(vecInfoBase *&a, vecInfoBase *&b)
{
    vecInfoBase *c(a); a = b; b = c;
}

inline void qswap(vecInfoBase &a, vecInfoBase &b)
{
    qswap(a.xhalfmprod,b.xhalfmprod);
    qswap(a.xiseqn    ,b.xiseqn    );

//    qswap(a.xmean  ,b.xmean  );
//    qswap(a.xmedian,b.xmedian);
//    qswap(a.xsqmean,b.xsqmean);
//    qswap(a.xvari  ,b.xvari  );
//    qswap(a.xstdev ,b.xstdev );
//    qswap(a.xmax   ,b.xmax   );
//    qswap(a.xmin   ,b.xmin   );
//    qswap(a.xrange ,b.xrange );
//    qswap(a.xmaxabs,b.xmaxabs);
//    qswap(a.xusize ,b.xusize );

    qswap(a.xusize    ,b.xusize    );
    qswap(a.hasbeenset,b.hasbeenset);
}

inline void qswap(SparseVector<vecInfoBase> *&a, SparseVector<vecInfoBase> *&b);
inline void qswap(SparseVector<vecInfoBase> *&a, SparseVector<vecInfoBase> *&b)
{
    SparseVector<vecInfoBase> *c(a); a = b; b = c;
}

class vecInfo;

inline void qswap(vecInfo &a, vecInfo &b);
inline void qswap(const vecInfo *&a, const vecInfo *&b);
inline void qswap(vecInfo *&a, vecInfo *&b);

OVERLAYMAKEFNVECTOR(vecInfo)
OVERLAYMAKEFNVECTOR(Vector<vecInfo>)
OVERLAYMAKEFNVECTOR(SparseVector<vecInfo>)

class vecInfo
{
public:
    explicit vecInfo()
    {
        scratch = nullptr;

        content.resize(2);

        MEMNEW(content("&",0),SparseVector<vecInfoBase>);
        MEMNEW(content("&",1),SparseVector<vecInfoBase>);

        setzero((*(content("&",0)))("&",0));
        setzero((*(content("&",1)))("&",0));

        isloc = 1;

        minind = 0;
        majind = 0;

        usize_overwrite = 0;
    }

    explicit vecInfo(const vecInfoBase &src)
    {
        scratch = nullptr;

        content.resize(2);

        MEMNEW(content("&",0),SparseVector<vecInfoBase>);
        MEMNEW(content("&",1),SparseVector<vecInfoBase>);

        setzero((*(content("&",0)))("&",0));
        setzero((*(content("&",1)))("&",0));

        isloc = 1;

        minind = 0;
        majind = 0;

        (*(content("&",0)))("&",0) = src;

        usize_overwrite = 0;
    }

    vecInfo(const vecInfo &src)
    {
        scratch = nullptr;

        content.resize(2);

        content("&",0) = nullptr;
        content("&",1) = nullptr;

        isloc = 0;

        minind = 0;
        majind = 0;

        usize_overwrite = 0;

        *this = src;
    }

    vecInfo &operator()(int _majind = -1, int _minind = -1, int xusize_overwrite = 0) const
    {
        int xmajind = ( _majind == -1 ) ? majind : _majind;
        int xminind = ( _minind == -1 ) ? minind : _minind;

        vecInfo &res = getvecscratch(xmajind,xminind);

        //(res.content).resize(2);

        if ( res.isloc )
        {
            MEMDEL((res.content)("&",0));
            MEMDEL((res.content)("&",1));

            res.content("&",0) = nullptr;
            res.content("&",1) = nullptr;

            (res.isloc) = 0;
        }

        (res.majind) = xmajind;
        (res.minind) = xminind;

        (res.content)("&",0) = content(0);
        (res.content)("&",1) = content(1);

        (res.usize_overwrite) = xusize_overwrite ? xusize_overwrite : usize_overwrite;

        return res;
    }

    vecInfo &operator=(const vecInfo &src)
    {
        content.resize(2);

        if ( isloc && src.isloc )
        {
            MEMDEL(content("&",0));
            MEMDEL(content("&",1));

            MEMNEW(content("&",0),SparseVector<vecInfoBase>);
            MEMNEW(content("&",1),SparseVector<vecInfoBase>);

            (*(content("&",0))) = (*((src.content(0))));
            (*(content("&",1))) = (*((src.content(1))));
        }

        else if ( !isloc && src.isloc )
        {
            MEMNEW(content("&",0),SparseVector<vecInfoBase>);
            MEMNEW(content("&",1),SparseVector<vecInfoBase>);

            (*(content("&",0))) = (*((src.content(0))));
            (*(content("&",1))) = (*((src.content(1))));
        }

        else if ( isloc && !(src.isloc) )
        {
            MEMDEL(content("&",0));
            MEMDEL(content("&",1));

            content("&",0) = src.content(0);
            content("&",1) = src.content(1);
        }

        else
        {
            content("&",0) = src.content(0);
            content("&",1) = src.content(1);
        }

        isloc = src.isloc;

        minind = src.minind;
        majind = src.majind;

        usize_overwrite = src.usize_overwrite;

        //if ( scratch )
        //{
        //    MEMDEL(scratch);
        //    scratch = nullptr;
        //}

        return *this;
    }

    ~vecInfo()
    {
        if ( isloc )
        {
            MEMDEL(content("&",0));
            MEMDEL(content("&",1));

            content("&",0) = nullptr;
            content("&",1) = nullptr;
        }

        if ( scratch )
        {
            MEMDEL(scratch);
            scratch = nullptr;
        }
    }

    const Vector<gentype> &xhalfmprod(void) const { return relbase().xhalfmprod; }

    int xiseqn(void) const { return relbase().xiseqn; }

//    const gentype &xmean  (void) const { return relbase().xmean;   }
//    const gentype &xmedian(void) const { return relbase().xmedian; }
//    const gentype &xsqmean(void) const { return relbase().xsqmean; }
//    const gentype &xvari  (void) const { return relbase().xvari;   }
//    const gentype &xstdev (void) const { return relbase().xstdev;  }
//    const gentype &xmax   (void) const { return relbase().xmax;    }
//    const gentype &xmin   (void) const { return relbase().xmin;    }
//    const gentype &xrange (void) const { return relbase().xrange;  }
//    const gentype &xmaxabs(void) const { return relbase().xmaxabs; }

    int xusize(void) const { return usize_overwrite ? usize_overwrite : relbase().xusize; }

    Vector<gentype> **xhalfinda(void) const { return relbase().xhalfinda; }
    Vector<gentype>  *xhalfindb(void) const { return relbase().xhalfindb; }

    int hasbeenset(void) const { return relbase().hasbeenset; }

    Vector<gentype> &xhalfmprod(void) { return relbase().xhalfmprod; }

    int &xiseqn(void) { return relbase().xiseqn; }

//    gentype &xmean  (void) { return relbase().xmean;   }
//    gentype &xmedian(void) { return relbase().xmedian; }
//    gentype &xsqmean(void) { return relbase().xsqmean; }
//    gentype &xvari  (void) { return relbase().xvari;   }
//    gentype &xstdev (void) { return relbase().xstdev;  }
//    gentype &xmax   (void) { return relbase().xmax;    }
//    gentype &xmin   (void) { return relbase().xmin;    }
//    gentype &xrange (void) { return relbase().xrange;  }
//    gentype &xmaxabs(void) { return relbase().xmaxabs; }

    int &xusize(void) { return usize_overwrite ? usize_overwrite : relbase().xusize; }

    int &hasbeenset(void) { return relbase().hasbeenset; }

    const vecInfoBase &relbase(void) const { return (*(content(    majind)))(    minind); }
          vecInfoBase &relbase(void)       { return (*(content("&",majind)))("&",minind); }

//private: - ok whatever, but don't use them

    Vector<SparseVector<vecInfoBase> *> content;

    int isloc;

    int minind;
    int majind; // 0 or 1

    int usize_overwrite;

    // Used to be a global, but not anymore as that clashed with multi-threaded operation

    mutable SparseVector<vecInfo> *scratch;

    vecInfo &getvecscratch(int xmajind, int xminind) const
    {
        if ( !scratch || !((*scratch).isindpresent((2*xmajind)+xminind)) )
        {
#ifdef ENABLE_THREADS
            vecinfoeyelock.lock();
#endif

            if ( !scratch )
            {
                MEMNEW(scratch,SparseVector<vecInfo>);
            }

            if ( !((*scratch).isindpresent((2*xmajind)+xminind)) )
            {
                (*scratch)((2*xmajind)+xminind);
            }

#ifdef ENABLE_THREADS
            vecinfoeyelock.unlock();
#endif
        }

        return (*scratch)("&",(2*xmajind)+xminind);
    }

#ifdef ENABLE_THREADS
    mutable std::mutex vecinfoeyelock;
#endif
};

inline vecInfo &setident (vecInfo &a) { NiceThrow("no"); return a; }
inline vecInfo &setzero  (vecInfo &a) { vecInfo b; return a = b; }
inline vecInfo &setposate(vecInfo &a) { return a; }
inline vecInfo &setnegate(vecInfo &a) { NiceThrow("bleh"); return a; }
inline vecInfo &setconj  (vecInfo &a) { NiceThrow("blit"); return a; }
inline vecInfo &setrand  (vecInfo &a) { NiceThrow("OK, rand"); return a; }

inline vecInfo *&setident (vecInfo *&a) { NiceThrow("no"); return a; }
inline vecInfo *&setzero  (vecInfo *&a) { return a = nullptr; }
inline vecInfo *&setposate(vecInfo *&a) { return a; }
inline vecInfo *&setnegate(vecInfo *&a) { NiceThrow("bleh"); return a; }
inline vecInfo *&setconj  (vecInfo *&a) { NiceThrow("blit"); return a; }
inline vecInfo *&setrand  (vecInfo *&a) { NiceThrow("OK, rand"); return a; }

inline const vecInfo *&setident (const vecInfo *&a) { NiceThrow("no"); return a; }
inline const vecInfo *&setzero  (const vecInfo *&a) { return a = nullptr; }
inline const vecInfo *&setposate(const vecInfo *&a) { return a; }
inline const vecInfo *&setnegate(const vecInfo *&a) { NiceThrow("bleh"); return a; }
inline const vecInfo *&setconj  (const vecInfo *&a) { NiceThrow("blit"); return a; }
inline const vecInfo *&setrand  (const vecInfo *&a) { NiceThrow("OK, rand"); return a; }


inline void qswap(const vecInfo *&a, const vecInfo *&b)
{
    const vecInfo *c(a); a = b; b = c;
}

inline void qswap(vecInfo *&a, vecInfo *&b)
{
    vecInfo *c(a); a = b; b = c;
}

inline void qswap(vecInfo &a, vecInfo &b)
{
    qswap(a.content        ,b.content        );
    qswap(a.isloc          ,b.isloc          );
    qswap(a.minind         ,b.minind         );
    qswap(a.majind         ,b.majind         );
    qswap(a.usize_overwrite,b.usize_overwrite);
    //qswap(a.scratch        ,b.scratch        );
}




// Kernel re-entry prototype: you can inherit from this and then overwrite
// K2xfer with some other function to evaluate the kernel.  Then set the
// pointers to force callback that over-rides ktype

class kernPrecursor;

inline kernPrecursor *&setzero  (kernPrecursor *&a);
inline kernPrecursor *&setident (kernPrecursor *&a);
inline kernPrecursor *&setposate(kernPrecursor *&a);
inline kernPrecursor *&setnegate(kernPrecursor *&a);
inline kernPrecursor *&setconj  (kernPrecursor *&a);
inline kernPrecursor *&setrand  (kernPrecursor *&a);

OVERLAYMAKEFNVECTOR(kernPrecursor)
OVERLAYMAKEFNVECTOR(Vector<kernPrecursor>)
OVERLAYMAKEFNVECTOR(SparseVector<kernPrecursor>)

inline std::ostream &operator<<(std::ostream &output, const kernPrecursor &src );
inline std::istream &operator>>(std::istream &input,        kernPrecursor &dest);



inline void qswap(kernPrecursor *&a, kernPrecursor *&b);

class kernPrecursor
{
public:
    explicit kernPrecursor()
    {
#ifdef ENABLE_THREADS
        kerneyelock.lock();
#endif

        if ( fullmllist == nullptr )
        {
            SparseVector<kernPrecursor *> *locfullmllist = nullptr;

            MEMNEW(locfullmllist,SparseVector<kernPrecursor *>);

            NiceAssert(locfullmllist);

            fullmllist = locfullmllist;
        }

        SparseVector<kernPrecursor *> &themllist = *fullmllist;

        // Search for new unused slot in ML list
        {
            xmlid = xmlidcnt();

            while ( themllist.isindpresent(xmlid) )
            {
                xmlid = xmlidcnt();
            }
        }

        themllist("&",xmlid) = this;

#ifdef ENABLE_THREADS
        kerneyelock.unlock();
#endif
    }

    virtual ~kernPrecursor()
    {
#ifdef ENABLE_THREADS
        kerneyelock.lock();
#endif

        SparseVector<kernPrecursor *> &themllist = *fullmllist;

        themllist.remove(xmlid);

        if ( !themllist.indsize() )
        {
            MEMDEL(fullmllist);
            fullmllist = nullptr;
        }

#ifdef ENABLE_THREADS
        kerneyelock.unlock();
#endif
    }

    kernPrecursor &operator=(const kernPrecursor &src)
    {
        assign(src);

        return *this;
    }

    //virtual void assign(const kernPrecursor &src, int onlySemiCopy = 0)
    virtual void assign(const kernPrecursor &, int = 0)
    {
    }

    //virtual void semicopy(const kernPrecursor &src)
    virtual void semicopy(const kernPrecursor &)
    {
    }

    virtual void qswapinternal(kernPrecursor &b)
    {
        int nv(xmlid); xmlid = b.xmlid; b.xmlid = nv;
    }

    virtual int isKVarianceNZ(void) const
    {
        return 0;
    }

    //
    // - resmode = 0: (default) the result is a number (or matrix or whatever)
    //   This is almost (but not quite) like the definition below, but with
    //   additional points at end.
    //
    // NB: - d2K support removed, placeholder resmode left
    //     - dkdr likewise removed, placeholder left
    //     - modes 16 and 32 also calculate result
    //
    // +---------+--------+----------------+-------------+-----------+-----------+-----------+-----------+------------+
    // | resmode | x,y    | integer consts | real consts | calculate | calculate | calculate | calculate | calculate  |
    // | resmode | subbed |     subbed     |    subbed   |   dk/dr   | dk/dxnorm | dk/dxyprod| d2k/dzdz  | K variance |
    // +---------+--------+----------------+-------------+-----------+-----------+-----------+-----------+------------+
    // | 0 deflt |   y    |        y       |      y      |           |           |           |           |            |
    // +---------+--------+----------------+-------------+-----------+-----------+-----------+-----------+------------+
    // | 1       |        |        y       |      y      |           |           |           |           |            |
    // +---------+--------+----------------+-------------+-----------+-----------+-----------+-----------+------------+
    // | 2       |   y    |                |      y      |           |           |           |           |            |
    // +---------+--------+----------------+-------------+-----------+-----------+-----------+-----------+------------+
    // | 3       |        |                |      y      |           |           |           |           |            |
    // +---------+--------+----------------+-------------+-----------+-----------+-----------+-----------+------------+
    // | 4       |   y    |        y       |             |           |           |           |           |            |
    // +---------+--------+----------------+-------------+-----------+-----------+-----------+-----------+------------+
    // | 5       |        |        y       |             |           |           |           |           |            |
    // +---------+--------+----------------+-------------+-----------+-----------+-----------+-----------+------------+
    // | 6       |   y    |                |             |           |           |           |           |            |
    // +---------+--------+----------------+-------------+-----------+-----------+-----------+-----------+------------+
    // | 7       |        |                |             |           |           |           |           |            |
    // +---------+--------+----------------+-------------+-----------+-----------+-----------+-----------+------------+
    // | 8       |   y    |        y       |      y      |     y     |           |           |           |            |
    // +---------+--------+----------------+-------------+-----------+-----------+-----------+-----------+------------+
    // | 9       |        |        y       |      y      |     y     |           |           |           |            |
    // +---------+--------+----------------+-------------+-----------+-----------+-----------+-----------+------------+
    // | 10      |   y    |                |      y      |     y     |           |           |           |            |
    // +---------+--------+----------------+-------------+-----------+-----------+-----------+-----------+------------+
    // | 11      |        |                |      y      |     y     |           |           |           |            |
    // +---------+--------+----------------+-------------+-----------+-----------+-----------+-----------+------------+
    // | 12      |   y    |        y       |             |     y     |           |           |           |            |
    // +---------+--------+----------------+-------------+-----------+-----------+-----------+-----------+------------+
    // | 13      |        |        y       |             |     y     |           |           |           |            |
    // +---------+--------+----------------+-------------+-----------+-----------+-----------+-----------+------------+
    // | 14      |   y    |                |             |     y     |           |           |           |            |
    // +---------+--------+----------------+-------------+-----------+-----------+-----------+-----------+------------+
    // | 15      |        |                |             |     y     |           |           |           |            |
    // +---------+--------+----------------+-------------+-----------+-----------+-----------+-----------+------------+
    // | 16      |   y    |        y       |      y      |           |     y     |           |           |            |
    // +---------+--------+----------------+-------------+-----------+-----------+-----------+-----------+------------+
    // | 32      |   y    |        y       |      y      |           |           |     y     |           |            |
    // +---------+--------+----------------+-------------+-----------+-----------+-----------+-----------+------------+
    // | 64      |   y    |        y       |      y      |           |           |           |     y     |            |
    // +---------+--------+----------------+-------------+-----------+-----------+-----------+-----------+------------+
    // | 128     |   y    |        y       |      y      |           |           |           |           |     y      |
    // +---------+--------+----------------+-------------+-----------+-----------+-----------+-----------+------------+

//NB: templates cannot be made virtual, so need both versions

    //virtual void K0xfer(gentype &res, int &minmaxind, int typeis,
    //                    const gentype &xyprod, const gentype &yxprod, const gentype &diffis,
    //                    int xdim, int densetype, int resmode, int mlid) const
    virtual void K0xfer(gentype &res, int &, int,
                        const gentype &, const gentype &, const gentype &,
                        int, int, int, int) const
    {
        // Design decision: just return 0 for now for simplicity (allowing -kt 8xx -ktx 0 to work) and let ml_base take care of rest
        //NiceThrow("K0xfer not defined here for m = 4");

        res = 0.0;
    }

    virtual void K0xfer(double &res, int &minmaxind, int typeis,
                        double xyprod, double yxprod, double diffis,
                        int xdim, int densetype, int resmode, int mlid) const
    {
        gentype tempres;

        gentype gxyprod(xyprod);
        gentype gyxprod(yxprod);
        gentype gdiffis(diffis);

        K0xfer(tempres,minmaxind,typeis,gxyprod,gyxprod,gdiffis,xdim,densetype,resmode,mlid);

        res = (double) tempres;
    }

    //virtual void K1xfer(gentype &res, int &minmaxind, int typeis,
    //                    const gentype &xyprod, const gentype &yxprod, const gentype &diffis,
    //                    const SparseVector<gentype> &xa, 
    //                    const vecInfo &xainfo, 
    //                    int ia, 
    //                    int xdim, int densetype, int resmode, int mlid) const
    virtual void K1xfer(gentype &res, int &, int,
                        const gentype &, const gentype &, const gentype &,
                        const SparseVector<gentype> &, 
                        const vecInfo &, 
                        int, 
                        int, int, int, int) const
    {
        // Design decision: just return 0 for now for simplicity (allowing -kt 8xx -ktx 0 to work) and let ml_base take care of rest
        //NiceThrow("K1xfer not defined here for m = 4");

        res = 0.0;
    }

    virtual void K1xfer(double &res, int &minmaxind, int typeis,
                        double xyprod, double yxprod, double diffis,
                        const SparseVector<gentype> &xa, 
                        const vecInfo &xainfo, 
                        int ia, 
                        int xdim, int densetype, int resmode, int mlid) const
    {
        gentype tempres;

        gentype gxyprod(xyprod);
        gentype gyxprod(yxprod);
        gentype gdiffis(diffis);

        K1xfer(tempres,minmaxind,typeis,gxyprod,gyxprod,gdiffis,xa,xainfo,ia,xdim,densetype,resmode,mlid);

        res = (double) tempres;
    }

    //virtual void K2xfer(gentype &dxyprod, gentype &ddiffis, gentype &res, int &minmaxind, int typeis,
    //                    const gentype &xyprod, const gentype &yxprod, const gentype &diffis,
    //                    const SparseVector<gentype> &xa, const SparseVector<gentype> &xb,
    //                    const vecInfo &xainfo, const vecInfo &xbinfo,
    //                    int ia, int ib,
    //                    int xdim, int densetype, int resmode, int mlid) const
    virtual void K2xfer(gentype &dxyprod, gentype &ddiffis, gentype &res, int &, int,
                        const gentype &, const gentype &, const gentype &,
                        const SparseVector<gentype> &, const SparseVector<gentype> &,
                        const vecInfo &, const vecInfo &,
                        int, int,
                        int, int, int, int) const
    {
        // Design decision: just return 0 for now for simplicity (allowing -kt 8xx -ktx 0 to work) and let ml_base take care of rest
        //NiceThrow("K2xfer not defined here for m = 2");

        res = 0.0;

        dxyprod = 0.0;
        ddiffis = 0.0;
    }

    virtual void K2xfer(double &dxyprod, double &ddiffis, double &res, int &minmaxind, int typeis,
                        double xyprod, double yxprod, double diffis,
                        const SparseVector<gentype> &xa, const SparseVector<gentype> &xb,
                        const vecInfo &xainfo, const vecInfo &xbinfo,
                        int ia, int ib,
                        int xdim, int densetype, int resmode, int mlid) const
    {
        gentype tempres;
        gentype tempdxyprod;
        gentype tempddiffis;

        gentype gxyprod(xyprod);
        gentype gyxprod(yxprod);
        gentype gdiffis(diffis);

        K2xfer(tempdxyprod,tempddiffis,tempres,minmaxind,typeis,gxyprod,gyxprod,gdiffis,xa,xb,xainfo,xbinfo,ia,ib,xdim,densetype,resmode,mlid);

        res = (double) tempres;

        dxyprod = tempdxyprod;
        ddiffis = tempddiffis;
    }

    //virtual void K3xfer(gentype &res, int &minmaxind, int typeis,
    //                    const gentype &xyprod, const gentype &yxprod, const gentype &diffis,
    //                    const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, const SparseVector<gentype> &xc, 
    //                    const vecInfo &xainfo, const vecInfo &xbinfo, const vecInfo &xcinfo, 
    //                    int ia, int ib, int ic, 
    //                    int xdim, int densetype, int resmode, int mlid) const
    virtual void K3xfer(gentype &res, int &, int,
                        const gentype &, const gentype &, const gentype &,
                        const SparseVector<gentype> &, const SparseVector<gentype> &, const SparseVector<gentype> &, 
                        const vecInfo &, const vecInfo &, const vecInfo &, 
                        int, int, int, 
                        int, int, int, int) const
    {
        // Design decision: just return 0 for now for simplicity (allowing -kt 8xx -ktx 0 to work) and let ml_base take care of rest
        //NiceThrow("K3xfer not defined here for m = 4");

        res = 0.0;
    }

    virtual void K3xfer(double &res, int &minmaxind, int typeis,
                        double xyprod, double yxprod, double diffis,
                        const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, const SparseVector<gentype> &xc, 
                        const vecInfo &xainfo, const vecInfo &xbinfo, const vecInfo &xcinfo, 
                        int ia, int ib, int ic, 
                        int xdim, int densetype, int resmode, int mlid) const
    {
        gentype tempres;

        gentype gxyprod(xyprod);
        gentype gyxprod(yxprod);
        gentype gdiffis(diffis);

        K3xfer(tempres,minmaxind,typeis,gxyprod,gyxprod,gdiffis,xa,xb,xc,xainfo,xbinfo,xcinfo,ia,ib,ic,xdim,densetype,resmode,mlid);

        res = (double) tempres;
    }

    //virtual void K4xfer(gentype &res, int &minmaxind, int typeis,
    //                    const gentype &xyprod, const gentype &yxprod, const gentype &diffis,
    //                    const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, const SparseVector<gentype> &xc, const SparseVector<gentype> &xd,
    //                    const vecInfo &xainfo, const vecInfo &xbinfo, const vecInfo &xcinfo, const vecInfo &xdinfo,
    //                    int ia, int ib, int ic, int id,
    //                    int xdim, int densetype, int resmode, int mlid) const
    virtual void K4xfer(gentype &res, int &, int,
                        const gentype &, const gentype &, const gentype &,
                        const SparseVector<gentype> &, const SparseVector<gentype> &, const SparseVector<gentype> &, const SparseVector<gentype> &,
                        const vecInfo &, const vecInfo &, const vecInfo &, const vecInfo &,
                        int, int, int, int,
                        int, int, int, int) const
    {
        // Design decision: just return 0 for now for simplicity (allowing -kt 8xx -ktx 0 to work) and let ml_base take care of rest
        //NiceThrow("K4xfer not defined here for m = 4");

        res = 0.0;
    }

    virtual void K4xfer(double &res, int &minmaxind, int typeis,
                        double xyprod, double yxprod, double diffis,
                        const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, const SparseVector<gentype> &xc, const SparseVector<gentype> &xd,
                        const vecInfo &xainfo, const vecInfo &xbinfo, const vecInfo &xcinfo, const vecInfo &xdinfo,
                        int ia, int ib, int ic, int id,
                        int xdim, int densetype, int resmode, int mlid) const
    {
        gentype tempres;

        gentype gxyprod(xyprod);
        gentype gyxprod(yxprod);
        gentype gdiffis(diffis);

        K4xfer(tempres,minmaxind,typeis,gxyprod,gyxprod,gdiffis,xa,xb,xc,xd,xainfo,xbinfo,xcinfo,xdinfo,ia,ib,ic,id,xdim,densetype,resmode,mlid);

        res = (double) tempres;
    }

    //virtual void Kmxfer(gentype &res, int &minmaxind, int typeis,
    //                    const gentype &xyprod, const gentype &yxprod, const gentype &diffis,
    //                    Vector<const SparseVector<gentype> *> &x,
    //                    Vector<const vecInfo *> &xinfo,
    //                    Vector<int> &i,
    //                    int xdim, int m, int densetype, int resmode, int mlid) const
    virtual void Kmxfer(gentype &res, int &, int,
                        const gentype &, const gentype &, const gentype &,
                        Vector<const SparseVector<gentype> *> &,
                        Vector<const vecInfo *> &,
                        Vector<int> &,
                        int, int, int, int, int) const
    {
        // Design decision: just return 0 for now for simplicity (allowing -kt 8xx -ktx 0 to work) and let ml_base take care of rest
/*
        if ( m == 0 )
        {
            K0xfer(res,minmaxind,typeis,xyprod,yxprod,diffis,xdim,densetype,resmode,mlid);
        }

        else if ( m == 1 )
        {
            K1xfer(res,minmaxind,typeis,xyprod,yxprod,diffis,*x(0),*xinfo(0),i(0),xdim,densetype,resmode,mlid);
        }

        else if ( m == 2 )
        {
            gentype dummy;

            K2xfer(dummy,dummy,res,minmaxind,typeis,xyprod,yxprod,diffis,*x(0),*x(1),*xinfo(0),*xinfo(1),i(0),i(1),xdim,densetype,resmode,mlid);
        }

        else if ( m == 3 )
        {
            K3xfer(res,minmaxind,typeis,xyprod,yxprod,diffis,*x(0),*x(1),*x(2),*xinfo(0),*xinfo(1),*xinfo(2),i(0),i(1),i(2),xdim,densetype,resmode,mlid);
        }

        else if ( m == 4 )
        {
            K4xfer(res,minmaxind,typeis,xyprod,yxprod,diffis,*x(0),*x(1),*x(2),*x(3),*xinfo(0),*xinfo(1),*xinfo(2),*xinfo(3),i(0),i(1),i(2),i(3),xdim,densetype,resmode,mlid);
        }

        else
*/
        {
            res = 0.0;

            // Design decision: just return 0 for now for simplicity (allowing -kt 8xx -ktx 0 to work) and let ml_base take care of rest
            //NiceThrow("Kmxfer not defined here for m > 4");
        }
    }

    virtual void Kmxfer(double &res, int &minmaxind, int typeis,
                        double xyprod, double yxprod, double diffis,
                        Vector<const SparseVector<gentype> *> &x,
                        Vector<const vecInfo *> &xinfo,
                        Vector<int> &i,
                        int xdim, int m, int densetype, int resmode, int mlid) const
    {
        gentype tempres(res);

        gentype gxyprod(xyprod);
        gentype gyxprod(yxprod);
        gentype gdiffis(diffis);

        Kmxfer(tempres,minmaxind,typeis,gxyprod,gyxprod,gdiffis,x,xinfo,i,xdim,m,densetype,resmode,mlid);

        res = (double) tempres;
    }





    // Kernel transfer switching stuff.  All MLs are registered so you
    // can switch between them (kernel transfer).
    //
    // MLid(): unique ID for this this ML.
    // setMLid(): MLid is default = > STARTMLID - use this to set to more sensible
    //            value.  Return 0 on success, nz otherwise.
    // getaltML(): get reference to ML with given ID.  Return 0 on success, 1 if nullptr.

    virtual int MLid(void) const
    {
        return xmlid;
    }

    virtual int setMLid(int nv)
    {
        int res = 0;

#ifdef ENABLE_THREADS
        kerneyelock.lock();
#endif

        SparseVector<kernPrecursor *> &themllist = *fullmllist;

        //if ( ( nv < 0 ) || ( nv > NUMMLINSTANCES ) )
        if ( nv < 0 )
        {
            res = 1;
        }

        else if ( themllist.isindpresent(nv) )
        {
            res = 2;
        }

        else
        {
            xmlid = nv;

            themllist("&",xmlid) = this;
        }

#ifdef ENABLE_THREADS
        kerneyelock.unlock();
#endif

        return res;
    }

    virtual int getaltML(kernPrecursor *&res, int altMLid) const
    {
#ifdef ENABLE_THREADS
        kerneyelock.lock();
#endif

        SparseVector<kernPrecursor *> &themllist = *fullmllist;

        int ires = 1;
        res = nullptr;

        if ( themllist.isindpresent(altMLid) )
        {
            ires = 0;
            res = themllist("&",altMLid);
        }

#ifdef ENABLE_THREADS
        kerneyelock.unlock();
#endif

        return ires;
    }

    int mllistsize(void)
    {
//#ifdef ENABLE_THREADS
//        svm_mutex_lock(kerneyelock);
//#endif
        int res = (*fullmllist).indsize();
//#ifdef ENABLE_THREADS
//        svm_mutex_unlock(kerneyelock);
//#endif
        return res;
}

    int mllistind(int i)
    {
#ifdef ENABLE_THREADS
        kerneyelock.lock();
#endif
        int res = (*fullmllist).ind(i);
#ifdef ENABLE_THREADS
        kerneyelock.unlock();
#endif
        return res;
    }

    int mllistisindpresent(int i)
    {
#ifdef ENABLE_THREADS
        kerneyelock.lock();
#endif
        int res = (*fullmllist).isindpresent(i);
#ifdef ENABLE_THREADS
        kerneyelock.unlock();
#endif
        return res;
    }

    int xmlid;

    virtual std::ostream &printstream(std::ostream &output, int dep) const { (void) dep; return output; }
    virtual std::istream &inputstream(std::istream &input ) { return input; }

    virtual int type(void) const { return -2; }
    virtual int subtype(void) const { return 0; }

    virtual int getparam (int ind, gentype         &val, const gentype         &xa, int ia, const gentype         &xb, int ib, charptr &desc) const { (void) ind; (void) val; (void) xa; (void) ia; (void) xb; (void) ib; desc = ""; return 0; }
    virtual int egetparam(int ind, Vector<gentype> &val, const Vector<gentype> &xa, int ia, const Vector<gentype> &xb, int ib               ) const { (void) ind; (void) val; (void) xa; (void) ia; (void) xb; (void) ib;            return 0; }

    //const svmvolatile SparseVector<kernPrecursor *> &getmllist(void) const { return *fullmllist; }



    // x data

    virtual const SparseVector<gentype> &x(int i)              const { (void) i; NiceThrow("Not there yet"); const static SparseVector<gentype> dummy; return dummy;  }
    virtual const SparseVector<gentype> &x(int i, int altMLid) const { kernPrecursor *tmp = nullptr; getaltML(tmp,altMLid);  NiceAssert(tmp); return (*tmp).x(i); }

private:

    int xmlidcnt(void)
    {
#ifdef ENABLE_THREADS
        static std::atomic<int> loccnt(STARTMLID); //NUMMLINSTANCES/2);
#endif
#ifndef ENABLE_THREADS
        static int loccnt(STARTMLID); //NUMMLINSTANCES/2);
#endif

        return (int) ++loccnt;
    }

    static SparseVector<kernPrecursor *>* fullmllist;
#ifdef ENABLE_THREADS
    static std::mutex kerneyelock;
#endif
};

inline kernPrecursor *&setident (kernPrecursor *&a) { NiceThrow("no"); return a; }
inline kernPrecursor *&setposate(kernPrecursor *&a) { return a; }
inline kernPrecursor *&setnegate(kernPrecursor *&a) { NiceThrow("bleh"); return a; }
inline kernPrecursor *&setconj  (kernPrecursor *&a) { NiceThrow("blit"); return a; }
inline kernPrecursor *&setrand  (kernPrecursor *&a) { NiceThrow("OK, rand"); return a; }

inline kernPrecursor *&setzero(kernPrecursor *&a)
{
    return a = nullptr;
}

inline void qswap(kernPrecursor *&a, kernPrecursor *&b)
{
    kernPrecursor *c(a); a = b; b = c;
}

inline std::ostream &operator<<(std::ostream &output, const kernPrecursor &src)
{
    return src.printstream(output,0);
}

inline std::istream &operator>>(std::istream &input, kernPrecursor &dest)
{
    return dest.inputstream(input);
}








//
// Kernel information structure: this stores information about what info
// the kernel function uses to evaluate.  Adding these gives the flags if
// the 

class kernInfo;

OVERLAYMAKEFNVECTOR(kernInfo)
OVERLAYMAKEFNVECTOR(Vector<kernInfo>)
OVERLAYMAKEFNVECTOR(SparseVector<kernInfo>)

inline void qswap(kernInfo *&a, kernInfo *&b);

class kernInfo
{
public:

    kernInfo()
    {
        usesDiff    = 0;
        usesInner   = 0;
        usesNorm    = 0;
        usesVector  = 0;
        usesMinDiff = 0;
        usesMaxDiff = 0;
    }

    kernInfo(const kernInfo &src)
    {
        usesDiff    = src.usesDiff;
        usesInner   = src.usesInner;
        usesNorm    = src.usesNorm;
        usesVector  = src.usesVector;
        usesMinDiff = src.usesMinDiff;
        usesMaxDiff = src.usesMaxDiff;
    }

    kernInfo &operator=(const kernInfo &src)
    {
        usesDiff    = src.usesDiff;
        usesInner   = src.usesInner;
        usesNorm    = src.usesNorm;
        usesVector  = src.usesVector;
        usesMinDiff = src.usesMinDiff;
        usesMaxDiff = src.usesMaxDiff;

        return *this;
    }

    int numflagsset(void) const
    {
        return usesDiff+usesInner+usesNorm+usesVector+usesMinDiff+usesMaxDiff;
    }

    kernInfo &zero(void)
    {
        usesDiff    = 0;
        usesInner   = 0;
        usesNorm    = 0;
        usesVector  = 0;
        usesMinDiff = 0;
        usesMaxDiff = 0;

        return *this;
    }

    unsigned int usesDiff    : 1; // set if kernel uses ||x-y||^2 explicitly
    unsigned int usesInner   : 1; // set if kernel uses x'y explicitly
    unsigned int usesNorm    : 1; // set if kernel uses ||x||^2 and ||y||^2 explicitly
    unsigned int usesVector  : 1; // set if kernel uses x and y vectors explicitly
    unsigned int usesMinDiff : 1; // set if kernel uses min(x-y) explicitly
    unsigned int usesMaxDiff : 1; // set if kernel uses max(x-y) explicitly
};

inline void qswap(kernInfo *&a, kernInfo *&b)
{
    kernInfo *c(a); a = b; b = c;
}

//
// +=: this is defined so that summing a vector of kernInfo works as OR
// ==: equivalence operator
// <<: output stream
// >>: input strea,
// setzero: sets all flags 0
// qswap:   standard quickswap operation
//

kernInfo &operator+=(kernInfo &a, const kernInfo &b);
int operator==(const kernInfo &a, const kernInfo &b);

std::ostream &operator<<(std::ostream &output, const kernInfo &src);
std::istream &operator>>(std::istream &input, kernInfo &dest);

inline kernInfo &setzero  (kernInfo &a);
inline kernInfo &setident (kernInfo &a);
inline kernInfo &setposate(kernInfo &a);
inline kernInfo &setnegate(kernInfo &a);
inline kernInfo &setconj  (kernInfo &a);
inline kernInfo &setrand  (kernInfo &a);

inline kernInfo &postProInnerProd(kernInfo &a) { return a; }
inline void qswap(kernInfo &a, kernInfo &b);

inline kernInfo &setident (kernInfo &a) { NiceThrow("no"); return a; }
inline kernInfo &setposate(kernInfo &a) { return a; }
inline kernInfo &setnegate(kernInfo &a) { NiceThrow("bleh"); return a; }
inline kernInfo &setconj  (kernInfo &a) { NiceThrow("blit"); return a; }
inline kernInfo &setrand  (kernInfo &a) { NiceThrow("OK, rand"); return a; }

inline kernInfo *&setident (kernInfo *&a) { NiceThrow("no"); return a; }
inline kernInfo *&setzero  (kernInfo *&a) { return a = nullptr; }
inline kernInfo *&setposate(kernInfo *&a) { return a; }
inline kernInfo *&setnegate(kernInfo *&a) { NiceThrow("bleh"); return a; }
inline kernInfo *&setconj  (kernInfo *&a) { NiceThrow("blit"); return a; }
inline kernInfo *&setrand  (kernInfo *&a) { NiceThrow("OK, rand"); return a; }

inline const kernInfo *&setident (const kernInfo *&a) { NiceThrow("no"); return a; }
inline const kernInfo *&setzero  (const kernInfo *&a) { return a = nullptr; }
inline const kernInfo *&setposate(const kernInfo *&a) { return a; }
inline const kernInfo *&setnegate(const kernInfo *&a) { NiceThrow("bleh"); return a; }
inline const kernInfo *&setconj  (const kernInfo *&a) { NiceThrow("blit"); return a; }
inline const kernInfo *&setrand  (const kernInfo *&a) { NiceThrow("OK, rand"); return a; }

inline kernInfo &setzero(kernInfo &a)
{
    return a.zero();
}

inline void qswap(kernInfo &a, kernInfo &b)
{
    kernInfo c(a); a = b; b = c;
}






std::ostream &operator<<(std::ostream &output, const vecInfoBase &src);
std::istream &operator>>(std::istream &input, vecInfoBase &dest);

std::ostream &operator<<(std::ostream &output, const vecInfo &src);
std::istream &operator>>(std::istream &input, vecInfo &dest);

// Swap function

inline void qswap(MercerKernel &a, MercerKernel &b);

OVERLAYMAKEFNVECTOR(MercerKernel)
OVERLAYMAKEFNVECTOR(Vector<MercerKernel>)
OVERLAYMAKEFNVECTOR(SparseVector<MercerKernel>)

class MercerKernel : public kernPrecursor
{
    friend int operator==(const MercerKernel &leftop, const MercerKernel &rightop);
    friend void qswap(MercerKernel &a, MercerKernel &b);

public:

    virtual std::ostream &printstream(std::ostream &output, int dep) const override;
    virtual std::istream &inputstream(std::istream &input)                 override;

    virtual int type   (void) const override { return -3; }
    virtual int subtype(void) const override { return 0; }

    virtual int getparam (int ind, gentype         &val, const gentype         &xa, int ia, const gentype         &xb, int ib, charptr &desc) const override;
    virtual int egetparam(int ind, Vector<gentype> &val, const Vector<gentype> &xa, int ia, const Vector<gentype> &xb, int ib               ) const override;

    // Constructors and assignment operators

    explicit MercerKernel();
             MercerKernel(const MercerKernel &src);

    ~MercerKernel();

    MercerKernel &operator=(const MercerKernel &src);

    // Overall Information:
    //
    // isAltDiff: 0:   ||x-y||_2^2    -> ||x||_m^m + ||x'||_m^m + ... - m.<<x,x',...>>_m
    //            1:   ||x-y||_2^2    -> ||x||_2^2 + ||x'||_2^2 + ... - 2.<<x,x',...>>_m (default)
    //            2:   2*(||x-y||_2^2 -> ||x||_2^2 + ||x'||_2^2 + ... - (1/m).(sum_{ij} <xi,xj>))
    //                 (the RBF has additional scaling as per paper - see Kbase)
    //            5:   ||x-y||_2^2    -> ||x-x'||_2^2 + ||x''-x'''||_2^2 + ...
    //                                 = ||x||_2^2 + ||x'||_x^2 + ... - 2<x,x'> - 2<x'',x'''> - ...
    //                                 = ||x||_2^2 + ||x'||_x^2 + ... - 2 sum_{i=0,2,...} <x_i,x_{i+1}>
    //            103: K(...) -> 1/2^{m-1} \sum_{s = [ +-1 +-1 ... ] \in R^m : |i:si=+1| + |i:si=-1| \in 4Z_+} K(||sum_i s_i x_i ||_2^2)
    //            104: K(...) -> 1/m!      \sum_{s = [ +-1 +-1 ... ] \in R^m : |i:si=+1| = |i:si=-1|         } K(||sum_i s_i x_i ||_2^2)
    //            203: like 103, but kernel expansion occurs over first kernel in chain only
    //            204: like 104, but kernel expansion occurs over first kernel in chain only
    //            300: true moment-kernel expension to 2-kernels

    bool unadornedRBFKernel(int allowsymm = 0) const { return isVeryTrivialKernel(allowsymm) && !sizeLinConstr() && ( cType() == 3 ) && ( ((double) cWeight()) == 1.0 ) && ( ((double) cRealConstants()(1)) == 0.0 ); }

    const Vector<int> &defindKey(void) const { return xdefindKey; } // on the training set at least
    int basexdim(void) const { return defindKey().size(); }

    int isSymmSet        (void) const { return issymmset;                 } // symmetrise setwise kernel evaluation
    int isFullNorm       (void) const { return isfullnorm;                } // normalise at outermost
    int isProd           (void) const { return isprod;                    } // K(x,y) = prod_i K(x_i,y_i)
    int isIndex          (void) const { return isind;                     } // x'z is indexed (x'z -> sum_{i in S} x_i.y_i)
    int isShifted        (void) const { return isshift & 1;               } // vectors shifted (x -> (x-sh))
    int isScaled         (void) const { return isshift & 2;               } // vectors scaled (x -> diag(sc).x)
    int isShiftedScaled  (void) const { return isshift == 3;              } // vectors shifted and scaled (x -> diag(sc).(x-sh))
    int isLeftPlain      (void) const { return leftplain;                 } // no normalisation applied to x in K(x,y)
    int isRightPlain     (void) const { return rightplain;                } // no normalisation applied to y in K(x,y)
    int isLeftRightPlain (void) const { return leftplain && rightplain;   } // no normalisation applied to x and y in K(x,y)
    int isLeftNormal     (void) const { return !leftplain;                } // normalisation may be applied to x in K(x,y)
    int isRightNormal    (void) const { return !rightplain;               } // normalisation may be applied to y in K(x,y)
    int isLeftRightNormal(void) const { return !leftplain && !rightplain; } // normalisation may be applied to x and y in K(x,y)
    int isPartNormal     (void) const { return !leftplain || !rightplain; } // normalisation may be applied to x or y in K(x,y)
    int isAltDiff        (void) const { return isdiffalt;                 } // see above notes
    int needsmProd       (void) const { return needsInner(-1,4);          } // m-kernel calculation requires <<x,y,...>>_m
    int wantsXYprod      (void) const { return needsMatDiff();            } // providing an xy matrix will result in speedup
    int suggestXYcache   (void) const { return xsuggestXYcache;           } // suggest to user that passing xy matrix will help even in 2-kernel cache (purely advisory, can be ignored)
    int isIPdiffered     (void) const { return xisIPdiffered;             } // inner-products have changes (0 means *probably* unchanged)
    int rankType         (void) const { return xranktype;                 } // how ranks are translated. 0: phi(x,x') = phi(x)-phi(x'), 1: phi(x,x') = phi(x)+phi(x'), 2: phi(x,x') = phi(x) \otimes phi(x') - phi(x') \otimes phi(x), 3: phi(x,x') = phi(x) \otimes phi(x') - phi(x') \otimes phi(x)

    double denseZeroPoint(void) const { return xdenseZeroPoint; } // zero point (beta) for dense integration (beta = r0.xdenseZeroPoint)

    int size       (void) const { return isnorm.size(); } // number of kernel "blocks" in total kernel
    int getSymmetry(void) const;                          // 1 for symmetric, -1 for anti, 0 for none

    const       Vector<int>     &cIndexes(void) const { return dIndexes; } // index vector S if used
    const SparseVector<gentype> &cShift  (void) const { return dShift;   } // shift used for normalisation
    const SparseVector<gentype> &cScale  (void) const { return dScale;   } // scale used for normalisation

    // Linear constraint information
    //
    // As per Jidling, you can enforce linear constraints on the RKHS by modifying
    // the kernel with the null-space operator of the form:
    //
    // O_0 O_1 ... O_{m-1} Km(x_0,x_1,...,x_{m-1})
    //
    // where O_i is an operator of the form:
    //
    // O_i = M_i (d/dx)^{\otimes p_i} (kronecker power)
    //
    // where p_i is an integer (order) and M_i is a matrix.

    int sizeLinConstr(void) const { return linGradOrd.size(); } // number of terms in linear constraint (see Jidling), 0 of no constraints

    const Vector<int>             &getlinGradOrd (void) const { return linGradOrd;  } // order of linear gradient constraints (see Jidling)
    const Vector<Matrix<double> > &getlinGradScal(void) const { return linGradScal; } // get matrix part of linear gradient constraints (see Jidling)

    // Kernel "block" information
    //
    // Constant overwrites let you take the value for real (integer)
    // constants from the input vectors x and y.  For example, if
    // cRealOverwrite(q) = ( 0:2 1:10 ) then:
    //
    // realConstant(0) -> x(2)*y(2)    (x(2) is rightPlain, y(2) if leftPlain)
    // realConstant(1) -> x(10)*y(10)  (x(2) is rightPlain, y(2) if leftPlain)

    const gentype &cWeight     (int q = 0) const { return dRealConstants(q)(0); } // weight w_q for K_q
    int            cType       (int q = 0) const { return dtype(q);             } // type of K_q
    int            isNormalised(int q = 0) const { return isnorm(q);            } // set if K_q is scaled/shifted (x -> diag(sc).(x-sh))
    int            isMagTerm   (int q = 0) const { return ismagterm(q);         } // K(x,y,...)=K(x,x,...).K(y,y,...)....

          int              numSamples        (void) const { return xnumsamples; } // used when interpretting functions as distributions
    const Vector<gentype> &sampleDistribution(void) const { return xsampdist;   } // used when interpretting functions as distributions
    const Vector<int>     &sampleIndices     (void) const { return xindsub;     } // used when interpretting functions as distributions

    const kernPrecursor *getAltCall(int q = 0, int currml = -1) const { (void) currml; NiceAssert( currml != altcallback(q) ); kernPrecursor *res = nullptr; int ires = getaltML(res,altcallback(q)); NiceAssert( !ires ); (void) ires; return res; }

    const Vector<gentype>   &cRealConstants(int q = 0) const { return dRealConstants(q)(1,1,dRealConstants(q).size()-1,cRealConstantsTmp); } // real constants for K_q
    const Vector<int>       &cIntConstants (int q = 0) const { return dIntConstants(q);                                                    } // int constants for K_q
    const SparseVector<int> &cRealOverwrite(int q = 0) const { return dRealOverwrite(q);                                                   } // real constant overwrites for K_q
    const SparseVector<int> &cIntOverwrite (int q = 0) const { return dIntOverwrite(q);                                                    } // int constant overwrites for K_q

    const gentype &getRealConstZero(int q = 0) const { return cRealConstants(q)(0); }
          int      getIntConstZero (int q = 0) const { return cIntConstants(q)(0);  }

    double effweight(int q = 0) const; // return effective weight for kernel starting at q (ie product of is isSplit == 1 terms)

    // Nominal bounds on constants (used in tuneKernel)

    const gentype &cWeightLB(int q = 0) const { return dRealConstantsLB(q)(0); }

    const Vector<gentype> &cRealConstantsLB(int q = 0) const { return dRealConstantsLB(q)(1,1,dRealConstantsLB(q).size()-1,cRealConstantsTmp); }
    const Vector<int>     &cIntConstantsLB (int q = 0) const { return dIntConstantsLB(q);                                                      }

    const gentype &getRealConstZeroLB(int q = 0) const { return cRealConstantsLB(q)(0); }
          int      getIntConstZeroLB (int q = 0) const { return cIntConstantsLB(q)(0);  }

    const gentype &cWeightUB(int q = 0) const { return dRealConstantsUB(q)(0); }

    const Vector<gentype> &cRealConstantsUB(int q = 0) const { return dRealConstantsUB(q)(1,1,dRealConstantsUB(q).size()-1,cRealConstantsTmp); }
    const Vector<int>     &cIntConstantsUB (int q = 0) const { return dIntConstantsUB(q);                                                      }

    const gentype &getRealConstZeroUB(int q = 0) const { return cRealConstantsUB(q)(0); }
          int      getIntConstZeroUB (int q = 0) const { return cIntConstantsUB(q)(0);  }

    // Random features
    //
    // getRandFeats: random features for kernel q, if any
    // isRandFeatReOnly: 0 for real and imaginary parts, 1 for real only, -1 for imaginary only
    // isRandFeatNoAngle: 0 for random angles, 1 for zero angle.

          int                             getnumRandFeats  (int q = 0) const { return randFeats(q).size(); }
    const Vector<SparseVector<gentype> > &getRandFeats     (int q = 0) const { return randFeats(q);        }
    const Vector<double>                 &getRandFeatAngle (int q = 0) const { return randFeatAngle(q);    }
          int                             isRandFeatReOnly (int q = 0) const { return randFeatReOnly(q);   }
          int                             isRandFeatNoAngle(int q = 0) const { return randFeatNoAngle(q);  }

    // Details on how the kernel "blocks" are put together
    //
    // Chaining: normally the total kernel function is:
    //
    // K = K_0 + K_1 + K_2 + K_3 + K_4 ...
    //
    // chaining involves taking the output of one kernel and feeding to the
    // input of the next kernel.  So if, for example, isChained(1) &&
    // isChained(2):
    //
    // K(...) = K_0(...) + K_3(K_2(K_1(...))) + K_4(...) + ...
    //
    // Note that chaining will only work for kernels that do not explicitly
    // use x,y (rather than x'x, x'y and y'y).  Kernels for which
    // !isKkitchensink(q) are fine.
    //
    //
    // Splitting: By splitting you can serparate kernels into multiple parts.
    // For example is isSplit(1) is set then:
    //
    // K(a,b,c,d,e) = K01(a,b).K23...(c,d,e)
    //
    // where K01 = K0+K1 (or different depending on chaining etc) and
    // K23... = K2+K3+....
    //
    // if issplit == 2 then this becomes *additive* rather than
    // multiplicative.
    //
    //
    // Multiplicative splitting: In this case the kernel can be built
    // as (in this example isMulSplit(2) = 1, rest 0):
    //
    // K(x,y) = K012(x,y).K34...(x,y)
    //
    // where K012 = K0+K1+K2 (or dfiferent depending on chaining etc) and
    // K23... = K2+K3+....
    //
    // if mulsplit == 2 then this becomes *additive* rather than
    // multiplicative.
    //
    //
    // The order of these is: first do mulsplit, then do split, then
    // do chaining.

    int isChained   (int q = 0) const { return ischain(q);   } // see above
    int isSplit     (int q = 0) const { return issplit(q);   } // see above
    int isMulSplit  (int q = 0) const { return mulsplit(q);  } // see above

    int numSplits   (void) const { return xnumSplits;    } // total number of splits
    int numMulSplits(void) const { return xnumMulSplits; } // total number of multiplicative splits

    // isKVarianceNZ: does K have variance (ie. inheritted from some GP or similar that uses averaging)

    int isKVarianceNZ(void) const override
    {
        int res = 0;

        //FIXME
        /*
        if ( size() )
        {
            int i;

            for ( i = 0 ; i < size() ; ++i )
            {
                if ( ( cType(i) >= 800 ) && ( cType(i) <= 899 ) )
                {
                    NiceAssert( MLid() != altcallback(i) );

                    if ( (*(getAltCall(i,mlid))).isKVarianceNZ(void) )
                    {
                        res = 1;
                        break;
                    }
                }
            }
        }
        */

        return res;
    }

    // Individual kernel block information.  Note that this does
    // not take norming into account.

    const kernInfo &kinf(int q) const { return kernflags(q); }
    const kernInfo  kinf(void)  const { return sum(kernflags); }

    // Modifiers:

    MercerKernel &add   (int q);
    MercerKernel &remove(int q);
    MercerKernel &resize(int nsize);

    MercerKernel &setdefindKey(const Vector<int> &nv) { xdefindKey = nv; recalcRandFeats(-1); return *this; }

    MercerKernel &setSymmSet        (void) {                                                                                                      issymmset        = 1;                                  recalcRandFeats(-1); return *this; }
    MercerKernel &setNoSymmSet      (void) {                                                                                                      issymmset        = 0;                                  recalcRandFeats(-1); return *this; }
    MercerKernel &setFullNorm       (void) {                                                                                                      isfullnorm       = 1;                                  recalcRandFeats(-1); return *this; }
    MercerKernel &setNoFullNorm     (void) {                                                                                                      isfullnorm       = 0;                                  recalcRandFeats(-1); return *this; }
    MercerKernel &setProd           (void) {                    xisfast = -1; xneedsInnerm2 = xneedsInner = -1; xneedsDiff = -1; xneedsNorm = -1; isprod           = 1;                                  recalcRandFeats(-1); return *this; }
    MercerKernel &setnonProd        (void) {                    xisfast = -1; xneedsInnerm2 = xneedsInner = -1; xneedsDiff = -1; xneedsNorm = -1; isprod           = 0;                                  recalcRandFeats(-1); return *this; }
    MercerKernel &setLeftPlain      (void) { xisIPdiffered = 1; xisfast = -1; xneedsInnerm2 = xneedsInner = -1; xneedsDiff = -1; xneedsNorm = -1; leftplain        = 1;                  fixShiftProd(); recalcRandFeats(-1); return *this; }
    MercerKernel &setRightPlain     (void) { xisIPdiffered = 1; xisfast = -1; xneedsInnerm2 = xneedsInner = -1; xneedsDiff = -1; xneedsNorm = -1; rightplain       = 1;                  fixShiftProd(); recalcRandFeats(-1); return *this; }
    MercerKernel &setLeftRightPlain (void) { xisIPdiffered = 1; xisfast = -1; xneedsInnerm2 = xneedsInner = -1; xneedsDiff = -1; xneedsNorm = -1; leftplain        = 1;  rightplain = 1; fixShiftProd(); recalcRandFeats(-1); return *this; }
    MercerKernel &setLeftNormal     (void) { xisIPdiffered = 1; xisfast = -1; xneedsInnerm2 = xneedsInner = -1; xneedsDiff = -1; xneedsNorm = -1; leftplain        = 0;                  fixShiftProd(); recalcRandFeats(-1); return *this; }
    MercerKernel &setRightNormal    (void) { xisIPdiffered = 1; xisfast = -1; xneedsInnerm2 = xneedsInner = -1; xneedsDiff = -1; xneedsNorm = -1; rightplain       = 0;                  fixShiftProd(); recalcRandFeats(-1); return *this; }
    MercerKernel &setLeftRightNormal(void) { xisIPdiffered = 1; xisfast = -1; xneedsInnerm2 = xneedsInner = -1; xneedsDiff = -1; xneedsNorm = -1; leftplain        = 0;  rightplain = 0; fixShiftProd(); recalcRandFeats(-1); return *this; }
    MercerKernel &setrankType       (int nv) {                  xisfast = -1; xneedsInnerm2 = xneedsInner = -1; xneedsDiff = -1; xneedsNorm = -1; xranktype        = nv;                                                      return *this; }

    MercerKernel &setdenseZeroPoint(double nv) { xdenseZeroPoint = nv; return *this; }

    MercerKernel &setAltDiff       (int nv) { xisfast = -1; xneedsInnerm2 = xneedsInner = -1; xneedsDiff = -1; xneedsNorm = -1; isdiffalt        = nv; recalcRandFeats(-1); return *this; }
    MercerKernel &setsuggestXYcache(int nv) {                                                                                   xsuggestXYcache  = nv; recalcRandFeats(-1); return *this; }
    MercerKernel &setIPdiffered    (int nv) {                                                                                   xisIPdiffered    = nv; recalcRandFeats(-1); return *this; }

    MercerKernel &setnumSamples        (int                    nv) { xnumsamples = nv; return *this; }
    MercerKernel &setSampleDistribution(const Vector<gentype> &nv) { xsampdist   = nv; return *this; }
    MercerKernel &setSampleIndices     (const Vector<int>     &nv) { xindsub     = nv; return *this; }

    MercerKernel &setIndexes(const Vector<int> &ndIndexes) { xisIPdiffered = 1; xisfast = -1; xneedsInnerm2 = xneedsInner = -1; xneedsDiff = -1; xneedsNorm = -1; isind = 1; dIndexes = ndIndexes; fixShiftProd(); recalcRandFeats(-1); return *this; }
    MercerKernel &setUnIndex(void)                         { xisIPdiffered = 1; xisfast = -1; xneedsInnerm2 = xneedsInner = -1; xneedsDiff = -1; xneedsNorm = -1; isind = 0;                       fixShiftProd(); recalcRandFeats(-1); return *this; }

    MercerKernel &setShift(const SparseVector<gentype> &ndShift) { xisIPdiffered = 1; xisfast = -1; xneedsInnerm2 = xneedsInner = -1; xneedsDiff = -1; xneedsNorm = -1; isshift |= 1; dShift = ndShift; dShift.makealtcontent(); fixShiftProd(); recalcRandFeats(-1); return *this; }
    MercerKernel &setScale(const SparseVector<gentype> &ndScale) { xisIPdiffered = 1; xisfast = -1; xneedsInnerm2 = xneedsInner = -1; xneedsDiff = -1; xneedsNorm = -1; isshift |= 2; dScale = ndScale; dScale.makealtcontent(); fixShiftProd(); recalcRandFeats(-1); return *this; }
    MercerKernel &setUnShiftedScaled(void)                       { xisIPdiffered = 1; xisfast = -1; xneedsInnerm2 = xneedsInner = -1; xneedsDiff = -1; xneedsNorm = -1; isshift  = 0;                                            fixShiftProd(); recalcRandFeats(-1); return *this; }

    MercerKernel &setChained   (int q = 0)         { xisfast = -1; xneedsInnerm2 = xneedsInner = -1; xneedsDiff = -1; xneedsNorm = -1; ischain  ("&",q) = 1;                                     recalcRandFeats(q); return *this; }
    MercerKernel &setNormalised(int q = 0)         { xisfast = -1; xneedsInnerm2 = xneedsInner = -1; xneedsDiff = -1; xneedsNorm = -1; isnorm   ("&",q) = 1;                                     recalcRandFeats(q); return *this; }
    MercerKernel &setSplit     (int q = 0)         { xisfast = -1; xneedsInnerm2 = xneedsInner = -1; xneedsDiff = -1; xneedsNorm = -1; issplit  ("&",q) = 1; xnumSplits    = calcnumSplits();    recalcRandFeats(q); return *this; }
    MercerKernel &setSplitAdd  (int q = 0)         { xisfast = -1; xneedsInnerm2 = xneedsInner = -1; xneedsDiff = -1; xneedsNorm = -1; issplit  ("&",q) = 2; xnumSplits    = calcnumSplits();    recalcRandFeats(q); return *this; }
    MercerKernel &setMulSplit  (int q = 0)         { xisfast = -1; xneedsInnerm2 = xneedsInner = -1; xneedsDiff = -1; xneedsNorm = -1; mulsplit ("&",q) = 1; xnumMulSplits = calcnumMulSplits(); recalcRandFeats(q); return *this; }
    MercerKernel &setAddSplit  (int q = 0)         { xisfast = -1; xneedsInnerm2 = xneedsInner = -1; xneedsDiff = -1; xneedsNorm = -1; mulsplit ("&",q) = 2; xnumMulSplits = calcnumMulSplits(); recalcRandFeats(q); return *this; }
    MercerKernel &setMagTerm   (int q = 0)         { xisfast = -1; xneedsInnerm2 = xneedsInner = -1; xneedsDiff = -1; xneedsNorm = -1; ismagterm("&",q) = 1;                                     recalcRandFeats(q); return *this; }

    MercerKernel &setUnChained   (int q = 0) { xisfast = -1; xneedsInnerm2 = xneedsInner = -1; xneedsDiff = -1; xneedsNorm = -1; ischain  ("&",q) = 0;                                     recalcRandFeats(q); return *this; }
    MercerKernel &setUnNormalised(int q = 0) { xisfast = -1; xneedsInnerm2 = xneedsInner = -1; xneedsDiff = -1; xneedsNorm = -1; isnorm   ("&",q) = 0;                                     recalcRandFeats(q); return *this; }
    MercerKernel &setUnSplit     (int q = 0) { xisfast = -1; xneedsInnerm2 = xneedsInner = -1; xneedsDiff = -1; xneedsNorm = -1; issplit  ("&",q) = 0; xnumSplits    = calcnumSplits();    recalcRandFeats(q); return *this; }
    MercerKernel &setUnMulSplit  (int q = 0) { xisfast = -1; xneedsInnerm2 = xneedsInner = -1; xneedsDiff = -1; xneedsNorm = -1; mulsplit ("&",q) = 0; xnumMulSplits = calcnumMulSplits(); recalcRandFeats(q); return *this; }
    MercerKernel &setUnMagTerm   (int q = 0) { xisfast = -1; xneedsInnerm2 = xneedsInner = -1; xneedsDiff = -1; xneedsNorm = -1; ismagterm("&",q) = 0;                                     recalcRandFeats(q); return *this; }

    MercerKernel &setWeight (const gentype &nw, int q = 0) { dRealConstants("&",q)("&",0) = nw; recalcRandFeats(q); return *this; }
    MercerKernel &setType   (int ndtype,        int q = 0);
    MercerKernel &setAltCall(int newMLid,       int q = 0) { xisfast = -1; xneedsInnerm2 = xneedsInner = -1; xneedsDiff = -1; xneedsNorm = -1; altcallback("&",q) = newMLid; recalcRandFeats(q); return *this; }

    MercerKernel &setRealConstants(const Vector<gentype>   &ndRealConstants, int q = 0) { NiceAssert( dRealConstants(q).size()-1 == ndRealConstants.size() ); retVector<gentype> tmpva; dRealConstants("&",q)("&",1,1,dRealConstants(q).size()-1,tmpva) = ndRealConstants; recalcRandFeats(q); return *this; }
    MercerKernel &setIntConstants (const Vector<int>       &ndIntConstants,  int q = 0) { NiceAssert( dIntConstants(q).size()    == ndIntConstants.size()  );                           dIntConstants("&",q)                                            = ndIntConstants;  recalcRandFeats(q); return *this; }
    MercerKernel &setRealOverwrite(const SparseVector<int> &ndRealOverwrite, int q = 0) { dRealOverwrite("&",q) = ndRealOverwrite; fixcombinedOverwriteSrc(); recalcRandFeats(q); return *this; }
    MercerKernel &setIntOverwrite (const SparseVector<int> &ndIntOverwrite,  int q = 0) { dIntOverwrite("&",q)  = ndIntOverwrite;  fixcombinedOverwriteSrc(); recalcRandFeats(q); return *this; }

    MercerKernel &setRealConstZero(double nv, int q = 0) { dRealConstants("&",q)("&",1) = nv; recalcRandFeats(q); return *this; }
    MercerKernel &setIntConstZero (int    nv, int q = 0) { dIntConstants("&",q)("&",0)  = nv; recalcRandFeats(q); return *this; }

    // Nominal bounds on constants (used in tuneKernel)

    MercerKernel &setWeightLB(const gentype &nwLB, int q = 0) { dRealConstantsLB("&",q)("&",0) = nwLB; return *this; }

    MercerKernel &setRealConstantsLB(const Vector<gentype> &ndRealConstantsLB, int q = 0) { NiceAssert( dRealConstantsLB(q).size()-1 == ndRealConstantsLB.size() ); retVector<gentype> tmpva; dRealConstantsLB("&",q)("&",1,1,dRealConstantsLB(q).size()-1,tmpva) = ndRealConstantsLB; return *this; }
    MercerKernel &setIntConstantsLB (const Vector<int>     &ndIntConstantsLB,  int q = 0) { NiceAssert( dIntConstantsLB(q).size()  == ndIntConstantsLB.size() ); dIntConstantsLB("&",q) = ndIntConstantsLB; return *this; }

    MercerKernel &setRealConstZeroLB(double nvLB, int q = 0) { dRealConstantsLB("&",q)("&",1) = nvLB; return *this; }
    MercerKernel &setIntConstZeroLB (int    nvLB, int q = 0) { dIntConstantsLB("&",q)("&",0)  = nvLB; return *this; }

    MercerKernel &setWeightUB(const gentype &nwUB, int q = 0) { dRealConstantsUB("&",q)("&",0) = nwUB; return *this; }

    MercerKernel &setRealConstantsUB(const Vector<gentype> &ndRealConstantsUB, int q = 0) { NiceAssert( dRealConstantsUB(q).size()-1 == ndRealConstantsUB.size() ); retVector<gentype> tmpva; dRealConstantsUB("&",q)("&",1,1,dRealConstantsUB(q).size()-1,tmpva) = ndRealConstantsUB; return *this; }
    MercerKernel &setIntConstantsUB (const Vector<int>     &ndIntConstantsUB,  int q = 0) { NiceAssert( dIntConstantsUB(q).size()  == ndIntConstantsUB.size() ); dIntConstantsUB("&",q) = ndIntConstantsUB; return *this; }

    MercerKernel &setRealConstZeroUB(double nvUB, int q = 0) { dRealConstantsUB("&",q)("&",1) = nvUB; return *this; }
    MercerKernel &setIntConstZeroUB (int    nvUB, int q = 0) { dIntConstantsUB("&",q)("&",0)  = nvUB; return *this; }

    // setnumRandFeats triggers calculation/drawing of features.
    // setRandFeats and sertRandFeatAngle does this manually.

    MercerKernel &setnumRandFeats  (int nv,                             int q = 0) { recalcRandFeats(q,nv);       return *this; }
    MercerKernel &setRandFeats     (Vector<SparseVector<gentype> > &nv, int q = 0) { randFeats("&",q)       = nv; return *this; }
    MercerKernel &setRandFeatAngle (Vector<double>                 &nv, int q = 0) { randFeatAngle("&",q)   = nv; return *this; }
    MercerKernel &setRandFeatReOnly(int nv,                             int q = 0) { randFeatReOnly("&",q)  = nv; return *this; }
    MercerKernel &setRandFeatNoAngle(int nv,                            int q = 0) { randFeatNoAngle("&",q) = nv; return *this; }

    MercerKernel &setlinGradOrd (const Vector<int>             &nv) { linGradOrd  = nv; fixhaslinconstr();   return *this; }
    MercerKernel &setlinGradScal(const Vector<Matrix<double> > &nv) { linGradScal = nv; fixlingradscaltsp(); return *this; }

    MercerKernel &setlinGradOrd (int i,       int             nv) { linGradOrd("&",i)  = nv; fixhaslinconstr();    return *this; }
    MercerKernel &setlinGradScal(int i, const Matrix<double> &nv) { linGradScal("&",i) = nv; fixlingradscaltsp(i); return *this; }

    // Element retrieval
    //
    // Sets res = x(i).direcref(j) (shifted/scaled if shifting/scaling is turned on)
    // and returns reference to this.

    gentype &xelm(gentype &res, const SparseVector<gentype> &x, int i, int j) const;
    int xindsize(const SparseVector<gentype> &x, int i) const;
    //const SparseVector<gentype> &getx(const SparseVector<gentype> &x, int i) const { (void) i; return x; }

    // Kernel-space distance
    //
    // ||x-y|| = K(x,x)+K(y,y)-2K(x,y)
    //
    // but may be accelerated for some cases (kernels 300-399)

    double distK(const SparseVector<gentype> &x, const SparseVector<gentype> &y, const vecInfo &xinfo, const vecInfo &yinfo, int i = DEFAULT_VECT_INDEX, int j = DEFAULT_VECT_INDEX, int xdim = 0, int xconsist = 0, int mlid = 0, const double *xy00 = nullptr, const double *xy10 = nullptr, const double *xy11 = nullptr, int assumreal = 0) const;
    void ddistKdx(double &xscaleres, double &yscaleres, int &minmaxind, const SparseVector<gentype> &x, const SparseVector<gentype> &y, const vecInfo &xinfo, const vecInfo &yinfo, int i = DEFAULT_VECT_INDEX, int j = DEFAULT_VECT_INDEX, int xdim = 0, int xconsist = 0, int mlid = 0, const double *xy00 = nullptr, const double *xy10 = nullptr, const double *xy11 = nullptr, int assumreal = 0) const;

    // Evaluate kernel K(x,y).
    //
    // Optional arguments: xnorm = x'x
    //                     ynorm = y'y
    //
    // If normalisation on then returns K(x,y)/sqrt(K(x,x)*K(y,y))
    //
    // Matrix arguments:
    //
    // - rows of left-hand matrix argument are x vectors
    // - columns of right-hand matrix argument are x vectors
    // - allrow forms assume arguments are rows in both left and right hand
    // - allcol forms assume arguments are columns in both left and right hand
    //
    // Biased forms:
    //
    // - bias is added to the inner product
    // - BiasedR implies bias vector is replaced by 1*b'
    // - BiasedL implies bias vector is replaced by b*1'
    //
    // Vector-less forms:
    //
    // - Only work for kernels that do not require explicit use of vectors
    //   x and y.  All pre-normalisation etc is assumed taken care of.
    // - biased: it is assumed that the bias HAS NOT BEEN ADDED to either
    //   xyprod or yxprod.
    // - real vectorless forms are very fast for isSimpleNNKernel types.
    //   These are the only K functions optimised for this type of kernel.
    //
    // Indexing:
    //
    // If xconsist is set then it is assumed that x and y share the same
    // indexes, which allows certain optimisations to occur (namely inner
    // products can be more quickly calculated).
    //
    // pxyprod: - if xyprod and diffis known then make this an array where
    //            pxyprod[0] points to xyprod and pxyprod[1] points to diffis
    //          - if xyprod is known only then " but pxyprod[1] = nullptr
    //          - if diffis is known only then " but pxyprod[0] = nullptr
    //          - otherwise set nullptr
    //          - for 8xx kernel pxyprod is the result
    //          - for simple chained 8xx kernels pxyprod is the result of the first part
    //
    //
    // Return as equation option (Keqn):
    //
    // - resmode = 0: (default) the result is a number (or matrix or whatever)
    //   K variance: if K is inherited then it can have inherent variance.
    //
    // +---------+--------+----------------+-------------+-----------+------------+
    // | resmode | x,y    | integer consts | real consts | calculate | calculate  |
    // | resmode | subbed |     subbed     |    subbed   |   dk/dr   | K variance |
    // +---------+--------+----------------+-------------+-----------+------------+
    // | 0 deflt |   y    |        y       |      y      |           |            |
    // +---------+--------+----------------+-------------+-----------+------------+
    // | 1       |        |        y       |      y      |           |            |
    // +---------+--------+----------------+-------------+-----------+------------+
    // | 2       |   y    |                |      y      |           |            |
    // +---------+--------+----------------+-------------+-----------+------------+
    // | 3       |        |                |      y      |           |            |
    // +---------+--------+----------------+-------------+-----------+------------+
    // | 4       |   y    |        y       |             |           |            |
    // +---------+--------+----------------+-------------+-----------+------------+
    // | 5       |        |        y       |             |           |            |
    // +---------+--------+----------------+-------------+-----------+------------+
    // | 6       |   y    |                |             |           |            |
    // +---------+--------+----------------+-------------+-----------+------------+
    // | 7       |        |                |             |           |            |
    // +---------+--------+----------------+-------------+-----------+------------+
    // | 8       |   y    |        y       |      y      |     y     |            |
    // +---------+--------+----------------+-------------+-----------+------------+
    // | 9       |        |        y       |      y      |     y     |            |
    // +---------+--------+----------------+-------------+-----------+------------+
    // | 10      |   y    |                |      y      |     y     |            |
    // +---------+--------+----------------+-------------+-----------+------------+
    // | 11      |        |                |      y      |     y     |            |
    // +---------+--------+----------------+-------------+-----------+------------+
    // | 12      |   y    |        y       |             |     y     |            |
    // +---------+--------+----------------+-------------+-----------+------------+
    // | 13      |        |        y       |             |     y     |            |
    // +---------+--------+----------------+-------------+-----------+------------+
    // | 14      |   y    |                |             |     y     |            |
    // +---------+--------+----------------+-------------+-----------+------------+
    // | 15      |        |                |             |     y     |            |
    // +---------+--------+----------------+-------------+-----------+------------+
    // | 128     |   y    |        y       |      y      |           |     y      |
    // +---------+--------+----------------+-------------+-----------+------------+
    //
    // - in equation: var(0,0) = x'x (if !(resmode|1))
    //                var(0,1) = y'y (if !(resmode|1))
    //                var(0,2) = x'y (if !(resmode|1))
    //                var(2,i) = ij  (if !(resmode|2))
    //                var(1,j) = rj  (if !(resmode|4))
    // - this can also do real constant gradients when resmode|8.  In this
    //   case the result is a vector of the required dimension, the elements
    //   of which may or may not be equations depending on the settings of
    //   the three LSB of resmode (see above table).

    gentype &Keqn(gentype &res, int resmode = 1) const
    {
        const static SparseVector<gentype> x;
        const static SparseVector<gentype> y;

        const static vecInfo xinfo;
        const static vecInfo yinfo;

//        K2(res,x,y,xinfo,yinfo,defaultgentype(),nullptr,DEFAULT_VECT_INDEX,DEFAULT_VECT_INDEX,0,0,resmode,0,nullptr,nullptr,nullptr,0);
        K2(res,x,y,xinfo,yinfo,0_gent,nullptr,DEFAULT_VECT_INDEX,DEFAULT_VECT_INDEX,0,0,resmode,0,nullptr,nullptr,nullptr,0);

        return res;
    }

    // Kernels for different norms.
    //
    // NB: - odd-order kernels implemented for fast kernels only.
    //     - The vectorial form can speed up k2xfer forms
    //     - for 2-norm forms:
    //     - you can do gradients directly through here (see mlinter.cc), but
    //       note these assume non-sparse formats.
    //
    // xy matrix stores either inner products [ <x,x> <x,y> ; <y,x> <y,y> ] or their transferred
    // equivalents [ K2xfer(x,x) K2xfer(x,y) ; K2xfer(y,x) K2xfer(y,y) ].
    //
    // xconsist:  set if we can assume the indices of x,y, etc and scale/shift are all the same
    // assumreal: set 1 if we assume x is real-valued to speed things up (call before doing kernel eval)

    gentype &K0(gentype &res, const gentype &bias, const gentype **pxyprod, int xdim, int xconsist, int resmode, int mlid, int assumreal = 0) const;
    double   K0(                    double   bias, const gentype **pxyprod, int xdim, int xconsist, int resmode, int mlid, int assumreal = 0) const;

    gentype &K1(gentype &res, const SparseVector<gentype> &xa, const vecInfo &xainfo, const gentype &bias, const gentype **pxyprod = nullptr, int ia = DEFAULT_VECT_INDEX, int xdim = 0, int xconsist = 0, int resmode = 0, int mlid = 0, const double *xy00 = nullptr, int assumreal = 0) const;
    double   K1(              const SparseVector<gentype> &xa, const vecInfo &xainfo,       double   bias, const gentype **pxyprod = nullptr, int ia = DEFAULT_VECT_INDEX, int xdim = 0, int xconsist = 0, int resmode = 0, int mlid = 0, const double *xy00 = nullptr, int assumreal = 0) const;

    gentype &K2(gentype &res, const SparseVector<gentype> &xa,  const SparseVector<gentype> &xb,  const vecInfo &xainfo, const vecInfo &xbinfo, const gentype &bias, const gentype **pxyprod = nullptr, int ia = DEFAULT_VECT_INDEX, int ib = DEFAULT_VECT_INDEX, int xdim = 0, int xconsist = 0, int resmode = 0, int mlid = 0, const double *xy00 = nullptr, const double *xy10 = nullptr, const double *xy11 = nullptr, int assumreal = 0) const;
    double   K2(              const SparseVector<gentype> &xa,  const SparseVector<gentype> &xb,  const vecInfo &xainfo, const vecInfo &xbinfo,       double   bias, const gentype **pxyprod = nullptr, int ia = DEFAULT_VECT_INDEX, int ib = DEFAULT_VECT_INDEX, int xdim = 0, int xconsist = 0, int resmode = 0, int mlid = 0, const double *xy00 = nullptr, const double *xy10 = nullptr, const double *xy11 = nullptr, int assumreal = 0) const;

    gentype &K3(gentype &res, const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, const SparseVector<gentype> &xc, const vecInfo &xainfo, const vecInfo &xbinfo, const vecInfo &xcinfo, const gentype &bias, const gentype **pxyprod = nullptr, int i = DEFAULT_VECT_INDEX, int j = DEFAULT_VECT_INDEX, int k = DEFAULT_VECT_INDEX, int xdim = 0, int xconsist = 0, int resmode = 0, int mlid = 0, const double *xy00 = nullptr, const double *xy10 = nullptr, const double *xy11 = nullptr, const double *xy20 = nullptr, const double *xy21 = nullptr, const double *xy22 = nullptr, int assumreal = 0) const;
    double   K3(              const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, const SparseVector<gentype> &xc, const vecInfo &xainfo, const vecInfo &xbinfo, const vecInfo &xcinfo,       double   bias, const gentype **pxyprod = nullptr, int i = DEFAULT_VECT_INDEX, int j = DEFAULT_VECT_INDEX, int k = DEFAULT_VECT_INDEX, int xdim = 0, int xconsist = 0, int resmode = 0, int mlid = 0, const double *xy00 = nullptr, const double *xy10 = nullptr, const double *xy11 = nullptr, const double *xy20 = nullptr, const double *xy21 = nullptr, const double *xy22 = nullptr, int assumreal = 0) const;

    gentype &K4(gentype &res, const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, const SparseVector<gentype> &xc, const SparseVector<gentype> &xd, const vecInfo &xainfo, const vecInfo &xbinfo, const vecInfo &xcinfo, const vecInfo &xdinfo, const gentype &bias, const gentype **pxyprod = nullptr, int i = DEFAULT_VECT_INDEX, int j = DEFAULT_VECT_INDEX, int k = DEFAULT_VECT_INDEX, int l = DEFAULT_VECT_INDEX, int xdim = 0, int xconsist = 0, int resmode = 0, int mlid = 0, const double *xy00 = nullptr, const double *xy10 = nullptr, const double *xy11 = nullptr, const double *xy20 = nullptr, const double *xy21 = nullptr, const double *xy22 = nullptr, const double *xy30 = nullptr, const double *xy31 = nullptr, const double *xy32 = nullptr, const double *xy33 = nullptr, int assumreal = 0) const;
    double   K4(              const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, const SparseVector<gentype> &xc, const SparseVector<gentype> &xd, const vecInfo &xainfo, const vecInfo &xbinfo, const vecInfo &xcinfo, const vecInfo &xdinfo,       double   bias, const gentype **pxyprod = nullptr, int i = DEFAULT_VECT_INDEX, int j = DEFAULT_VECT_INDEX, int k = DEFAULT_VECT_INDEX, int l = DEFAULT_VECT_INDEX, int xdim = 0, int xconsist = 0, int resmode = 0, int mlid = 0, const double *xy00 = nullptr, const double *xy10 = nullptr, const double *xy11 = nullptr, const double *xy20 = nullptr, const double *xy21 = nullptr, const double *xy22 = nullptr, const double *xy30 = nullptr, const double *xy31 = nullptr, const double *xy32 = nullptr, const double *xy33 = nullptr, int assumreal = 0) const;

    gentype &Km(int m, gentype &res, Vector<const SparseVector<gentype> *> &x, Vector<const vecInfo *> &xinfo, const gentype &bias, Vector<int> &i, const gentype **pxyprod = nullptr, int xdim = 0, int xconsist = 0, int resmode = 0, int mlid = 0, const Matrix<double> *xy = nullptr, int assumreal = 0) const;
    double   Km(int m,               Vector<const SparseVector<gentype> *> &x, Vector<const vecInfo *> &xinfo,       double   bias, Vector<int> &i, const gentype **pxyprod = nullptr, int xdim = 0, int xconsist = 0, int resmode = 0, int mlid = 0, const Matrix<double> *xy = nullptr, int assumreal = 0) const;

    // 2-kernel product.
    //
    // K2x2(x,xa,xb) = K2(x,xa).K2(x,xb)
    //
    // The trick here is that this does the right thing with dense integrals on x,
    // allowing them to be incorporated for a limited set of kernels without the
    // need for numerical integration.

    gentype &K2x2(gentype &res, const SparseVector<gentype> &x,  const SparseVector<gentype> &xa, const SparseVector<gentype> &xb,  const vecInfo &xinfo, const vecInfo &xainfo, const vecInfo &xbinfo, const gentype &bias, int i = DEFAULT_VECT_INDEX, int ia = DEFAULT_VECT_INDEX, int ib = DEFAULT_VECT_INDEX, int xdim = 0, int xconsist = 0, int resmode = 0, int mlid = 0, const double *xy00 = nullptr, const double *xy10 = nullptr, const double *xy11 = nullptr, const double *xy20 = nullptr, const double *xy21 = nullptr, const double *xy22 = nullptr, int assumreal = 0) const;
    double   K2x2(              const SparseVector<gentype> &x,  const SparseVector<gentype> &xa, const SparseVector<gentype> &xb,  const vecInfo &xinfo, const vecInfo &xainfo, const vecInfo &xbinfo,       double   bias, int i = DEFAULT_VECT_INDEX, int ia = DEFAULT_VECT_INDEX, int ib = DEFAULT_VECT_INDEX, int xdim = 0, int xconsist = 0, int resmode = 0, int mlid = 0, const double *xy00 = nullptr, const double *xy10 = nullptr, const double *xy11 = nullptr, const double *xy20 = nullptr, const double *xy21 = nullptr, const double *xy22 = nullptr, int assumreal = 0) const;

    // Density function (if defined for RFF):

    double density(const SparseVector<gentype> &xa, const vecInfo &xainfo,       double   bias, int ia = DEFAULT_VECT_INDEX, int xdim = 0, int xconsist = 0, int mlid = 0, int assumreal = 0) const;

    // Feature maps
    //
    // phim: returns the image of x in feature space.  This may be finite dimensional if possible
    //       (and allowfinite = 1), but otherwise infinite dimensional.  Does not include bias term.
    // phidim: return -1 if feature map infinite dimensional, >= 0 otherwise

    int phi1(Vector<gentype> &res, const SparseVector<gentype> &x, const vecInfo &xinfo, int i = DEFAULT_VECT_INDEX, int allowfinite = 1, int xdim = 0, int xconsist = 0, int assumreal = 0) const { return phim(1,res,x,xinfo,i,allowfinite,xdim,xconsist,assumreal); }
    int phi1(Vector<double>  &res, const SparseVector<gentype> &x, const vecInfo &xinfo, int i = DEFAULT_VECT_INDEX, int allowfinite = 1, int xdim = 0, int xconsist = 0, int assumreal = 0) const { return phim(1,res,x,xinfo,i,allowfinite,xdim,xconsist,assumreal); }

    int phi2(Vector<gentype> &res, const SparseVector<gentype> &x, const vecInfo &xinfo, int i = DEFAULT_VECT_INDEX, int allowfinite = 1, int xdim = 0, int xconsist = 0, int assumreal = 0) const { return phim(2,res,x,xinfo,i,allowfinite,xdim,xconsist,assumreal); }
    int phi2(Vector<double>  &res, const SparseVector<gentype> &x, const vecInfo &xinfo, int i = DEFAULT_VECT_INDEX, int allowfinite = 1, int xdim = 0, int xconsist = 0, int assumreal = 0) const { return phim(2,res,x,xinfo,i,allowfinite,xdim,xconsist,assumreal); }

    int phi3(Vector<gentype> &res, const SparseVector<gentype> &x, const vecInfo &xinfo, int i = DEFAULT_VECT_INDEX, int allowfinite = 1, int xdim = 0, int xconsist = 0, int assumreal = 0) const { return phim(3,res,x,xinfo,i,allowfinite,xdim,xconsist,assumreal); }
    int phi3(Vector<double>  &res, const SparseVector<gentype> &x, const vecInfo &xinfo, int i = DEFAULT_VECT_INDEX, int allowfinite = 1, int xdim = 0, int xconsist = 0, int assumreal = 0) const { return phim(3,res,x,xinfo,i,allowfinite,xdim,xconsist,assumreal); }

    int phi4(Vector<gentype> &res, const SparseVector<gentype> &x, const vecInfo &xinfo, int i = DEFAULT_VECT_INDEX, int allowfinite = 1, int xdim = 0, int xconsist = 0, int assumreal = 0) const { return phim(4,res,x,xinfo,i,allowfinite,xdim,xconsist,assumreal); }
    int phi4(Vector<double>  &res, const SparseVector<gentype> &x, const vecInfo &xinfo, int i = DEFAULT_VECT_INDEX, int allowfinite = 1, int xdim = 0, int xconsist = 0, int assumreal = 0) const { return phim(4,res,x,xinfo,i,allowfinite,xdim,xconsist,assumreal); }

    int phim(int m, Vector<gentype> &res, const SparseVector<gentype> &x, const vecInfo &xinfo, int i = DEFAULT_VECT_INDEX, int allowfinite = 1, int xdim = 0, int xconsist = 0, int assumreal = 0) const;
    int phim(int m, Vector<double>  &res, const SparseVector<gentype> &x, const vecInfo &xinfo, int i = DEFAULT_VECT_INDEX, int allowfinite = 1, int xdim = 0, int xconsist = 0, int assumreal = 0) const;

    int phidim(int allowfinite = 1, int xdim = 0) const { SparseVector<gentype> xdummy; vecInfo xinfodummy; Vector<double> resdummy; return phim(-1,resdummy,xdummy,xinfodummy,0,allowfinite,xdim); }

    // Inner-product calculation forms
    //
    // These just calculate the inner product, not the kernel.  If *simple* kernel transfer
    // is enabled then the inner product is actually the result of evaluating the transfered
    // kernel.  This operation is not well defined for non-simple kernels.

    double K0ip(double bias, const gentype **pxyprod, int xdim, int xconsist, int mlid, int assumreal) const;
    double K1ip(const SparseVector<gentype> &xa, const vecInfo &xainfo, double bias, const gentype **pxyprod = nullptr, int ia = DEFAULT_VECT_INDEX, int xdim = 0, int xconsist = 0, int mlid = 0, int assumreal = 0) const;
    double K2ip(const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, const vecInfo &xainfo, const vecInfo &xbinfo, double bias, const gentype **pxyprod = nullptr, int ia = DEFAULT_VECT_INDEX, int ib = DEFAULT_VECT_INDEX, int xdim = 0, int xconsist = 0, int mlid = 0, int assumreal = 0) const;
    double K3ip(const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, const SparseVector<gentype> &xc, const vecInfo &xainfo, const vecInfo &xbinfo, const vecInfo &xcinfo, double bias, const gentype **pxyprod = nullptr, int ia = DEFAULT_VECT_INDEX, int ib = DEFAULT_VECT_INDEX, int ic = DEFAULT_VECT_INDEX, int xdim = 0, int xconsist = 0, int mlid = 0, int assumreal = 0) const;
    double K4ip(const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, const SparseVector<gentype> &xc, const SparseVector<gentype> &xd, const vecInfo &xainfo, const vecInfo &xbinfo, const vecInfo &xcinfo, const vecInfo &xdinfo, double bias, const gentype **pxyprod = nullptr, int ia = DEFAULT_VECT_INDEX, int ib = DEFAULT_VECT_INDEX, int ic = DEFAULT_VECT_INDEX, int id = DEFAULT_VECT_INDEX, int xdim = 0, int xconsist = 0, int mlid = 0, int assumreal = 0) const;
    double Kmip(int m, Vector<const SparseVector<gentype> *> &x, Vector<const vecInfo *> &xinfo, Vector<int> &i, double bias, const gentype **pxyprod = nullptr, int xdim = 0, int xconsist = 0, int mlid = 0, int assumreal = 0) const;

    // 2-norm derivatives
    //
    // dK2delx: calculates derivative w.r.t. x vector.  Result is xscaleres.x + yscaleres.y.
    // d2K2delxdelx: calculates 2nd derivative d/dx d/dx K.  Result is xxscaleres.x.x' + yyscaleres.y.y' + xyscaleres.x.y' + yxscaleres.y.x' + constres.I
    // d2K2delxdely: calculates 2nd derivative d/dx d/dy K.  Result is xxscaleres.x.x' + yyscaleres.y.y' + xyscaleres.x.y' + yxscaleres.y.x' + constres.I
    // dnK2del: nth derivative (currently only for RBF kernel).  Result is an array:
    //
    // dnK/dx_q0.dx_q1... sum_i sc_i kronProd_{j=0,1,...} [ x{n_ij}   if n_ij = 0,1
    //                                                    [ kd{n_ij}  if n_ij < 0
    //
    // where: x{0} = x
    //        x{1} = y
    //        kd{a} ... kd{a} = kronecker-delta (vectorised identity matrix) on indices
    //
    // If minmaxind >= 0 then derivative is only with respect to element minmaxind
    // of vectors x,y (so result is xscaleres.x(minmaxind) + yscaleres.y(minmaxind)).
    //
    // NB: this is actually the derivative wrt dScale.*(x-dShift) if shifting and/or
    //     scaling is present, so factor this in when calculating results.  That is
    //     d/dx_i => dScale_i d/dx_i etc

    void dK2delx(gentype &xscaleres, gentype &yscaleres, int &minmaxind, const SparseVector<gentype> &x, const SparseVector<gentype> &y, const vecInfo &xinfo, const vecInfo &yinfo, const gentype &bias, const gentype **pxyprod = nullptr, int i = DEFAULT_VECT_INDEX, int j = DEFAULT_VECT_INDEX, int xdim = 0, int xconsist = 0, int mlid = 0, const double *xy00 = nullptr, const double *xy10 = nullptr, const double *xy11 = nullptr, int assumreal = 0) const;
    void dK2delx(double  &xscaleres, double  &yscaleres, int &minmaxind, const SparseVector<gentype> &x, const SparseVector<gentype> &y, const vecInfo &xinfo, const vecInfo &yinfo,       double   bias, const gentype **pxyprod = nullptr, int i = DEFAULT_VECT_INDEX, int j = DEFAULT_VECT_INDEX, int xdim = 0, int xconsist = 0, int mlid = 0, const double *xy00 = nullptr, const double *xy10 = nullptr, const double *xy11 = nullptr, int assumreal = 0) const;

    void d2K2delxdelx(gentype &xxscaleres, gentype &yyscaleres, gentype &xyscaleres, gentype &yxscaleres, gentype &constres, int &minmaxind, const SparseVector<gentype> &x, const SparseVector<gentype> &y, const vecInfo &xinfo, const vecInfo &yinfo, const gentype &bias, const gentype **pxyprod = nullptr, int i = DEFAULT_VECT_INDEX, int j = DEFAULT_VECT_INDEX, int xdim = 0, int xconsist = 0, int mlid = 0, const double *xy00 = nullptr, const double *xy10 = nullptr, const double *xy11 = nullptr, int deepDerive = 0, int assumreal = 0) const;
    void d2K2delxdelx(double  &xxscaleres, double  &yyscaleres, double  &xyscaleres, double  &yxscaleres, double  &constres, int &minmaxind, const SparseVector<gentype> &x, const SparseVector<gentype> &y, const vecInfo &xinfo, const vecInfo &yinfo,       double   bias, const gentype **pxyprod = nullptr, int i = DEFAULT_VECT_INDEX, int j = DEFAULT_VECT_INDEX, int xdim = 0, int xconsist = 0, int mlid = 0, const double *xy00 = nullptr, const double *xy10 = nullptr, const double *xy11 = nullptr, int deepDerive = 0, int assumreal = 0) const;

    void d2K2delxdely(gentype &xxscaleres, gentype &yyscaleres, gentype &xyscaleres, gentype &yxscaleres, gentype &constres, int &minmaxind, const SparseVector<gentype> &x, const SparseVector<gentype> &y, const vecInfo &xinfo, const vecInfo &yinfo, const gentype &bias, const gentype **pxyprod = nullptr, int i = DEFAULT_VECT_INDEX, int j = DEFAULT_VECT_INDEX, int xdim = 0, int xconsist = 0, int mlid = 0, const double *xy00 = nullptr, const double *xy10 = nullptr, const double *xy11 = nullptr, int deepDerive = 0, int assumreal = 0) const;
    void d2K2delxdely(double  &xxscaleres, double  &yyscaleres, double  &xyscaleres, double  &yxscaleres, double  &constres, int &minmaxind, const SparseVector<gentype> &x, const SparseVector<gentype> &y, const vecInfo &xinfo, const vecInfo &yinfo,       double   bias, const gentype **pxyprod = nullptr, int i = DEFAULT_VECT_INDEX, int j = DEFAULT_VECT_INDEX, int xdim = 0, int xconsist = 0, int mlid = 0, const double *xy00 = nullptr, const double *xy10 = nullptr, const double *xy11 = nullptr, int deepDerive = 0, int assumreal = 0) const;

    void dnK2del(Vector<gentype> &sc, Vector<Vector<int> > &n, int &minmaxind, const Vector<int> &q, const SparseVector<gentype> &x, const SparseVector<gentype> &y, const vecInfo &xinfo, const vecInfo &yinfo, const gentype &bias, const gentype **pxyprod = nullptr, int i = DEFAULT_VECT_INDEX, int j = DEFAULT_VECT_INDEX, int xdim = 0, int xconsist = 0, int mlid = 0, const double *xy00 = nullptr, const double *xy10 = nullptr, const double *xy11 = nullptr, int deepDerive = 0, int assumreal = 0) const;
    void dnK2del(Vector<double>  &sc, Vector<Vector<int> > &n, int &minmaxind, const Vector<int> &q, const SparseVector<gentype> &x, const SparseVector<gentype> &y, const vecInfo &xinfo, const vecInfo &yinfo,       double   bias, const gentype **pxyprod = nullptr, int i = DEFAULT_VECT_INDEX, int j = DEFAULT_VECT_INDEX, int xdim = 0, int xconsist = 0, int mlid = 0, const double *xy00 = nullptr, const double *xy10 = nullptr, const double *xy11 = nullptr, int deepDerive = 0, int assumreal = 0) const;

    // 2-norm derivatives (alternative form - deprecated)
    //
    // dK: assuming kernel can be written K(<x,y>,||x||^2,||y||^2), with symmetry in x,y, this
    //     returns the derivatives with respect to the first two arguments.
    //     If K is a simple transfer kernel then this derivative is with respect to the the
    //     arguments in the form K(K2xfer(x,y),K2xfer(x,x),K2xfer(y,y)) (the derivative
    //     dK/dK2xfer(x,y), xK/dK2xfer(x,x)).  This behaviour can be changed by setting the
    //     arguments deepDeriv to 1, which will recurse down to <x,y>,||x||^2,||y||^2 where
    //     possible.  Behaviour for non-simple transfer kernels is ill-defined (unless
    //     deepDeriv is set to 1).

    void dK(gentype &xygrad, gentype &xnormgrad, int &minmaxind, const SparseVector<gentype> &x, const SparseVector<gentype> &y, const vecInfo &xinfo, const vecInfo &yinfo, const gentype &bias, const gentype **pxyprod = nullptr, int i = DEFAULT_VECT_INDEX, int j = DEFAULT_VECT_INDEX, int xdim = 0, int xconsist = 0, int mlid = 0, const double *xy00 = nullptr, const double *xy10 = nullptr, const double *xy11 = nullptr, int deepDeriv = 0, int assumreal = 0) const;
    void dK(double  &xygrad, double  &xnormgrad, int &minmaxind, const SparseVector<gentype> &x, const SparseVector<gentype> &y, const vecInfo &xinfo, const vecInfo &yinfo,       double   bias, const gentype **pxyprod = nullptr, int i = DEFAULT_VECT_INDEX, int j = DEFAULT_VECT_INDEX, int xdim = 0, int xconsist = 0, int mlid = 0, const double *xy00 = nullptr, const double *xy10 = nullptr, const double *xy11 = nullptr, int deepDeriv = 0, int assumreal = 0) const;

    // Note: dk(x,y)/dynorm = dk(y,x)/dxnorm etc, standard assumptions necessary

    void d2K(gentype &xygrad, gentype &xnormgrad, gentype &xyxygrad, gentype &xyxnormgrad, gentype &xyynormgrad, gentype &xnormxnormgrad, gentype &xnormynormgrad, gentype &ynormynormgrad, int &minmaxind, const SparseVector<gentype> &x, const SparseVector<gentype> &y, const vecInfo &xinfo, const vecInfo &yinfo, const gentype &bias, const gentype **pxyprod = nullptr, int i = DEFAULT_VECT_INDEX, int j = DEFAULT_VECT_INDEX, int xdim = 0, int xconsist = 0, int mlid = 0, const double *xy00 = nullptr, const double *xy10 = nullptr, const double *xy11 = nullptr, int deepDeriv = 0, int assumreal = 0) const;
    void d2K(double  &xygrad, double  &xnormgrad, double  &xyxygrad, double  &xyxnormgrad, double  &xyynormgrad, double  &xnormxnormgrad, double  &xnormynormgrad, double  &ynormynormgrad, int &minmaxind, const SparseVector<gentype> &x, const SparseVector<gentype> &y, const vecInfo &xinfo, const vecInfo &yinfo,       double   bias, const gentype **pxyprod = nullptr, int i = DEFAULT_VECT_INDEX, int j = DEFAULT_VECT_INDEX, int xdim = 0, int xconsist = 0, int mlid = 0, const double *xy00 = nullptr, const double *xy10 = nullptr, const double *xy11 = nullptr, int deepDeriv = 0, int assumreal = 0) const;

    // "Reversing" functions.
    //
    // For speed of operation it is sometimes helpful to retrieve either the
    // inner product or distance from an evaluated kernel.  These functions
    // let you do that
    //
    // isReversible: test if kernel is reversible.  Output is:
    //     0: kernel cannot be reversed
    //     1: kernel can be reversed to produce <x,y>+bias
    //     2: kernel can be reversed to produce ||x-y||^2
    //
    // reverseK: reverse kernel as described by isReversible
    //
    // The result so produced can be fed back in via the pxyprod argument
    // (appropriately set) to speed up calculation of results.  Use case
    // could be quickly changing kernel parameters with minimal recalculation.
    //
    // As a general rule these only work with isSimpleFastKernel or
    // isSimpleKernelChain, and then in limited cases.  For the chain case
    // the result is the relevant (processed) output of the first layer.

    int isReversible(void) const;
    gentype &reverseK(gentype &res, const gentype &Kval) const;
    double  &reverseK(double &res,        double   Kval) const;

    // Evaluate kernel gradient dK/dx(x,y) and dK/dy(x,y)
    //
    // FIXME: at present this assumes everything is real-valued.  The more
    // general case is a little more difficult.
    //
    // Product kernels are not dealt with at present
    //
    // The returned value is in terms of x and y scales.  The gradient so
    // represented is of the form (x gradient case):
    //
    // dK/dx = xscaleres.x + yscaleres.y
    //
    // densedKdx: for product kernels only this calculates:
    //            d/dx0 d/dx1 ... K(x,y) = \prod_j dK(xj,yj)/dxj
    //            *This will disable callback for inner product calculation*
    // denseintK: reverse of densedKdx
    //
    // Design decision: for the kernel defined on max(x_k-y_k) the dense
    // derivative is simply the derivative on this axis.  This enables us
    // to estimate variance on the pareto frontier.
    //
    // At present this makes the following assumptions:
    //
    // - the caller is aware of any indexing tricks
    // - kernels are either inner product or norm difference kernels
    //
    // Biased gradients: these actually return gradients for the vectors
    //
    // ( x )  and  ( y    )
    // ( 1 )       ( bias )
    //
    // (so xscaleres refers to the scale for the augmented vector, and like-
    // wise yscaleres).  This makes surprisingly little difference if you
    // want the gradients for x and y as the scale factors are the same
    // (dxaug/dx = diag(I,0)).  To calculate the bias gradient, note that:
    //
    // dK/dbias = dK/dxaug dxaug/dbias + dK/dyaug dyaug/dbias
    //          = dK/dyaug dyaug/dbias
    //          = dyxscaleres + bias.dyyscaleres
    //
    // minmaxind: -1  if gradient is for whole x/y
    //            >=0 if gradient is for just one element of min/max(x-y)
    //
    // For Km gradients: xyscaleres refers to scaling factor on x(0).^{m-1} (for dx) or x(1).^{m-1} (for dy) (.^ is the elementwise power)
    //                   zscaleres refers to scaling factor on x(i0)*x(i1)*...x(i{m-2}) (elementwise product of all x except x(0) (for dx) or x(1) (for dy))
    //
    // Currently second order gradients are not implemented for Km kernels.  If
    // you want to implement them bear in mind that you will need xxscaleres for
    // weighting (m-1)-order terms (and yyscaleres etc), plus constres, but also
    // weight terms for (m-2) order terms, so things will get a bit tricky.
    //
    // Only a very limited subset of second order derivatives are defined!

    // Dense derivatives and integrals

    void densedKdx(double &res, const SparseVector<gentype> &x, const SparseVector<gentype> &y, const vecInfo &xinfo, const vecInfo &yinfo, double bias, int i = DEFAULT_VECT_INDEX, int j = DEFAULT_VECT_INDEX, int xdim = 0, int xconsist = 0, int mlid = 0, int assumreal = 0) const;
    void denseintK(double &res, const SparseVector<gentype> &x, const SparseVector<gentype> &y, const vecInfo &xinfo, const vecInfo &yinfo, double bias, int i = DEFAULT_VECT_INDEX, int j = DEFAULT_VECT_INDEX, int xdim = 0, int xconsist = 0, int mlid = 0, int assumreal = 0) const;

    // Get vector information, taking into account indexing.
    //
    // scratch: may or may not be used for something or other, saves on allocs and statics
    //
    // xmag: 2-norm, if known

    vecInfo     &getvecInfo(vecInfo     &res, const SparseVector<gentype> &x, const gentype *xmag = nullptr, int xconsist = 0, int assumreal = 0) const;
    vecInfoBase &getvecInfo(vecInfoBase &res, const SparseVector<gentype> &x, const gentype *xmag = nullptr, int xconsist = 0, int assumreal = 0) const;

    const gentype &getmnorm(const vecInfo &xinfo, const SparseVector<gentype> &x, int m, int xconsist = 0, int assumreal = 0) const;
          gentype &getmnorm(      vecInfo &xinfo, const SparseVector<gentype> &x, int m, int xconsist = 0, int assumreal = 0) const;

    // Kernel scaling

    MercerKernel &operator*=(double sf)
    {
        int q;
        int goon = 0;

        for ( q = 0 ; q < size() ; ++q )
        {
            if ( !isChained(q) || isSplit(q) || isMulSplit(q) )
            {
                dRealConstants("&",q)("&",0) *= ( goon ? sf : 1.0 );
            }

            if ( isSplit(q) == 1 )
            {
                goon = 0;
            }

            if ( isSplit(q) == 2 )
            {
                goon = 1;
            }

            if ( isMulSplit(q) == 1 )
            {
                goon = 0;
            }

            if ( isMulSplit(q) == 2 )
            {
                goon = 1;
            }
        }

        recalcRandFeats(-1);

        return *this;
    }

private:

    int calcnumSplits(int indstart = 0, int indend = -1) const
    {
        if ( indend == -1 )
        {
            indend = size()-1;
        }

        if ( indend <= 0 )
        {
            return 0;
        }

        int i,res = 0;

        for ( i = indstart ; i < indend ; ++i )
        {
            res += ( issplit(i) ? 1 : 0 );
        }

        return res;
/*
        retVector<int> tmp;

        if ( indend == -1 )
        {
            indend = size()-1;
        }

        return ( indend <= 0 ) ? 0 : sum(issplit(indstart,1,indend-1,tmp));
*/
    }

    int calcnumMulSplits(int indstart = 0, int indend = -1) const
    {
        if ( indend == -1 )
        {
            indend = size()-1;
        }

        if ( indend <= 0 )
        {
            return 0;
        }

        int i,res = 0;

        for ( i = indstart ; i < indend ; ++i )
        {
            res += ( mulsplit(i) ? 1 : 0 );
        }

        return res;
    }

    // Terms used:
    //
    // - normalised:         Kn(x,y) = K(x,y)/sqrt(|K(x,x)|.|K(y,y)|)
    // - shifted and scaled: Ks(x,y) = K((x+shift).*scale,(y+shift).*scale)
    //
    // dtype: kernel type vector.
    // isprod:     0 = normal, 1 = K(x,y) = prod_i K(x_i,y_i)
    // isnorm:     0 = normal, 1 = normalisation on.
    // isdiffalt:  see previous
    // ischain:    0 = normal, 1 = this kernel is then chained into next kernel.
    // issplit:    0 = normal, 1 = this kernel (for this part of x) stops here, next kernel (for this part of x) starts, 2 means additive split
    // mulsplit:   0 = normal, 1 = this kernel (for all x) stops here, next kernel (for all x) starts, 2 for additive split.
    // ismagtern   0 = normal, 1 = use K(x,x).K(y,y) rather than K(x,y).
    // isshift:    0 = normal, 1 = use shifting only, 2 = use scaling only, 3 = use shifting and scaling
    // isind:      0 = normal, 1 = use indexed products
    // isfullnorm: 0 = normal, 1 = normalise at outermost
    // leftplain:  0 = normal, 1 = don't shift-scale left-hand argument in K
    // rightplain: 0 = normal, 1 = don't shift-scale right-hand argument in K
    // weight: weight factor kernel is multiplied by
    //         (now stored as index 0 of real constants)
    // dIntConstants: integer constants in kernel
    // dRealConstants: real constants in kernel
    // dIntConstantsLB: lower bound integer constants in kernel
    // dRealConstantsLB: lower bound real constants in kernel
    // dIntConstantsUB: upper bound integer constants in kernel
    // dRealConstantsUB: upper bound real constants in kernel
    // dIntOverwrite: selects which variables will be overwritten by which x(i)*y(i)
    // dRealOverwrite: selects which variables will be overwritten by which x(i)*y(i)
    // dIndexes: indices used in index products
    // dShift: shift factor
    // dScale: scale factor
    // dShiftProd: ||dShift.*dScale||_2^2

    Vector<int> xdefindKey;

    mutable int isind;
    int isshift;
    int leftplain;
    int rightplain;
    int isprod;
    int isdiffalt;
    int xproddepth;
    int enchurn; // set if kernel reversal is enabled.
    int xsuggestXYcache;
    int xisIPdiffered;
    int isfullnorm;
    int issymmset;
    int xnumSplits;
    int xnumMulSplits;
    int xranktype;
    double xdenseZeroPoint;

    Vector<int> dtype;
    Vector<int> isnorm;
    Vector<int> ischain;
    Vector<int> issplit;
    Vector<int> mulsplit;
    Vector<int> ismagterm;
    mutable Vector<int> dIndexes;
    Vector<kernInfo> kernflags;
    mutable Vector<Vector<gentype> > dRealConstants;
    mutable Vector<Vector<int> > dIntConstants;
    mutable Vector<Vector<gentype> > dRealConstantsLB;
    mutable Vector<Vector<int> > dIntConstantsLB;
    mutable Vector<Vector<gentype> > dRealConstantsUB;
    mutable Vector<Vector<int> > dIntConstantsUB;
    Vector<SparseVector<int> > dRealOverwrite;
    Vector<SparseVector<int> > dIntOverwrite;
    Vector<int> altcallback;
    Vector<Vector<SparseVector<gentype> > > randFeats;
    Vector<Vector<double> > randFeatAngle;
    Vector<int> randFeatReOnly; // 0 both real and im, 1 re only, -1 im only
    Vector<int> randFeatNoAngle; // 0 for random angle, 1 for no angle.

    SparseVector<gentype> dShift;
    SparseVector<gentype> dScale;
    gentype dShiftProd;
    gentype dShiftProdNoConj;
    gentype dShiftProdRevConj;

    mutable retVector<gentype> cRealConstantsTmp;
    mutable retVector<int> cRealConstantsTmpb;

    Vector<int> linGradOrd;
    Vector<Matrix<double> > linGradScal;
    Vector<Matrix<double> > linGradScalTsp;
    bool haslinconstr;

    // random features calculation stub.  If numFeats = -1 then just
    // fix the features that exist, otherwise start from scratch with
    // the specified number of random features.

    void recalcRandFeats(int q, int numFeats = -1);

    // Feature no longer used, assume enchurn == 0
    //
    // churnInner:   set 1 if we want to attempt to retrieve and reuse
    //               inner products <x,y>+b and distances ||x-y||^2 when
    //               changing the kernel (see prepareKernel in ml_base).
    //               This does not guarantee that retrieval will occur, but
    //               only that if it is possible and implemented then it will
    //               be attempted when feasible.  Only really speeds things up
    //               when you're using kernel inheritance.
    //

    int churnInner(void) const { return enchurn; }
    MercerKernel &setChurnInner(int nv) { enchurn = nv; return *this; }

    // Distribution kernel information:
    //
    // xnumSamples: number of samples to estimate the kernel
    // xindsub:     indices of variables in distributions that are substituted
    // xsampdist:   sample distribution for these variables
    //
    // That is, we are estimating:
    //
    // E_a[K(x(a),y(a))]
    //
    // where x and y are (or contain) *distributions*, so
    //
    // x \sim dist(a)
    //
    // and a itself if drawn from sampdist, and has indices xindsub.

    int xnumsamples;
    Vector<int> xindsub;
    Vector<gentype> xsampdist;

    // Call tree to calculate kernel.
    //
    // - public version calculates xyprod etc and calls first version
    //
    // - yyyK version does preprocessing on [ xa ~ xb ... ] forms
    // - next levels goes through kernel structure and calls second version
    //   to evaluate individual kernels in structure (indexed by q)
    // - this calls unnorm form and applies normalisation if needed
    // - unnorm form calculates diffis (||x-y||^2) if needed and then
    //   calls Kbase
    // - Kbase does the actual work.
    // - resmode = 0: standard evaluation
    //   resmode = 1: return equation, including constants
    //   resmode = 2: return equation, integers substituted out
    //   resmode = 3: return equation, integers and reals subbed out
    //     var(0,0) = x'x
    //     var(0,1) = y'y
    //     var(0,2) = x'y
    //     var(1,j) = rj (real constants) (if resmode == 1,2)
    //     var(2,i) = ij (integer constants) (if resmode == 1)
    //
    // K4 and Km are similar but work with 4 and m norms before finally
    // converging onto the same Kbase for final evaluation
    //
    // densetype = 0: normal operation
    //             1: calculate dense derivative d/dx0 d/dx1 ... K(x,y)
    //             2: calculate dense integral int_x0 ind_x1 ... K(x,y)
    //            -1: calculate dense derivative d/dy0 d/dy1 ... K(x,y)
    //            -2: calculate dense integral int_y0 ind_y1 ... K(x,y)
    //
    // iset: controls how distributions in the data are treated.
    //     0 = standard behaviour, distributions are treated as such, result is average of samples
    //     1 = distributions represent draws from infinite sets, result is largest (most similar) evaluation with draws from given distribution(s)
    //
    // The actual dense derivative/integral operations work by pairing
    // kernels.  That is, if K is the kernel then the dense derivative will
    // find the kernel corresponding to the derivative and then call that
    // instead.  Only works if required pair is defined.
    //
    // FIXME: will also only work for simple kernels
    //
    //
    //
    //
    // ------------------------------------------------------------------
    //
    // More detail on the yyyK... levels
    //
    //    inline gentype &K2(gentype &res, const SparseVector<gentype> &x,  const SparseVector<gentype> &y,  const vecInfo &xinfo, const vecInfo &yinfo, const gentype &bias, const gentype **pxyprod = nullptr, int i = DEFA$
    //    inline double  &K2(double  &res, const SparseVector<gentype> &x,  const SparseVector<gentype> &y,  const vecInfo &xinfo, const vecInfo &yinfo, const double  &bias, const gentype **pxyprod = nullptr, int i = DEFA$
    // these translate to gentype and call direct to...
    //
    //     template <class T> T &yyyK2(T &res, const SparseVector<gentype> &x, const SparseVector<gentype> &y, const vecInfo &xinfo, const vecInfo &yinfo, const T &bias, const gentype **pxyprod, int i, int j, int xdim, $ 
    // this does nothing (for now) but calls direct to...
    //
    //     template <class T> T &yyyaK2(T &res, const SparseVector<gentype> &x, const SparseVector<gentype> &y, const vecInfo &xinfo, const vecInfo &yinfo, const T &bias, const gentype **pxyprod, int i, int j, int xdim,$ 
    // *data dependent operation*
    // if diagonal kernel: return diagonal
    // if simple evaluation: jump to xKKK2
    // otherwise calls to...
    //
    //     template <class T> T &yyybK2(T &res, const SparseVector<gentype> &x, const SparseVector<gentype> &y, const vecInfo &xinfo, const vecInfo &yinfo, const T &bias, const gentype **pxyprod, int i, int j, int xdim,$ 
    // *data dependent operation*
    // if far reference present then evaluate as rank kernel by computing difference...
    // evaluation by calling...
    //
    //     template <class T> T &yyycK2(T &res, const SparseVector<gentype> &x, const SparseVector<gentype> &y, const vecInfo &xinfo, const vecInfo &yinfo, const T &bias, const gentype **pxyprod, int i, int j, int xdim,$ 
    // *data dependent operation*
    // does gradients if required by branching to gradient functions (K2 only).
    // otherwise calls to...
    //
    //    template <class T> T &yyyKK2(T &res, const SparseVector<gentype> &x, const SparseVector<gentype> &y, const vecInfo &xinfo, const vecInfo &yinfo, const T &bias, const gentype **pxyprod, int i, int j, int xdim,$ 
    // *data dependent operation*
    // branching for setwise kernels.  For example K2([x~y],[a~b~c]) = K5(x,y,a,b,c).
    // based on nupsize calls to xkkk2, xkkk3, ...,
    // but usually goes through to...
    //
    //     template <class T> T &xKKK2(T &res, const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, const vecInfo &xainfo, const vecInfo &xbinfo, const T &bias, const gentype **pxyprod, int ia, int ib, int $ 
    // *kernel dependent operation*
    // processes mulSplits, which are points in the kernel dictionary that evaluate as <left of split>*<right of split>
    // each "split" evaluated by calling...
    //
    //     template <class T> T &xKK2(T &res, const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, const vecInfo &xainfo, const vecInfo &xbinfo, const T &bias, const gentype **pxyprod, int ia, int ib, int x$ 
    // *kernel dependent operation*
    // processes normalisation and splits.
    // normalisation is when K(x,y) -> K(x,y)/sqrt(K(x,x)*K(y,y)).
    // designed to allow for changes made in yyykk2 function!
    // does this by calling (in the most basic path)...
    //
    //     template <class T> T &KK2(T &res, T &logres, int &logresvalid, const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, const vecInfo &xainfo, const vecInfo &xbinfo, const T &bias, const gentype **px$ 
    // *data dependent operation*
    // does kernels over distributions.  If arguments are functions then this does monte-carlo integration on an even grid.
    // does this by calling...
    //
    //     template <class T> T &LL2(T &res, T &logres, int &logresvalid, const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, const vecInfo &xainfo, const vecInfo &xbinfo, const T &bias, const gentype **px$ 
    // *kernel and data dependent operation*
    // actual kernel evaluation begins.
    // ip evaluation branches here
    // isprod evaluation recurses from here
    // kernel evaluation for relatively simple kernels goes here.
    // Otherwise falls through to K2i which does the full tree as described previously.

    double   yyyK2x2(              const SparseVector<gentype> &x, const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, const vecInfo &xinfo, const vecInfo &xainfo, const vecInfo &xbinfo,       double   bias, int i, int ia, int ib, int xdim, int xconsist, int resmode, int mlid, const double *xy00, const double *xy10, const double *xy11, const double *xy20, const double *xy21, const double *xy22, int assumreal, int justcalcip) const;
    gentype &yyyK2x2(gentype &res, const SparseVector<gentype> &x, const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, const vecInfo &xinfo, const vecInfo &xainfo, const vecInfo &xbinfo, const gentype &bias, int i, int ia, int ib, int xdim, int xconsist, int resmode, int mlid, const double *xy00, const double *xy10, const double *xy11, const double *xy20, const double *xy21, const double *xy22, int assumreal, int justcalcip) const;

    template <class T> T &yyyaK2x2(T &res, const SparseVector<gentype> &x, const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, const vecInfo &xinfo, const vecInfo &xainfo, const vecInfo &xbinfo, int xignorefarfar, int xaignorefarfar, int xbignorefarfar, int xignorefarfarfar, int xaignorefarfarfar, int xbignorefarfarfar, int xgradordadd, int xagradordadd, int xbgradordadd, int xgradordaddR, int xagradordaddR, int xbgradordaddR, const T &bias, int i, int ia, int ib, int xdim, int xconsist, int resmode, int mlid, const double *xy00, const double *xy10, const double *xy11, const double *xy20, const double *xy21, const double *xy22, int assumreal, int justcalcip) const;
    template <class T> T &yyybK2x2(T &res, const SparseVector<gentype> &x, const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, const vecInfo &xinfo, const vecInfo &xainfo, const vecInfo &xbinfo, int xgradOrder, int xagradOrder, int xbgradOrder, int xgradOrderR, int xagradOrderR, int xbgradOrderR, int iupm, int iaupm, int ibupm, int xfarpresent, int xafarpresent, int xbfarpresent, double xrankw, double xarankw, double xbrankw, double xArankw, double xBrankw, int xfarfarpresent, int xafarfarpresent, int xbfarfarpresent, int xfarfarfarpresent, int xafarfarfarpresent, int xbfarfarfarpresent, int xgradup, int xagradup, int xbgradup, int xgradupR, int xagradupR, int xbgradupR, int xignorefarfar, int xaignorefarfar, int xbignorefarfar, int xignorefarfarfar, int xaignorefarfarfar, int xbignorefarfarfar, const T &bias, int i, int ia, int ib, int xdim, int xbonsist, int resmode, int mlid, const double *xy00, const double *xy10, const double *xy11, const double *xy20, const double *xy21, const double *xy22, int iset, int iaset, int ibset, int assumreal, int justcalcip, int densetype, int adensetype, int bdensetype) const;
    template <class T> T &yyycK2x2(T &res, const SparseVector<gentype> &x, const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, const vecInfo &xinfo, const vecInfo &xainfo, const vecInfo &xbinfo, int xgradOrder, int xagradOrder, int xbgradOrder, int xgradup, int xagradup, int xbgradup, int iupm, int iaupm, int ibupm, const SparseVector<gentype> &xff, const SparseVector<gentype> &xaff, const SparseVector<gentype> &xbff, const T &bias, int i, int ia, int ib, int xdim, int xconsist, int resmode, int mlid, const double *xy00, const double *xy10, const double *xy11, const double *xy20, const double *xy21, const double *xy22, int iset, int iaset, int ibset, int assumreal, int justcalcip, int densetype, int adensetype, int bdensetype) const;
    template <class T> T &yyyKK2x2(T &res, const SparseVector<gentype> &x, const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, const vecInfo &xinfo, const vecInfo &xainfo, const vecInfo &xvinfo, int xgradOrder, int xagradOrder, int xbgradOrder, int xgradup, int xagradup, int xbgradup, int iupm, int iaupm, int ibupm, const SparseVector<gentype> &xff, const SparseVector<gentype> &xaff, const SparseVector<gentype> &xbff, const T &bias, int i, int ia, int ib, int xdim, int xconsist, int resmode, int mlid, const double *xy00, const double *xy10, const double *xy11, const double *xy20, const double *xy21, const double *xy22, int iset, int iaset, int ibset, int assumreal, int justcalcip, int densetype, int adensetype, int bdensetype) const;

    double yyyK0(       double bias, const gentype **pxyprod, int xdim, int xconsist, int resmode, int mlid, int assumreal, int justcalcip) const;
    double yyyK1(       const SparseVector<gentype> &xa, const vecInfo &xainfo, double bias, const gentype **pxyprod, int ia, int xdim, int xconsist, int resmode, int mlid, const double *xy, int assumreal, int justcalcip) const;
    double yyyK2(       const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, const vecInfo &xainfo, const vecInfo &xbinfo, double bias, const gentype **pxyprod, int ia, int ib, int xdim, int xconsist, int resmode, int mlid, const double *xy00, const double *xy10, const double *xy11, int assumreal, int justcalcip) const;
    double yyyK3(       const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, const SparseVector<gentype> &xc, const vecInfo &xainfo, const vecInfo &xbinfo, const vecInfo &xcinfo, double bias, const gentype **pxyprod, int i, int j, int k, int xdim, int xconsist, int resmode, int mlid, const double *xy00, const double *xy10, const double *xy11, const double *xy20, const double *xy21, const double *xy22, int assumreal, int justcalcip) const;
    double yyyK4(       const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, const SparseVector<gentype> &xc, const SparseVector<gentype> &xd, const vecInfo &xainfo, const vecInfo &xbinfo, const vecInfo &xcinfo, const vecInfo &xdinfo, double bias, const gentype **pxyprod, int i, int j, int k, int l, int xdim, int xconsist, int resmode, int mlid, const double *xy00, const double *xy10, const double *xy11, const double *xy20, const double *xy21, const double *xy22, const double *xy30, const double *xy31, const double *xy32, const double *xy33, int assumreal, int justcalcip) const;
    double yyyKm(int m, Vector<const SparseVector<gentype> *> &x, Vector<const vecInfo *> &xinfo, double bias, Vector<int> &i, const gentype **pxyprod, int xdim, int xconsist, int resmode, int mlid, const Matrix<double> *xy, int assumreal, int justcalcip) const;

    gentype &yyyK0(       gentype &res, const gentype &bias, const gentype **pxyprod, int xdim, int xconsist, int resmode, int mlid, int assumreal, int justcalcip) const;
    gentype &yyyK1(       gentype &res, const SparseVector<gentype> &xa, const vecInfo &xainfo, const gentype &bias, const gentype **pxyprod, int ia, int xdim, int xconsist, int resmode, int mlid, const double *xy, int assumreal, int justcalcip) const;
    gentype &yyyK2(       gentype &res, const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, const vecInfo &xainfo, const vecInfo &xbinfo, const gentype &bias, const gentype **pxyprod, int ia, int ib, int xdim, int xconsist, int resmode, int mlid, const double *xy00, const double *xy10, const double *xy11, int assumreal, int justcalcip) const;
    gentype &yyyK3(       gentype &res, const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, const SparseVector<gentype> &xc, const vecInfo &xainfo, const vecInfo &xbinfo, const vecInfo &xcinfo, const gentype &bias, const gentype **pxyprod, int i, int j, int k, int xdim, int xconsist, int resmode, int mlid, const double *xy00, const double *xy10, const double *xy11, const double *xy20, const double *xy21, const double *xy22, int assumreal, int justcalcip) const;
    gentype &yyyK4(       gentype &res, const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, const SparseVector<gentype> &xc, const SparseVector<gentype> &xd, const vecInfo &xainfo, const vecInfo &xbinfo, const vecInfo &xcinfo, const vecInfo &xdinfo, const gentype &bias, const gentype **pxyprod, int i, int j, int k, int l, int xdim, int xconsist, int resmode, int mlid, const double *xy00, const double *xy10, const double *xy11, const double *xy20, const double *xy21, const double *xy22, const double *xy30, const double *xy31, const double *xy32, const double *xy33, int assumreal, int justcalcip) const;
    gentype &yyyKm(int m, gentype &res, Vector<const SparseVector<gentype> *> &x, Vector<const vecInfo *> &xinfo, const gentype &bias, Vector<int> &i, const gentype **pxyprod, int xdim, int xconsist, int resmode, int mlid, const Matrix<double> *xy, int assumreal, int justcalcip) const;

    template <class T> T &yyyaK0(T &res, const T &bias, const gentype **pxyprod, int xdim, int xconsist, int resmode, int mlid, int assumreal, int justcalcip) const;
    template <class T> T &yyyaK1(T &res, const SparseVector<gentype> &xa, const vecInfo &xainfo, int xaignorefarfar, int xaignorefarfarfar, int xagradordadd, int xagradordaddR, const T &bias, const gentype **pxyprod, int ia, int xdim, int xconsist, int resmode, int mlid, const double *xy, int assumreal, int justcalcip) const;
    template <class T> T &yyyaK2(T &res, const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, const vecInfo &xainfo, const vecInfo &xbinfo, int xaignorefarfar, int xbignorefarfar, int xaignorefarfarfar, int xbignorefarfarfar, int xagradordadd, int xbgradordadd, int xagradordaddR, int xbgradordaddR, const T &bias, const gentype **pxyprod, int ia, int ib, int xdim, int xconsist, int resmode, int mlid, const double *xy00, const double *xy10, const double *xy11, int assumreal, int justcalcip) const;
    template <class T> T &yyyaK3(T &res, const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, const SparseVector<gentype> &xc, const vecInfo &xainfo, const vecInfo &xbinfo, const vecInfo &xcinfo, int xaignorefarfar, int xbignorefarfar, int xcignorefarfar, int xaignorefarfarfar, int xbignorefarfarfar, int xcignorefarfarfar, int xagradordadd, int xbgradordadd, int xcgradordadd, int xagradordaddR, int xbgradordaddR, int xcgradordaddR, const T &bias, const gentype **pxyprod, int i, int j, int k, int xdim, int xconsist, int resmode, int mlid, const double *xy00, const double *xy10, const double *xy11, const double *xy20, const double *xy21, const double *xy22, int assumreal, int justcalcip) const;
    template <class T> T &yyyaK4(T &res, const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, const SparseVector<gentype> &xc, const SparseVector<gentype> &xd, const vecInfo &xainfo, const vecInfo &xbinfo, const vecInfo &xcinfo, const vecInfo &xdinfo, int xaignorefarfar, int xbignorefarfar, int xcignorefarfar, int xdignorefarfar, int xaignorefarfarfar, int xbignorefarfarfar, int xcignorefarfarfar, int xdignorefarfarfar, int xagradordadd, int xbgradordadd, int xcgradordadd, int xdgradordadd, int xagradordaddR, int xbgradordaddR, int xcgradordaddR, int xdgradordaddR, const T &bias, const gentype **pxyprod, int i, int j, int k, int l, int xdim, int xconsist, int resmode, int mlid, const double *xy00, const double *xy10, const double *xy11, const double *xy20, const double *xy21, const double *xy22, const double *xy30, const double *xy31, const double *xy32, const double *xy33, int assumreal, int justcalcip) const;
    template <class T> T &yyyaKm(int m, T &res, Vector<const SparseVector<gentype> *> &x, Vector<const vecInfo *> &xinfo, Vector<int> &ignorefarfar, Vector<int> &ignorefarfarfar, Vector<int> &xgradordadd, Vector<int> &xgradordaddR, const T &bias, Vector<int> &i, const gentype **pxyprod, int xdim, int xconsist, int resmode, int mlid, const Matrix<double> *xy, int assumreal, int justcalcip) const;

    template <class T> T &yyybK0(T &res, const T &bias, const gentype **pxyprod, int xdim, int xconsist, int resmode, int mlid, int assumreal, int justcalcip) const;
    template <class T> T &yyybK1(T &res, const SparseVector<gentype> &xa, const vecInfo &xainfo, int xagradOrder, int xagradOrderR, int iaupm, int xafarpresent, double xarankw, double xArankw, int xafarfarpresent, int xafarfarfarpresent, int xagradup, int xagradupR, int xaignorefarfar, int xaignorefarfarfar, const T &bias, const gentype **pxyprod, int ia, int xdim, int xconsist, int resmode, int mlid, const double *xy, int iaset, int assumreal, int justcalcip) const;
    template <class T> T &yyybK2(T &res, const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, const vecInfo &xainfo, const vecInfo &xbinfo, int xagradOrder, int xbgradOrder, int xagradOrderR, int xbgradOrderR, int iaupm, int ibupm, int xafarpresent, int xbfarpresent, double xarankw, double xbrankw, double xArankw, double xBrankw, int xafarfarpresent, int xbfarfarpresent, int xafarfarfarpresent, int xbfarfarfarpresent, int xagradup, int xbgradup, int xagradupR, int xbgradupR, int xaignorefarfar, int xbignorefarfar, int xaignorefarfarfar, int xbignorefarfarfar, const T &bias, const gentype **pxyprod, int ia, int ib, int xdim, int xconsist, int resmode, int mlid, const double *xy00, const double *xy10, const double *xy11, int iaset, int ibset, int assumreal, int justcalcip, int adensetype, int bdensetype) const;
    template <class T> T &yyybK3(T &res, const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, const SparseVector<gentype> &xc, const vecInfo &xainfo, const vecInfo &xbinfo, const vecInfo &xcinfo, int xagradOrder, int xbgradOrder, int xcgradOrder, int xagradOrderR, int xbgradOrderR, int xcgradOrderR, int iaupm, int ibupm, int icupm, int xafarpresent, int xbgrapresent, int xcfarpresent, double xarankw, double xbrankw, double xcrankw, double xArankw, double xBrankw, double xCrankw, int xafarfarpresent, int xbfarfarpresent, int xcfarfarpresent, int xafarfarfarpresent, int xbfarfarfarpresent, int xcfarfarfarpresent, int xagradup, int xbgradup, int xcgradup, int xagradupR, int xbgradupR, int xcgradupR, int xaignorefarfar, int xbignorefarfar, int xcignorefarfar, int xaignorefarfarfar, int xbignorefarfarfar, int xcignorefarfarfar, const T &bias, const gentype **pxyprod, int i, int j, int k, int xdim, int xconsist, int resmode, int mlid, const double *xy00, const double *xy10, const double *xy11, const double *xy20, const double *xy21, const double *xy22, int iaset, int ibset, int icset, int assumreal, int justcalcip) const;
    template <class T> T &yyybK4(T &res, const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, const SparseVector<gentype> &xc, const SparseVector<gentype> &xd, const vecInfo &xainfo, const vecInfo &xbinfo, const vecInfo &xcinfo, const vecInfo &xdinfo, int xagradOrder, int xbgradOrder, int xcgradOrder, int xdgradOrder, int xagradOrderR, int xbgradOrderR, int xcgradOrderR, int xdgradOrderR, int iaupm, int ibupm, int icupm, int idupm, int xafarpresent, int xbfarpresent, int xcfarpresent, int xdfarpresent, double xarankw, double xbrankw, double xcrankw, double xdrankw, double xArankw, double xBrankw, double xCrankw, double xDrankw, int xafarfarpresent, int xbfarfarpresent, int xcfarfarpresent, int xdfarfarpresent, int xafarfarfarpresent, int xbfarfarfarpresent, int xcfarfarfarpresent, int xdfarfarfarpresent, int xagradup, int xbgradup, int xcgradup, int xdgradup, int xagradupR, int xbgradupR, int xcgradupR, int xdgradupR, int xaignorefarfar, int xbignorefarfar, int xcignorefarfar, int xdignorefarfar, int xaignorefarfarfar, int xbignorefarfarfar, int xcignorefarfarfar, int xdignorefarfarfar, const T &bias, const gentype **pxyprod, int i, int j, int k, int l, int xdim, int xconsist, int resmode, int mlid, const double *xy00, const double *xy10, const double *xy11, const double *xy20, const double *xy21, const double *xy22, const double *xy30, const double *xy31, const double *xy32, const double *xy33, int iaset, int ibset, int icset, int idset, int assumreal, int justcalcip) const;
    template <class T> T &yyybKm(int m, T &res, Vector<const SparseVector<gentype> *> &x, Vector<const vecInfo *> &xinfo, Vector<int> &xgradOrder, Vector<int> &xgradOrderR, Vector<int> &iupm, Vector<int> &xfarpresent, Vector<double> &xxrankw, Vector<double> &xXrankw, Vector<int> &sfarfarpresent, Vector<int> &sfarfarfarpresent, Vector<int> &xgradup, Vector<int> &xgradupR, Vector<int> &ignorefarfar, Vector<int> &ignorefarfarfar, const T &bias, Vector<int> &i, const gentype **pxyprod, int xdim, int xconsist, int resmode, int mlid, const Matrix<double> *xy, const Vector<int> *iset, int assumreal, int justcalcip) const;
    template <class T> T &yyybKmb(int m, T &res, Vector<const SparseVector<gentype> *> &x, Vector<const SparseVector<gentype> *> &xn, Vector<const SparseVector<gentype> *> &xf, Vector<const SparseVector<gentype> *> &xff, Vector<const SparseVector<gentype> *> &xfff, Vector<const vecInfo *> &xinfo, Vector<int> &xgradOrder, Vector<int> &xgradOrderR, Vector<int> &iupm, Vector<int> &xfarpresent, Vector<double> &xxrankw, Vector<double> &xXrankw, Vector<int> &xgradup, Vector<int> &xgradupR, const T &bias, Vector<int> &i, const gentype **pxyprod, int xdim, int xconsist, int resmode, int mlid, const Matrix<double> *xy, const Vector<int> *iiset, int assumreal, int justcalcip) const;

    template <class T> T &yyycK0(T &res, const T &bias, const gentype **pxyprod, int xdim, int xconsist, int resmode, int mlid, int assumreal, int justcalcip) const;
    template <class T> T &yyycK1(T &res, const SparseVector<gentype> &xa, const vecInfo &xainfo, int xagradOrder, int xagradup, int iaupm, const SparseVector<gentype> &xaff, const T &bias, const gentype **pxyprod, int ia, int xdim, int xconsist, int resmode, int mlid, const double *xy, int iaset, int assumreal, int justcalcip) const;
    template <class T> T &yyycK2(T &res, const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, const vecInfo &xainfo, const vecInfo &ybinfo, int xagradOrder, int xbgradOrder, int xagradup, int xbgradup, int iaupm, int ibupm, const SparseVector<gentype> &xaff, const SparseVector<gentype> &xbff, const T &bias, const gentype **pxyprod, int ia, int ib, int xdim, int xconsist, int resmode, int mlid, const double *xy00, const double *xy10, const double *xy11, int iaset, int ibset, int assumreal, int justcalcip, int adensetype, int bdensetype) const;
    template <class T> T &yyycK3(T &res, const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, const SparseVector<gentype> &xc, const vecInfo &xainfo, const vecInfo &xbinfo, const vecInfo &xcinfo, int xagradOrder, int xbgradOrder, int xcgradOrder, int xagradup, int xbgradup, int xcgradup, int iaupm, int ibupm, int icupm, const SparseVector<gentype> &xaff, const SparseVector<gentype> &xbff, const SparseVector<gentype> &xcff, const T &bias, const gentype **pxyprod, int i, int j, int k, int xdim, int xconsist, int resmode, int mlid, const double *xy00, const double *xy10, const double *xy11, const double *xy20, const double *xy21, const double *xy22, int iaset, int ibset, int icset, int assumreal, int justcalcip) const;
    template <class T> T &yyycK4(T &res, const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, const SparseVector<gentype> &xc, const SparseVector<gentype> &xd, const vecInfo &xainfo, const vecInfo &xbinfo, const vecInfo &xcinfo, const vecInfo &xdinfo, int xagradOrder, int xbgradOrder, int xcgradOrder, int xdgradOrder, int xagradup, int xbgradup, int xcgradup, int xdgradup, int iaupm, int ibupm, int icupm, int idupm, const SparseVector<gentype> &xaff, const SparseVector<gentype> &xbff, const SparseVector<gentype> &xcff, const SparseVector<gentype> &xdff, const T &bias, const gentype **pxyprod, int i, int j, int k, int l, int xdim, int xconsist, int resmode, int mlid, const double *xy00, const double *xy10, const double *xy11, const double *xy20, const double *xy21, const double *xy22, const double *xy30, const double *xy31, const double *xy32, const double *xy33, int iaset, int ibset, int icset, int idset, int assumreal, int justcalcip) const;
    template <class T> T &yyycKm(int m, T &res, Vector<const SparseVector<gentype> *> &x, Vector<const vecInfo *> &xinfo, Vector<int> &xgradOrder, Vector<int> &xgradup, Vector<int> &iupm, Vector<const SparseVector<gentype> *> &xff, const T &bias, Vector<int> &i, const gentype **pxyprod, int xdim, int xconsist, int resmode, int mlid, const Matrix<double> *xy, const Vector<int> *iset, int assumreal, int justcalcip) const;

    template <class T> T &yyyKK0(T &res, const T &bias, const gentype **pxyprod, int xdim, int xconsist, int resmode, int mlid, int assumreal, int justcalcip) const;
    template <class T> T &yyyKK1(T &res, const SparseVector<gentype> &xa, const vecInfo &xainfo, int xagradOrder, int xagradup, int iaupm, const SparseVector<gentype> &xaff, const T &bias, const gentype **pxyprod, int ia, int xdim, int xconsist, int resmode, int mlid, const double *xy, int iaset, int assumreal, int justcalcip) const;
    template <class T> T &yyyKK2(T &res, const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, const vecInfo &xainfo, const vecInfo &xbinfo, int xagradOrder, int xbgradOrder, int xagradup, int xbgradup, int iaupm, int ibupm, const SparseVector<gentype> &xaff, const SparseVector<gentype> &xbff, const T &bias, const gentype **pxyprod, int ia, int ib, int xdim, int xconsist, int resmode, int mlid, const double *xy00, const double *xy10, const double *xy11, int iaset, int ibset, int assumreal, int justcalcip, int adensetype, int bdensetype) const;
    template <class T> T &yyyKK3(T &res, const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, const SparseVector<gentype> &xc, const vecInfo &xainfo, const vecInfo &xbinfo, const vecInfo &xcinfo, int xagradOrder, int xbgradOrder, int xcgradOrder, int xagradup, int xbgradup, int xcgradup, int iaupm, int ibupm, int icupm, const SparseVector<gentype> &xaff, const SparseVector<gentype> &xbff, const SparseVector<gentype> &xcff, const T &bias, const gentype **pxyprod, int i, int j, int k, int xdim, int xconsist, int resmode, int mlid, const double *xy00, const double *xy10, const double *xy11, const double *xy20, const double *xy21, const double *xy22, int iaset, int ibset, int icset, int assumreal, int justcalcip) const;
    template <class T> T &yyyKK4(T &res, const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, const SparseVector<gentype> &xc, const SparseVector<gentype> &xd, const vecInfo &xainfo, const vecInfo &xbinfo, const vecInfo &xcinfo, const vecInfo &xdinfo, int xagradOrder, int xbgradOrder, int xcgradOrder, int xdgradOrder, int xagradup, int xbgradup, int xcgradup, int xdgradup, int iaupm, int ibupm, int icupm, int idupm, const SparseVector<gentype> &xaff, const SparseVector<gentype> &xbff, const SparseVector<gentype> &xcff, const SparseVector<gentype> &xdff, const T &bias, const gentype **pxyprod, int i, int j, int k, int l, int xdim, int xconsist, int resmode, int mlid, const double *xy00, const double *xy10, const double *xy11, const double *xy20, const double *xy21, const double *xy22, const double *xy30, const double *xy31, const double *xy32, const double *xy33, int iaset, int ibset, int icset, int idset, int assumreal, int justcalcip) const;
    template <class T> T &yyyKKm(int m, T &res, Vector<const SparseVector<gentype> *> &x, Vector<const vecInfo *> &xinfo, const Vector<int> &xgradOrder, const Vector<int> &xgradup, const Vector<int> &xupm, Vector<const SparseVector<gentype> *> &xff, const T &bias, Vector<int> &i, const gentype **pxyprod, int xdim, int xconsist, int resmode, int mlid, const Matrix<double> *xy, const Vector<int> *iset, int assumreal, int justcalcip) const;

    template <class T> T &xKKK0(T &res, const T &bias, const gentype **pxyprod, int xdim, int xconsist, int assumreal, int xresmode, int mlid, int justcalcip) const;
    template <class T> T &xKKK1(T &res, const SparseVector<gentype> &xa, const vecInfo &xainfo, int xagradOrder, const SparseVector<gentype> &xaff, const T &bias, const gentype **pxyprod, int ia, int xdim, int xconsist, int assumreal, int resmode, int mlid, const double *xy, int justcalcip, int iaset) const;
    template <class T> T &xKKK2(T &res, const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, const vecInfo &xainfo, const vecInfo &xbinfo, int xagradOrder, int xbgradOrder, const SparseVector<gentype> &xaff, const SparseVector<gentype> &xbff, const T &bias, const gentype **pxyprod, int ia, int ib, int xdim, int xconsist, int assumreal, int resmode, int mlid, const double *xy00, const double *xy10, const double *xy11, int justcalcip, int iset, int jset, int adensetype, int bdensetype) const;
    template <class T> T &xKKK3(T &res, const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, const SparseVector<gentype> &xc, const vecInfo &xainfo, const vecInfo &xbinfo, const vecInfo &xcinfo, int xagradOrder, int xbgradOrder, int xcgradOrder, const SparseVector<gentype> &xaff, const SparseVector<gentype> &xbff, const SparseVector<gentype> &xcff, const T &bias, const gentype **pxyprod, int ia, int ib, int ic, int xdim, int xconsist, int assumreal, int xresmode, int mlid, const double *xy00, const double *xy10, const double *xy11, const double *xy20, const double *xy21, const double *xy22, int justcalcip, int iaset, int ibset, int icset) const;
    template <class T> T &xKKK4(T &res, const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, const SparseVector<gentype> &xc, const SparseVector<gentype> &xd, const vecInfo &xainfo, const vecInfo &xbinfo, const vecInfo &xcinfo, const vecInfo &xdinfo, int xagradOrder, int xbgradOrder, int xcgradOrder, int xdgradOrder, const SparseVector<gentype> &xaff, const SparseVector<gentype> &xbff, const SparseVector<gentype> &xcff, const SparseVector<gentype> &xdff, const T &bias, const gentype **pxyprod, int ia, int ib, int ic, int id, int xdim, int xconsist, int assumreal, int xresmode, int mlid, const double *xy00, const double *xy10, const double *xy11, const double *xy20, const double *xy21, const double *xy22, const double *xy30, const double *xy31, const double *xy32, const double *xy33, int justcalcip, int iaset, int ibset, int icset, int idset) const;
    template <class T> T &xKKKm(int m, T &res, Vector<const SparseVector<gentype> *> &x, Vector<const vecInfo *> &xinfo, const Vector<int> &xgradOrder, Vector<const SparseVector<gentype> *> &xff, const T &bias, Vector<int> &i, const gentype **pxyprod, int xdim, int xconsist, int assumreal, int resmode, int mlid, const Matrix<double> *xy, int justcalcip, const Vector<int> *iset) const;

    template <class T> T &xKK0(T &res, const T &bias, const gentype **pxyprod, int xdim, int xconsist, int assumreal, int xresmode, int mlid, int justcalcip, int indstart, int indend, int ns) const;
    template <class T> T &xKK1(T &res, const SparseVector<gentype> &xa, const vecInfo &xainfo, int xagradOrder, const SparseVector<gentype> &xaff, const T &bias, const gentype **pxyprod, int ia, int xdim, int xconsist, int assumreal, int resmode, int mlid, const double *xy, int justcalcip, int iaset, int indstart, int indend, int ns) const;
    template <class T> T &xKK2(T &res, const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, const vecInfo &xainfo, const vecInfo &xbinfo, int xagradOrder, int xbgradOrder, const SparseVector<gentype> &xaff, const SparseVector<gentype> &xbff, const T &bias, const gentype **pxyprod, int ia, int ib, int xdim, int xconsist, int assumreal, int resmode, int mlid, const double *xy00, const double * xy10, const double *xy11, int justcalcip, int iset, int jset, int indstart, int indend, int ns, int adensetype, int bdensetype) const;
    template <class T> T &xKK3(T &res, const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, const SparseVector<gentype> &xc, const vecInfo &xainfo, const vecInfo &xbinfo, const vecInfo &xcinfo, int xagradOrder, int xbgradOrder, int xcgradOrder, const SparseVector<gentype> &xaff, const SparseVector<gentype> &xbff, const SparseVector<gentype> &xcff, const T &bias, const gentype **pxyprod, int ia, int ib, int ic, int xdim, int xconsist, int assumreal, int xresmode, int mlid, const double *xy00, const double *xy10, const double *xy11, const double *xy20, const double *xy21, const double *xy22, int justcalcip, int iaset, int ibset, int icset, int indstart, int indend, int ns) const;
    template <class T> T &xKK4(T &res, const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, const SparseVector<gentype> &xc, const SparseVector<gentype> &xd, const vecInfo &xainfo, const vecInfo &xbinfo, const vecInfo &xcinfo, const vecInfo &xdinfo, int xagradOrder, int xbgradOrder, int xcgradOrder, int xdgradOrder, const SparseVector<gentype> &xaff, const SparseVector<gentype> &xbff, const SparseVector<gentype> &xcff, const SparseVector<gentype> &xdff, const T &bias, const gentype **pxyprod, int ia, int ib, int ic, int id, int xdim, int xconsist, int assumreal, int xresmode, int mlid, int justcalcip, const double *xy00, const double *xy10, const double *xy11, const double *xy20, const double *xy21, const double *xy22, const double *xy30, const double *xy31, const double *xy32, const double *xy33, int iaset, int ibset, int icset, int idset, int indstart, int indend, int ns) const;
    template <class T> T &xKKm(int m, T &res, Vector<const SparseVector<gentype> *> &x, Vector<const vecInfo *> &xinfo, const Vector<int> &xgradOrder, Vector<const SparseVector<gentype> *> &xaff, const T &bias, Vector<int> &i, const gentype **pxyprod, int xdim, int xconsist, int assumreal, int resmode, int mlid, const Matrix<double> *xy, int justcalcip, const Vector<int> *iset, int indstart, int indend, int ns) const;

    template <class T> T &KK0(T &res, T &logres, int &logresvalid, const T &bias, const gentype **pxyprod, int xdim, int xconsist, int assumreal, int xresmode, int mlid, int justcalcip, int indstart, int indend, int skipbias = 0) const;
    template <class T> T &KK1(T &res, T &logres, int &logresvalid, const SparseVector<gentype> &xa, const vecInfo &xainfo, int xagradOrder, const SparseVector<gentype> &xaff, const T &bias, const gentype **pxyprod, int ia, int xdim, int xconsist, int assumreal, int resmode, int mlid, const double *xy, int justcalcip, int indstart, int indend, int iaset, int skipbias = 0, int skipxa = 0) const;
    template <class T> T &KK2(int adensetype, int bdensetype, T &res, T &logres, int &logresvalid, const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, const vecInfo &xainfo, const vecInfo &xbinfo, int xagradOrder, int xbgradOrder, const SparseVector<gentype> &xaff, const SparseVector<gentype> &xbff, const T &bias, const gentype **pxyprod, int ia, int ib, int xdim, int xconsist, int assumreal, int resmode, int mlid, const double *xy00, const double *xy10, const double *xy11, int justcalcip, int indstart, int indend, int iset, int jset, int skipbias = 0, int skipxa = 0, int skipxb = 0) const;
    template <class T> T &KK3(T &res, T &logres, int &logresvalid, const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, const SparseVector<gentype> &xc, const vecInfo &xainfo, const vecInfo &xbinfo, const vecInfo &xcinfo, int xagradOrder, int xbgradOrder, int xcgradOrder, const SparseVector<gentype> &xaff, const SparseVector<gentype> &xbff, const SparseVector<gentype> &xcff, const T &bias, const gentype **pxyprod, int ia, int ib, int ic, int xdim, int xconsist, int assumreal, int xresmode, int mlid, const double *xy00, const double *xy10, const double *xy11, const double *xy20, const double *xy21, const double *xy22, const Vector<int> *s, int justcalcip, int indstart, int indend, int iaset, int ibset, int icset, int skipbias = 0, int skipxa = 0, int skipxb = 0, int skipxc = 0) const;
    template <class T> T &KK4(T &res, T &logres, int &logresvalid, const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, const SparseVector<gentype> &xc, const SparseVector<gentype> &xd, const vecInfo &xainfo, const vecInfo &xbinfo, const vecInfo &xcinfo, const vecInfo &xdinfo, int xagradOrder, int xbgradOrder, int xcgradOrder, int xdgradOrder, const SparseVector<gentype> &xaff, const SparseVector<gentype> &xbff, const SparseVector<gentype> &xcff, const SparseVector<gentype> &xdff, const T &bias, const gentype **pxyprod, int ia, int ib, int ic, int id, int xdim, int xconsist, int assumreal, int xresmode, int mlid, const Vector<int> *s, int justcalcip, const double *xy00, const double *xy10, const double *xy11, const double *xy20, const double *xy21, const double *xy22, const double *xy30, const double *xy31, const double *xy32, const double *xy33, int indstart, int indend, int iaset, int ibset, int icset, int idset, int skipbias = 0, int skipxa = 0, int skipxb = 0, int skipxc = 0, int skipxd = 0) const;
    template <class T> T &KK6(T &res, T &logres, int &logresvalid, const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, const SparseVector<gentype> &xc, const SparseVector<gentype> &xd, const SparseVector<gentype> &xe, const SparseVector<gentype> &xf, const vecInfo &xainfo, const vecInfo &xbinfo, const vecInfo &xcinfo, const vecInfo &xdinfo, const vecInfo &xeinfo, const vecInfo &xfinfo, int xagradOrder, int xbgradOrder, int xcgradOrder, int xdgradOrder, int xegradOrder, int xfgradOrder, const SparseVector<gentype> &xaff, const SparseVector<gentype> &xbff, const SparseVector<gentype> &xcff, const SparseVector<gentype> &xdff, const SparseVector<gentype> &xeff, const SparseVector<gentype> &xf4, const T &bias, const gentype **pxyprod, int ia, int ib, int ic, int id, int ie, int jf, int xdim, int xconsist, int assumreal, int xresmode, int mlid, const Matrix<double> *xy, const Vector<int> *s, int justcalcip, int indstart, int indend, int iaset, int ibset, int icset, int idset, int ieset, int ifset) const;
    template <class T> T &KKm(int m, T &res, T &logres, int &logresvalid, Vector<const SparseVector<gentype> *> &x, Vector<const vecInfo *> &xinfo, const Vector<int> &xgradOrder, Vector<const SparseVector<gentype> *> &xff, const T &bias, Vector<int> &i, const gentype **pxyprod, int xdim, int xconsist, int assumreal, int resmode, int mlid, const Matrix<double> *xy, const Vector<int> *s, int justcalcip, int indstart, int indend, const Vector<int> *iset, int skipbias = 0, int skipx = 0) const;

    template <class T> T &LL0(T &res, T &logres, int &logresvalid, const T &bias, const gentype **pxyprod, int xdim, int xconsist, int assumreal, int xresmode, int mlid, int justcalcip, int indstart, int indend) const;
    template <class T> T &LL1(T &res, T &logres, int &logresvalid, const SparseVector<gentype> &xa, const vecInfo &xainfo, const T &bias, const gentype **pxyprod, int ia, int xdim, int xconsist, int assumreal, int resmode, int mlid, const double *xy, int justcalcip, int indstart, int indend) const;
    template <class T> T &LL2(int adensetype, int bdensetype, T &res, T &logres, int &logresvalid, const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, const vecInfo &xainfo, const vecInfo &xbinfo, const T &bias, const gentype **pxyprod, int ia, int ib, int xdim, int xconsist, int assumreal, int resmode, int mlid, const double *xy00, const double *xy10, const double *xy11, int justcalcip, int indstart, int indend) const;
    template <class T> T &LL3(T &res, T &logres, int &logresvalid, const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, const SparseVector<gentype> &xc, const vecInfo &xainfo, const vecInfo &xbinfo, const vecInfo &xcinfo, const T &bias, const gentype **pxyprod, int ia, int ib, int ic, int xdim, int xconsist, int assumreal, int xresmode, int mlid, const double *xy00, const double *xy10, const double *xy11, const double *xy20, const double *xy21, const double *xy22, const Vector<int> *s, int justcalcip, int indstart, int indend) const;
    template <class T> T &LL4(T &res, T &logres, int &logresvalid, const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, const SparseVector<gentype> &xc, const SparseVector<gentype> &xd, const vecInfo &xainfo, const vecInfo &xbinfo, const vecInfo &xcinfo, const vecInfo &xdinfo, const T &bias, const gentype **pxyprod, int ia, int ib, int ic, int id, int xdim, int xconsist, int assumreal, int xresmode, int mlid, const Vector<int> *s, int justcalcip, const double *xy00, const double *xy10, const double *xy11, const double *xy20, const double *xy21, const double *xy22, const double *xy30, const double *xy31, const double *xy32, const double *xy33, int indstart, int indend) const;
    template <class T> T &LLm(int m, T &res, T &logres, int &logresvalid, Vector<const SparseVector<gentype> *> &x, Vector<const vecInfo *> &xinfo, const T &bias, Vector<int> &i, const gentype **pxyprod, int xdim, int xconsist, int assumreal, int resmode, int mlid, const Matrix<double> *xy, const Vector<int> *s, int justcalcip, int indstart, int indend) const;

    double LL2fast(const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, const vecInfo &xainfo, const vecInfo &xbinfo, double bias, const gentype **pxyprod, int ia, int ib, int xdim, int xconsist, int assumreal, const double *xy00, const double *xy10, const double *xy11) const;

    // phim evaluation tree is similar:
    //
    // - phim(m,...)
    // calls direct to:
    //
    // - yyyphim(m,...)
    // calls direct to:
    //
    // - yyyaphim(m,...)
    // *data dependent operation*
    // assert that this is not a diagonal.
    // call direct to:
    //
    // - yyybphim(m,...)
    // *data dependent operation*
    // if far reference present then return difference of feature maps for near and far,
    // evaluation by calling:
    //
    // - yyycphim(m,...)
    // *data dependent operation*
    // extract order of gradient and add as parameter,
    // then call to:
    //
    // - yyyPphim(m,...,gradOrder)
    // *data dependent operation*
    // if setwise then evaluate next level as elementwise product of each call to,
    // evaluation by calling:
    //
    // - xPPphim(m,...,gradOrder,usize)
    // *kernel dependent operation*
    // if there are multiplicative splits then return kronprod of each,
    // then call:
    //
    // - xPphim(m,...,gradOrder,usize)
    //     template <class T> T &xKK2(T &res, const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, const vecInfo &xainfo, const vecInfo &xbinfo, const T &bias, const gentype **pxyprod, int ia, int ib, int x$ 
    // *kernel dependent operation*
    // normalise if needed, dividing by appropriate root of normalisation constant, throw if there is non-trivial normalisation due to setwise operation,
    // then call to:
    //
    // - Pphim(m,...,gradOrder)
    //     template <class T> T &KK2(T &res, T &logres, int &logresvalid, const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, const vecInfo &xainfo, const vecInfo &xbinfo, const T &bias, const gentype **px$ 
    // *data dependent operation*
    // If arguments are functions then this computes the average on an even grid,
    // calling to:
    //
    // - Qqhim(m,...,gradOrder)
    // *kernel and data dependent operation*
    // assert !isprod
    // if not a simple kernel sum then throw an exception
    // do sum of kernels by appending vectors to each other
    // weighting by multiplying by appropriate root of weight
    // individual kernels by usual reference.
    // gradients done at this level.
    // inner normalisation here with appropriate square-root

    int yyyphim(int m, Vector<double>  &res, const SparseVector<gentype> &x, const vecInfo &xinfo, int i, int allowfinite, int xdim, int xconsist, int assumreal) const;
    int yyyphim(int m, Vector<gentype> &res, const SparseVector<gentype> &x, const vecInfo &xinfo, int i, int allowfinite, int xdim, int xconsist, int assumreal) const;

    template <class T> int yyyaphim(int m, Vector<T> &res, const SparseVector<gentype> &x, const vecInfo &xinfo, int xaignorefarfar, int xaignorefarfarfar, int xagradordadd, int xagradordaddR, int i, int allowfinite, int xdim, int xconsist, int assumreal) const;
    template <class T> int yyybphim(int m, Vector<T> &res, const SparseVector<gentype> &x, const vecInfo &xinfo, int xaignorefarfar, int xaignorefarfarfar, int i, int xagradOrder, int xagradOrderR, int iaupm, int xafarpresent, int xafarfarpresent, int xafarfarfarpresent, int xagradup, int xagradupR, int allowfinite, int xdim, int xconsist, int assumreal, int iaset) const;
    template <class T> int yyycphim(int m, Vector<T> &res, const SparseVector<gentype> &x, const vecInfo &xinfo, int i, int xagradOrder, int iaupm, int xagradup, const SparseVector<gentype> &xaff, int allowfinite, int xdim, int xconsist, int assumreal, int iaset) const;
    template <class T> int yyyPphim(int m, Vector<T> &res, const SparseVector<gentype> &x, const vecInfo &xinfo, int i, int allowfinite, int xdim, int xconsist, int assumreal, int iaset, int gradOrder, int xagradup, int iaupm) const;
    //template <class T> int xPPphim (int m, Vector<T> &res, const SparseVector<gentype> &x, const vecInfo &xinfo, int i, int allowfinite, int xdim, int xconsist, int assumreal, int iaset, int gradOrder, int xagradup) const;
    //template <class T> int xPphim  (int m, Vector<T> &res, const SparseVector<gentype> &x, const vecInfo &xinfo, int i, int allowfinite, int xdim, int xconsist, int assumreal, int iaset, int gradOrder, int xagradup, int indstart, int indend, int ns) const;
    template <class T> int Pphim   (int m, Vector<T> &res, const SparseVector<gentype> &x, const vecInfo &xinfo, int i, int allowfinite, int xdim, int xconsist, int assumreal, int iaset, int gradOrder, int xagradup, int indstart, int indend, int xaskip = 0) const;
    template <class T> int Qqhim   (int m, Vector<T> &res, const SparseVector<gentype> &x, const vecInfo &xinfo, int i, int allowfinite, int xdim, int xconsist, int assumreal,            int gradOrder, int xagradup, int indstart, int indend) const;






    // Analogous trees for derivative evaluation

    template <class T> void yyydKK2( T &xygrad, T &xnormgrad, int &minmaxind, const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, const vecInfo &xainfo, const vecInfo &xbinfo, const T &bias, const gentype **pxyprod, int ia, int ib, int xdim, int xconsist, int assumreal, int mlid, const double *xy00, const double *xy10, const double *xy11, int deepDeriv) const;
    template <class T> void yyyd2KK2(T &xygrad, T &xnormgrad, T &xyxygrad, T &xyxnormgrad, T &xyynormgrad, T &xnormxnormgrad, T &xnormynormgrad, T &ynormynormgrad, int &minmaxind, const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, const vecInfo &xainfo, const vecInfo &xbinfo, const T &bias, const gentype **pxyprod, int ia, int ib, int xdim, int xconsist, int assumreal, int mlid, const double *xy00, const double *xy10, const double *xy11, int deepDeriv) const;
    template <class T> void yyydnKK2del(Vector<T> &sc, Vector<Vector<int> > &n, int &minmaxind, const Vector<int> &q, const SparseVector<gentype> &x, const SparseVector<gentype> &y, const vecInfo &xinfo, const vecInfo &yinfo, const T &bias, const gentype **pxyprod, int i, int j, int xdim, int xconsist, int assumreal, int mlid, const double *xy00, const double *xy10, const double *xy11, int deepDeriv) const;

    template <class T> void yyyadKK2( T &xygrad, T &xnormgrad, int &minmaxind, const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, const vecInfo &xainfo, const vecInfo &xbinfo, const T &bias, const gentype **pxyprod, int ia, int ib, int xdim, int xconsist, int assumreal, int mlid, const double *xy00, const double *xy10, const double *xy11, int deepDeriv) const;
    template <class T> void yyyad2KK2(T &xygrad, T &xnormgrad, T &xyxygrad, T &xyxnormgrad, T &xyynormgrad, T &xnormxnormgrad, T &xnormynormgrad, T &ynormynormgrad, int &minmaxind, const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, const vecInfo &xainfo, const vecInfo &xbinfo, const T &bias, const gentype **pxyprod, int ia, int ib, int xdim, int xconsist, int assumreal, int mlid, const double *xy00, const double *xy10, const double *xy11, int deepDeriv) const;
    template <class T> void yyyadnKK2del(Vector<T> &sc, Vector<Vector<int> > &n, int &minmaxind, const Vector<int> &q, const SparseVector<gentype> &x, const SparseVector<gentype> &y, const vecInfo &xinfo, const vecInfo &yinfo, const T &bias, const gentype **pxyprod, int i, int j, int xdim, int xconsist, int assumreal, int mlid, const double *xy00, const double *xy10, const double *xy11, int deepDeriv) const;

    template <class T> void yyybdKK2( T &xygrad, T &xnormgrad, int &minmaxind, const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, const vecInfo &xainfo, const vecInfo &xbinfo, const T &bias, const gentype **pxyprod, int ia, int ib, int xdim, int xconsist, int assumreal, int mlid, const double *xy00, const double *xy10, const double *xy11, int deepDeriv, int iset, int jset) const;
    template <class T> void yyybd2KK2(T &xygrad, T &xnormgrad, T &xyxygrad, T &xyxnormgrad, T &xyynormgrad, T &xnormxnormgrad, T &xnormynormgrad, T &ynormynormgrad, int &minmaxind, const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, const vecInfo &xainfo, const vecInfo &xbinfo, const T &bias, const gentype **pxyprod, int ia, int ib, int xdim, int xconsist, int assumreal, int mlid, const double *xy00, const double *xy10, const double *xy11, int deepDeriv, int iset, int jset) const;
    template <class T> void yyybdnKK2del(Vector<T> &sc, Vector<Vector<int> > &n, int &minmaxind, const Vector<int> &q, const SparseVector<gentype> &x, const SparseVector<gentype> &y, const vecInfo &xinfo, const vecInfo &yinfo, const T &bias, const gentype **pxyprod, int i, int j, int xdim, int xconsist, int assumreal, int mlid, const double *xy00, const double *xy10, const double *xy11, int deepDeriv, int iset, int jset) const;

    template <class T> void yyycdKK2( T &xygrad, T &xnormgrad, int &minmaxind, const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, const vecInfo &xainfo, const vecInfo &xbinfo, const T &bias, const gentype **pxyprod, int ia, int ib, int xdim, int xconsist, int assumreal, int mlid, const double *xy00, const double *xy10, const double *xy11, int deepDeriv, int iset, int jset) const;
    template <class T> void yyycd2KK2(T &xygrad, T &xnormgrad, T &xyxygrad, T &xyxnormgrad, T &xyynormgrad, T &xnormxnormgrad, T &xnormynormgrad, T &ynormynormgrad, int &minmaxind, const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, const vecInfo &xainfo, const vecInfo &xbinfo, const T &bias, const gentype **pxyprod, int ia, int ib, int xdim, int xconsist, int assumreal, int mlid, const double *xy00, const double *xy10, const double *xy11, int deepDeriv, int iset, int jset) const;
    template <class T> void yyycdnKK2del(Vector<T> &sc, Vector<Vector<int> > &n, int &minmaxind, const Vector<int> &q, const SparseVector<gentype> &x, const SparseVector<gentype> &y, const vecInfo &xinfo, const vecInfo &yinfo, const T &bias, const gentype **pxyprod, int i, int j, int xdim, int xconsist, int assumreal, int mlid, const double *xy00, const double *xy10, const double *xy11, int deepDeriv, int iset, int jset) const;

    template <class T> void qqqdK2delx(T &xscaleres, T &yscaleres, int &minmaxind, const SparseVector<gentype> &x, const SparseVector<gentype> &y, const vecInfo &xinfo, const vecInfo &yinfo, const T &bias, const gentype **pxyprod, int i, int j, int xdim, int xconsist, int mlid, const double *xy00, const double *xy10, const double *xy11, int iaset, int ibset, int assumreal) const;
    template <class T> void qqqd2K2delxdelx(T &xxscaleres, T &yyscaleres, T &xyscaleres, T &yxscaleres, T &constres, int &minmaxind, const SparseVector<gentype> &x, const SparseVector<gentype> &y, const vecInfo &xinfo, const vecInfo &yinfo, const T &bias, const gentype **pxyprod, int i, int j, int xdim, int xconsist, int mlid, const double *xy00, const double *xy10, const double *xy11, int deepDerive, int iaset, int ibset, int assumreal) const;
    template <class T> void qqqd2K2delxdely(T &xxscaleres, T &yyscaleres, T &xyscaleres, T &yxscaleres, T &constres, int &minmaxind, const SparseVector<gentype> &x, const SparseVector<gentype> &y, const vecInfo &xinfo, const vecInfo &yinfo, const T &bias, const gentype **pxyprod, int i, int j, int xdim, int xconsist, int mlid, const double *xy00, const double *xy10, const double *xy11, int deepDerive, int iaset, int ibset, int assumreal) const;
    template <class T> void qqqdnK2del(Vector<T> &sc, Vector<Vector<int> > &n, int &minmaxind, const Vector<int> &q, const SparseVector<gentype> &x, const SparseVector<gentype> &y, const vecInfo &xinfo, const vecInfo &yinfo, const T &bias, const gentype **pxyprod, int i, int j, int xdim, int xconsist, int mlid, const double *xy00, const double *xy10, const double *xy11, int deepDerive, int iaset, int ibset, int assumreal) const;

    template <class T> void xdKK2( T &xygrad, T &xnormgrad, int &minmaxind, const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, const vecInfo &xainfo, const vecInfo &xbinfo, const T &bias, const gentype **pxyprod, int ia, int ib, int xdim, int xconsist, int assumreal, int mlid, const double *xy00, const double *xy10, const double *xy11, int deepDeriv, int iset, int jset) const;
    template <class T> void xd2KK2(T &xygrad, T &xnormgrad, T &xyxygrad, T &xyxnormgrad, T &xyynormgrad, T &xnormxnormgrad, T &xnormynormgrad, T &ynormynormgrad, int &minmaxind, const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, const vecInfo &xainfo, const vecInfo &xbinfo, const T &bias, const gentype **pxyprod, int ia, int ib, int xdim, int xconsist, int assumreal, int mlid, const double *xy00, const double *xy10, const double *xy11, int deepDeriv, int iset, int jset) const;
    template <class T> void xdnKK2del(Vector<T> &sc, Vector<Vector<int> > &n, int &minmaxind, const Vector<int> &q, const SparseVector<gentype> &x, const SparseVector<gentype> &y, const vecInfo &xinfo, const vecInfo &yinfo, const T &bias, const gentype **pxyprod, int i, int j, int xdim, int xconsist, int assumreal, int mlid, const double *xy00, const double *xy10, const double *xy11, int deepDeriv, int iset, int jset) const;

    template <class T> void dKK2( T &xygrad, T &xnormgrad, int &minmaxind, const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, const vecInfo &xainfo, const vecInfo &xbinfo, const T &bias, const gentype **pxyprod, int ia, int ib, int xdim, int xconsist, int assumreal, int mlid, const double *xy00, const double *xy10, const double *xy11, int deepDeriv, int iaset, int ibset, int skipbias = 0, int skipxa = 0, int skipxb = 0) const;
    template <class T> void d2KK2(T &xygrad, T &xnormgrad, T &xyxygrad, T &xyxnormgrad, T &xyynormgrad, T &xnormxnormgrad, T &xnormynormgrad, T &ynormynormgrad, int &minmaxind, const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, const vecInfo &xainfo, const vecInfo &xbinfo, const T &bias, const gentype **pxyprod, int ia, int ib, int xdim, int xconsist, int assumreal, int mlid, const double *xy00, const double *xy10, const double *xy11, int deepDeriv, int iaset, int ibset, int skipbias = 0, int skipxa = 0, int skipxb = 0) const;
    template <class T> void dnKK2del(Vector<T> &sc, Vector<Vector<int> > &n, int &minmaxind, const Vector<int> &q, const SparseVector<gentype> &x, const SparseVector<gentype> &y, const vecInfo &xinfo, const vecInfo &yinfo, const T &bias, const gentype **pxyprod, int i, int j, int xdim, int xconsist, int assumreal, int mlid, const double *xy00, const double *xy10, const double *xy11, int deepDeriv, int iaset, int ibset, int skipbias = 0, int skipxa = 0, int skipxb = 0) const;

    template <class T> void dLL2( T &xygrad, T &xnormgrad, int &minmaxind, const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, const vecInfo &xainfo, const vecInfo &xbinfo, const T &bias, const gentype **pxyprod, int ia, int ib, int xdim, int xconsist, int assumreal, int mlid, const double *xy00, const double *xy10, const double *xy11, int deepDeriv) const;
    template <class T> void d2LL2(T &xygrad, T &xnormgrad, T &xyxygrad, T &xyxnormgrad, T &xyynormgrad, T &xnormxnormgrad, T &xnormynormgrad, T &ynormynormgrad, int &minmaxind, const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, const vecInfo &xainfo, const vecInfo &xbinfo, const T &bias, const gentype **pxyprod, int ia, int ib, int xdim, int xconsist, int assumreal, int mlid, const double *xy00, const double *xy10, const double *xy11, int deepDeriv) const;
    template <class T> void dnLL2del(Vector<T> &sc, Vector<Vector<int> > &n, int &minmaxind, const Vector<int> &q, const SparseVector<gentype> &x, const SparseVector<gentype> &y, const vecInfo &xinfo, const vecInfo &yinfo, const T &bias, const gentype **pxyprod, int i, int j, int xdim, int xconsist, int assumreal, int mlid, const double *xy00, const double *xy10, const double *xy11, int deepDeriv) const;




    template <class T> int  KKpro(  T &res, const T &xyprod, const T &diffis, int *i, int locindstart, int locindend, int xdim, int m, T &logres, const T *xprod) const;
    template <class T> void dKKpro( T &xygrad, T &xnormgrad, T &res, const T &xyprod, const T &diffis, int i, int j, int locindstart, int locindend, int xdim, int m, const T &xxprod, const T &yyprod) const;
    template <class T> void d2KKpro(T &xygrad, T &xnormgrad, T &xyxygrad, T &xyxnormgrad, T &xyynormgrad, T &xnormxnormgrad, T &xnormynormgrad, T &ynormynormgrad, T &res, const T &xyprod, const T &diffis, int i, int j, int locindstart, int locindend, int xdim, int m, const T &xxprod, const T &yyprod) const;
    template <class T> void dnKKpro(T &res, const Vector<int> &gd, const T &xyprod, const T &diffis, int i, int j, int locindstart, int locindend, int xdim, int m, int isfirstcalc, T &scratch) const;


    template <class T> int  KKprosingle(  T &res, const T &xyprod, const T &diffis, int *i, int xdim, int m, T &logres, const T *xprod, int ktype, int &logresvalid, const gentype &weight, const Vector<gentype> &r, const Vector<int> &ic, int magterm) const;
    template <class T> void dKKprosingle( T &xygrad, T &diffgrad, T &xnormonlygrad, T &res, const T &xyprod, const T &diffis, int i, int j, int xdim, int m, const T &xxprod, const T &yyprod, int ktype, const gentype &weight, const Vector<gentype> &r, const Vector<int> &ic, int magterm) const;
    template <class T> void d2KKprosingle(T &xygrad, T &diffgrad, T &xnormonlygrad, T &xyxygrad, T &diffdiffgrad, T &xnormxnormonlygrad, T &xnormynormonlygrad, T &ynormynormonlygrad, T &res, const T &xyprod, const T &diffis, int i, int j, int xdim, int m, const T &xxprod, const T &yyprod, int ktype, const gentype &weight, const Vector<gentype> &r, const Vector<int> &ic, int magterm) const;
//    template <class T> void dnKKprosingle(T &res, const Vector<int> &gd, const T &xyprod, const T &diffis, int i, int j, int locindstart, int locindend, int xdim, int m, int isfirstcalc, T &scratch, const T &xxprod, const T &yyprod, int ktype, const gentype &weight, const Vector<gentype> &r, const Vector<int> &ic, int magterm) const;

    template <class T> int  KKprosinglediffiszero(T &res, const T &xyprod, int ia, int ib, const T &xxprod, const T &yyprod, int ktype, const gentype &weight, const Vector<gentype> &r, const Vector<int> &ic) const;



    template <class T> int QQpro      (int m, Vector<T> &res, const SparseVector<gentype> &xa, const vecInfo &xainfo, int ia, int allowfinite, int xdim, int xconsist, int assumreal, int gradOrder, int xagradup, int indstart, int indend) const;
    template <class T> int QQprosingle(int m, Vector<T> &res, const SparseVector<gentype> &xa, const vecInfo &xainfo, int ia, int allowfinite, int xdim, int xconsist, int assumreal, int gradOrder, int xagradup, int ind, int ktype, const gentype &weight, const Vector<gentype> &r, const Vector<int> &ic) const;


    void K0i(     gentype &res,        const gentype &xyprod,                                    int xdim, int resmode, int mlid, int indstart, int indend) const;
    void K0(      gentype &res, int q, const gentype &xyprod, gentype &diffis, int recalcdiffis, int xdim, int resmode, int mlid) const;
    void K0unnorm(gentype &res, int q, const gentype &xyprod, gentype &diffis, int recalcdiffis, int xdim, int resmode, int mlid) const;


    void K2i(     gentype &res,        const gentype &xyprod, const gentype &yxprod,                                    const vecInfo &xinfo, const vecInfo &yinfo, const gentype &xnorm, const gentype &ynorm, const SparseVector<gentype> &x, const SparseVector<gentype> &y, int i, int j, int xdim, int adensetype, int bdensetype, int resmode, int mlid, int indstart, int indend, int assumreal) const;
    void K2(      gentype &res, int q, const gentype &xyprod, const gentype &yxprod, gentype &diffis, int recalcdiffis, const vecInfo &xinfo, const vecInfo &yinfo, const gentype &xnorm, const gentype &ynorm, const SparseVector<gentype> &x, const SparseVector<gentype> &y, int i, int j, int xdim, int adensetype, int bdensetype, int resmode, int mlid) const;
    void K2unnorm(gentype &res, int q, const gentype &xyprod, const gentype &yxprod, gentype &diffis, int recalcdiffis, const vecInfo &xinfo, const vecInfo &yinfo, const gentype &xnorm, const gentype &ynorm, const SparseVector<gentype> &x, const SparseVector<gentype> &y, int i, int j, int xdim, int adensetype, int bdensetype, int resmode, int mlid) const;


    void K4i(     gentype &res,        const gentype &xyprod,                                    const vecInfo &xainfo, const vecInfo &xbinfo, const vecInfo &xcinfo, const vecInfo &xdinfo, const gentype &xanorm, const gentype &xbnorm, const gentype &xcnorm, const gentype &xdnorm, const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, const SparseVector<gentype> &xc, const SparseVector<gentype> &xd, int i, int j, int k, int l, int xdim, int resmode, int mlid, double xy00, double xy10, double xy11, double xy20, double xy21, double xy22, double xy30, double xy31, double xy32, double xy33, const Vector<int> *s, int indstart, int indend, int assumreal) const;
    void K4(      gentype &res, int q, const gentype &xyprod, gentype &diffis, int recalcdiffis, const vecInfo &xainfo, const vecInfo &xbinfo, const vecInfo &xcinfo, const vecInfo &xdinfo, const gentype &xanorm, const gentype &xbnorm, const gentype &xcnorm, const gentype &xdnorm, const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, const SparseVector<gentype> &xc, const SparseVector<gentype> &xd, int i, int j, int k, int l, int xdim, int resmode, int mlid, double xy00, double xy10, double xy11, double xy20, double xy21, double xy22, double xy30, double xy31, double xy32, double xy33, const Vector<int> *s) const;
    void K4unnorm(gentype &res, int q, const gentype &xyprod, gentype &diffis, int recalcdiffis, const vecInfo &xainfo, const vecInfo &xbinfo, const vecInfo &xcinfo, const vecInfo &xdinfo, const gentype &xanorm, const gentype &xbnorm, const gentype &xcnorm, const gentype &xdnorm, const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, const SparseVector<gentype> &xc, const SparseVector<gentype> &xd, int i, int j, int k, int l, int xdim, int resmode, int mlid, double xy00, double xy10, double xy11, double xy20, double xy21, double xy22, double xy30, double xy31, double xy32, double xy33, const Vector<int> *s) const;


    void Kmi(     gentype &res,        const gentype &xyprod,                                    Vector<const vecInfo *> &xinfo, Vector<const gentype *> &xnorm, Vector<const SparseVector<gentype> *> &x, Vector<int> &i, int xdim, int m, int resmode, int mlid, const Matrix<double> &xy, const Vector<int> *s, int indstart, int indend, int assumreal) const;
    void Km(      gentype &res, int q, const gentype &xyprod, gentype &diffis, int recalcdiffis, Vector<const vecInfo *> &xinfo, Vector<const gentype *> &xnorm, Vector<const SparseVector<gentype> *> &x, Vector<int> &i, int xdim, int m, int resmode, int mlid, const Matrix<double> &xy, const Vector<int> *s) const;
    void Kmunnorm(gentype &res, int q, const gentype &xyprod, gentype &diffis, int recalcdiffis, Vector<const vecInfo *> &xinfo, Vector<const gentype *> &xnorm, Vector<const SparseVector<gentype> *> &x, Vector<int> &i, int xdim, int m, int resmode, int mlid, const Matrix<double> &xy, const Vector<int> *s) const;


    void Kbase(gentype &res, int q, int typeis,
               const gentype &xyprod, const gentype &yxprod, const gentype &diffis,
               Vector<const SparseVector<gentype> *> &x,
               Vector<const vecInfo *> &xinfo,
               Vector<const gentype *> &xnorm,
               Vector<int> &i,
               int xdim, int m, int adensetype, int bdensetype, int resmode, int mlid) const;

    // Kernel normalisation constants (altdiff 2,3)

    double AltDiffNormConst(int xdim, int m, double gamma) const
    {
        return ( ( m == 0 ) || ( m == 2 ) || ( !xdim ) || ( isAltDiff() != 2 ) ) ? 1 : (pow(2.0/m,xdim/2.0)*pow(2.0/(NUMBASE_PI*gamma*gamma),(xdim/2.0)*((m/2.0)-1)));
    }

    // Derivative tree - first order
    //
    // in dKmdx: x is the first argument, "y" is the elementwise product of all other arguments

    void dKdaz(gentype &resda, gentype &resdz, int &minmaxind, const gentype &xyprod, const gentype &yxprod, const vecInfo &xinfo, const vecInfo &yinfo, const gentype &xnorm, const gentype &ynorm, const SparseVector<gentype> &x, const SparseVector<gentype> &y, int i, int j, int xdim, int mlid, int assumreal) const;

    void dKda(gentype &res, int &minmaxind, int q, const gentype &xyprod, const gentype &yxprod, gentype &diffis, int recalcdiffis, const vecInfo &xinfo, const vecInfo &yinfo, const gentype &xnorm, const gentype &ynorm, const SparseVector<gentype> &x, const SparseVector<gentype> &y, int i, int j, int xdim, int mlid) const;
    void dKdz(gentype &res, int &minmaxind, int q, const gentype &xyprod, const gentype &yxprod, gentype &diffis, int recalcdiffis, const vecInfo &xinfo, const vecInfo &yinfo, const gentype &xnorm, const gentype &ynorm, const SparseVector<gentype> &x, const SparseVector<gentype> &y, int i, int j, int xdim, int mlid) const;

    void dKunnormda(gentype &res, int &minmaxind, int q, const gentype &xyprod, const gentype &yxprod, gentype &diffis, int recalcdiffis, const vecInfo &xinfo, const vecInfo &yinfo, const gentype &xnorm, const gentype &ynorm, const SparseVector<gentype> &x, const SparseVector<gentype> &y, int i, int j, int xdim, int mlid) const;
    void dKunnormdz(gentype &res, int &minmaxind, int q, const gentype &xyprod, const gentype &yxprod, gentype &diffis, int recalcdiffis, const vecInfo &xinfo, const vecInfo &yinfo, const gentype &xnorm, const gentype &ynorm, const SparseVector<gentype> &x, const SparseVector<gentype> &y, int i, int j, int xdim, int mlid) const;


    void dKdaBase(gentype &res, int &minmaxind, int q, 
                  const gentype &xyprod, const gentype &yxprod, const gentype &diffis, 
                  Vector<const SparseVector<gentype> *> &x,
                  Vector<const vecInfo *> &xinfo,
                  Vector<const gentype *> &xnorm,
                  Vector<int> &i,
                  int xdim, int m, int mlid) const;

    void dKdzBase(gentype &res, int &minmaxind, int q, 
                  const gentype &xyprod, const gentype &yxprod, const gentype &diffis, 
                  Vector<const SparseVector<gentype> *> &x,
                  Vector<const vecInfo *> &xinfo,
                  Vector<const gentype *> &xnorm,
                  Vector<int> &i,
                  int xdim, int m, int mlid) const;


    // Kernel fall-through for 800-series kernels

    void kernel8xx(int q, gentype &res, int &minmaxind, int typeis,
                   const gentype &xyprod, const gentype &yxprod, const gentype &diffis,
                   int xdim, int resmode, int mlid) const;

    void kernel8xx(int q, gentype &res, int &minmaxind, int typeis,
                   const gentype &xyprod, const gentype &yxprod, const gentype &diffis,
                   const SparseVector<gentype> &xa,
                   const vecInfo &xainfo,
                   int ia,
                   int xdim, int resmode, int mlid) const;

    void kernel8xx(int q, gentype &res, int &minmaxind, int typeis,
                   const gentype &xyprod, const gentype &yxprod, const gentype &diffis,
                   const SparseVector<gentype> &xa, const SparseVector<gentype> &xb,
                   const vecInfo &xainfo, const vecInfo &xbinfo,
                   int ia, int ib,
                   int xdim, int resmode, int mlid) const;

    void kernel8xx(int q, gentype &res, int &minmaxind, int typeis,
                   const gentype &xyprod, const gentype &yxprod, const gentype &diffis,
                   const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, const SparseVector<gentype> &xc,
                   const vecInfo &xainfo, const vecInfo &xbinfo, const vecInfo &xcinfo,
                   int ia, int ib, int ic,
                   int xdim, int resmode, int mlid) const;

    void kernel8xx(int q, gentype &res, int &minmaxind, int typeis,
                   const gentype &xyprod, const gentype &yxprod, const gentype &diffis,
                   const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, const SparseVector<gentype> &xc, const SparseVector<gentype> &xd,
                   const vecInfo &xainfo, const vecInfo &xbinfo, const vecInfo &xcinfo, const vecInfo &xdinfo,
                   int ia, int ib, int ic, int id,
                   int xdim, int resmode, int mlid) const;

    void kernel8xx(int q, gentype &res, int &minmaxind, int typeis,
                   const gentype &xyprod, const gentype &yxprod, const gentype &diffis,
                   Vector<const SparseVector<gentype> *> &x,
                   Vector<const vecInfo *> &xinfo,
                   Vector<int> &i,
                   int xdim, int m, int resmode, int mlid) const;

    void kernel8xx(int q, double &res, int &minmaxind, int typeis,
                   double xyprod, double yxprod, double diffis,
                   int xdim, int resmode, int mlid) const;

    void kernel8xx(int q, double &res, int &minmaxind, int typeis,
                   double xyprod, double yxprod, double diffis,
                   const SparseVector<gentype> &xa,
                   const vecInfo &xainfo,
                   int ia,
                   int xdim, int resmode, int mlid) const;

    void kernel8xx(int q, double &res, int &minmaxind, int typeis,
                   double xyprod, double yxprod, double diffis,
                   const SparseVector<gentype> &xa, const SparseVector<gentype> &xb,
                   const vecInfo &xainfo, const vecInfo &xbinfo,
                   int ia, int ib,
                   int xdim, int resmode, int mlid) const;

    void kernel8xx(int q, double &res, int &minmaxind, int typeis,
                   double xyprod, double yxprod, double diffis,
                   const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, const SparseVector<gentype> &xc,
                   const vecInfo &xainfo, const vecInfo &xbinfo, const vecInfo &xcinfo,
                   int ia, int ib, int ic,
                   int xdim, int resmode, int mlid) const;

    void kernel8xx(int q, double &res, int &minmaxind, int typeis,
                   double xyprod, double yxprod, double diffis,
                   const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, const SparseVector<gentype> &xc, const SparseVector<gentype> &xd,
                   const vecInfo &xainfo, const vecInfo &xbinfo, const vecInfo &xcinfo, const vecInfo &xdinfo,
                   int ia, int ib, int ic, int id,
                   int xdim, int resmode, int mlid) const;

    void kernel8xx(int q, double &res, int &minmaxind, int typeis,
                   double xyprod, double yxprod, double diffis,
                   Vector<const SparseVector<gentype> *> &x,
                   Vector<const vecInfo *> &xinfo,
                   Vector<int> &i,
                   int xdim, int m, int resmode, int mlid) const;

    void dkernel8xx(int q, gentype &dxyprod, gentype &ddiffis, gentype &res, int &minmaxind, int typeis,
                   const gentype &xyprod, const gentype &yxprod, const gentype &diffis,
                   const SparseVector<gentype> &xa, const SparseVector<gentype> &xb,
                   const vecInfo &xainfo, const vecInfo &xbinfo,
                   int ia, int ib,
                   int xdim, int resmode, int mlid) const;

    void dkernel8xx(int q, double &dxyprod, double &ddiffis, double &res, int &minmaxind, int typeis,
                   double xyprod, double yxprod, double diffis,
                   const SparseVector<gentype> &xa, const SparseVector<gentype> &xb,
                   const vecInfo &xainfo, const vecInfo &xbinfo,
                   int ia, int ib,
                   int xdim, int resmode, int mlid) const;




    // Final destination inner products, where redirection occurs from if
    // redirction is turned on.
    //
    // inding: 0 - not indexed
    //         1 - indexed
    // conj: 0 - no conj
    //       1 - normal conj operation
    //       2 - reversed conj
    // scaling: 0 - no scale
    //          1 - left scale
    //          2 - right scale
    //          3 - left/right scale
    //
    // Return value: 0 if result is not an equation or distribution (uses isValEqn)
    //               nz otherwise (if res has type != gentype then result *not* set)

    int innerProductDiverted       (gentype &res, const SparseVector<gentype> &a, const SparseVector<gentype> &b, int xconsist = 0, int assumreal = 0) const;
    int innerProductDivertedRevConj(gentype &res, const gentype &xyres, const SparseVector<gentype> &a, const SparseVector<gentype> &b, int xconsist = 0, int assumreal = 0) const;

    int innerProductDiverted       (double &res, const SparseVector<gentype> &a, const SparseVector<gentype> &b, int xconsist = 0, int assumreal = 0) const;
    int innerProductDivertedRevConj(double &res, double xyres, const SparseVector<gentype> &, const SparseVector<gentype> &, int xconsist = 0, int assumreal = 0) const { (void) xconsist; (void) assumreal; res = xyres; return 0; }

    int oneProductDiverted  (       gentype &res, const SparseVector<gentype> &a, int xconsist = 0, int assumreal = 0) const;
    int twoProductDiverted  (       gentype &res, const SparseVector<gentype> &a, const SparseVector<gentype> &b, int xconsist = 0, int assumreal = 0) const;
    int threeProductDiverted(       gentype &res, const SparseVector<gentype> &a, const SparseVector<gentype> &b, const SparseVector<gentype> &c, int xconsist = 0, int assumreal = 0) const;
    int fourProductDiverted (       gentype &res, const SparseVector<gentype> &a, const SparseVector<gentype> &b, const SparseVector<gentype> &c, const SparseVector<gentype> &d, int xconsist = 0, int assumreal = 0) const;
    int mProductDiverted    (int m, gentype &res, const Vector<const SparseVector<gentype> *> &a, int xconsist = 0, int assumreal = 0) const;

    int oneProductDiverted  (       double &res, const SparseVector<gentype> &a, int xconsist = 0, int assumreal = 0) const;
    int twoProductDiverted  (       double &res, const SparseVector<gentype> &a, const SparseVector<gentype> &b, int xconsist = 0, int assumreal = 0) const;
    int threeProductDiverted(       double &res, const SparseVector<gentype> &a, const SparseVector<gentype> &b, const SparseVector<gentype> &c, int xconsist = 0, int assumreal = 0) const;
    int fourProductDiverted (       double &res, const SparseVector<gentype> &a, const SparseVector<gentype> &b, const SparseVector<gentype> &c, const SparseVector<gentype> &d, int xconsist = 0, int assumreal = 0) const;
    int mProductDiverted    (int m, double &res, const Vector<const SparseVector<gentype> *> &a, int xconsist = 0, int assumreal = 0) const;

    // Further in, deeper down

    void getOneProd  (gentype &res, const SparseVector<gentype> &xa, int inding, int scaling, int xconsist, int assumreal) const;
    void getTwoProd  (gentype &res, const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, int inding, int conj, int scaling, int xconsist, int assumreal) const;
    void getThreeProd(gentype &res, const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, const SparseVector<gentype> &xc, int inding, int scaling, int xconsist, int assumreal) const;
    void getFourProd (gentype &res, const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, const SparseVector<gentype> &xc, const SparseVector<gentype> &xd, int inding, int scaling, int xconsist, int assumreal) const;
    void getmProd    (gentype &res, const Vector<const SparseVector<gentype> *> &x, int inding, int scaling, int xconsist, int assumreal) const;

    double getOneProd  (const SparseVector<gentype> &xa, int inding, int scaling, int xconsist, int assumreal) const;
    double getTwoProd  (const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, int inding, int conj, int scaling, int xconsist, int assumreal) const;
    double getThreeProd(const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, const SparseVector<gentype> &xc, int inding, int scaling, int xconsist, int assumreal) const;
    double getFourProd (const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, const SparseVector<gentype> &xc, const SparseVector<gentype> &xd, int inding, int scaling, int xconsist, int assumreal) const;
    double getmProd    (const Vector<const SparseVector<gentype> *> &x, int inding, int scaling, int xconsist, int assumreal) const;

    void fixShiftProd(void);

    SparseVector<gentype> &preShiftScale(SparseVector<gentype> &res, const SparseVector<gentype> &x) const;

    // Note: diff0norm and diff1norm evaluate to zero in all cases, so we bypass them here

    void diff0norm(gentype &res, const gentype &xyprod) const { (void) xyprod; res = 0; }
    void diff1norm(gentype &res, const gentype &xyprod, const gentype &xanorm) const { (void) xyprod; (void) xanorm; res = 0; }
    void diff2norm(gentype &res, const gentype &xyprod, const gentype &xanorm, const gentype &xbnorm) const { res = xyprod; res *= -2.0; res += xanorm; setconj(res); res += xbnorm; setconj(res); }
    void diff3norm(gentype &res, const gentype &xyprod, const gentype &xanorm, const gentype &xbnorm, const gentype &xcnorm, double xy00, double xy10, double xy11, double xy20, double xy21, double xy22, const Vector<int> *s = nullptr) const;
    void diff4norm(gentype &res, const gentype &xyprod, const gentype &xanorm, const gentype &xbnorm, const gentype &xcnorm, const gentype &xdnorm, double xy00, double xy10, double xy11, double xy20, double xy21, double xy22, double xy30, double xy31, double xy32, double xy33, const Vector<int> *s = nullptr) const;
    void diffmnorm(int m, gentype &res, const gentype &xyprod, const Vector<const gentype *> &xanorm, const Matrix<double> &xy, const Vector<int> *s = nullptr) const;

    double diff0norm(double xyprod) const { (void) xyprod; return 0; }
    double diff1norm(double xyprod, double xanorm) const { (void) xyprod; (void) xanorm; return 0; }
    double diff2norm(double xyprod, double xanorm, double xbnorm) const { return xanorm+xbnorm-(2*xyprod); }
    double diff3norm(double xyprod, double xanorm, double xbnorm, double xcnorm, double xy00, double xy10, double xy11, double xy20, double xy21, double xy22, const Vector<int> *s = nullptr) const;
    double diff4norm(double xyprod, double xanorm, double xbnorm, double xcnorm, double xdnorm, double xy00, double xy10, double xy11, double xy20, double xy21, double xy22, double xy30, double xy31, double xy32, double xy33, const Vector<int> *s = nullptr) const;
    double diffmnorm(int m, double xyprod, const Vector<const double *> &xanorm, const Matrix<double> &xy, const Vector<int> *s = nullptr) const;

    void diff0norm(double &res, double xyprod) const { (void) xyprod; res = 0; }
    void diff1norm(double &res, double xyprod, double xanorm) const { (void) xyprod; (void) xanorm; res = 0; }
    void diff2norm(double &res, double xyprod, double xanorm, double xbnorm) const { res = xanorm+xbnorm-(2*xyprod); }
    void diff3norm(double &res, double xyprod, double xanorm, double xbnorm, double xcnorm, double xy00, double xy10, double xy11, double xy20, double xy21, double xy22, const Vector<int> *s = nullptr) const { res = diff3norm(xyprod,xanorm,xbnorm,xcnorm,xy00,xy10,xy11,xy20,xy21,xy22,s); }
    void diff4norm(double &res, double xyprod, double xanorm, double xbnorm, double xcnorm, double xdnorm, double xy00, double xy10, double xy11, double xy20, double xy21, double xy22, double xy30, double xy31, double xy32, double xy33, const Vector<int> *s = nullptr) const { res = diff4norm(xyprod,xanorm,xbnorm,xcnorm,xdnorm,xy00,xy10,xy11,xy20,xy21,xy22,xy30,xy31,xy32,xy33,s); }
    void diffmnorm(int m, double &res, double xyprod, const Vector<const double *> &xanorm, const Matrix<double> &xy, const Vector<int> *s = nullptr) const { res = diffmnorm(m,xyprod,xanorm,xy,s); }

    void diff0norm(gentype &res, double xyprod) const { (void) xyprod; res.force_double() = 0; }
    void diff1norm(gentype &res, double xyprod, double xanorm) const { (void) xyprod; (void) xanorm; res.force_double() = 0; }
    void diff2norm(gentype &res, double xyprod, double xanorm, double xbnorm) const { res.force_double() = xanorm+xbnorm-(2*xyprod); }
    void diff3norm(gentype &res, double xyprod, double xanorm, double xbnorm, double xcnorm, double xy00, double xy10, double xy11, double xy20, double xy21, double xy22, const Vector<int> *s = nullptr) const { diff3norm(res.force_double(),xyprod,xanorm,xbnorm,xcnorm,xy00,xy10,xy11,xy20,xy21,xy22,s); }
    void diff4norm(gentype &res, double xyprod, double xanorm, double xbnorm, double xcnorm, double xdnorm, double xy00, double xy10, double xy11, double xy20, double xy21, double xy22, double xy30, double xy31, double xy32, double xy33, const Vector<int> *s = nullptr) const { diff4norm(res.force_double(),xyprod,xanorm,xbnorm,xcnorm,xdnorm,xy00,xy10,xy11,xy20,xy21,xy22,xy30,xy31,xy32,xy33,s); }
    void diffmnorm(int m, gentype &res, double xyprod, const Vector<const double *> &xanorm, const Matrix<double> &xy, const Vector<int> *s = nullptr) const { diffmnorm(m,res.force_double(),xyprod,xanorm,xy,s); }

    // If optionCache set then dereferences this, otherwise resizes altres to m*m and fills it will <x,y> products.

    void fillXYMatrix(double &altxyr00, double &altxyr10, double &altxyr11, double &altxyr20, double &altxyr21, double &altxyr22, const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, const SparseVector<gentype> &xc, const vecInfo &xainfo, const vecInfo &xbinfo, const vecInfo &xcinfo, const double *xy00, const double *xy10, const double *xy11, const double *xy20, const double *xy21, const double *xy22, int doanyhow = 0, int assumreal = 0) const;
    void fillXYMatrix(double &altxyr00, double &altxyr10, double &altxyr11, double &altxyr20, double &altxyr21, double &altxyr22, double &altxyr30, double &altxyr31, double &altxyr32, double &altxyr33, const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, const SparseVector<gentype> &xc, const SparseVector<gentype> &xd, const vecInfo &xainfo, const vecInfo &xbinfo, const vecInfo &xcinfo, const vecInfo &xdinfo, const double *xy00, const double *xy10, const double *xy11, const double *xy20, const double *xy21, const double *xy22, const double *xy30, const double *xy31, const double *xy32, const double *xy33, int doanyhow = 0, int assumreal = 0) const;

    const Matrix<double> &fillXYMatrix(int m, Matrix<double> &altres, Vector<const SparseVector<gentype> *> &x, Vector<const vecInfo *> &xinfo, const Matrix<double> *optionCache = nullptr, int doanyhow = 0, int assumreal = 0) const;

    // Function to overwrite constants (integer and real) from source vectors

    Vector<int> combinedOverwriteSrc;

    mutable int backupisind; // don't worry that this is not initialised - it is
                             // always set when required.  Also no need to save this.
    mutable Vector<int> backupdIndexes;

    void processOverwrites(int q, const SparseVector<gentype> &x, const SparseVector<gentype> &y) const;
    void fixcombinedOverwriteSrc(void);
    void addinOverwriteInd(const SparseVector<gentype> &v) const;
    void addinOverwriteInd(const SparseVector<gentype> &x, const SparseVector<gentype> &y) const;
    void addinOverwriteInd(const SparseVector<gentype> &v, const SparseVector<gentype> &w, const SparseVector<gentype> &x) const;
    void addinOverwriteInd(const SparseVector<gentype> &v, const SparseVector<gentype> &w, const SparseVector<gentype> &x, const SparseVector<gentype> &y) const;
    void addinOverwriteInd(const Vector<const SparseVector<gentype> *> &a) const;
//    void addinOverwriteInd(const Vector<gentype> &x, const Vector<gentype> &y) const;
//    void addinOverwriteInd(const SparseVector<double> &x, const SparseVector<double> &y) const;
//    void addinOverwriteInd(const Vector<double> &x, const Vector<double> &y) const;
    void addinOverwriteInd(void) const;
    void removeOverwriteInd(void) const;

    int arexysimple(const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, const SparseVector<gentype> &xc, const SparseVector<gentype> &xd) const
    {
        if ( !arexysimple(xa,xb) )
        {
            return 0;
        }

        if ( !arexysimple(xa,xc) )
        {
            return 0;
        }

        if ( !arexysimple(xa,xd) )
        {
            return 0;
        }

        return 1;
    }

    int arexysimple(const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, const SparseVector<gentype> &xc) const
    {
        if ( !arexysimple(xa,xb) )
        {
            return 0;
        }

        if ( !arexysimple(xa,xc) )
        {
            return 0;
        }

        return 1;
    }

    int arexysimple(const SparseVector<gentype> &xa, const SparseVector<gentype> &xb) const
    {
        if ( ( xa.nindsize() == 0 ) && ( xb.nindsize() == 0 ) )
        {
            return 1;
        }

        if ( ( xa.nindsize() == 1 ) && ( xb.nindsize() == 1 ) )
        {
            if ( xa.ind(0) == xb.ind(0) )
            {
                return 1;
            }
        }

        return 0;
    }

    int arexysimple(const SparseVector<gentype> &x) const
    {
        if ( ( x.nindsize() == 0 ) || ( x.nindsize() == 1 ) )
        {
             return 1;
        }

        return 0;
    }

    int arexysimple(int m, const Vector<const SparseVector<gentype> *> &x) const
    {
        NiceAssert( m <= x.size() );

        if ( m > 1 )
        {
            int i = 0;

            for ( i = 1 ; i < m ; ++i )
            {
                if ( !arexysimple(*(x(0)),*(x(i))) )
                {
                    return 0;
                }
            }
        }

        return 1;
    }

    // The only relevant part of indres is the index vector

    void combind(SparseVector<gentype> &indres, const SparseVector<gentype> &x, const SparseVector<gentype> &y) const
    {
        indres.resize(0);

        if ( x.nindsize() )
        {
            int i;

            for ( i = 0 ; i < x.nindsize() ; ++i )
            {
                indres("&",x.ind(i)) = x.direcref(i);
            }
        }

        if ( y.nindsize() )
        {
            int i;

            for ( i = 0 ; i < y.nindsize() ; ++i )
            {
                indres("&",y.ind(i)) = y.direcref(i);
            }
        }
    }

    void combind(int m, SparseVector<gentype> &indres, const Vector<const SparseVector<gentype> *> &x) const
    {
        indres.resize(0);

        int i,j;

        if ( m )
        {
            for ( j = 0 ; j < m ; ++j )
            {
                if ( (*(x(j))).nindsize() )
                {
                    for ( i = 0 ; i < (*(x(j))).nindsize() ; ++i )
                    {
                        indres("&",(*(x(j))).ind(i)) = (*(x(j))).direcref(i);
                    }
                }
            }
        }
    }

    // Given the result of kernel evaluation, this function will attempt
    // to calculate xyprod and yxprod.  Returns 0 on success, nz on fail.

    int reverseEngK(gentype &res, const vecInfo &xinfo, const vecInfo &yinfo, const SparseVector<gentype> &x, const SparseVector<gentype> &y, double Kres) const;
    int reverseEngK(gentype &res, const vecInfo &xainfo, const vecInfo &xbinfo, const vecInfo &xcinfo, const vecInfo &xdinfo, const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, const SparseVector<gentype> &xc, const SparseVector<gentype> &xd, double Kres) const;
    int reverseEngK(int m, gentype &res, const Vector<const vecInfo *> &xinfo, const Vector<const SparseVector<gentype> *> &x, double Kres) const;

    int isKernelDerivativeEasy(void) const
    {
//        return !isProd() &&
//               !isIndex() &&
//               !isShifted() &&
//               !isScaled() &&
//               ( size() == 1 ) &&
//               !isNormalised(0) &&
//               ( kinf(0).numflagsset() <= 1 ) &&
//               ( ( kinf(0).numflagsset() == 0 ) || kinf(0).usesDiff || kinf(0).usesInner || kinf(0).usesMinDiff || kinf(0).usesMaxDiff );
        return !isProd() &&
               ( size() == 1 ) &&
               !isNormalised(0) &&
               ( kinf(0).numflagsset() <= 1 ) &&
               ( ( kinf(0).numflagsset() == 0 ) || kinf(0).usesDiff || kinf(0).usesInner || kinf(0).usesMinDiff || kinf(0).usesMaxDiff );
    }

    // Function to tell us if kerrnel index actually exists

    int iskern(int potind) const;

    // This function returns true if, despite redirected inner products, the
    // kernel will still require the actual vectors themselves.  Note that
    // evaluation may still throw an exception if overwrites must be processed
    // or pre-processing on vector basis is requested.

    int needExplicitVector(void) const
    {
        return kinf(0).usesVector || isProd();
    }

    // combine minmaxadd

    int combineminmaxind(int aminmaxind, int bminmaxind) const
    {
        if ( aminmaxind == -2 )
        {
            return ( bminmaxind == -2 ) ? -1 : bminmaxind;
        }

        if ( bminmaxind == -2 )
        {
            return ( aminmaxind == -2 ) ? -1 : aminmaxind;
        }

        if ( ( aminmaxind == -1 ) && ( bminmaxind == -1 ) )
        {
            return -1;
        }

        NiceThrow("Incompatible gradient indices error");

        return -3;
    }





    void fixhaslinconstr()
    {
        if ( sizeLinConstr() )
        {
            haslinconstr = false;

            int q;

            for ( q = 0 ; q < sizeLinConstr() ; ++q )
            {
                if ( !linGradOrd(q) )
                {
                    haslinconstr = true;
                    break;
                }
            }
        }

        else
        {
            haslinconstr = true;
        }

        return;
    }

    void fixlingradscaltsp(int i = -1)
    {
        int q;

        if ( i == -1 )
        {
            linGradScalTsp.resize(linGradScal.size());
        }

        for ( q = ( ( i >= 0 ) ? i : 0 ) ; q < ( ( i >= 0 ) ? (i+1) : (linGradScal.size()) ) ; ++q )
        {
            linGradScalTsp("&",q) = linGradScal(q);
            linGradScalTsp("&",q).transpose();
        }

        return;
    }







    // xisfast: -1 if unknown
    //          0  if kernel is not fast and full calculation is required
    //          1  if completely unchained kernel where all kernels are either inner-product or diff
    //          2  if completely chained kernel where kernel 0 is either inner-product or diff, and remaining kernels are inner-product (no splits allowed or magterms)
    //          3  if completely chained kernel where kernel 0 is kernel transfer, kernel 1 is either inner-product or diff, and remaining kernels are inner-product (no splits or magterms allowed)
    // xneedsInner: needs inner product to calculate
    // xneedsDiff:  needs inner product to calculate
    // xneedsNorm:  needs norms of vectors to calculate

    mutable int xisfast;
    mutable int xneedsInner;
    mutable int xneedsInnerm2;
    mutable int xneedsDiff;
    mutable int xneedsNorm;

    // needsInner:   returns 1 if inner (m) product is required in this kernel (-1 for all parts)
    // needsDiff:    returns 1 if diff  (m) product is required in this kernel (-1 for all parts)
    // needsMatDiff: returns 1 if diff  (m) product is required and matrix accelerated works
    //               returns 2 if diff  (m) product is required, matrix accel works, but we can get away with only pairwise parts.
    // needsNorm:    returns 1 if ubber (m) norm(s) is(are) required in this kernel (-1 for all parts)

    int needsMatDiff(int q = -1) const
    {
        if ( needsDiff(q) && isAltDiff() == 5 )
        {
            return -1;
        }

        return needsDiff(q) && ( ( isAltDiff() == 2   ) ||
                                 ( isAltDiff() == 102 ) || ( isAltDiff() == 103 ) || ( isAltDiff() == 104 ) ||
                                 ( isAltDiff() == 202 ) || ( isAltDiff() == 203 ) || ( isAltDiff() == 204 ) ||
                                 ( isAltDiff() == 300 )    );
    }

//ADDHERE
    int isFastKernelType(int ind) const
    {
        return ( ( cType(ind) == 0   ) ||
                 ( cType(ind) == 1   ) ||
                 ( cType(ind) == 2   ) ||
                 ( cType(ind) == 3   ) ||
                 ( cType(ind) == 4   ) ||
                 ( cType(ind) == 5   ) ||
                 ( cType(ind) == 7   ) ||
                 ( cType(ind) == 8   ) ||
                 ( cType(ind) == 9   ) ||
                 ( cType(ind) == 10  ) ||
                 ( cType(ind) == 11  ) ||
                 ( cType(ind) == 12  ) ||
                 ( cType(ind) == 13  ) ||
                 ( cType(ind) == 14  ) ||
                 ( cType(ind) == 15  ) ||
                 ( cType(ind) == 19  ) ||
                 ( cType(ind) == 23  ) ||
                 ( cType(ind) == 24  ) ||
                 ( cType(ind) == 25  ) ||
                 ( cType(ind) == 26  ) ||
                 ( cType(ind) == 27  ) ||
                 ( cType(ind) == 32  ) ||
                 ( cType(ind) == 33  ) ||
                 ( cType(ind) == 34  ) ||
                 ( cType(ind) == 38  ) ||
                 ( cType(ind) == 39  ) ||
                 ( cType(ind) == 42  ) ||
                 ( cType(ind) == 43  ) ||
                 ( cType(ind) == 44  ) ||
                 ( cType(ind) == 45  ) ||
                 ( cType(ind) == 46  ) ||
                 ( cType(ind) == 47  ) ||
                 ( cType(ind) == 49  ) ||
                 ( cType(ind) == 50  ) ||
                 ( cType(ind) == 51  ) ||
                 ( cType(ind) == 52  ) ||
                 ( cType(ind) == 53  ) ||
                 ( cType(ind) == 100 ) ||
                 ( cType(ind) == 103 ) ||
                 ( cType(ind) == 104 ) ||
                 ( cType(ind) == 106 ) ||
                 ( cType(ind) == 200 ) ||
                 ( cType(ind) == 203 ) ||
                 ( cType(ind) == 204 ) ||
                 ( cType(ind) == 206 )    );
    }

    int isfast(void) const
    {
        int res = xisfast;

        if ( xisfast == -1 )
        {
             res = isfastunsafe();
        }

        return res;
    }

    int needsInner(int q = -1, int m = 2) const
    {
        NiceAssert( q < size() );
        NiceAssert( q >= -1 );

        int res = ( m == 2 ) ? xneedsInnerm2 : xneedsInner;

        if ( q >= 0 )
        {
            res = kinf(q).usesInner || ( kinf(q).usesDiff && ( ( m == 2 ) || ( isAltDiff() <= 1 ) ) );
        }

        else if ( res == -1 )
        {
            res = needsInnerunsafe(m);
        }

        return res;
    }

    int needsDiff(int q = -1) const
    {
        NiceAssert( q < size() );
        NiceAssert( q >= -1 );

        int res = xneedsDiff;

        if ( q >= 0 )
        {
            res = kinf(q).usesDiff;
        }

        else if ( xneedsDiff == -1 )
        {
            res = needsDiffunsafe();
        }

        return res;
    }

    int needsNorm(int q = -1) const
    {
        NiceAssert( q < size() );
        NiceAssert( q >= -1 );

        int res = xneedsNorm;

        if ( q >= 0 )
        {
            res = needsDiff(q) || ( needsInner(q) && isMagTerm(q) );
        }

        else if ( xneedsNorm == -1 )
        {
            res = needsNormunsafe();
        }

        return res;
    }

    int isfastunsafe(void) const
    {
        // xisfast: -1 if unknown

        if ( xisfast == -1 )
        {
          //static svm_mutex eyelock; - assume mercer object is single-thread only
          //svm_mutex_lock(eyelock);

          if ( xisfast == -1 )
          {
            xisfast = 0;

            //          0  if kernel is not fast and full calculation is required

            retVector<int> tmpva;

//errstream() << "phantomxyzxyz 42: numSplits() = " << numSplits() << "\n";
//errstream() << "phantomxyzxyz 42: numMulSplits() = " << numMulSplits() << "\n";
//errstream() << "phantomxyzxyz 42: size() = " << size() << "\n";
//errstream() << "phantomxyzxyz 42: isnorm(size()-1) = " << isnorm(size()-1) << "\n";
//errstream() << "phantomxyzxyz 42: isAltDiff() = " << isAltDiff() << "\n";
//errstream() << "phantomxyzxyz 42: ischain(0,1,size()-2) = " << ischain(0,1,size()-2,tmpva) << "\n";
//errstream() << "phantomxyzxyz 42: cType(0) = " << cType(0) << "\n";
//errstream() << "phantomxyzxyz 42: big clause = " << ( ( !numSplits() && !numMulSplits() && 
//                      ( ( size() >= 1 ) && ( ( isnorm(size()-1) == 0 ) || ( isAltDiff() <= 99 ) ) 
//                                        && (    ( ( size() == 1 ) || ( ischain(0,1,size()-2,tmpva) == 1 ) ) 
//                                             && (    ( ( cType(0) >= 800 ) && ( cType(0) <= 829 ) ) ) ) ) ) ? 1 : 0 ) << "\n";

            if ( ( size() <= 1 ) || ( isnorm(0,1,size()-2,tmpva) == 0 ) )
            {
                if ( ( size() >= 1 ) && ( isnorm(size()-1) == 0 ) && ( ischain(0,1,size()-2,tmpva) == 0 ) )
                {
                    // Could be xisfast == 1
                    //          1  if completely unchained kernel where all kernels are either inner-product or diff

                    xisfast = 1;

                    int i;

                    for ( i = 0 ; i < size() ; ++i )
                    {
                        if ( !isFastKernelType(i) )
                        {
                            xisfast = 0;
                            break;
                        }
                    }
                }

                // Important: can't use else if here, as might be xisfast == 2

                if ( ( xisfast == 0 ) && !numSplits() && !numMulSplits() && 
                      ( ( size() >= 1 ) && ( ( isnorm(size()-1) == 0 ) || ( isAltDiff() <= 99 ) ) 
                                        && (    ( ( size() == 1 ) || ( ischain(0,1,size()-2,tmpva) == 1 ) ) 
                                             && ( cType(0) < 800 ) ) ) )
                {
                    // Could be xisfast == 2
                    //          2  if completely chained kernel where kernel 0 is either inner-product or diff, and remaining kernels are inner-product (no splits allowed or magterms)

                    xisfast = 2;

                    int i;

                    for ( i = 0 ; i < size() ; ++i )
                    {
                        if ( !isFastKernelType(i) || ( i && needsDiff(i) ) || isMagTerm(i) )
                        {
                            xisfast = 0;
                            break;
                        }
                    }
                }

                // Important: can't use else if here, as might be xisfast == 3

                if ( ( xisfast == 0 ) && !numSplits() && !numMulSplits() && 
                      ( ( size() >= 1 ) && ( ( isnorm(size()-1) == 0 ) || ( isAltDiff() <= 99 ) ) 
                                        && (    ( ( size() == 1 ) || ( ischain(0,1,size()-2,tmpva) == 1 ) ) 
                                             && (    ( ( cType(0) >= 800 ) && ( cType(0) <= 829 ) ) ) ) ) )
                {
                    // Could be xisfast == 3
                    //          3  if completely chained kernel where kernel 0 is kernel transfer not requiring inner product, norm or diff; kernel 1 is either inner-product or diff; and remaining kernels are inner-product (no splits or magterms allowed)

                    xisfast = 3;

                    int i;

                    for ( i = 0 ; i < size() ; ++i )
                    {
                        if ( ( i && ( !isFastKernelType(i) || ( ( i > 1 ) && needsDiff(i) ) ) ) || isMagTerm(i) )
                        {
                            xisfast = 0;
                            break;
                        }
                    }
                }
            }
          }

          //svm_mutex_unlock(eyelock);
        }

        return xisfast;
    }

    int needsInnerunsafe(int m) const
    {
        if ( ( xneedsInner == -1 ) || ( xneedsInnerm2 == -1 ) )
        {
            //static svm_mutex eyelock;
            //svm_mutex_lock(eyelock);

            int usesInner = 0;
            int usesDiff  = 0;

            if ( ( xneedsInner == -1 ) || ( xneedsInnerm2 == -1 ) )
            {
                if ( size() )
                {
                    int q;

                    for ( q = 0 ; q < size() ; ++q )
                    {
                        usesInner |= kinf(q).usesInner;
                        usesDiff  |= kinf(q).usesDiff;
                    }
                }

                if ( xneedsInner == -1 )
                {
                    xneedsInner = ( usesInner || ( usesDiff && ( isAltDiff() <= 1 ) ) ) ? 1 : 0;
                }

                if ( xneedsInnerm2 == -1 )
                {
                    xneedsInnerm2 = ( usesInner || usesDiff ) ? 1 : 0;
                }
            }

            //svm_mutex_unlock(eyelock);
        }

        return ( m == 2 ) ? xneedsInnerm2 : xneedsInner;
    }

    int needsDiffunsafe(void) const
    {
        if ( xneedsDiff == -1 )
        {
            //static svm_mutex eyelock;
            //svm_mutex_lock(eyelock);

            if ( xneedsDiff == -1 )
            {
                int usesDiff  = 0;

                if ( size() )
                {
                    int q;

                    for ( q = 0 ; q < size() ; ++q )
                    {
                        usesDiff  |= kinf(q).usesDiff;
                    }
                }

                xneedsDiff = usesDiff ? 1 : 0;
            }

            //svm_mutex_unlock(eyelock);
        }

        return xneedsDiff;
    }

    int needsNormunsafe(void) const
    {
        if ( xneedsNorm == -1 )
        {
            //static svm_mutex eyelock;
            //svm_mutex_lock(eyelock);

            if ( xneedsNorm == -1 )
            {
                int usesNorm = 0;

                if ( size() )
                {
                    int q;

                    for ( q = 0 ; q < size() ; ++q )
                    {
                        usesNorm |= ( needsDiff(q) || ( needsInner(q) && isMagTerm(q) ) );
                    }
                }

                xneedsNorm = usesNorm ? 1 : 0;
            }

            //svm_mutex_unlock(eyelock);
        }

        return xneedsNorm;
    }

    // Sampling functions for distribution kernels - return 0 if nothing is changed by sampling, >0 otherwise

    int subSample(SparseVector<SparseVector<gentype> > &subval, SparseVector<gentype> &x, vecInfo &xinfo) const;
    int subSample(SparseVector<SparseVector<gentype> > &subval, gentype &b) const;
    int subSample(SparseVector<SparseVector<gentype> > &subval, double  &b) const;

    // Various short-circuited kernels
    //
    // isSimpleKernel:           size 1, no normalisation, no chaining
    // isSimpleBasicKernel:      isSimpleKernel, and type   0-99  (NN kernel)
    // isSimpleNNKernel:         isSimpleKernel, and type 100-299 (NN kernel)
    // isSimpleDistKernel:       isSimpleKernel, and type 300-399 (-ve dist kernel)
    // isSimpleXferKernel:       isSimpleKernel, and type 800-899
    // isSimpleKernelChain:      size 2, no normalisation, chained, with kernel 0 being a kernel transfer

public:
    int isSimpleKernel     (void) const { return ( ( size() == 1 ) && !isNormalised() && !isChained() && !isSplit() && !isMulSplit() && !isMagTerm() ); }
    int isSimpleBasicKernel(void) const { return ( isSimpleKernel() && ( cType() >=   0 ) && ( cType() <  100 ) ); }
    int isSimpleNNKernel   (void) const { return ( isSimpleKernel() && ( cType() >= 100 ) && ( cType() <  300 ) ); }
    int isSimpleDistKernel (void) const { return ( isSimpleKernel() && ( cType() >= 300 ) && ( cType() <  400 ) ); }
    int isSimpleXferKernel (void) const { return ( isSimpleKernel() && ( ( cType() >= 800 ) && ( cType() <= 829 ) ) ); }
    int isSimpleKernelChain(void) const { return ( ( size() == 2 )  && ( ( cType() >= 800 ) && ( cType() <= 829 ) )
                                          && !isNormalised(0) && !isNormalised(1) && isChained(0) && !isSplit(0) && !isMulSplit(0) && !isMagTerm() ); }
    int isTrivialKernel    (int allowsymm = 0) const { const static gentype tempsampdist("[ ]"); return ( ( size() == 1 ) && !isFullNorm() && ( allowsymm || !isSymmSet() ) && !isProd() && !isIndex() && !isShifted() && !isScaled() && !isLeftPlain() &&
                                          !isRightPlain() && ( isAltDiff() == 1 ) && !isNormalised() && !isChained() && !isSplit() && !isMulSplit() && !isMagTerm() &&
                                          ( numSamples() == DEFAULT_NUMKERNSAMP ) && ( sampleDistribution() == tempsampdist ) && ( sampleIndices().size() == 0 ) &&
                                          ( cRealOverwrite().indsize() == 0 ) && ( cIntOverwrite().indsize() == 0 ) ); }
    int isVeryTrivialKernel(int allowsymm = 0) const { return ( ( !xdefindKey.size() || ( xdefindKey(xdefindKey.size()-1) == xdefindKey.size()-1 ) ) && isTrivialKernel(allowsymm) && ( !sizeLinConstr() ) ); }

    int isFastKernelSum  (void) const { return ( isfast() == 1 ); }
    int isFastKernelChain(void) const { return ( isfast() == 2 ); } // No splits or magnitude terms allowed
    int isFastKernelXfer (void) const { return ( isfast() == 3 ); } // No splits or magnitude terms allowed

    int isSimpleLinearKernel(void) const { return ( isSimpleKernel() && ( cType() == 1 ) ); }

private:
    Vector<gentype> &local_makeanRKHSVector(Vector<gentype> &res, const MercerKernel &kern, const SparseVector<gentype> &x, const gentype &a, int m) const;
    Vector<double> &local_makeanRKHSVector(Vector<double> &res, const MercerKernel &, const SparseVector<gentype> &, const gentype &, int) const;
};

inline std::ostream &operator<<(std::ostream &output, const MercerKernel &src)
{
    return src.printstream(output,0);
}

inline std::istream &operator>>(std::istream &input, MercerKernel &dest)
{
    return dest.inputstream(input);
}


inline void qswap(MercerKernel &a, MercerKernel &b)
{
    qswap(a.xdefindKey,b.xdefindKey);

    qswap(a.isprod              ,b.isprod              );
    qswap(a.isind               ,b.isind               );
    qswap(a.isfullnorm          ,b.isfullnorm          );
    qswap(a.issymmset           ,b.issymmset           );
    qswap(a.isshift             ,b.isshift             );
    qswap(a.leftplain           ,b.leftplain           );
    qswap(a.rightplain          ,b.rightplain          );
    qswap(a.isdiffalt           ,b.isdiffalt           );
    qswap(a.xproddepth          ,b.xproddepth          );
    qswap(a.enchurn             ,b.enchurn             );
    qswap(a.xsuggestXYcache     ,b.xsuggestXYcache     );
    qswap(a.xisIPdiffered       ,b.xisIPdiffered       );
    qswap(a.xnumSplits          ,b.xnumSplits          );
    qswap(a.xnumMulSplits       ,b.xnumMulSplits       );
    qswap(a.xdenseZeroPoint     ,b.xdenseZeroPoint     );

    qswap(a.dtype               ,b.dtype               );
    qswap(a.isnorm              ,b.isnorm              );
    qswap(a.ischain             ,b.ischain             );
    qswap(a.issplit             ,b.issplit             );
    qswap(a.mulsplit            ,b.mulsplit            );
    qswap(a.ismagterm           ,b.ismagterm           );
    qswap(a.xranktype           ,b.xranktype           );
    qswap(a.dIndexes            ,b.dIndexes            );
    qswap(a.kernflags           ,b.kernflags           );
    qswap(a.dRealConstants      ,b.dRealConstants      );
    qswap(a.dIntConstants       ,b.dIntConstants       );
    qswap(a.dRealConstantsLB    ,b.dRealConstantsLB    );
    qswap(a.dIntConstantsLB     ,b.dIntConstantsLB     );
    qswap(a.dRealConstantsUB    ,b.dRealConstantsUB    );
    qswap(a.dIntConstantsUB     ,b.dIntConstantsUB     );
    qswap(a.dRealOverwrite      ,b.dRealOverwrite      );
    qswap(a.dIntOverwrite       ,b.dIntOverwrite       );
    qswap(a.altcallback         ,b.altcallback         );
    qswap(a.randFeats           ,b.randFeats           );
    qswap(a.randFeatAngle       ,b.randFeatAngle       );
    qswap(a.randFeatReOnly      ,b.randFeatReOnly      );
    qswap(a.randFeatNoAngle     ,b.randFeatNoAngle     );

    qswap(a.dShift              ,b.dShift              );
    qswap(a.dScale              ,b.dScale              );
    qswap(a.dShiftProd          ,b.dShiftProd          );
    qswap(a.dShiftProdNoConj    ,b.dShiftProdNoConj    );
    qswap(a.dShiftProdRevConj   ,b.dShiftProdRevConj   );

    qswap(a.linGradOrd          ,b.linGradOrd          );
    qswap(a.linGradScal         ,b.linGradScal         );
    qswap(a.linGradScalTsp      ,b.linGradScalTsp      );
    qswap(a.haslinconstr        ,b.haslinconstr        );

    qswap(a.xnumsamples         ,b.xnumsamples         );
    qswap(a.xindsub             ,b.xindsub             );
    qswap(a.xsampdist           ,b.xsampdist           );

    qswap(a.combinedOverwriteSrc     ,b.combinedOverwriteSrc     );
    qswap(a.backupisind              ,b.backupisind              );
    qswap(a.backupdIndexes           ,b.backupdIndexes           );

    qswap((a.xisfast)      ,(b.xisfast)      );
    qswap((a.xneedsInner)  ,(b.xneedsInner)  );
    qswap((a.xneedsInnerm2),(b.xneedsInnerm2));
    qswap((a.xneedsDiff)   ,(b.xneedsDiff)   );
    qswap((a.xneedsNorm)   ,(b.xneedsNorm)   );
}





// ===================================================================================
// ===================================================================================
// ===================================================================================
// ===================================================================================
// ===================================================================================
// ===================================================================================
// ===================================================================================
// ===================================================================================
// ===================================================================================
// ===================================================================================
// ===================================================================================
// ===================================================================================
// ===================================================================================
// ===================================================================================
// ===================================================================================
// ===================================================================================
// ===================================================================================
// ===================================================================================
// ===================================================================================
// ===================================================================================
// ===================================================================================
// ===================================================================================
// ===================================================================================
// ===================================================================================
// ===================================================================================

// ====================================================================================








// ===================================================================================
// ===================================================================================
// ===================================================================================
// ===================================================================================
// ===================================================================================
// ===================================================================================
// ===================================================================================
// ===================================================================================
// ===================================================================================
// ===================================================================================
// ===================================================================================
// ===================================================================================
// ===================================================================================
// ===================================================================================
// ===================================================================================
// ===================================================================================
// ===================================================================================
// ===================================================================================
// ===================================================================================
// ===================================================================================
// ===================================================================================
// ===================================================================================
// ===================================================================================




























// ===================================================================================
// ===================================================================================
// ===================================================================================
// ===================================================================================
// ===================================================================================
// ===================================================================================
// ===================================================================================
// ===================================================================================
// ===================================================================================
// ===================================================================================
// ===================================================================================
// ===================================================================================
// ===================================================================================
// ===================================================================================
// ===================================================================================
// ===================================================================================
// ===================================================================================
// ===================================================================================
// ===================================================================================
// ===================================================================================
// ===================================================================================
// ===================================================================================
// ===================================================================================
// ===================================================================================
// ===================================================================================













// ========================================================================================
// ========================================================================================
// ========================================================================================
// ========================================================================================
// ========================================================================================
// ========================================================================================
// ========================================================================================
// ========================================================================================
// ========================================================================================
// ========================================================================================
// ========================================================================================
// ========================================================================================
// ========================================================================================
// ========================================================================================
// ========================================================================================
// ========================================================================================
// ========================================================================================
// ========================================================================================
// ========================================================================================


//FIXME: define dKKprodip, dKKprodd for inner product and diffis derivatives
//FIXME: then make dKdz, dKdz functions that follow same form as K to this level, then pass off into base afterwards (with throw if m > 2 and isaltdiff != 0 for simplicity)

template <class T>
int MercerKernel::KKpro(T &totres, const T &inxyprod, const T &diffis, int *i, int locindstart, int locindend, int xdim, int m, T &logres, const T *xprod) const
{
    NiceAssert( ( m == 2 ) || ( ismagterm == 0 ) );

    T xyprod = inxyprod;

    totres = xyprod;

    int logresvalid = 0;

    if ( !isFastKernelSum() && ( locindstart > locindend ) )
    {
        return 0;
    }

    else if ( locindstart == locindend )
    {
        // shortcut version.

        int ind = locindstart;
        {
            logresvalid = 0;

            T &res = totres;

            retVector<gentype> tmpva;

            const Vector<gentype> &r = dRealConstants(ind)(1,1,dRealConstants(ind).size()-1,tmpva);
            const Vector<int> &ic = dIntConstants(ind);

            int ktype = cType(ind);

            KKprosingle(res,xyprod,diffis,i,xdim,m,logres,xprod,ktype,logresvalid,cWeight(ind),r,ic,isMagTerm(ind));
        }
    }

    else
    {
        retVector<int>     tmpva;
        retVector<gentype> tmpvb;

        (void) tmpva;

        NiceAssert( isFastKernelSum() || ( ismagterm(locindstart,1,locindend,tmpva) == 0 ) );

        int ind = locindstart;

        // NB: xyprod is used at all layers for chained kernels
        //     diffis is used only at first layer for chained kernels

        Vector<T> allres(locindend-locindstart+1);

        Vector<T> allxygrad(locindend-locindstart+1);
        Vector<T> alldiffgrad(locindend-locindstart+1);

        for ( ; ind <= locindend ; ++ind )
        {
            logresvalid = 0; // only final in chain can set logres

            T &res = allres("&",ind-locindstart);

            const Vector<gentype> &r = dRealConstants(ind)(1,1,dRealConstants(ind).size()-1,tmpvb);
            const Vector<int> &ic = dIntConstants(ind);

            int ktype = cType(ind);

            KKprosingle(res,xyprod,diffis,i,xdim,m,logres,xprod,ktype,logresvalid,cWeight(ind),r,ic,isMagTerm(ind));

            if ( isFastKernelSum() && ( ind == locindstart ) )
            {
                totres = res;
            }

            else if ( isFastKernelSum() )
            {
                totres += res;
            }

            else if ( ( ind == locindend ) && ( ind == locindstart ) )
            {
                totres = res;
            }

            else if ( ind == locindstart )
            {
                xyprod = res;
            }

            else if ( ind < locindend )
            {
                xyprod = res;
            }

            else
            {
                totres = res;
            }

            //if ( isSplit(ind) )
            //{
            //    ++ind;
            //    break;
            //}
        }
    }

    return logresvalid && ( !isFastKernelSum() || ( locindstart == locindend ) );
}

template <class T>
int MercerKernel::QQpro(int m, Vector<T> &res, const SparseVector<gentype> &xa, const vecInfo &xainfo, int ia, int allowfinite, int xdim, int xconsist, int assumreal, int gradOrder, int xagradup, int indstart, int indend) const
{
    int dres = 0;
    int ind;

    retVector<gentype> tmpva;

    for ( ind = indstart ; ind <= indend ; ++ind )
    {
        if ( ind == indstart )
        {
            int ddres = QQprosingle(m,res,xa,xainfo,ia,allowfinite,xdim,xconsist,assumreal,gradOrder,xagradup,ind,cType(ind),cWeight(ind),dRealConstants(ind)(1,1,dRealConstants(ind).size()-1,tmpva),dIntConstants(ind));

            dres = ( ddres == -1 ) ? -1 : dres+ddres;
        }

        else
        {
            Vector<T> tmp;

            int ddres = QQprosingle(m,tmp,xa,xainfo,ia,allowfinite,xdim,xconsist,assumreal,gradOrder,xagradup,ind,cType(ind),cWeight(ind),dRealConstants(ind)(1,1,dRealConstants(ind).size()-1,tmpva),dIntConstants(ind));

            dres = ( ddres == -1 ) ? -1 : dres+ddres;

            res.append(res.size(),tmp);
        }
    }

    return dres;
}

//KERNELSHERE
//phantomx
//ADDHERE

template <class T>
int MercerKernel::KKprosingle(T &res, const T &xyprod, const T &diffis, int *i, int xdim, int m, T &logres, const T *xprod, int ktype, int &logresvalid, const gentype &weight, const Vector<gentype> &r, const Vector<int> &ic, int magterm) const
{
//FIXME see also KKprosinglediffiszero
    if ( magterm )
    {
        NiceAssert( m == 2 );

        res         = (const T &) weight;
        logres      = log((const T &) weight);
        logresvalid = 0;

        int retval = 0;
        int j,k;

        T altdiffis; altdiffis = 0.0;

        int *ix; MEMNEWARRAY(ix,int,m);
        T *xxprod; MEMNEWARRAY(xxprod,T,m);

        for ( j = 0 ; j < m ; ++j )
        {
            T resx;    resx    = 0.0;
            T logresx; logresx = 0.0;
            int logresxvalid = 0;

            for ( k = 0 ; k < m ; ++k )
            {
                ix[k]     = i[j];
                xxprod[k] = xprod[j];
            }

            int retvalx = KKprosingle(resx,xprod[j],altdiffis,ix,xdim,m,logresx,xxprod,ktype,logresxvalid,1.0_gent,r,ic,0);

            res         *= resx;
            logres      += logresx;
            logresvalid *= logresxvalid;

            retval += retvalx;
        }

        MEMDELARRAY(ix);
        MEMDELARRAY(xxprod);

        return retval;
    }

    res = 0.0;

    int retval = 0;

    switch ( ktype )
    {
        case 0:
        {
            // K = r1

            res = r(1);

            break;
        }

        case 1:
        {
            // K = z/(r0.r0)

            res = xyprod;
            scaldiv(res,r(0));
            scaldiv(res,r(0));

            break;
        }

        case 2:
        {
            // K = ( r1 + z/(r0.r0) )^i0

            res = xyprod;
            scaldiv(res,r(0));
            scaldiv(res,r(0));
            scaladd(res,r(1));
            raiseto(res,ic(0));

            break;
        }

        case 3:
        {
            // K = exp(-d/(2.r0.r0)-r1)

            res  = diffis;
            res *= -0.5;
            scaldiv(res,r(0));
            scaldiv(res,r(0));
            scalsub(res,r(1));
            res += log(AltDiffNormConst(xdim,m,r(0)));

            logres      = res;
            logresvalid = 1;

            OP_exp(res);

            break;
        }

        case 4:
        {
            // K = exp(-sqrt(d)/r0)
            //
            // At d=0: dK = 0, d2K = 0

            T tmp(diffis);

            OP_sqrt(tmp);

            res = tmp;
            setnegate(res);
            scaldiv(res,r(0));
            scalsub(res,r(1));

            logres      = res;
            logresvalid = 1;

            OP_exp(res);

            break;
        }

        case 5:
        {
            // K = exp(-sqrt(d)^r1/(r1*r0^r1))
            //
            // At d=0, if r1 < 2: dK = 0, d2K = 0

            T tmpb = pow(sqrt(diffis),(T) r(1));
            T tmpc = pow((T) r(0),(T) r(1));

            res  = tmpb;
            res /= tmpc;
            scaldiv(res,r(1));
            setnegate(res);
            scalsub(res,r(2));

            logres      = res;
            logresvalid = 1;

            OP_exp(res);

            break;
        }

        case 7:
        {
            // K = tanh( z/(r0.r0) + r1 )

            res = xyprod;
            scaldiv(res,r(0));
            scaldiv(res,r(0));
            scaladd(res,r(1));
            OP_tanh(res);

            break;
        }

        case 8:
        {
            // K = ( 1 + d/(2*r0*r0*r1) )^(-r1)

            //OLD     8  | Rational quadratic     | 1 - d/(d+r0)
            //OLD     8  | Rational quadratic     | -1/(d+r0) + d/(d+r0)^2 = -K(x,y)/(d+r0)
            //OLD     8  | Rational quadratic     | K(x,y)/((d+r0)^2) - K(x,y)/((d+r0)^2) = 0

            T tmp;

            tmp  = diffis;
            tmp *= 0.5;
            scaldiv(tmp,r(0));
            scaldiv(tmp,r(0));
            scaldiv(tmp,r(1));
            tmp += 1.0;

            res = pow(tmp,-((T) r(1)));

//OLD            res = diffis;
//OLD            scaldiv(res,(diffis+r(0)));
//OLD            setnegate(res);
//OLD            res += 1.0;
//OLD
//OLD            xygrad = 0.0;
//OLD
//OLD            diffgrad = res;
//OLD            setnegate(diffgrad);
//OLD            scaldiv(res,(diffis+r(0)));

            break;
        }

        case 9:
        {
            // K = sqrt( d/(r0.r0) + r1^2 )
            //
            // if d/(r0.r0) + r1^2 = 0 then dk,d2K = 0

            res = diffis;
            scaldiv(res,r(0));
            scaldiv(res,r(0));
            scaladd(res,r(1),r(1));
            OP_sqrt(res);

            break;
        }

        case 10:
        {
            // K = 1/sqrt( d/(r0.r0) + r1^2 )
            //
            // Ill-defined as d + r1^2 -> 0

            res = diffis;
            scaldiv(res,r(0));
            scaldiv(res,r(0));
            scaladd(res,r(1),r(1));
            OP_sqrt(res);
            OP_einv(res);

            break;
        }

        case 11:
        {
            // K = 2/pi * arccos(-sqrt(d)/r0) - 2/pi * sqrt(d)/r0 * sqrt(1 - d/r0^2)

            T tempres(diffis);
            OP_sqrt(tempres);
            scaldiv(tempres,r(0));
            tempres *= -1.0;

            T tempsq(tempres);
            tempsq *= tempsq;
            tempsq *= -1.0;
            tempsq += 1.0;
            OP_sqrt(tempsq);

            if ( (double) abs2(tempres) < 1.0 )
            {
                // K = 2/pi * arccos(-sqrt(d)/r0) - 2/pi * sqrt(d)/r0 * sqrt(1 - d/r0^2)

                res  = tempsq;
                res *= tempres;
                res += acos(tempres);
                res *= NUMBASE_2ONPI;
            }

            break;
        }

        case 12:
        {
            // K = 1 - 3/2 * sqrt(d)/r0 + 1/2 * sqrt(d)^3/r0^3

            T tempres(diffis);
            OP_sqrt(tempres);
            scaldiv(tempres,r(0));

            // K = 1 - 3/2 * sqrt(d)/r0 + 1/2 * sqrt(d)^3/r0^3

            res = tempres;
            res *= tempres;
            res *= tempres;
            res /= 3.0;
            res -= tempres;
            res /= 2.0;
            res *= 3.0;
            res += 1.0;

            //res = tempres;
            //res *= tempres;
            //res *= tempres;
            //res /= 2.0;
            //res *= 0.6666666666666666666666;
            //res -= tempres;
            //res /= 0.6666666666666666666666;
            //res += 1.0;

            break;
        }

        case 13:
        {
            // K = sinc(sqrt(d)/r0)
            //
            // if d = 0 then dK,d2K = 0

            T tmp(diffis);

            OP_sqrt(tmp);

            T tmpb(tmp);

            scaldiv(tmpb,r(0));

            res = tmpb;
            OP_sinc(res);

            break;
        }

        case 14:
        {
            // K = -sqrt(d)^r1
            //
            // if d = 0 then dK,d2K = 0

            res  = diffis;
            scaldiv(res,r(0));
            scaldiv(res,r(0));
            OP_sqrt(res);
            res  = pow(res,(T) r(1));
            res *= -1.0;

            break;
        }

        case 15:
        {
            // K = -log(sqrt(d)^r1 + 1)

            T tmpa(diffis);

            scaldiv(tmpa,r(0));
            scaldiv(tmpa,r(0));

            OP_sqrt(tmpa);

            T tmpb;

            tmpb = pow(tmpa,(T) r(1));
            tmpb += 1.0;

            res = tmpb;
            OP_log(res);
            setnegate(res);

            break;
        }

        case 19:
        {
            // K = 1/(1+(d/(r0.r0)))

            res = diffis;
            scaldiv(res,r(0));
            scaldiv(res,r(0));
            res += 1.0;
            OP_einv(res);

            break;
        }

        case 23:
        {
            // K = 1/(1+(sqrt(d)/r0)^r1)

            T tmp(diffis);

            OP_sqrt(tmp);
            scaldiv(tmp,r(0));

            res  = pow(tmp,(T) r(1));
            res += 1.0;
            OP_einv(res);

            break;
        }

        case 24:
        {
            // K = (1-((z/(r0.r0))^i0))/(1-(z/(r0.r0)))
            //
            // Ill-defined at z = 1

            T zsc(xyprod);

            scaldiv(zsc,r(0));
            scaldiv(zsc,r(0));

            if ( ( (double) abs2(zsc) > BADZEROTOL ) || ( ic(0) == 0 ) )
            {
                T tmp = zsc;

                raiseto(tmp,ic(0));

                res  = 1.0;
                res -= tmp;
                res /= (1.0-zsc);
            }

            break;
        }

        case 25:
        {
            // K = pi.cosh(pi-(sqrt(d)/r0))

            T tmp(diffis);

            OP_sqrt(tmp);

            res  = tmp;
            scaldiv(res,r(0));
            res -= NUMBASE_PI;
            res *= -1.0;
            OP_cosh(res);
            res *= NUMBASE_PI;

            break;
        }

        case 26:
        {
            // K = ((d/r0)^(r1+0.5))

            res  = diffis;
            scaldiv(res,r(0));
            res  = pow(res,((T) r(1))+0.5);

            break;
        }

        case 27:
        {
            // K = ((d/r0)^r1).ln(sqrt(d/r0))

            T scalres(diffis);

            scaldiv(scalres,r(0));
            OP_sqrt(scalres);

            T tempres(scalres);

            OP_log(tempres);

            scalres = pow(scalres,(T) r(1));

            res  = scalres;
            res *= tempres;

            break;
        }

        case 32:
        {
            // K = r1 if i == j >= 0, 0 otherwise

            if ( m )
            {
                if ( i[0] >= 0 )
                {
                    int j;

                    for ( j = 0 ; j < m ; ++j )
                    {
                        if ( i[0] != i[j] )
                        {
                            break;
                        }
                    }

                    if ( j == m )
                    {
                        res = r(1);
                    }
                }
            }

            break;
        }

        case 33:
        {
            // K = 1/(2.r0) ( 1 if real(sqrt(d)) < r0, 0 otherwise )

            //if ( real(sqrt(diffis)-r(0)) < zerogentype() )
            if ( real(sqrt(diffis)-r(0)) < 0.0_gent )
            {
                res = 0.5/r(0);
            }

            break;
        }

        case 34:
        {
            // K = (1-sqrt(d)/r0)/r0 if real(sqrt(d)) < r0, 0 otherwise )

            T tempres(diffis);
            OP_sqrt(tempres);
            scaldiv(tempres,r(0));

            if ( (double) real(tempres-1.0) < 0.0 )
            {
                res  = 1.0;
                res -= tempres;
                scaldiv(res,r(0));
            }

            break;
        }

        case 38:
        {
            // K = exp(-sqrt(d)/r0)

            T tempres(diffis);
            OP_sqrt(tempres);
            scaldiv(tempres,r(0));
            tempres *= -1.0;

            res = tempres;

            logres      = res;
            logresvalid = 1;

            OP_exp(res);

            break;
        }

        case 39:
        {
            // K = (1+((sqrt(3)/r0).sqrt(d))) . exp(-(sqrt(3)/r0).sqrt(d))

            T tempres(diffis);
            OP_sqrt(tempres);
            scaldiv(tempres,r(0));
            tempres *= sqrt(3.0);

            T expres(tempres);
            expres *= -1.0;
            OP_exp(expres);

            res  = tempres;
            res += 1;
            res *= expres;

            break;
        }

        case 42:
        {
            // K = agd(z/(r0.r0))

            T scalres = diffis;
            scaldiv(scalres,r(0));
            scaldiv(scalres,r(0));

            T scz = scalres;
            OP_sec(scz);
            scz *= scz;

            T taz = scalres;
            OP_tan(taz);

            res = scalres;
            OP_agd(res);

            break;
        }

        case 43:
        {
            // K = log((1+z/(r0.r0))/(1-z/(r0.r0)))

            T tempa = xyprod;

            tempa  = xyprod;
            scaldiv(tempa,r(0));
            scaldiv(tempa,r(0));

            T tempb = tempa;

            tempa += 1.0;
            tempb -= 1.0;

            res  = tempa;
            res /= tempb;
            OP_log(res);

            break;
        }

        case 44:
        {
            // K = exp(z/(r0.r0)-r1)

            res = xyprod;
            scaldiv(res,r(0));
            scaldiv(res,r(0));
            scalsub(res,r(1));

            logres      = res;
            logresvalid = 1;

            OP_exp(res);

            break;
        }

        case 45:
        {
            // K = sinh(z/(r0.r0))

            res = xyprod;
            scaldiv(res,r(0));
            scaldiv(res,r(0));
            OP_sinh(res);

            break;
        }

        case 46:
        {
            // K = cosh(z/(r0.r0))

            res = xyprod;
            scaldiv(res,r(0));
            scaldiv(res,r(0));
            OP_cosh(res);

            break;
        }

        case 47:
        {
            // K = sinc(sqrt(d)/r0).cos(2*pi*sqrt(d)/(r0.r1))
            //
            // if d = 0 then dK,d2K = 0

            T tmp(diffis);

            OP_sqrt(tmp);

            T tmpb(tmp);

            scaldiv(tmpb,r(0));

            res = tmpb;
            OP_sinc(res);

            T tmpc;

            tmpc = tmpb;
            tmpc *= (2*NUMBASE_PI);
            scaldiv(tmpc,r(1));
            OP_cos(tmpc);

            res *= tmpc;

            break;
        }

        case 49:
        {
            // K = exp(-d/(2.r0.r0)-r1)

            T tmp;

            tmp  = diffis;
            tmp *= -0.5;
            scaldiv(tmp,r(0));
            scaldiv(tmp,r(0));
            scalsub(tmp,r(1));
            tmp += log(AltDiffNormConst(xdim,m,r(0)));
            OP_exp(tmp);
            scalmul(tmp,r(2));
            tmp -= 1.0;

            res  = r(2);
            res -= 1.0;
            scaldiv(res,tmp);

            break;
        }

        case 50:
        {
            // K = pi - arccos(z)

            res = xyprod;
            scaldiv(res,r(0));
            scaldiv(res,r(0));
            OP_acos(res);
            res *= -1.0;
            res += NUMBASE_PI;

            break;
        }

        case 51:
        {
            // K = 1 / ( 2 - z/(r0.r0) )

            res = xyprod;
            scaldiv(res,r(0));
            scaldiv(res,r(0));
            res *= -1.0;
            res += 2.0;
            OP_einv(res);

            break;
        }

        case 52:
        {
            // K = sqrt(a).sqrt(b)/(r0.r0)

            res = 1.0;

            for ( int j = 0 ; j < m ; ++j )
            {
                res *= xprod[j];
            }

            T oneonm(1.0/m);
            res = pow(res,oneonm);
            scaldiv(res,r(0));
            scaldiv(res,r(0));

            break;
        }

        case 53:
        {
            // K = (1-(1-sqrt(a)^r1)^r2).(1-(1-sqrt(b)^r1)^r2)/(r0.r0)

            T oneonm(1.0/m);

            res = 1.0;

            for ( int j = 0 ; j < m ; ++j )
            {
                T tempres(xprod[j]);

                tempres = pow(tempres,oneonm);

                tempres = pow(tempres,(T) r(1));
                tempres *= -1.0;
                tempres += 1.0;
                tempres = pow(tempres,(T) r(2));
                tempres *= -1.0;
                tempres += 1.0;

                res *= tempres;
            }

            scaldiv(res,r(0));
            scaldiv(res,r(0));

            break;
        }

        case 100:
        {
            // K = z/(r0.r0)

            res = xyprod;
            scaldiv(res,r(0));
            scaldiv(res,r(0));

            break;
        }

        case 103:
        {
            // K = 0 if real(z) < 0, 1 otherwise

            const static T zgt(0.0);

            if ( xyprod < zgt )
            {
                res = 0.0;
            }

            else
            {
                res = 1.0;
            }

            break;
        }

        case 104:
        {
            // K = 0 if real(z) < 0, z/(r0*r0) otherwise

            const static T zgt(0.0);

            if ( xyprod < zgt )
            {
                res = 0.0;
            }

            else
            {
                res = xyprod;
                scaldiv(res,r(0));
                scaldiv(res,r(0));
            }

            break;
        }

        case 106:
        {
            // K = r1*z/(r0*r0) if real(z) < 0, z/(r0*r0) otherwise

            const static T zgt(0.0);

            res = xyprod;
            scaldiv(res,r(0));
            scaldiv(res,r(0));

            if ( xyprod < zgt )
            {
                scalmul(res,r(1));
            }

            break;
        }

        case 200:
        {
            // K = z/(r0.r0) - 1

            res = xyprod;
            scaldiv(res,r(0));
            scaldiv(res,r(0));
            res -= 1.0;

            break;
        }

        case 203:
        {
            // K = -1 if real(z) < 0, 1 otherwise

            const static T zgt(0.0);

            if ( xyprod < zgt )
            {
                res = -1.0;
            }

            else
            {
                res = 1.0;
            }

            break;
        }

        case 204:
        {
            // K = 0 if real(z) < 0, z/(r0*r0) otherwise    - 1

            const static T zgt(0.0);

            if ( xyprod < zgt )
            {
                res = -1.0;
            }

            else
            {
                res = xyprod;
                scaldiv(res,r(0));
                scaldiv(res,r(0));
                res -= 1.0;
            }

            break;
        }

        case 206:
        {
            // K = r1*z/(r0*r0) if real(z) < 0, z/(r0*r0) otherwise

            const static T zgt(0.0);

            res = xyprod;
            scaldiv(res,r(0));
            scaldiv(res,r(0));

            if ( xyprod < zgt )
            {
                scalmul(res,r(1));
            }

            res -= 1.0;

            break;
        }

        default:
        {
            NiceThrow("fee fi fo fum");

            retval = 1;
            break;
        }
    }

    res    *= (const T &) weight;
    logres += log((const T &) weight);

    return retval;
}

template <class T>
int MercerKernel::KKprosinglediffiszero(T &res, const T &xyprod, int ia, int ib, const T &xxprod, const T &yyprod, int ktype, const gentype &weight, const Vector<gentype> &r, const Vector<int> &ic) const
{
// See KKprosingle
    res = 0.0;

    int retval = 0;

    switch ( ktype )
    {
        case 0:
        case 9:
        {
            // 0: K = r1
            // 9: K = sqrt( d/(r0.r0) + r1^2 )
            //    K = r1

            res = r(1);

            break;
        }

        case 3:
        case 4:
        {
            // 3: K = exp(-d/(2.r0.r0)-r1)
            //    K = exp(-r1)
            // 4: K = exp(-sqrt(d)/r0 - r1)
            //    K = exp(-r1)

            res = -r(1);

            OP_exp(res);

            break;
        }

        case 8:
        case 11:
        case 12:
        case 13:
        case 19:
        case 23:
        case 38:
        case 39:
        case 47:
        {
            // 8:  K = ( 1 + d/(2*r0*r0*r1) )^(-r1)
            //     K = 1
            // 11: K = 2/pi * arccos(-sqrt(d)/r0) - 2/pi * sqrt(d)/r0 * sqrt(1 - d/r0^2)
            //     K = 2/pi * arccos(0)
            //     K = 2/pi * pi/2
            //     K = 1
            // 12: K = 1 - 3/2 * sqrt(d)/r0 + 1/2 * sqrt(d)^3/r0^3
            //     K = 1
            // 13: K = sinc(sqrt(d)/r0)
            //     K = 1
            // 19: K = 1/(1+(d/(r0.r0)))
            //     K = 1
            // 23: K = 1/(1+(sqrt(d)/r0)^r1)
            //     K = 1
            // 38: K = exp(-sqrt(d)/r0)
            //     K = exp(0) = 1
            // 39: K = (1+((sqrt(3)/r0).sqrt(d))) . exp(-(sqrt(3)/r0).sqrt(d))
            //     K = 1
            // 47: K = sinc(sqrt(d)/r0).cos(2*pi*sqrt(d)/(r0.r1))
            //     K = 1

            res = 1.0;

            break;
        }

        case 14:
        case 15:
        case 26:
        case 27:
        case 42:
        {
            // 14: K = -sqrt(d)^r1
            //     K = 0
            // 15: K = -log(sqrt(d)^r1 + 1)
            //     K = 0
            // 26: K = ((d/r0)^(r1+0.5))
            //     K = 0
            // 27: K = ((d/r0)^r1).ln(sqrt(d/r0)) (0 for d=0)
            //     K = 0
            // 42: K = agd(d/(r0.r0))
            //     K = 0

            break;
        }




        case 1:
        {
            // K = z/(r0.r0)

            res = xyprod;
            scaldiv(res,r(0));
            scaldiv(res,r(0));

            break;
        }

        case 2:
        {
            // K = ( r1 + z/(r0.r0) )^i0

            res = xyprod;
            scaldiv(res,r(0));
            scaldiv(res,r(0));
            scaladd(res,r(1));
            raiseto(res,ic(0));

            break;
        }

        case 5:
        {
            // K = exp(-sqrt(d)^r1/(r1*r0^r1) - r2)
            // K = exp(-r2)

            res = -r(2);

            OP_exp(res);

            break;
        }

        case 7:
        {
            // K = tanh( z/(r0.r0) + r1 )

            res = xyprod;
            scaldiv(res,r(0));
            scaldiv(res,r(0));
            scaladd(res,r(1));
            OP_tanh(res);

            break;
        }

        case 10:
        {
            // K = 1/sqrt( d/(r0.r0) + r1^2 )
            // K = 1/r1

            res = r(1);

            OP_einv(res);

            break;
        }

        case 24:
        {
            // K = (1-((z/(r0.r0))^i0))/(1-(z/(r0.r0)))
            //
            // Ill-defined at z = 1

            T zsc(xyprod);

            scaldiv(zsc,r(0));
            scaldiv(zsc,r(0));

            if ( ( (double) abs2(zsc) > BADZEROTOL ) || ( ic(0) == 0 ) )
            {
                T tmp = zsc;

                raiseto(tmp,ic(0));

                res  = 1.0;
                res -= tmp;
                res /= (1.0-zsc);
            }

            break;
        }

        case 25:
        {
            // K = pi.cosh(pi-(sqrt(d)/r0))
            // K = pi.cosh(pi)

            res = 36.4171952511;

            break;
        }

        case 32:
        {
            // K = r1 if i == j >= 0, 0 otherwise

            if ( ( ia == ib ) && ( ia >= 0 ) )
            {
                res = r(1);
            }

            break;
        }

        case 33:
        {
            // K = 1/(2.r0) ( 1 if real(sqrt(d)) < r0, 0 otherwise )

            res = 0.5/r(0);

            break;
        }

        case 34:
        {
            // K = (1-sqrt(d)/r0)/r0 if real(sqrt(d)) < r0, 0 otherwise )
            // K = 1/r0

            res = r(0);

            OP_einv(res);

            break;
        }

        case 43:
        {
            // K = log((1+z/(r0.r0))/(1-z/(r0.r0)))

            T tempa = xyprod;

            tempa  = xyprod;
            scaldiv(tempa,r(0));
            scaldiv(tempa,r(0));

            T tempb = tempa;

            tempa += 1.0;
            tempb -= 1.0;

            res  = tempa;
            res /= tempb;
            OP_log(res);

            break;
        }

        case 44:
        {
            // K = exp(z/(r0.r0)-r1)

            res = xyprod;
            scaldiv(res,r(0));
            scaldiv(res,r(0));
            scalsub(res,r(1));

            OP_exp(res);

            break;
        }

        case 45:
        {
            // K = sinh(z/(r0.r0))

            res = xyprod;
            scaldiv(res,r(0));
            scaldiv(res,r(0));
            OP_sinh(res);

            break;
        }

        case 46:
        {
            // K = cosh(z/(r0.r0))

            res = xyprod;
            scaldiv(res,r(0));
            scaldiv(res,r(0));
            OP_cosh(res);

            break;
        }

        case 49:
        {
            // K = exp(-d/(2.r0.r0)-r1)
            // K = exp(-r1)

            res = -r(1);

            OP_exp(res);

            break;
        }

        case 50:
        {
            // K = pi - arccos(z)

            res = xyprod;
            scaldiv(res,r(0));
            scaldiv(res,r(0));
            OP_acos(res);
            res *= -1.0;
            res += NUMBASE_PI;

            break;
        }

        case 51:
        {
            // K = 1 / ( 2 - z/(r0.r0) )

            res = xyprod;
            scaldiv(res,r(0));
            scaldiv(res,r(0));
            res *= -1.0;
            res += 2.0;
            OP_einv(res);

            break;
        }

        case 52:
        {
            // K = sqrt(a).sqrt(b)/(r0.r0)

            res  = xxprod;
            res *= yyprod;
            OP_sqrt(res);
            scaldiv(res,r(0));
            scaldiv(res,r(0));

            break;
        }

        case 53:
        {
            // K = (1-(1-sqrt(a)^r1)^r2).(1-(1-sqrt(b)^r1)^r2)/(r0.r0)

            T oneonm(1.0/2);

            res = 1.0;

            {
                T tempres(xxprod);

                tempres = pow(tempres,oneonm);

                tempres = pow(tempres,(T) r(1));
                tempres *= -1.0;
                tempres += 1.0;
                tempres = pow(tempres,(T) r(2));
                tempres *= -1.0;
                tempres += 1.0;

                res *= tempres;
            }

            {
                T tempres(yyprod);

                tempres = pow(tempres,oneonm);

                tempres = pow(tempres,(T) r(1));
                tempres *= -1.0;
                tempres += 1.0;
                tempres = pow(tempres,(T) r(2));
                tempres *= -1.0;
                tempres += 1.0;

                res *= tempres;
            }

            scaldiv(res,r(0));
            scaldiv(res,r(0));

            break;
        }

        case 100:
        {
            // K = z/(r0.r0)

            res = xyprod;
            scaldiv(res,r(0));
            scaldiv(res,r(0));

            break;
        }

        case 103:
        {
            // K = 0 if real(z) < 0, 1 otherwise

            const static T zgt(0.0);

            if ( xyprod < zgt )
            {
                res = 0.0;
            }

            else
            {
                res = 1.0;
            }

            break;
        }

        case 104:
        {
            // K = 0 if real(z) < 0, z/(r0*r0) otherwise

            const static T zgt(0.0);

            if ( xyprod < zgt )
            {
                res = 0.0;
            }

            else
            {
                res = xyprod;
                scaldiv(res,r(0));
                scaldiv(res,r(0));
            }

            break;
        }

        case 106:
        {
            // K = r1*z/(r0*r0) if real(z) < 0, z/(r0*r0) otherwise

            const static T zgt(0.0);

            res = xyprod;
            scaldiv(res,r(0));
            scaldiv(res,r(0));

            if ( xyprod < zgt )
            {
                scalmul(res,r(1));
            }

            break;
        }

        case 200:
        {
            // K = z/(r0.r0) - 1

            res = xyprod;
            scaldiv(res,r(0));
            scaldiv(res,r(0));
            res -= 1.0;

            break;
        }

        case 203:
        {
            // K = -1 if real(z) < 0, 1 otherwise

            const static T zgt(0.0);

            if ( xyprod < zgt )
            {
                res = -1.0;
            }

            else
            {
                res = 1.0;
            }

            break;
        }

        case 204:
        {
            // K = 0 if real(z) < 0, z/(r0*r0) otherwise    - 1

            const static T zgt(0.0);

            if ( xyprod < zgt )
            {
                res = -1.0;
            }

            else
            {
                res = xyprod;
                scaldiv(res,r(0));
                scaldiv(res,r(0));
                res -= 1.0;
            }

            break;
        }

        case 206:
        {
            // K = r1*z/(r0*r0) if real(z) < 0, z/(r0*r0) otherwise

            const static T zgt(0.0);

            res = xyprod;
            scaldiv(res,r(0));
            scaldiv(res,r(0));

            if ( xyprod < zgt )
            {
                scalmul(res,r(1));
            }

            res -= 1.0;

            break;
        }

        default:
        {
            NiceThrow("fee fi fo fum");

            retval = 1;
            break;
        }
    }

    res *= (const T &) weight;

    return retval;
}


template <class T>
int MercerKernel::QQprosingle(int m, Vector<T> &res, const SparseVector<gentype> &xa, const vecInfo &xainfo, int ia, int allowfinite, int xdim, int xconsist, int assumreal, int gradOrder, int xagradup, int ind, int ktype, const gentype &weight, const Vector<gentype> &r, const Vector<int> &ic) const
{
    (void) xainfo;
    (void) ia;

    NiceAssert( !gradOrder );

    (void) gradOrder;
    (void) xagradup;

    int i;
    int dres = -1; // This signifies default infdim vector, which is the default

    if ( allowfinite && ( ktype == 0 ) )
    {
        // K(x,y) = r1

        dres = 1;
    }

    else if ( allowfinite && ( ( ktype == 1 ) || ( ktype == 100 ) ) )
    {
        // K(x,y) = <x/r0,y/r0>

        dres = xdim;
    }

    else if ( allowfinite && ( ktype == 2 ) )
    {
        // K(x,y) = ( r1 + <x/r0,y/r0> )^i0

        dres = (int) pow(xdim+1,ic(0));
    }

    else if ( randFeats(ind).size() )
    {
        // Use random features approximation

        dres = randFeatReOnly(ind) ? (randFeats(ind).size()) : (2*(randFeats(ind).size()));
    }

    if ( m >= 0 )
    {
        if ( allowfinite && ( ktype == 0 ) )
        {
            // K(x,y) = r1

            if ( res.infsize() )
            {
                const static Vector<T> temp(1);

                res = temp;
            }

            gentype oneonm(1.0/m);

            (res.resize(1))("&",0) = pow(r(1),oneonm);
        }

        else if ( allowfinite && ( ( ktype == 1 ) || ( ktype == 100 ) ) )
        {
            // K(x,y) = <x/r0,y/r0>

            if ( res.infsize() )
            {
                const static Vector<T> temp;

                res = temp;
            }

            res.resize(xdim);

            for ( i = 0 ; i < xdim ; ++i )
            {
                res("&",i) = (T) xa(i);
                res("&",i) /= (T) r(0);
            }
        }

        else if ( allowfinite && ( ktype == 2 ) )
        {
            // K(x,y) = ( r1 + <x/r0,y/r0> )^i0

            if ( res.infsize() )
            {
                const static Vector<T> temp;

                res = temp;
            }

            SparseVector<gentype> tmp(xa);

            gentype oneonm(1.0/m);

            tmp /= r(0);
            tmp("&",xdim) = pow(r(1),oneonm);

            Vector<gentype> tmpres;

            kronpow(tmpres,tmp,xdim+1,ic(0));

            int ii;

            res.resize(tmpres.size());

            for ( ii = 0 ; ii < res.size() ; ++ii )
            {
                res("&",ii) = (T) tmpres(ii);
            }
        }

        else if ( dres >= 0 )
        {
            // Return RFF approximation of translation invariant kernel
            //
            // - Only works for translation-invariant kernels
            // - Which kernel this is approximating depends entirely on the
            //   distribution from which the random features were drawn!

            NiceAssert( !kinf(ind).usesInner   );
            NiceAssert( !kinf(ind).usesNorm    );
            NiceAssert( !kinf(ind).usesVector  );
            NiceAssert( !kinf(ind).usesMinDiff );
            NiceAssert( !kinf(ind).usesMaxDiff );

            res.resize(dres);

            int ii;
            int M = randFeats(ind).size();
            bool ImOnly = ( randFeatReOnly(ind) == -1 );
            T xyprod;

            for ( ii = 0 ; ii < dres ; ++ii )
            {
                innerProductDiverted(xyprod,xa,randFeats(ind)(ii%M),xconsist,assumreal);
                xyprod += ( randFeatNoAngle(ind) ? 0.0 : randFeatAngle(ind)(ii%M) );

                bool isSinPart = ( ( ii >= M ) || ImOnly );

                if ( isSinPart )
                {
                    res("&",ii) = sin(xyprod);
                    res("&",ii) *= sqrt(1.0/((double) M));
                }

                else
                {
                    res("&",ii) = cos(xyprod);
                    res("&",ii) *= sqrt(1.0/((double) M));
                }
            }
        }

        else
        {
            // Return as RKHS vector

            gentype a(1.0);

            local_makeanRKHSVector(res,*this,xa,a,m);
        }
    }

    gentype oneonm(1.0/m);

    res.scale((T) pow(weight,oneonm));

    return dres;
}


template <class T>
void MercerKernel::dKKpro(T &totxygrad, T &totxnormgrad, T &totres, const T &inxyprod, const T &diffis, int i, int j, int locindstart, int locindend, int xdim, int m, const T &xxprod, const T &yyprod) const
{
    // Assumptions enforced here
    //
    // - magterm only included if this is a kernel sum
    // - if kernel chain then only the final term can use diffis
    // - no mixed sum/chain

    T xyprod = inxyprod;

    totres = xyprod;

    totxygrad    = 1.0;
    totxnormgrad = 0.0;

    if ( !isFastKernelSum() && ( locindstart > locindend ) )
    {
        return;
    }

    // Chained derivative is the prod: dkn(k{n-1}(...k1(k0(q)))) * dk{n-1}(...k1(k0(q)))... * dk1(k0(q)) * dk0(q)

    T totdiffgrad;

    totdiffgrad = 0.0;

    int ind;

    // NB: xyprod is used at all layers for chained kernels
    //     diffis is used only at first layer for chained kernels

    Vector<T> allres(locindend-locindstart+1);

    Vector<T> allxygrad(locindend-locindstart+1);
    Vector<T> alldiffgrad(locindend-locindstart+1);
    Vector<T> allxnormonlygrad(locindend-locindstart+1);

    retVector<gentype> tmpva;

    for ( ind = locindstart ; ind <= locindend ; ++ind )
    {
        T &res = allres("&",ind-locindstart);

        T &xygrad        = allxygrad("&",ind-locindstart);
        T &diffgrad      = alldiffgrad("&",ind-locindstart);
        T &xnormonlygrad = allxnormonlygrad("&",ind-locindstart);

        const Vector<gentype> &r = dRealConstants(ind)(1,1,dRealConstants(ind).size()-1,tmpva);
        const Vector<int> &ic = dIntConstants(ind);

        int ktype = cType(ind);

        dKKprosingle(xygrad,diffgrad,xnormonlygrad,res,xyprod,diffis,i,j,xdim,m,xxprod,yyprod,ktype,cWeight(ind),r,ic,isMagTerm(ind));

        if ( isFastKernelSum() && ( ind == locindstart ) )
        {
            totres = res;

            totxygrad    = xygrad;
            totdiffgrad  = diffgrad;
            totxnormgrad = xnormonlygrad;
        }

        else if ( isFastKernelSum() )
        {
            totres += res;

            totxygrad    += xygrad;
            totdiffgrad  += diffgrad;
            totxnormgrad += xnormonlygrad;
        }

        else if ( ( ind == locindend ) && ( ind == locindstart ) )
        {
            totres = res;

            totxygrad    = xygrad;
            totdiffgrad  = diffgrad;
            totxnormgrad = xnormonlygrad;
        }

        else if ( ind == locindstart )
        {
            xyprod = res;

            totxygrad    = xygrad;
            totdiffgrad  = diffgrad;
            totxnormgrad = xnormonlygrad;
        }

        else if ( ind < locindend )
        {
            xyprod = res;

            totxygrad    *= xygrad;
            totdiffgrad  *= xygrad; // diffgrad zero here by definition
            totxnormgrad *= xnormonlygrad; // xnormonlygrad likely
        }

        else
        {
            totres = res;

            totxygrad    *= xygrad;
            totdiffgrad  *= xygrad; // diffgrad zero here by definition
            totxnormgrad *= xnormonlygrad; // xnormonlygrad likely
        }
    }

    // diffis = ||x-y||^2 = ||x||^2 + ||y||^2 - 2<x,y>
    //
    // dK/dxyprod = partialK/partialxyprod + partialK/partialdiffis partialdiffis/partialxyprod
    //            = partialK/partialxyprod - 2*partialK/partialdiffis
    // dK/dxnorm  = partialK/partialdiffis partialdiffis/partialxnorm
    //            = partialK/partialdiffis 

    totxygrad -= totdiffgrad;
    totxygrad -= totdiffgrad;

    totxnormgrad += totdiffgrad;
}

//KERNELSHERE
//phantomx

//ADDHERE
template <class T>
void MercerKernel::dKKprosingle(T &xygrad, T &diffgrad, T &xnormonlygrad, T &res, const T &xyprod, const T &diffis, int i, int j, int xdim, int m, const T &xxprod, const T &yyprod, int ktype, const gentype &weight, const Vector<gentype> &r, const Vector<int> &ic, int magterm) const
{
    res = 0.0;

    xygrad        = 0.0;
    diffgrad      = 0.0;
    xnormonlygrad = 0.0;

    if ( magterm )
    {
        xygrad = 0.0;

        T xres; xres = 0.0;
        T yres; yres = 0.0;

        T ddgrad;         ddgrad         = 0.0;
        T ddiffgrad;      ddiffgrad      = 0.0;
        T ddnormonlygrad; ddnormonlygrad = 0.0;

        T altdiffis; altdiffis = 0.0;

        T xxgrad; xxgrad = 0.0;

        dKKprosingle(xxgrad,ddiffgrad,ddnormonlygrad,xres,xxprod,altdiffis,i,i,xdim,m,xxprod,xxprod,ktype,1.0_gent,r,ic,0);
        dKKprosingle(ddgrad,ddiffgrad,ddnormonlygrad,yres,yyprod,altdiffis,j,j,xdim,m,yyprod,yyprod,ktype,1.0_gent,r,ic,0);

        (void) ddgrad;
        (void) ddiffgrad;
        (void) ddnormonlygrad;

        res  = xres;
        res *= yres;

        //xygrad  = 0.0;
        //xygrad *= yres;

        //diffgrad  = 0.0;
        //diffgrad *= yres;

        xnormonlygrad  = xxgrad;
        xnormonlygrad *= yres;

        res           *= (const T &) weight;
        //xygrad        *= (const T &) weight;
        //diffgrad      *= (const T &) weight;
        xnormonlygrad *= (const T &) weight;

        return;
    }

    switch ( ktype )
    {
        case 0:
        {
            // K = r1
            // dK = 0

            res = r(1);

            break;
        }

        case 1:
        {
            // K = z/(r0.r0)
            // dK = 1/(r0.r0)

            res    = xyprod;
            scaldiv(res,r(0));
            scaldiv(res,r(0));

            xygrad = 1.0;
            scaldiv(xygrad,r(0));
            scaldiv(xygrad,r(0));

            break;
        }

        case 2:
        {
            // K = ( r1 + z/(r0.r0) )^i0
            // dK = i0/(r0.r0) * ( r1 + z/(r0.r0) )^(i0-1)            if ( i0 >= 1 )

            T temp(xyprod);

            scaldiv(temp,r(0));
            scaldiv(temp,r(0));
            scaladd(temp,r(1));

            res = temp;
            raiseto(res,ic(0));

            if ( ic(0) >= 1 )
            {
                xygrad = temp;
                raiseto(xygrad,ic(0)-1);
                xygrad *= ic(0);
                scaldiv(xygrad,r(0));
                scaldiv(xygrad,r(0));
            }

            break;
        }

        case 3:
        {
            // K = exp(-d/(2.r0.r0))
            // dK = -K/(2*r0*r0)

            res  = diffis;
            res *= -0.5;
            scaldiv(res,r(0));
            scaldiv(res,r(0));
            res += log(AltDiffNormConst(xdim,m,r(0)));
            scalsub(res,r(1));
            OP_exp(res);

            diffgrad  = res;
            diffgrad *= -0.5;
            scaldiv(diffgrad,r(0));
            scaldiv(diffgrad,r(0));

            break;
        }

        case 4:
        {
            // K = exp(-sqrt(d)/r0)
            // dK = -K/(2*r0*sqrt(d))
            //
            // At d=0: dK = 0, d2K = 0

            T tmp(diffis);

            OP_sqrt(tmp);

            res = tmp;
            setnegate(res);
            scaldiv(res,r(0));
            scalsub(res,r(1));
            OP_exp(res);

            if ( (double) abs2(diffis) > BADZEROTOL )
            {
                diffgrad = res;
                diffgrad *= -0.5;
                scaldiv(diffgrad,r(0));
                diffgrad /= tmp;
            }

            break;
        }

        case 5:
        {
            // K = exp(-sqrt(d)^r1/(r1*r0^r1))
            // dK = -K*((sqrt(d)^(r1-2))/(2*r0^r1))
            //    = -K*((sqrt(d)^r1)/(2*d*r0^r1))
            //
            // At d=0, if r1 < 2: dK = 0, d2K = 0

            T tmpb = pow(sqrt(diffis),(T) r(1));
            T tmpc = pow((T) r(0),(T) r(1));

            res  = tmpb;
            res /= tmpc;
            scaldiv(res,r(1));
            setnegate(res);
            scalsub(res,r(2));
            OP_exp(res);

            if ( ( (double) abs2(diffis) > BADZEROTOL ) || ( (double) abs2(r(1)) >= 2.0 ) )
            {
                // dK = -K*((sqrt(d)^r1)/(2*d*r0^r1))

                diffgrad  = res;
                diffgrad *= tmpb;
                diffgrad *= -0.5;
                diffgrad /= diffis;
                diffgrad /= tmpc;
            }

            break;
        }

        case 7:
        {
            // K = tanh( z/(r0.r0) + r1 )
            // dK = 1/(r0.r0) * sech^2( r0 z + r1 )

            res = xyprod;
            scaldiv(res,r(0));
            scaldiv(res,r(0));
            scaladd(res,r(1));
            OP_tanh(res);

            xygrad = xyprod;
            scaldiv(xygrad,r(0));
            scaldiv(xygrad,r(0));
            scaladd(xygrad,r(1));
            OP_sech(xygrad);
            xygrad *= xygrad;
            scaldiv(xygrad,r(0));
            scaldiv(xygrad,r(0));

            break;
        }

        case 8:
        {
            // K = ( 1 + d/(2*r0*r0*r1) )^(-r1)
            // dK = -(( 1 + d/(2*r0*r0*r1) )^(-r1-1))/(2*r0*r0)
            //    = -K/(2*r0*r0*( 1 + d/(2*r0*r0*r1) ))

            //OLD     8  | Rational quadratic     | 1 - d/(d+r0)
            //OLD     8  | Rational quadratic     | -1/(d+r0) + d/(d+r0)^2 = -K(x,y)/(d+r0)
            //OLD     8  | Rational quadratic     | K(x,y)/((d+r0)^2) - K(x,y)/((d+r0)^2) = 0

            T tmp;

            tmp  = diffis;
            tmp *= 0.5;
            scaldiv(tmp,r(0));
            scaldiv(tmp,r(0));
            scaldiv(tmp,r(1));
            tmp += 1.0;

            res = pow(tmp,-((T) r(1)));

            xygrad  = res;
            xygrad *= -0.5;
            scaldiv(xygrad,r(0));
            scaldiv(xygrad,r(0));
            xygrad /= tmp;

//OLD            res = diffis;
//OLD            scaldiv(res,(diffis+r(0)));
//OLD            setnegate(res);
//OLD            res += 1.0;
//OLD
//OLD            xygrad = 0.0;
//OLD
//OLD            diffgrad = res;
//OLD            setnegate(diffgrad);
//OLD            scaldiv(res,(diffis+r(0)));

            break;
        }

        case 9:
        {
            // K = sqrt( d/(r0.r0) + r1^2 )
            // dK = (1/(r0.r0))/(2.K)
            //
            // if d/(r0.r0) + r1^2 = 0 then dk,d2K = 0

            res = diffis;
            scaldiv(res,r(0));
            scaldiv(res,r(0));
            scaladd(res,r(1),r(1));
            OP_sqrt(res);

            if ( (double) abs2(res) > 1e-24 )
            {
                diffgrad  = res;
                diffgrad *= 2.0;
                OP_einv(diffgrad);
                scaldiv(diffgrad,r(0));
                scaldiv(diffgrad,r(0));
            }

            break;
        }

        case 10:
        {
            // K = 1/sqrt( d/(r0.r0) + r1^2 )
            // dK = (1/(r0.r0))*-(K^3)/2
            //
            // Ill-defined as d + r1^2 -> 0

            res = diffis;
            scaldiv(res,r(0));
            scaldiv(res,r(0));
            scaladd(res,r(1),r(1));
            OP_sqrt(res);
            OP_einv(res);

            diffgrad  = res;
            diffgrad *= res;
            diffgrad *= res;
            diffgrad *= -2.0;
            OP_einv(diffgrad);
            scaldiv(diffgrad,r(0));
            scaldiv(diffgrad,r(0));

            break;
        }

        case 11:
        {
            // K = 2/pi * arccos(-sqrt(d)/r0) - 2/pi * sqrt(d)/r0 * sqrt(1 - d/r0^2)
            // dK = ( 2/pi * 1/sqrt(1 - d/r0^2) - 2/pi * sqrt(1 - d/r0^2) - 1/pi * sqrt(d)/r0 * 1/sqrt(1 - d/r0^2) * -2 sqrt(d)/r0 ) * 1/(2*r0*sqrt(d))
            //    = ( 2/pi * 1/sqrt(1 - d/r0^2) - 2/pi * sqrt(1 - d/r0^2) + 2/pi * d/r0^2 * 1/sqrt(1 - d/r0^2) ) * 1/(2*r0*sqrt(d))
            //    = ( 1/sqrt(1 - d/r0^2) - sqrt(1 - d/r0^2) + d/r0^2 * 1/sqrt(1 - d/r0^2) ) * 1/(pi*r0*sqrt(d))
            //    = ( 1 - 1 + d/r0^2 + d/r0^2 ) * 1/(pi*r0*sqrt(d)*sqrt(1 - d/r0^2))
            //    = ( d/r0^2 + d/r0^2 ) * 1/(pi*r0*sqrt(d)*sqrt(1 - d/r0^2))
            //    = d/r0^2 * 2/(pi*r0*sqrt(d)*sqrt(1 - d/r0^2))
            //    = sqrt(d)/r0^2 * 2/(pi*r0*sqrt(1 - d/r0^2))
            //    = 2/pi 1/r0^2 sqrt(d)/r0 * 1/sqrt(1 - d/r0^2)

            T tempres(diffis);
            OP_sqrt(tempres);
            scaldiv(tempres,r(0));
            tempres *= -1.0;

            T tempsq(tempres);
            tempsq *= tempsq;
            tempsq *= -1.0;
            tempsq += 1.0;
            OP_sqrt(tempsq);

            if ( (double) abs2(tempres) < 1.0 )
            {
                // K = 2/pi * arccos(-sqrt(d)/r0) - 2/pi * sqrt(d)/r0 * sqrt(1 - d/r0^2)

                res  = tempsq;
                res *= tempres;
                res += acos(tempres);
                res *= NUMBASE_2ONPI;

                //    = 2/pi 1/r0^2 sqrt(d)/r0 * 1/sqrt(1 - d/r0^2)

                diffgrad  = tempsq;
                OP_einv(diffgrad);
                diffgrad *= tempres;
                res *= NUMBASE_2ONPI;
                scaldiv(diffgrad,r(0));
                scaldiv(diffgrad,r(0));
            }

            break;
        }

        case 12:
        {
            // K = 1 - 3/2 * sqrt(d)/r0 + 1/2 * sqrt(d)^3/r0^3
            // dK = ( 3/2 + 3/2 * (sqrt(d)/r0)^2 ) 1/(2*sqrt(d)*r0)
            //    = ( 3/2 + 3/2 * (sqrt(d)/r0)^2 ) 1/2 1/r0^2 r0/sqrt(d)
            //    = 3/4 1/r0^2 ( (sqrt(d)/r0)^{-1} + sqrt(d)/r0 )

            T tempres(diffis);
            OP_sqrt(tempres);
            scaldiv(tempres,r(0));

            // K = 1 - 3/2 * sqrt(d)/r0 + 1/2 * sqrt(d)^3/r0^3

            res = tempres;
            res *= tempres;
            res *= tempres;
            res /= 2.0;
            res *= 0.6666666666666666666666;
            res -= tempres;
            res /= 0.6666666666666666666666;
            res += 1.0;

            //    = 3/4 1/r0^2 ( (sqrt(d)/r0)^{-1} + sqrt(d)/r0 )

            diffgrad  = tempres;
            OP_einv(diffgrad);
            diffgrad += tempres;
            diffgrad *= 0.75;
            scaldiv(diffgrad,r(0));
            scaldiv(diffgrad,r(0));

            break;
        }

        case 13:
        {
            // K = sinc(sqrt(d)/r0)
            // dK = ( cos(sqrt(d)/r0) - K )/(2*r0*sqrt(d))
            //
            // if d = 0 then dK,d2K = 0

            T tmp(diffis);

            OP_sqrt(tmp);

            T tmpb(tmp);

            scaldiv(tmpb,r(0));

            res = tmpb;
            OP_sinc(res);

            if ( (double) tmpb > BADZEROTOL )
            {
                diffgrad  = tmpb;
                OP_cos(diffgrad);
                diffgrad -= res;
                diffgrad *= 0.5;
                scaldiv(diffgrad,r(0));
                diffgrad /= tmp;
            }

            break;
        }

        case 14:
        {
            // K = -sqrt(d)^r1
            // dK = -(r1*sqrt(d)^(r1-2))/2 
            //    = -(r1*sqrt(d)^r1)/(2*d) 
            //    = (r1*K)/(2*d) 
            //    = r1*K/(2*d)
            //
            // if d = 0 then dK,d2K = 0

            res  = diffis;
            scaldiv(res,r(0));
            scaldiv(res,r(0));
            OP_sqrt(res);
            res  = pow(res,(T) r(1));
            res *= -1.0;

            if ( (double) diffis > BADZEROTOL )
            {
                diffgrad  = res;
                scalmul(diffgrad,r(1));
                diffgrad *= -0.5;
                diffgrad /= diffis;
                scaldiv(diffgrad,r(0));
                scaldiv(diffgrad,r(0));
            }

            break;
        }

        case 15:
        {
            // K = -log(sqrt(d)^r1 + 1)
            // dK = -(r1.sqrt(d)^(r1-2))/(2*(sqrt(d)^r1 + 1))

            T tmpa(diffis);

            scaldiv(tmpa,r(0));
            scaldiv(tmpa,r(0));

            OP_sqrt(tmpa);

            T tmpb;

            tmpb = pow(tmpa,(T) r(1));
            tmpb += 1.0;

            res = tmpb;
            OP_log(res);
            setnegate(res);

            diffgrad = pow(tmpb,((T) r(1))-2.0);
            scalmul(diffgrad,r(1));
            diffgrad *= -0.5;
            diffgrad /= tmpb;
            scaldiv(diffgrad,r(0));
            scaldiv(diffgrad,r(0));

            break;
        }

        case 19:
        {
            // K = 1/(1+(d/(r0.r0)))
            // dK = -K^2/(r0.r0)

            res = diffis;
            scaldiv(res,r(0));
            scaldiv(res,r(0));
            res += 1.0;
            OP_einv(res);

            diffgrad  = res;
            diffgrad *= res;
            diffgrad *= -1.0;
            scaldiv(diffgrad,r(0));
            scaldiv(diffgrad,r(0));

            break;
        }

        case 23:
        {
            // K = 1/(1+(sqrt(d)/r0)^r1)
            // dK = -(r1/(2.r0)) * (sqrt(d)/r(0))^(r1-2) * K^2

            T tmp(diffis);

            OP_sqrt(tmp);
            scaldiv(tmp,r(0));

            res  = pow(tmp,(T) r(1));
            res += 1.0;
            OP_einv(res);

            T tmpb;
            tmpb = pow(tmp,(T) r(1)-2.0);

            diffgrad  = res;
            diffgrad *= res;
            diffgrad *= -0.5;
            scaldiv(diffgrad,r(0));
            scalmul(diffgrad,r(1));
            diffgrad *= tmpb;

            break;
        }

        case 24:
        {
            // K = (1-(z^i0))/(1-z)
            // dK = ( -i0.(z^(i0-1)) + (1-(z^i0))/(1-z) )/(1-z) 
            //    = ( -i0.(z^i0)/z + K )/(1-z)                         if ( i0 >= 1 )
            //
            // Ill-defined at z = 1
            //
            // z -> z/(r0.r0) and blah blah

            T zsc(xyprod);

            scaldiv(zsc,r(0));
            scaldiv(zsc,r(0));

            if ( ( (double) abs2(zsc) > BADZEROTOL ) || ( ic(0) == 0 ) )
            {
                T tmp = zsc;

                raiseto(tmp,ic(0));

                res  = 1.0;
                res -= tmp;
                res /= (1.0-zsc);
            }

            if ( ( (double) abs2(zsc) > BADZEROTOL ) || ( ic(0) == 1 ) )
            {
                T tmp = zsc;

                raiseto(tmp,ic(0)-1);

                xygrad  = tmp;
                xygrad *= -ic(0);
                xygrad += res;
                xygrad /= (1.0-zsc);
                scaldiv(xygrad,r(0));
                scaldiv(xygrad,r(0));
            }

            break;
        }

        case 25:
        {
            // K = pi.cosh(pi-(sqrt(d)/r0))
            // dK = -pi/(2.r0) * sinh(pi-sqrt(d)/r0) / sqrt(d)

            T tmp(diffis);

            OP_sqrt(tmp);

            res  = tmp;
            scaldiv(res,r(0));
            res -= NUMBASE_PI;
            res *= -1.0;
            OP_cosh(res);
            res *= NUMBASE_PI;

            diffgrad  = tmp;
            scaldiv(diffgrad,r(0));
            diffgrad -= NUMBASE_PI;
            diffgrad *= -1.0;
            OP_sinh(diffgrad);
            diffgrad *= NUMBASE_PION2;            
            diffgrad *= -0.5;
            scaldiv(diffgrad,r(0));
            diffgrad /= tmp;

            break;
        }

        case 26:
        {
            // K = ((d/r0)^(r1+0.5))
            // dK = 1/r0 * (r1+0.5) * (d/r0)^(r1-0.5)
            //    = 1/r0 * (r1+0.5) * K/d

            res  = diffis;
            scaldiv(res,r(0));
            res  = pow(res,((T) r(1))+0.5);

            if ( (double) diffis > BADZEROTOL )
            {
                diffgrad = 0.5;
                scaladd(diffgrad,r(1));
                scaldiv(diffgrad,r(0));
                diffgrad *= res;
                diffgrad /= diffis;
            }

            break;
        }

        case 27:
        {
            // K = ((d/r0)^r1).ln(sqrt(d/r0))
            // dK = (r1/r0).((d/r0)^(r1-1)).ln(sqrt(d/r0)) + ((d/r0)^r1) 1/(sqrt(d/r0)) 1/2 1/sqrt(d*r0)
            //    = (r1/r0).((d/r0)^r1).ln(sqrt(d/r0)).(r0/d) + ((d/r0)^r1)/(2d)
            //    = 2.r1.((d/r0)^r1).ln(sqrt(d/r0))/(2d) + ((d/r0)^r1)/(2d)
            //    = ( 2.r1.ln(sqrt(d/r0)) + 1 ).((d/r0)^r1)/(2d)
            //    = ( ln(sqrt(d/r0)) + 1/(2.r1) ).((d/r0)^r1).(2.r1)/(2d)
            //    = ( ((d/r0)^r1).ln(sqrt(d/r0)) + ((d/r0)^r1)/(2.r1) ).(2.r1)/(2d)
            //    = ( K + ((d/r0)^r1)/(2.r1) ).(2.r1)/(2d)

            T scalres(diffis);

            scaldiv(scalres,r(0));
            OP_sqrt(scalres);

            T tempres(scalres);

            OP_log(tempres);

            scalres = pow(scalres,(T) r(1));

            res  = scalres;
            res *= tempres;

            if ( (double) diffis > BADZEROTOL )
            {
                diffgrad  = scalres;
                diffgrad *= 0.5;
                scaldiv(diffgrad,r(1));
                diffgrad += res;
                diffgrad *= 2;
                scalmul(diffgrad,r(1));
                diffgrad *= 0.5;
                diffgrad /= diffis;
            }

            break;
        }

        case 32:
        {
            // K = r1 if i == j >= 0, 0 otherwise
            // dK = 0.0

            if ( ( i == j ) && ( i >= 0 ) )
            {
                res = r(1);
            }

            break;
        }

        case 33:
        {
            // K = 1/(2.r0) ( 1 if real(sqrt(d)) < r0, 0 otherwise )
            // dK = 0

            //if ( real(sqrt(diffis)-r(0)) < zerogentype() )
            if ( real(sqrt(diffis)-r(0)) < 0.0_gent )
            {
                res = 0.5/r(0);
            }

            break;
        }

        case 34:
        {
            // K = (1-sqrt(d)/r0)/r0 if real(sqrt(d)) < r0, 0 otherwise )
            // dK = 1/r0 1/(2*sqrt(d)*r0)
            //    = 1/r0 1/2 1/r0^2 r0/sqrt(d)
            //    = 1/r0^3 1/2 r0/sqrt(d)

            T tempres(diffis);
            OP_sqrt(tempres);
            scaldiv(tempres,r(0));

            if ( (double) real(tempres-1.0) < 0.0 )
            {
                res  = 1.0;
                res -= tempres;
                scaldiv(res,r(0));

                diffgrad = tempres;
                OP_einv(diffgrad);
                diffgrad /= 2.0;
                scaldiv(diffgrad,r(0));
                scaldiv(diffgrad,r(0));
                scaldiv(diffgrad,r(0));
            }

            break;
        }

        case 38:
        {
            // K = exp(-sqrt(d)/r0)
            // dK = 1/r0^2 -r0/sqrt(d) exp(-sqrt(d)/r0)
            //    = 1/r0^2 -r0/sqrt(d) K

            T tempres(diffis);
            OP_sqrt(tempres);
            scaldiv(tempres,r(0));
            tempres *= -1.0;

            res = tempres;
            OP_exp(res);

            diffgrad  = res;
            diffgrad *= tempres;
            scaldiv(diffgrad,r(0));
            scaldiv(diffgrad,r(0));

            break;
        }

        case 39:
        {
            // K = (1+((sqrt(3)/r0).sqrt(d))) . exp(-(sqrt(3)/r0).sqrt(d))
            // dK = ( exp( -sqrt(3)/r0 sqrt(d) ) - ( 1 + sqrt(3)/r0 sqrt(d) ) exp( -sqrt(3)/r0 sqrt(d) ) ) sqrt(3)/r0 1/2 1/sqrt(d)
            //    = -((sqrt(3)/r0).sqrt(d)) exp(-((sqrt(3)/r0).sqrt(d))) sqrt(3)/r0 1/2 1/sqrt(d)
            //    = -1/2 3/r0^2 exp(-((sqrt(3)/r0).sqrt(d)))
            //    = -3/2 1/r0^2 exp(-((sqrt(3)/r0).sqrt(d)))

            T tempres(diffis);
            OP_sqrt(tempres);
            scaldiv(tempres,r(0));
            tempres *= sqrt(3.0);

            T expres(tempres);
            expres *= -1.0;
            OP_exp(expres);

            res  = tempres;
            res += 1;
            res *= expres;

            diffgrad  = expres;
            diffgrad *= -1.5;
            scaldiv(diffgrad,r(0));
            scaldiv(diffgrad,r(0));

            break;
        }

        case 42:
        {
            // K = agd(z/(r0.r0))
            // dK = (1/(r0.r0)) sec^2(z/(r0.r0)) / ( 1 - tan^2(z/(r0.r0)) )

            T scalres = diffis;
            scaldiv(scalres,r(0));
            scaldiv(scalres,r(0));

            T scz = scalres;
            OP_sec(scz);
            scz *= scz;

            T taz = scalres;
            OP_tan(taz);

            res = scalres;
            OP_agd(res);

            xygrad  = taz;
            xygrad *= taz;
            xygrad *= -1.0;
            xygrad += 1.0;
            OP_einv(xygrad);
            xygrad *= scz;
            scaldiv(xygrad,r(0));
            scaldiv(xygrad,r(0));

            break;
        }

        case 43:
        {
            // K = log((1+r0.z)/(1-r0.z))
            // dK = r0*(1-r0.z)/(1+r0.z)*( 1/(1-r0.z) + (1+r0.z)/(1-r0.z)^2 )
            //    = r0*(1-r0.z)/(1+r0.z)*( (1-r0.z) + (1+r0.z) )/(1-r0.z)^2
            //    = r0*((1-r0.z)/(1+r0.z))/(1-r0.z)^2
            //    = r0/((1+r0.z)*(1-r0.z))
            // ADDENDUM: replace ro with 1/(r0.r0)

            T tempa = xyprod;

            tempa  = xyprod;
            scaldiv(tempa,r(0));
            scaldiv(tempa,r(0));

            T tempb = tempa;

            tempa += 1.0;
            tempb -= 1.0;

            res  = tempa;
            res /= tempb;
            OP_log(res);

            xygrad  = tempa;
            xygrad *= tempb;
            OP_einv(xygrad);
            scaldiv(xygrad,r(0));
            scaldiv(xygrad,r(0));

            break;
        }

        case 44:
        {
            // K = exp(z/(r0.r0))
            // dK = K/(r0.r0)

            res = xyprod;
            scaldiv(res,r(0));
            scaldiv(res,r(0));
            scalsub(res,r(1));
            OP_exp(res);

            xygrad = res;
            scaldiv(xygrad,r(0));
            scaldiv(xygrad,r(0));

            break;
        }

        case 45:
        {
            // K = sinh(z/(r0.r0))
            // dK = cosh(z/(r0.r0))/(r0.r0)

            res = xyprod;
            scaldiv(res,r(0));
            scaldiv(res,r(0));
            OP_sinh(res);

            xygrad = xyprod;
            scaldiv(xygrad,r(0));
            scaldiv(xygrad,r(0));
            OP_cosh(xygrad);
            scaldiv(xygrad,r(0));
            scaldiv(xygrad,r(0));

            break;
        }

        case 46:
        {
            // K = cosh(z/(r0.r0))
            // dK = sinh(z/(r0.r0))/(r0.r0)

            res = xyprod;
            scaldiv(res,r(0));
            scaldiv(res,r(0));
            OP_cosh(res);

            xygrad = xyprod;
            scaldiv(xygrad,r(0));
            scaldiv(xygrad,r(0));
            OP_sinh(xygrad);
            scaldiv(xygrad,r(0));
            scaldiv(xygrad,r(0));

            break;
        }

        case 47:
        {
            // K = sinc(sqrt(d)/r0).cos(2*pi*sqrt(d)/(r0.r1))
            //
            // if d = 0 then dK,d2K = 0

            NiceThrow("bugger that");

            break;
        }

        case 49:
        {
            // K = exp(-d/(2.r0.r0)-r1)

            NiceThrow("Maybe one day");

            break;
        }

        case 50:
        {
            // K = pi - arccos(z)
            // dK = 1/(r0.r0.sqrt(1-(z/r0.r0)^2))

            T temp(xyprod);

            scaldiv(temp,r(0));
            scaldiv(temp,r(0));

            res = temp;
            OP_acos(res);
            res *= -1.0;
            res += NUMBASE_PI;

            xygrad = temp;
            xygrad *= temp;
            xygrad *= -1.0;
            xygrad += 1.0;
            OP_sqrt(xygrad);
            scalmul(xygrad,r(0));
            scalmul(xygrad,r(0));
            OP_einv(xygrad);

            break;
        }

        case 51:
        {
            // K = 1 / ( 2 - z/(r0.r0) )
            // dK = 1/r0.r0.(2-(z/r0.r0))^2

            T temp(xyprod);

            scaldiv(temp,r(0));
            scaldiv(temp,r(0));

            temp *= -1.0;
            temp += 2.0;

            res = temp;
            res *= temp;
            scalmul(xygrad,r(0));
            scalmul(xygrad,r(0));
            OP_einv(res);

            xygrad = temp;

            break;
        }

        case 52:
        {
            // K = sqrt(a.b)/(r0.r0)
            // dK/da = sqrt(b/a)/(2.r0.r0)

            xnormonlygrad = yyprod;
            xnormonlygrad /= xxprod;
            OP_sqrt(xnormonlygrad);
            scaldiv(xnormonlygrad,r(0));
            scaldiv(xnormonlygrad,r(0));
            xnormonlygrad *= 0.5;

            res = yyprod;
            res *= xxprod;
            OP_sqrt(res);
            scaldiv(res,r(0));
            scaldiv(res,r(0));

            break;
        }

        case 53:
        {
            // K = (1-(1-sqrt(a)^r1)^r2).(1-(1-sqrt(b)^r1)^r2)/(r0.r0)
            // dK/da = (-r2.(1-sqrt(a)^r1)^(r2-1))  .  (-r1.sqrt(a)^(r1-1))  .  (1/(2.sqrt(a)))  .  (1-(1-sqrt(b)^r1)^r2)/(r0.r0)

            xnormonlygrad = yyprod;

            T xxsqrt(xxprod);

            OP_sqrt(xxsqrt);

            {
                T tempres(xxsqrt);

                tempres = pow(tempres,(T) r(1));
                tempres *= -1.0;
                tempres += 1.0;
                tempres = pow(tempres,((T) r(2))-1.0);
                tempres *= -1.0;
                scalmul(tempres,r(2));

                xnormonlygrad *= tempres;
            }

            {
                T tempres(xxsqrt);

                tempres = pow(tempres,((T) r(1))-1.0);
                tempres *= -1.0;
                scalmul(tempres,r(1));

                xnormonlygrad *= tempres;
            }

            {
                xnormonlygrad /= xxsqrt;
                xnormonlygrad *= 0.5;
            }

            {
                T tempres(yyprod);

                OP_sqrt(tempres);

                tempres = pow(tempres,(T) r(1));
                tempres *= -1.0;
                tempres += 1.0;
                tempres = pow(tempres,(T) r(2));
                tempres *= -1.0;
                tempres += 1.0;

                xnormonlygrad *= tempres;
            }

            scaldiv(xnormonlygrad,r(0));
            scaldiv(xnormonlygrad,r(0));

            res = 1.0;

            {
                T tempres(xxprod);

                OP_sqrt(tempres);

                tempres = pow(tempres,(T) r(1));
                tempres *= -1.0;
                tempres += 1.0;
                tempres = pow(tempres,(T) r(2));
                tempres *= -1.0;
                tempres += 1.0;

                res *= tempres;
            }

            {
                T tempres(yyprod);

                OP_sqrt(tempres);

                tempres = pow(tempres,(T) r(1));
                tempres *= -1.0;
                tempres += 1.0;
                tempres = pow(tempres,(T) r(2));
                tempres *= -1.0;
                tempres += 1.0;

                res *= tempres;
            }

            scaldiv(res,r(0));
            scaldiv(res,r(0));

            break;
        }

        case 100:
        {
            // K = z/(r0.r0)

            res = xyprod;
            scaldiv(res,r(0));
            scaldiv(res,r(0));

            xygrad = 1.0;
            scaldiv(xygrad,r(0));
            scaldiv(xygrad,r(0));

            break;
        }

        case 103:
        {
            // K = 0 if real(z) < 0, 1 otherwise

            const static T zgt(0.0);

            if ( xyprod < zgt )
            {
                res = 0.0;
            }

            else
            {
                res = 1.0;
            }

            xygrad = 0.0;

            break;
        }

        case 104:
        {
            // K = 0 if real(z) < 0, z/(r0*r0) otherwise

            const static T zgt(0.0);

            if ( xyprod < zgt )
            {
                res = 0.0;

                xygrad = 0.0;
            }

            else
            {
                res = xyprod;
                scaldiv(res,r(0));
                scaldiv(res,r(0));

                xygrad = 1.0;
                scaldiv(xygrad,r(0));
                scaldiv(xygrad,r(0));
            }

            break;
        }

        case 106:
        {
            // K = r1*z/(r0*r0) if real(z) < 0, z/(r0*r0) otherwise

            const static T zgt(0.0);

            res = xyprod;
            scaldiv(res,r(0));
            scaldiv(res,r(0));

            xygrad = 1.0;
            scaldiv(xygrad,r(0));
            scaldiv(xygrad,r(0));

            if ( xyprod < zgt )
            {
                scalmul(res,r(1));
                scalmul(xygrad,r(1));
            }

            break;
        }

        case 200:
        {
            // K = z/(r0.r0) - 1

            res = xyprod;
            scaldiv(res,r(0));
            scaldiv(res,r(0));
            res -= 1.0;

            xygrad = 1.0;
            scaldiv(xygrad,r(0));
            scaldiv(xygrad,r(0));

            break;
        }

        case 203:
        {
            // K = -1 if real(z) < 0, 1 otherwise

            const static T zgt(0.0);

            if ( xyprod < zgt )
            {
                res = -1.0;
            }

            else
            {
                res = 1.0;
            }

            xygrad = 0.0;

            break;
        }

        case 204:
        {
            // K = 0 if real(z) < 0, z/(r0*r0) otherwise    - 1

            const static T zgt(0.0);

            if ( xyprod < zgt )
            {
                res = -1.0;

                xygrad = 0.0;
            }

            else
            {
                res = xyprod;
                scaldiv(res,r(0));
                scaldiv(res,r(0));
                res -= 1.0;

                xygrad = 1.0;
                scaldiv(xygrad,r(0));
                scaldiv(xygrad,r(0));
            }

            break;
        }

        case 206:
        {
            // K = r1*z/(r0*r0) if real(z) < 0, z/(r0*r0) otherwise

            const static T zgt(0.0);

            res = xyprod;
            scaldiv(res,r(0));
            scaldiv(res,r(0));

            xygrad = 1.0;
            scaldiv(xygrad,r(0));
            scaldiv(xygrad,r(0));

            if ( xyprod < zgt )
            {
                scalmul(res,r(1));
                scalmul(xygrad,r(1));
            }

            res -= 1.0;

            break;
        }

        default:
        {
            NiceThrow("fee fi fo fum");

            break;
        }
    }

    res      *= (const T &) weight;
    xygrad   *= (const T &) weight;
    diffgrad *= (const T &) weight;
}

template <class T>
void MercerKernel::d2KKpro(T &totxygrad, T &totxnormgrad, T &totxyxygrad,
                           T &totxyxnormgrad, T &totxyynormgrad,
                           T &totxnormxnormgrad, T &totxnormynormgrad, T &totynormynormgrad,
                           T &totres,
                           const T &inxyprod, const T &diffis,
                           int i, int j,
                           int locindstart, int locindend,
                           int xdim, int m, const T &xxprod, const T &yyprod) const
{
    T xyprod = inxyprod;

    totres = xyprod;

    totxygrad    = 1.0;
    totxnormgrad = 0.0;

    totxyxygrad       = 0.0;
    totxyxnormgrad    = 0.0;
    totxyynormgrad    = 0.0;
    totxnormxnormgrad = 0.0;
    totxnormynormgrad = 0.0;
    //totynormxnormgrad = 0.0;
    totynormynormgrad = 0.0;

    if ( !isFastKernelSum() && ( locindstart > locindend ) )
    {
        return;
    }

    // Base kernel is: kn(k{n-1}(...k1(k0(q))...)), where q is either <x,y> or ||x-y||^2
    //
    // Chained derivative is the prod: dkn(k{n-1}(...k1(k0(q)))) * dk{n-1}(...k1(k0(q)))... * dk1(k0(q)) * dk0(q)
    //
    // Chained 2nd derivative is sum/prod:   d2kn(k{n-1}(...k1(k0(q)))) * dk{n-1}(...k1(k0(q)))... * dk1(k0(q)) * dk0(q)
    //                                     + dkn(dk{n-1(...k1(k0(q)))) * d2k{n-1}(...k1(k0(q)))... * dk1(k0(q)) * dk0(q)
    //                                     + dkn(dk{n-1(...k1(k0(q)))) * dk{n-1}(...k1(k0(q)))... * d2k1(k0(q)) * dk0(q)
    //                                     + dkn(dk{n-1(...k1(k0(q)))) * dk{n-1}(...k1(k0(q)))... * dk1(k0(q)) * d2k0(q)

    T totdiffgrad;
    T totdiffdiffgrad;

    totdiffgrad     = 0.0;
    totdiffdiffgrad = 0.0;

    int ind;

    // NB: xyprod is used at all layers for chained kernels
    //     diffis is used only at first layer for chained kernels

    Vector<T> allres(locindend-locindstart+1);

    Vector<T> allxygrad(locindend-locindstart+1);
    Vector<T> alldiffgrad(locindend-locindstart+1);
    Vector<T> allxnormonlygrad(locindend-locindstart+1);

    Vector<T> allxyxygrad(locindend-locindstart+1);
    Vector<T> alldiffdiffgrad(locindend-locindstart+1);
    Vector<T> allxnormxnormonlygrad(locindend-locindstart+1);
    Vector<T> allxnormynormonlygrad(locindend-locindstart+1);
    //Vector<T> allynormxnormonlygrad(locindend-locindstart+1);
    Vector<T> allynormynormonlygrad(locindend-locindstart+1);

    retVector<gentype> tmpva;

    for ( ind = locindstart ; ind <= locindend ; ++ind )
    {
        T &res = allres("&",ind-locindstart);

        T &xygrad        = allxygrad("&",ind-locindstart);
        T &diffgrad      = alldiffgrad("&",ind-locindstart);
        T &xnormonlygrad = allxnormonlygrad("&",ind-locindstart);

        T &xyxygrad           = allxyxygrad("&",ind-locindstart);
        T &diffdiffgrad       = alldiffdiffgrad("&",ind-locindstart);
        T &xnornxnormonlygrad = allxnormxnormonlygrad("&",ind-locindstart);
        T &xnornynormonlygrad = allxnormynormonlygrad("&",ind-locindstart);
        //T &ynornxnormonlygrad = allynormxnormonlygrad("&",ind-locindstart);
        T &ynornynormonlygrad = allynormynormonlygrad("&",ind-locindstart);

        const Vector<gentype> &r = dRealConstants(ind)(1,1,dRealConstants(ind).size()-1,tmpva);
        const Vector<int> &ic = dIntConstants(ind);

        int ktype = cType(ind);

        d2KKprosingle(xygrad,diffgrad,xnormonlygrad,xyxygrad,diffdiffgrad,xnornxnormonlygrad,xnornynormonlygrad,ynornynormonlygrad,res,xyprod,diffis,i,j,xdim,m,xxprod,yyprod,ktype,cWeight(locindstart),r,ic,isMagTerm(ind));

        if ( isFastKernelSum() && ( ind == locindstart ) )
        {
            totres = res;

            totxygrad    = xygrad;
            totdiffgrad  = diffgrad;
            totxnormgrad = xnormonlygrad;

            totxyxygrad       = xyxygrad;
            totdiffdiffgrad   = diffdiffgrad;
            totxnormxnormgrad = xnornxnormonlygrad;
            totxnormynormgrad = xnornynormonlygrad;
            //totynormxnormgrad = ynornxnormonlygrad;
            totynormynormgrad = ynornynormonlygrad;
        }

        else if ( isFastKernelSum() )
        {
            totres += res;

            totxygrad    += xygrad;
            totdiffgrad  += diffgrad;
            totxnormgrad += xnormonlygrad;

            totxyxygrad       += xyxygrad;
            totdiffdiffgrad   += diffdiffgrad;
            totxnormxnormgrad += xnornxnormonlygrad;
            totxnormynormgrad += xnornynormonlygrad;
            //totynormxnormgrad += ynornxnormonlygrad;
            totynormynormgrad += ynornynormonlygrad;
        }

        else if ( ( ind == locindend ) && ( ind == locindstart ) )
        {
            totres = res;

            totxygrad    = xygrad;
            totdiffgrad  = diffgrad;
            totxnormgrad = xnormonlygrad;

            totxyxygrad       = xyxygrad;
            totdiffdiffgrad   = diffdiffgrad;
            totxnormxnormgrad = xnornxnormonlygrad;
            totxnormynormgrad = xnornynormonlygrad;
            //totynormxnormgrad = ynornxnormonlygrad;
            totynormynormgrad = ynornynormonlygrad;
        }

        else if ( ind == locindstart )
        {
            xyprod = res;

            totxygrad    = xygrad;
            totdiffgrad  = diffgrad;
            totxnormgrad = xnormonlygrad;

            // second-order gradients need to be post-calculated
        }

        else if ( ind < locindend )
        {
            xyprod = res;

            totxygrad    *= xygrad;
            totdiffgrad  *= xygrad; // diffgrad zero here by definition
            totxnormgrad *= xnormonlygrad; // likewise

            // second-order gradients need to be post-calculated
        }

        else
        {
            totres = res;

            totxygrad    *= xygrad;
            totdiffgrad  *= xygrad; // diffgrad zero here by definition
            totxnormgrad *= xnormonlygrad; // likewise

            // second-order gradients need to be post-calculated
        }
    }

    // second-oder gradient post-calculation

    if ( !isFastKernelSum() && ( locindend > locindstart ) )
    {
        // So *not* magterm, meaning totxnormgrad = 0 at this point

        totxyxygrad     = 0.0;
        totdiffdiffgrad = 0.0;

        int indin;

        for ( ind = locindstart ; ind <= locindend ; ++ind )
        {
            T tempxyxygrad;     tempxyxygrad     = 1.0;
            T tempdiffdiffgrad; tempdiffdiffgrad = 1.0;

            for ( indin = locindstart ; indin <= locindend ; ++indin )
            {
                if ( indin == ind )
                {
                    T &xyxygrad     = allxyxygrad("&",indin-locindstart);
                    T &diffdiffgrad = alldiffdiffgrad("&",indin-locindstart);

                    tempxyxygrad     *= xyxygrad;
                    tempdiffdiffgrad *= diffdiffgrad;
                }

                else
                {
                    T &xygrad   = allxygrad("&",indin-locindstart);
                    T &diffgrad = alldiffgrad("&",indin-locindstart);

                    tempxyxygrad     *= xygrad;
                    tempdiffdiffgrad *= diffgrad;
                }
            }

            totxyxygrad     += tempxyxygrad;
            totdiffdiffgrad += tempdiffdiffgrad;
        }
    }

    // diffis = ||x-y||^2 = ||x||^2 + ||y||^2 - 2<x,y>
    //
    // dK/dxyprod = partialK/partialxyprod + partialK/partialdiffis partialdiffis/partialxyprod
    //            = partialK/partialxyprod - 2*partialK/partialdiffis
    // dK/dxnorm  = partialK/partialdiffis partialdiffis/partialxnorm
    //            = partialK/partialdiffis 

    totxygrad -= totdiffgrad;
    totxygrad -= totdiffgrad;

    totxnormgrad += totdiffgrad;

    // diffis = ||x-y||^2 = ||x||^2 + ||y||^2 - 2<x,y>
    //
    // dK/dxyprod = partialK/partialxyprod + partialK/partialdiffis partialdiffis/partialxyprod
    //            = partialK/partialxyprod - 2*partialK/partialdiffis
    // dK/dxnorm  = partialK/partialdiffis partialdiffis/partialxnorm
    //            = partialK/partialdiffis 
    // dK/dynorm  = partialK/partialdiffis partialdiffis/partialynorm
    //            = partialK/partialdiffis 
    //
    // d2K/dxyxy = partial2K/partialxyxy - 2*partial2K/partialdiffdiffis partialdiffis/partialxyprod
    //           = partial2K/partialxyxy + 4*partial2K/partialdiffdiffis
    // d2K/dxyxnorm = partial2K/partialdiffdiffis partialdiffis/partialxyprod
    //              = -2*partial2K/partialdiffdiffis
    // d2K/dxyynorm = partial2K/partialdiffdiffis partialdiffis/partialxyprod
    //              = -2*partial2K/partialdiffdiffis
    // d2K/dxnormxnorm = partial2K/partialdiffdiffis partialdiffis/partialxnorm
    //                 = partial2K/partialdiffdiffis
    // d2K/dxnormynorm = partial2K/partialdiffdiffis partialdiffis/partialynorm
    //                 = partial2K/partialdiffdiffis
    // d2K/dynormxnorm = partial2K/partialdiffdiffis partialdiffis/partialxnorm
    //                 = partial2K/partialdiffdiffis
    // d2K/dynormynorm = partial2K/partialdiffdiffis partialdiffis/partialynorm
    //                 = partial2K/partialdiffdiffis

    totxyxygrad += totdiffdiffgrad;
    totxyxygrad += totdiffdiffgrad;
    totxyxygrad += totdiffdiffgrad;
    totxyxygrad += totdiffdiffgrad;

    totxyxnormgrad  = totdiffdiffgrad;
    totxyxnormgrad += totdiffdiffgrad;
    totxyxnormgrad *= -1.0;

    totxyynormgrad  = totdiffdiffgrad;
    totxyynormgrad += totdiffdiffgrad;
    totxyynormgrad *= -1.0;

    totxnormxnormgrad += totdiffdiffgrad;
    totxnormynormgrad += totdiffdiffgrad;
//    totynormxnormgrad += totdiffdiffgrad;
    totynormynormgrad += totdiffdiffgrad;
}



//KERNELSHERE
//phantomx

//ADDHERE
template <class T>
void MercerKernel::d2KKprosingle(T &xygrad, T &diffgrad, T &xnormonlygrad,
                                 T &xyxygrad, T &diffdiffgrad,
                                 T &xnormxnormonlygrad, T &xnormynormonlygrad, T &ynormynormonlygrad,
                                 T &res,
                                 const T &xyprod, const T &diffis,
                                 int i, int j,
                                 int xdim, int m,
                                 const T &xxprod, const T &yyprod,
                                 int ktype, const gentype &weight,
                                 const Vector<gentype> &r, const Vector<int> &ic,
                                 int magterm) const
{
    res = 0.0;

    xygrad        = 0.0;
    diffgrad      = 0.0;
    xnormonlygrad = 0.0;

    xyxygrad     = 0.0;
    diffdiffgrad = 0.0;

    if ( magterm )
    {
        xygrad = 0.0;

        T xres; xres = 0.0;
        T yres; yres = 0.0;

        T ddgrad;         ddgrad         = 0.0;
        T ddiffgrad;      ddiffgrad      = 0.0;
        T ddnormonlygrad; ddnormonlygrad = 0.0;

        T ddiffdiffgrad;      ddiffdiffgrad      = 0.0;
        T dnormdnormonlygrad; dnormdnormonlygrad = 0.0;

        T altdiffis; altdiffis = 0.0;

        T xxgrad; xxgrad = 0.0;
        T yygrad; yygrad = 0.0;

        T xxxxgrad; xxxxgrad = 0.0;
        T yyyygrad; yyyygrad = 0.0;

        d2KKprosingle(xxgrad,ddiffgrad,ddnormonlygrad,xxxxgrad,ddiffdiffgrad,dnormdnormonlygrad,dnormdnormonlygrad,dnormdnormonlygrad,xres,xxprod,altdiffis,i,i,xdim,m,xxprod,xxprod,ktype,1.0_gent,r,ic,0);
        d2KKprosingle(yygrad,ddiffgrad,ddnormonlygrad,yyyygrad,ddiffdiffgrad,dnormdnormonlygrad,dnormdnormonlygrad,dnormdnormonlygrad,yres,yyprod,altdiffis,j,j,xdim,m,yyprod,yyprod,ktype,1.0_gent,r,ic,0);

        (void) ddgrad;
        (void) ddiffgrad;
        (void) ddnormonlygrad;

        (void) ddiffdiffgrad;
        (void) dnormdnormonlygrad;

        res  = xres;
        res *= yres;

        //xygrad  = 0.0;
        //xygrad *= yres;
        
        //diffgrad  = 0.0;
        //diffgrad *= yres;

        xnormonlygrad  = xxgrad;
        xnormonlygrad *= yres;

        //xyxygrad  = 0.0;
        //xyxygrad *= yres;

        //diffdiffgrad  = 0.0;
        //diffdiffgrad *= yres;

        xnormxnormonlygrad  = xxxxgrad;
        xnormxnormonlygrad *= yres;

        xnormynormonlygrad  = xxgrad;
        xnormynormonlygrad *= yygrad;

        //ynormxnormonlygrad  = ??grad;
        //ynormxnormonlygrad *= ??grad;

        ynormynormonlygrad  = xres;
        ynormynormonlygrad *= yyyygrad;

        res                *= (const T &) weight;
        //xygrad             *= (const T &) weight;
        //diffgrad           *= (const T &) weight;
        xnormonlygrad      *= (const T &) weight;
        xyxygrad           *= (const T &) weight;
        diffdiffgrad       *= (const T &) weight;
        xnormxnormonlygrad *= (const T &) weight;
        xnormynormonlygrad *= (const T &) weight;
        //ynormxnormonlygrad *= (const T &) weight;
        ynormynormonlygrad *= (const T &) weight;

        return;
    }

    switch ( ktype )
    {
        case 0:
        {
            // K = r1
            // dK = 0
            // d2K = 0

            res = r(1);

            break;
        }

        case 1:
        {
            // K = z/(r0.r0)
            // dK = 1/(r0.r0)
            // d2K = 0

            res    = xyprod;
            scaldiv(res,r(0));
            scaldiv(res,r(0));

            xygrad = 1.0;
            scaldiv(xygrad,r(0));
            scaldiv(xygrad,r(0));

            break;
        }

        case 2:
        {
            // K = ( r1 + z/(r0.r0) )^i0
            // dK = i0/(r0.r0) * ( r1 + z/(r0.r0) )^(i0-1)               if ( i0 >= 1 )
            // d2K = i0.(i0-1)/(r0.r0.r0.r0) * ( r1 + z/(r0.r0) )^(i0-2) if ( i0 >= 2 )

            T temp(xyprod);

            scaldiv(temp,r(0));
            scaldiv(temp,r(0));
            scaladd(temp,r(1));

            res = temp;
            raiseto(res,ic(0));

            if ( ic(0) >= 1 )
            {
                xygrad = temp;
                raiseto(xygrad,ic(0)-1);
                xygrad *= ic(0);
                scaldiv(xygrad,r(0));
                scaldiv(xygrad,r(0));
            }

            if ( ic(0) >= 2 )
            {
                xyxygrad = temp;
                raiseto(xyxygrad,ic(0)-2);
                xyxygrad *= ic(0)*(ic(0)-1);
                scaldiv(xyxygrad,r(0));
                scaldiv(xyxygrad,r(0));
                scaldiv(xyxygrad,r(0));
                scaldiv(xyxygrad,r(0));
            }

            break;
        }

        case 3:
        {
            // K = exp(-d/(2.r0.r0))
            // dK = -K/(2*r0*r0)
            // d2K = -dK/(2*r0*r0)

            res  = diffis;
            res *= -0.5;
            scaldiv(res,r(0));
            scaldiv(res,r(0));
            res += log(AltDiffNormConst(xdim,m,r(0)));
            scalsub(res,r(1));
            OP_exp(res);

            diffgrad  = res;
            diffgrad *= -0.5;
            scaldiv(diffgrad,r(0));
            scaldiv(diffgrad,r(0));

            diffdiffgrad  = diffgrad;
            diffdiffgrad *= -0.5;
            scaldiv(diffdiffgrad,r(0));
            scaldiv(diffdiffgrad,r(0));

            break;
        }

        case 4:
        {
            // K = exp(-sqrt(d)/r0)
            // dK = -K/(2*r0*sqrt(d))
            // d2K = -dK/(2*r0*sqrt(d)) + K/(4*r0*d*sqrt(d))
            //     = -dK/(2*r0*sqrt(d)) - dK/(2*d)
            //     = -( 1/(r0*sqrt(d)) + 1/d )*dK/2
            //     = -( sqrt(d)/r0 + 1 )*dK/(2.d)
            //
            // At d=0: dK = 0, d2K = 0

            T tmp(diffis);

            OP_sqrt(tmp);

            res = tmp;
            setnegate(res);
            scaldiv(res,r(0));
            scalsub(res,r(1));
            OP_exp(res);

            if ( (double) abs2(diffis) > BADZEROTOL )
            {
                diffgrad = res;
                diffgrad *= -0.5;
                scaldiv(diffgrad,r(0));
                diffgrad /= tmp;

                diffdiffgrad = tmp;
                scaldiv(diffdiffgrad,r(0));
                diffdiffgrad += 1.0;
                diffdiffgrad *= diffgrad;
                diffdiffgrad *= -0.5;
                scaldiv(diffdiffgrad,diffis);
            }

            break;
        }

        case 5:
        {
            // K = exp(-sqrt(d)^r1/(r1*r0^r1))
            // dK = -K*((sqrt(d)^(r1-2))/(2*r0^r1))
            //    = -K*((sqrt(d)^r1)/(2*d*r0^r1))
            // d2K = -dK*((sqrt(d)^(r1-2))/(2*r0^r1)) - K*(r1-2)*((sqrt(d)^(r1-4))/(4*r0^r1))
            //     = -dK*((sqrt(d)^(r1-2))/(2*r0^r1)) - (r1-2)*K*((sqrt(d)^(r1-2))/(4*d*r0^r1))
            //     = -dK*((sqrt(d)^(r1-2))/(2*r0^r1)) + (r1-2)*dK/(2*d)
            //     = -( ((sqrt(d)^(r1-2))/(r0^r1)) - (r1-2)/d )*dK/2
            //     = -( ((sqrt(d)^r1)/(d*r0^r1)) - (r1-2)/d )*dK/2
            //     = -( ((sqrt(d)^r1)/(r0^r1)) - (r1-2) )*dK/(2*d)
            //     = ( -((sqrt(d)^r1)/(r0^r1)) + (r1-2) )*dK/(2*d)
            //
            // At d=0, if r1 < 2: dK = 0, d2K = 0

            T tmpb = pow(sqrt(diffis),(T) r(1));
            T tmpc = pow((T) r(0),(T) r(1));

            res  = tmpb;
            res /= tmpc;
            scaldiv(res,r(1));
            setnegate(res);
            scalsub(res,r(2));
            OP_exp(res);

            if ( ( (double) abs2(diffis) > BADZEROTOL ) || ( (double) abs2(r(1)) >= 2.0 ) )
            {
                // dK = -K*((sqrt(d)^r1)/(2*d*r0^r1))

                diffgrad  = res;
                diffgrad *= tmpb;
                diffgrad *= -0.5;
                diffgrad /= diffis;
                diffgrad /= tmpc;

                // d2K = ( -((sqrt(d)^r1)/(r0^r1)) + (r1-2) )*dK/(2*d)

                diffdiffgrad  = tmpb;
                diffdiffgrad /= tmpc;
                diffdiffgrad *= -1.0;
                scaladd(diffdiffgrad,r(1));
                diffdiffgrad -= 2.0;
                diffdiffgrad *= diffgrad;
                diffdiffgrad *= 0.5;
                diffdiffgrad /= diffis;
            }

            break;
        }

        case 7:
        {
            // K = tanh( z/(r0.r0) + r1 )
            // dK = 1/(r0.r0) * sech^2( z/(r0.r0) + r1 )
            // d2K = -2.sech( z/(r0.r0) + r1 ).sech( z/(r0.r0) + r1).tanh( z/(r0.r0) + r1)/(r0.r0.r0.r0)
            //     = -2.sech^2( z/(r0.r0) + r1 ).tanh( z/(r0.r0) + r1)/(r0.r0.r0.r0)
            //     = -2.dK.K/(r0.r0)

            res = xyprod;
            scaldiv(res,r(0));
            scaldiv(res,r(0));
            scaladd(res,r(1));
            OP_tanh(res);

            xygrad = xyprod;
            scaldiv(xygrad,r(0));
            scaldiv(xygrad,r(0));
            scaladd(xygrad,r(1));
            OP_sech(xygrad);
            xygrad *= xygrad;
            scaldiv(xygrad,r(0));
            scaldiv(xygrad,r(0));

            xyxygrad  = xygrad;
            xyxygrad *= res;
            scaldiv(xyxygrad,r(0));
            scaldiv(xyxygrad,r(0));
            xyxygrad *= -2.0;

            break;
        }

        case 8:
        {
            // K = ( 1 + d/(2*r0*r0*r1) )^(-r1)
            // dK = -(( 1 + d/(2*r0*r0*r1) )^(-r1-1))/(2*r0*r0)
            //    = -K/(2*r0*r0*( 1 + d/(2*r0*r0*r1) ))
            // d2K = (r1-1).(( 1 + d/(2*r0*r0*r1) )^(-r1-2))/(4*r0*r0*r0*r0*r1)
            //     = (r1-1).(( 1 + d/(2*r0*r0*r1) )^(-r1))/(2*r0*r0*( 1 + d/(2*r0*r0*r1) )*2*r0*r0*( 1 + d/(2*r0*r0*r1) )*r1)
            //     = -(r1-1).dK/(2*r0*r0*( 1 + d/(2*r0*r0*r1) )*r1)

            //OLD     8  | Rational quadratic     | 1 - d/(d+r0)
            //OLD     8  | Rational quadratic     | -1/(d+r0) + d/(d+r0)^2 = -K(x,y)/(d+r0)
            //OLD     8  | Rational quadratic     | K(x,y)/((d+r0)^2) - K(x,y)/((d+r0)^2) = 0

            T tmp;

            tmp  = diffis;
            tmp *= 0.5;
            scaldiv(tmp,r(0));
            scaldiv(tmp,r(0));
            scaldiv(tmp,r(1));
            tmp += 1.0;

            res = pow(tmp,-((T) r(1)));

            xygrad  = res;
            xygrad *= -0.5;
            scaldiv(xygrad,r(0));
            scaldiv(xygrad,r(0));
            xygrad /= tmp;

            xyxygrad  = xygrad;
            xyxygrad *= ((T) res)-1.0;
            xyxygrad *= -0.5;
            scaldiv(xyxygrad,r(0));
            scaldiv(xyxygrad,r(0));
            scaldiv(xyxygrad,r(1));
            xyxygrad /= tmp;

//OLD            res = diffis;
//OLD            scaldiv(res,(diffis+r(0)));
//OLD            setnegate(res);
//OLD            res += 1.0;
//OLD
//OLD            xygrad = 0.0;
//OLD
//OLD            diffgrad = res;
//OLD            setnegate(diffgrad);
//OLD            scaldiv(res,(diffis+r(0)));

            break;
        }

        case 9:
        {
            // K = sqrt( d + r1^2 )
            // dK = 1/(2.K)
            // d2K = -1/(4.K^3)
            //
            // if d + r1^2 = 0 then dk,d2K = 0
            //
            // d -> d/(r0.r0) blah blah

            res = diffis;
            scaldiv(res,r(0));
            scaldiv(res,r(0));
            scaladd(res,r(1),r(1));
            OP_sqrt(res);

            if ( (double) abs2(res) > 1e-24 )
            {
                diffgrad  = res;
                diffgrad *= 2.0;
                OP_einv(diffgrad);
                scaldiv(diffgrad,r(0));
                scaldiv(diffgrad,r(0));

                diffdiffgrad  = res;
                diffdiffgrad *= res;
                diffdiffgrad *= res;
                diffdiffgrad *= 4.0;
                OP_einv(diffdiffgrad);
                diffdiffgrad *= -1.0;
                scaldiv(diffdiffgrad,r(0));
                scaldiv(diffdiffgrad,r(0));
                scaldiv(diffdiffgrad,r(0));
                scaldiv(diffdiffgrad,r(0));
            }

            break;
        }

        case 10:
        {
            // K = 1/sqrt( d + r1^2 )
            // dK = -(K^3)/2
            // d2K = 3.(K^5)/4
            //
            // Ill-defined as d + r0^2 -> 0
            //
            // d -> d/(r0.r0) blah blah

            res = diffis;
            scaldiv(res,r(0));
            scaldiv(res,r(0));
            scaladd(res,r(1),r(1));
            OP_sqrt(res);
            OP_einv(res);

            diffgrad  = res;
            diffgrad *= res;
            diffgrad *= res;
            diffgrad *= -2.0;
            OP_einv(diffgrad);
            scaldiv(diffgrad,r(0));
            scaldiv(diffgrad,r(0));

            diffdiffgrad  = res;
            diffdiffgrad *= res;
            diffdiffgrad *= res;
            diffdiffgrad *= res;
            diffdiffgrad *= res;
            diffdiffgrad *= 4.0;
            OP_einv(diffdiffgrad);
            diffdiffgrad *= 3.0;
            scaldiv(diffdiffgrad,r(0));
            scaldiv(diffdiffgrad,r(0));
            scaldiv(diffdiffgrad,r(0));
            scaldiv(diffdiffgrad,r(0));

            break;
        }

        case 11:
        {
            // K = 2/pi * arccos(-sqrt(d)/r0) - 2/pi * sqrt(d)/r0 * sqrt(1 - d/r0^2)
            // dK = ( 2/pi * 1/sqrt(1 - d/r0^2) - 2/pi * sqrt(1 - d/r0^2) - 1/pi * sqrt(d)/r0 * 1/sqrt(1 - d/r0^2) * -2 sqrt(d)/r0 ) * 1/(2*r0*sqrt(d))
            //    = ( 2/pi * 1/sqrt(1 - d/r0^2) - 2/pi * sqrt(1 - d/r0^2) + 2/pi * d/r0^2 * 1/sqrt(1 - d/r0^2) ) * 1/(2*r0*sqrt(d))
            //    = ( 1/sqrt(1 - d/r0^2) - sqrt(1 - d/r0^2) + d/r0^2 * 1/sqrt(1 - d/r0^2) ) * 1/(pi*r0*sqrt(d))
            //    = ( 1 - 1 + d/r0^2 + d/r0^2 ) * 1/(pi*r0*sqrt(d)*sqrt(1 - d/r0^2))
            //    = ( d/r0^2 + d/r0^2 ) * 1/(pi*r0*sqrt(d)*sqrt(1 - d/r0^2))
            //    = d/r0^2 * 2/(pi*r0*sqrt(d)*sqrt(1 - d/r0^2))
            //    = sqrt(d)/r0^2 * 2/(pi*r0*sqrt(1 - d/r0^2))
            //    = 2/pi 1/r0^2 sqrt(d)/r0 * 1/sqrt(1 - d/r0^2)
            // d2K = 2/pi 1/r0^2 ( 1/sqrt(1 - d/r0^2) - 1/2 sqrt(d)/r0 1/(1 - d/r0^2)^(3/2) -2 sqrt(d)/r0 ) 1/(2*r0*sqrt(d))
            //     = 2/pi 1/r0^2 ( 1 - d/r0^2 + d/r0^2 ) 1/(2*r0*sqrt(d)) 1/(1 - d/r0^2) 1/sqrt(1 - d/r0^2)
            //     = 2/pi 1/r0^2 1/(2*r0*sqrt(d)) 1/(1 - d/r0^2) 1/sqrt(1 - d/r0^2)
            //     = 2/pi 1/r0^2 1/(2*r0^2*sqrt(d)/r0) 1/(1 - d/r0^2) 1/sqrt(1 - d/r0^2)
            //     = 1/pi 1/r0^4 1/(sqrt(d)/r0) 1/(1 - d/r0^2) 1/sqrt(1 - d/r0^2)

            T tempres(diffis);
            OP_sqrt(tempres);
            scaldiv(tempres,r(0));
            tempres *= -1.0;

            T tempsq(tempres);
            tempsq *= tempsq;
            tempsq *= -1.0;
            tempsq += 1.0;
            OP_sqrt(tempsq);

            if ( (double) abs2(tempres) < 1.0 )
            {
                // K = 2/pi * arccos(-sqrt(d)/r0) - 2/pi * sqrt(d)/r0 * sqrt(1 - d/r0^2)

                res  = tempsq;
                res *= tempres;
                res += acos(tempres);
                res *= NUMBASE_2ONPI;

                //    = 2/pi 1/r0^2 sqrt(d)/r0 * 1/sqrt(1 - d/r0^2)

                diffgrad  = tempsq;
                OP_einv(diffgrad);
                diffgrad *= tempres;
                res *= NUMBASE_2ONPI;
                scaldiv(diffgrad,r(0));
                scaldiv(diffgrad,r(0));

                //     = 1/pi 1/r0^4 1/(sqrt(d)/r0) 1/sqrt(1 - d/r0^2)^3

                diffdiffgrad  = tempsq;
                diffdiffgrad *= tempsq;
                diffdiffgrad *= tempsq;
                diffdiffgrad /= tempres;
                diffdiffgrad /= NUMBASE_PI;
                scaldiv(diffdiffgrad,r(0));
                scaldiv(diffdiffgrad,r(0));
                scaldiv(diffdiffgrad,r(0));
                scaldiv(diffdiffgrad,r(0));
            }

            break;
        }

        case 12:
        {
            // K = 1 - 3/2 * sqrt(d)/r0 + 1/2 * sqrt(d)^3/r0^3
            // dK = ( 3/2 + 3/2 * (sqrt(d)/r0)^2 ) 1/(2*sqrt(d)*r0)
            //    = ( 3/2 + 3/2 * (sqrt(d)/r0)^2 ) 1/2 1/r0^2 r0/sqrt(d)
            //    = 3/4 1/r0^2 ( (sqrt(d)/r0)^{-1} + sqrt(d)/r0 )
            // d2K = 3/4 1/r0^2 ( 1 - (sqrt(d)/r0)^{-2} ) 1/(2*sqrt(d)*r0)
            //     = 3/4 1/r0^2 ( 1 - (sqrt(d)/r0)^{-2} ) 1/2 1/r0^2 r0/sqrt(d)
            //     = 3/8 1/r0^4 ( (sqrt(d)/r0)^{-1} - (sqrt(d)/r0)^{-3} )

            T tempres(diffis);
            OP_sqrt(tempres);
            scaldiv(tempres,r(0));

            // K = 1 - 3/2 * sqrt(d)/r0 + 1/2 * sqrt(d)^3/r0^3

            res = tempres;
            res *= tempres;
            res *= tempres;
            res /= 2.0;
            res *= 0.6666666666666666666666;
            res -= tempres;
            res /= 0.6666666666666666666666;
            res += 1.0;

            //    = 3/4 1/r0^2 ( (sqrt(d)/r0)^{-1} + sqrt(d)/r0 )

            diffgrad  = tempres;
            OP_einv(diffgrad);
            diffgrad += tempres;
            diffgrad *= 0.75;
            scaldiv(diffgrad,r(0));
            scaldiv(diffgrad,r(0));

            //     = 3/8 1/r0^4 ( (sqrt(d)/r0)^{-1} - (sqrt(d)/r0)^{-3} )

            OP_einv(tempres);
            diffdiffgrad  = tempres;            
            diffdiffgrad *= tempres;            
            diffdiffgrad -= 1.0;            
            diffdiffgrad *= tempres;            
            diffdiffgrad *= -1.0;            
            diffdiffgrad *= 3.0/8.0;
            scaldiv(diffdiffgrad,r(0));
            scaldiv(diffdiffgrad,r(0));
            scaldiv(diffdiffgrad,r(0));
            scaldiv(diffdiffgrad,r(0));

            break;
        }

        case 13:
        {
            // K = sinc(sqrt(d)/r0)
            // dK = ( cos(sqrt(d)/r0) - K )/(2*r0*sqrt(d))
            // d2K = ( -sin(sqrt(d)/r0)/(2*r0*sqrt(d)) - dK )/(2*r0*sqrt(d)) - ( cos(sqrt(d)/r0) - K )/(4*r0*d*sqrt(d))
            //     = ( -K/(2*r0^2) - dK )/(2*r0*sqrt(d)) - dK/(2*d)
            //     = ( -K/(2*r0^2) - dK )/(2*r0*sqrt(d)) - ( dK*(2*r0*sqrt(d))/(2*d) )/(2*r0*sqrt(d))
            //     = ( -K/(2*r0^2) - dK*( 1 + r0/sqrt(d) ) )/(2*r0*sqrt(d))
            //     = ( -K/(2*r0^2) - dK*( sqrt(d) + r0 )/sqrt(d) )/(2*r0*sqrt(d))
            //     = ( -K - dK*(2*r0^2)*( sqrt(d) + r0 )/sqrt(d) )/(4*(r0^3)*sqrt(d))
            //     = -( K + dK*(2*r0^2)*( sqrt(d) + r0 )/sqrt(d) )/(4*(r0^3)*sqrt(d))
            //
            // if d = 0 then dK,d2K = 0

            T tmp(diffis);

            OP_sqrt(tmp);

            T tmpb(tmp);

            scaldiv(tmpb,r(0));

            res = tmpb;
            OP_sinc(res);

            if ( (double) tmpb > BADZEROTOL )
            {
                diffgrad  = tmpb;
                OP_cos(diffgrad);
                diffgrad -= res;
                diffgrad *= 0.5;
                scaldiv(diffgrad,r(0));
                diffgrad /= tmp;

                diffdiffgrad  = tmp;
                scaladd(diffdiffgrad,r(0));
                diffdiffgrad *= diffgrad;
                diffdiffgrad *= 2.0;
                scalmul(diffdiffgrad,r(0));
                scalmul(diffdiffgrad,r(0));
                diffdiffgrad /= tmp;
                diffdiffgrad += res;
                diffgrad *= -0.25;
                scaldiv(diffdiffgrad,r(0));
                scaldiv(diffdiffgrad,r(0));
                scaldiv(diffdiffgrad,r(0));
                diffdiffgrad /= tmp;
            }

            break;
        }

        case 14:
        {
            // K = -sqrt(d)^r1
            // dK = -(r1*sqrt(d)^(r1-2))/2 
            //    = -(r1*sqrt(d)^r1)/(2*d) 
            //    = (r1*K)/(2*d) 
            //    = r1*K/(2*d)
            // d2K = -(r1*(r1-2)*sqrt(d)^(r1-4))/4
            //     = -(r1*(r1-2)*sqrt(d)^r1)/(4*d^2)
            //     = (r1*(r1-2)*K)/(4*d^2)
            //     = (r1-2)*dK/(2*d)
            //
            // if d = 0 then dK,d2K = 0

            res  = diffis;
            scaldiv(res,r(0));
            scaldiv(res,r(0));
            OP_sqrt(res);
            res  = pow(res,(T) r(1));
            res *= -1.0;

            if ( (double) abs2(diffis) > BADZEROTOL )
            {
                diffgrad  = res;
                scalmul(diffgrad,r(1));
                diffgrad *= -0.5;
                diffgrad /= diffis;
                scaldiv(diffgrad,r(0));
                scaldiv(diffgrad,r(0));

                diffdiffgrad  = diffgrad;
                scalmul(diffdiffgrad,((T) r(1))-2.0);
                diffdiffgrad *= -0.5;
                diffdiffgrad /= diffis;
                scaldiv(diffdiffgrad,r(0));
                scaldiv(diffdiffgrad,r(0));
            }

            break;
        }

        case 15:
        {
            // K = -log(sqrt(d)^r1 + 1)
            // dK = -(r1.sqrt(d)^(r1-2))/(2*(sqrt(d)^r1 + 1))
            // d2K = -(r1.(r1-2).sqrt(d)^(r1-4))/(4.(sqrt(d)^r1 + 1)) + ((r1.sqrt(d)^(r1-2))^2)/((2*(sqrt(d)^r1 + 1))^2)
            //     = -(r1-2)*dK/(2*d) + dK^2
            //     = dK*( dK - (r1-2)/(2*d) )

            T tmpa(diffis);

            scaldiv(tmpa,r(0));
            scaldiv(tmpa,r(0));

            OP_sqrt(tmpa);

            T tmpb;

            tmpb = pow(tmpa,(T) r(1));
            tmpb += 1.0;

            res = tmpb;
            OP_log(res);
            setnegate(res);

            diffgrad = pow(tmpb,((T) r(1))-2.0);
            scalmul(diffgrad,r(1));
            diffgrad *= -0.5;
            diffgrad /= tmpb;
            scaldiv(diffgrad,r(0));
            scaldiv(diffgrad,r(0));

            diffdiffgrad = (T) r(1);
            diffdiffgrad -= 2.0;
            diffdiffgrad *= -0.5;
            diffdiffgrad /= diffis;
            diffdiffgrad += diffgrad;
            diffdiffgrad *= diffgrad;
            scaldiv(diffdiffgrad,r(0));
            scaldiv(diffdiffgrad,r(0));

            break;
        }

        case 19:
        {
            // K = 1/(1+(d/(r0.r0)))
            // dK = -K^2/(r0.r0)
            // d2K = 2*K^3/r0^4
            //     = -2*dK*K/(r0*r0)

            res = diffis;
            scaldiv(res,r(0));
            scaldiv(res,r(0));
            res += 1.0;
            OP_einv(res);

            diffgrad  = res;
            diffgrad *= res;
            diffgrad *= -1.0;
            scaldiv(diffgrad,r(0));
            scaldiv(diffgrad,r(0));

            diffdiffgrad = diffgrad;
            diffdiffgrad *= res;
            diffdiffgrad *= -2.0;
            scaldiv(diffdiffgrad,r(0));
            scaldiv(diffdiffgrad,r(0));

            break;
        }

        case 23:
        {
            // K = 1/(1+(sqrt(d)/r0)^r1)
            // dK = -r1/(2.r0) * (sqrt(d)/r0)^(r1-2) * K^2
            // d2K = ( -r1/(4.r0^2) * (r1-2) * (sqrt(d)/r0)^(r1-4) * K^2 ) + ( -r1/(2.r0) * (sqrt(d)/r0)^(r1-2) * 2 * K * dK )
            //     = ( -r1/(2.r0^2) * (sqrt(d)/r0)^(r1-2) * K^2 * (r1-2)/(2*d/r0) ) + ( -r1/(2.r0) * (sqrt(d)/r0)^(r1-2) * K^2 * dK/(2*K) )
            //     = ( -r1/(2.r0) * (sqrt(d)/r0)^(r1-2) * K^2 * (r1-2)/(2*d) ) + ( -r1/(2.r0) * (sqrt(d)/r0)^(r1-2) * K^2 * dK/(2*K) )
            //     = ( dK*(r1-2)/(2*d) ) + ( dK^2/(2*K) )
            //     = ( dK*(r1-2)/(2*d) ) + ( d*dK*dK/(2*d*K) )
            //     = ( (r1-2) + d*dK/K )*dK/(2*d)

            T tmp(diffis);

            OP_sqrt(tmp);
            scaldiv(tmp,r(0));

            res  = pow(tmp,(T) r(1));
            res += 1.0;
            OP_einv(res);

            T tmpb;
            tmpb = pow(tmp,(T) r(1)-2.0);

            diffgrad  = res;
            diffgrad *= res;
            diffgrad *= -0.5;
            scaldiv(diffgrad,r(0));
            scalmul(diffgrad,r(1));
            diffgrad *= tmpb;

            diffdiffgrad  = diffgrad;
            diffdiffgrad /= res;
            diffdiffgrad *= diffis;
            scaladd(diffdiffgrad,r(1));
            diffdiffgrad -= 2.0;
            diffdiffgrad *= diffgrad;
            diffdiffgrad *= 0.5;
            diffdiffgrad /= diffis;

            break;
        }

        case 24:
        {
            // K = (1-(z^i0))/(1-z)
            // dK = ( -i0.(z^(i0-1)) + (1-(z^i0))/(1-z) )/(1-z) 
            //    = ( -i0.(z^i0)/z + K )/(1-z)                         if ( i0 >= 1 )
            // d2K = ( -i0.(i0-1).(z^(i0))/z^2 + dK )/(1-z) + dK/(1-z)
            //     = ( -i0.(i0-1).(z^(i0))/z^2 + 2*K )/(1-z)           if ( i0 >= 2 )
            //
            // Ill-defined at z = 1
            //
            // z -> z/(r0.r0) and blah blah

            T zsc(xyprod);

            scaldiv(zsc,r(0));
            scaldiv(zsc,r(0));

            if ( ( (double) abs2(zsc) > BADZEROTOL ) || ( ic(0) == 0 ) )
            {
                T tmp = zsc;

                raiseto(tmp,ic(0));

                res  = 1.0;
                res -= tmp;
                res /= (1.0-zsc);
            }

            if ( ( (double) abs2(zsc) > BADZEROTOL ) || ( ic(0) == 1 ) )
            {
                T tmp = zsc;

                raiseto(tmp,ic(0)-1);

                xygrad  = tmp;
                xygrad *= -ic(0);
                xygrad += res;
                xygrad /= (1.0-zsc);
                scaldiv(xygrad,r(0));
                scaldiv(xygrad,r(0));
            }

            if ( ( (double) abs2(zsc) > BADZEROTOL ) || ( ic(0) == 2 ) )
            {
                T tmp = xyprod;

                raiseto(tmp,ic(0)-2);

                xyxygrad  = tmp;
                xyxygrad *= -ic(0)*(ic(0)-1);
                xyxygrad += res;
                xyxygrad += res;
                xyxygrad /= (1.0-zsc);
                scaldiv(xyxygrad,r(0));
                scaldiv(xyxygrad,r(0));
                scaldiv(xyxygrad,r(0));
                scaldiv(xyxygrad,r(0));
            }

            break;
        }

        case 25:
        {
            // K = pi.cosh(pi-(sqrt(d)/r0))
            // dK = -pi/(2.r0) * sinh(pi-sqrt(d)/r0) / sqrt(d)
            // d2K = pi^2/(4.r0*r0) * cosh(pi-sqrt(d)/r0) / d  - 1/2d dK
            //     = pi/(4.r0*r0) * K / d  - 1/2d dK
            //     = ( pi*K/(2.r0*r0) - dK )/(2*d)

            T tmp(diffis);

            OP_sqrt(tmp);

            res  = tmp;
            scaldiv(res,r(0));
            res -= NUMBASE_PI;
            res *= -1.0;
            OP_cosh(res);
            res *= NUMBASE_PI;

            diffgrad  = tmp;
            scaldiv(diffgrad,r(0));
            diffgrad -= NUMBASE_PI;
            diffgrad *= -1.0;
            OP_sinh(diffgrad);
            diffgrad *= NUMBASE_PION2;            
            diffgrad *= -0.5;
            scaldiv(diffgrad,r(0));
            diffgrad /= tmp;

            diffdiffgrad  = res;
            diffdiffgrad *= NUMBASE_PI;
            diffdiffgrad *= 0.5;
            scaldiv(diffdiffgrad,r(0));
            scaldiv(diffdiffgrad,r(0));
            diffdiffgrad -= diffgrad;
            diffdiffgrad *= 0.5;
            diffdiffgrad /= diffis;

            break;
        }

        case 26:
        {
            // K = ((d/r0)^(r1+0.5))
            // dK = 1/r0 * (r1+0.5) * (d/r0)^(r1-0.5)
            //    = 1/r0 * (r1+0.5) * K/d
            // d2K = 1/r0^2 * (r1+0.5) * (r1-0.5) * (d/r0)^(r1-1.5)
            //     = 1/r0 * (r1-0.5) * dK/d

            res  = diffis;
            scaldiv(res,r(0));
            res  = pow(res,((T) r(1))+0.5);

            if ( (double) abs2(diffis) > BADZEROTOL )
            {
                diffgrad = 0.5;
                scaladd(diffgrad,r(1));
                scaldiv(diffgrad,r(0));
                diffgrad *= res;
                diffgrad /= diffis;

                diffdiffgrad = -0.5;
                scaladd(diffdiffgrad,r(1));
                scaldiv(diffdiffgrad,r(0));
                diffdiffgrad *= diffgrad;
                diffdiffgrad /= diffis;
            }

            break;
        }

        case 27:
        {
            // K = ((d/r0)^r1).ln(sqrt(d/r0))
            // dK = (r1/r0).((d/r0)^(r1-1)).ln(sqrt(d/r0)) + ((d/r0)^r1) 1/(sqrt(d/r0)) 1/2 1/sqrt(d*r0)
            //    = (r1/r0).((d/r0)^r1).ln(sqrt(d/r0)).(r0/d) + ((d/r0)^r1)/(2d)
            //    = 2.r1.((d/r0)^r1).ln(sqrt(d/r0))/(2d) + ((d/r0)^r1)/(2d)
            //    = ( 2.r1.ln(sqrt(d/r0)) + 1 ).((d/r0)^r1)/(2d)
            //    = ( ln(sqrt(d/r0)) + 1/(2.r1) ).((d/r0)^r1).(2.r1)/(2d)
            //    = ( ((d/r0)^r1).ln(sqrt(d/r0)) + ((d/r0)^r1)/(2.r1) ).(2.r1)/(2d)
            //    = ( K + ((d/r0)^r1)/(2.r1) ).(2.r1)/(2d)
            // d2K = ( dK + r1/d ((d/r0)^r1)/(2.r1) ).(2.r1)/(2d)  -  ( K + ((d/r0)^r1)/(2.r1) ).(2.r1)/(2d^2) 
            // d2K = ( dK + r1/d ((d/r0)^r1)/(2.r1) ).(2.r1)/(2d)  - 2*( K + ((d/r0)^r1)/(2.r1) ).(2.r1)/((2d)*(2d)) 
            // d2K = ( dK + r1/d ((d/r0)^r1)/(2.r1) ).(2.r1)/(2d)  - (2*dK/(2.r1)).(2.r1)/(2d) 
            // d2K = ( dK + r1/d ((d/r0)^r1)/(2.r1) - 2*dK/(2.r1) ).(2.r1)/(2d) 
            // d2K = ( ( 1 - 1/r1 ).dK + r1/d ((d/r0)^r1)/(2.r1) ).(2.r1)/(2d) 
            // d2K = ( dK + r1*((d/r0)^r1)/(2*(r1-1)*d) )*(2*(r1-1))/(2d) 

            T scalres(diffis);

            scaldiv(scalres,r(0));
            OP_sqrt(scalres);

            T tempres(scalres);

            OP_log(tempres);

            scalres = pow(scalres,(T) r(1));

            res  = scalres;
            res *= tempres;

            if ( (double) abs2(diffis) > BADZEROTOL )
            {
                diffgrad  = scalres;
                diffgrad *= 0.5;
                scaldiv(diffgrad,r(1));
                diffgrad += res;
                diffgrad *= 2;
                scalmul(diffgrad,r(1));
                diffgrad *= 0.5;
                diffgrad /= diffis;

                diffdiffgrad = scalres;
                scalmul(diffdiffgrad,r(1));
                diffdiffgrad *= 0.5;
                diffdiffgrad /= diffis;
                scaldiv(diffdiffgrad,r(1)-1.0);
                diffdiffgrad += diffgrad;
                scalmul(diffdiffgrad,r(1)-1.0);
                diffdiffgrad /= diffis;
            }

            break;
        }

        case 32:
        {
            // K = r1 if i == j >= 0, 0 otherwise
            // dK = 0.0
            // d2K = 0.0

            if ( ( i == j ) && ( i >= 0 ) )
            {
                res = r(1);
            }

            break;
        }

        case 33:
        {
            // K = 1/(2.r0) ( 1 if real(sqrt(d)) < r0, 0 otherwise )
            // dK = 0
            // d2K = 0

            //if ( real(sqrt(diffis)-r(0)) < zerogentype() )
            if ( real(sqrt(diffis)-r(0)) < 0.0_gent )
            {
                res = 0.5/r(0);
            }

            break;
        }

        case 34:
        {
            // K = (1-sqrt(d)/r0)/r0 if real(sqrt(d)) < r0, 0 otherwise )
            // dK = 1/r0 1/(2*sqrt(d)*r0)
            //    = 1/r0 1/2 1/r0^2 r0/sqrt(d)
            //    = 1/r0^3 1/2 r0/sqrt(d)
            // d2k = 1/r0 1/2 1/r0^2 -1/2 r0/sqrt(d) 1/d
            //     = -1/r0^3 1/4 r0/sqrt(d) 1/d

            T tempres(diffis);
            OP_sqrt(tempres);
            scaldiv(tempres,r(0));

            if ( (double) real(tempres-1.0) < 0.0 )
            {
                res  = 1.0;
                res -= tempres;
                scaldiv(res,r(0));

                diffgrad = tempres;
                OP_einv(diffgrad);
                diffgrad /= 2.0;
                scaldiv(diffgrad,r(0));
                scaldiv(diffgrad,r(0));
                scaldiv(diffgrad,r(0));

                diffdiffgrad = tempres;
                OP_einv(diffdiffgrad);
                diffdiffgrad /= diffis;
                diffdiffgrad /= -4.0;
                scaldiv(diffdiffgrad,r(0));
                scaldiv(diffdiffgrad,r(0));
                scaldiv(diffdiffgrad,r(0));
            }

            break;
        }

        case 38:
        {
            // K = exp(-sqrt(d)/r0)
            // dK = 1/r0^2 -r0/sqrt(d) exp(-sqrt(d)/r0)
            //    = 1/r0^2 -r0/sqrt(d) K
            // d2K = 1/r0 1/2 1/d 1/sqrt(d) exp(-sqrt(d)/r0) + 1/r0^2 1/d exp(-sqrt(d)/r0)
            //     = 1/r0^4 1/2 r0^2/d r0/sqrt(d) exp(-sqrt(d)/r0) + 1/r0^4 ro^2/d exp(-sqrt(d)/r0)
            //     = 1/r0^4 r0^2/d exp(-sqrt(d)/r0) ( 1/2 r0/sqrt(d) + 1 )
            //     = 1/2 1/r0^2 -r0/sqrt(d) dK ( 2 - r0/sqrt(d) )

            T tempres(diffis);
            OP_sqrt(tempres);
            scaldiv(tempres,r(0));
            tempres *= -1.0;

            res = tempres;
            OP_exp(res);

            diffgrad  = res;
            diffgrad *= tempres;
            scaldiv(diffgrad,r(0));
            scaldiv(diffgrad,r(0));

            diffdiffgrad  = tempres;
            diffdiffgrad += 2.0;
            diffdiffgrad *= diffgrad;
            diffdiffgrad *= tempres;
            scaldiv(diffdiffgrad,r(0));
            scaldiv(diffdiffgrad,r(0));
            diffdiffgrad *= 0.5;

            break;
        }

        case 39:
        {
            // K = (1+((sqrt(3)/r0).sqrt(d))) . exp(-(sqrt(3)/r0).sqrt(d))
            // dK = ( exp( -sqrt(3)/r0 sqrt(d) ) - ( 1 + sqrt(3)/r0 sqrt(d) ) exp( -sqrt(3)/r0 sqrt(d) ) ) sqrt(3)/r0 1/2 1/sqrt(d)
            //    = -((sqrt(3)/r0).sqrt(d)) exp(-((sqrt(3)/r0).sqrt(d))) sqrt(3)/r0 1/2 1/sqrt(d)
            //    = -1/2 3/r0^2 exp(-((sqrt(3)/r0).sqrt(d)))
            //    = -3/2 1/r0^2 exp(-((sqrt(3)/r0).sqrt(d)))
            // d2K = -3/2 1/r0^2 -sqrt(3)/r0 1/sqrt(d) exp(-((sqrt(3)/r0).sqrt(d)))
            //     = (3.sqrt(3))/2 1/r0^3 1/sqrt(d) exp(-((sqrt(3)/r0).sqrt(d)))
            //     = (3.3)/2 1/r0^4 r0/sqrt(3).sqrt(d) exp(-((sqrt(3)/r0).sqrt(d)))
            //     = 3/2 1/r0^4 1/((sqrt(3)/r0).sqrt(d)) exp(-((sqrt(3)/r0).sqrt(d)))
            //     = 1/r0^2 1/((sqrt(3)/r0).sqrt(d)) 3/2 1/r0^2 exp(-((sqrt(3)/r0).sqrt(d)))
            //     = -1/r0^2 1/((sqrt(3)/r0).sqrt(d)) dK

            T tempres(diffis);
            OP_sqrt(tempres);
            scaldiv(tempres,r(0));
            tempres *= sqrt(3.0);

            T expres(tempres);
            expres *= -1.0;
            OP_exp(expres);

            res  = tempres;
            res += 1;
            res *= expres;

            diffgrad  = expres;
            diffgrad *= -1.5;
            scaldiv(diffgrad,r(0));
            scaldiv(diffgrad,r(0));
            
            diffdiffgrad  = diffgrad;
            diffdiffgrad /= tempres;
            scaldiv(diffdiffgrad,r(0));
            scaldiv(diffdiffgrad,r(0));

            break;
        }

        case 42:
        {
            // K = agd(z/(r0.r0))
            // dK = (1/(r0.r0)) sec^2(z/(r0.r0)) / ( 1 - tan^2(z/(r0.r0)) )
            // d2K = (2/(r0.r0.r0.r0)) sec^2(z/(r0.r0)) tan(z/(r0.r0)) / ( 1 - tan^2(z/(r0.r0)) ) + (2/(r0.r0.r0.r0)) sec^4(z/(r0.r0)) tan(z/(r0.r0)) / ( 1 - tan^2(z/(r0.r0)) )^2
            // d2K = (2/(r0.r0.r0.r0)) tan(z/(r0.r0)) sec^2(z/(r0.r0)) / ( 1 - tan^2(z/(r0.r0)) ) + (2/(r0.r0.r0.r0)) tan(z/(r0.r0)) sec^4(z/(r0.r0)) / ( 1 - tan^2(z/(r0.r0)) )^2
            // d2K = (2/(r0.r0)) tan(z/(r0.r0)) dK + (2/(r0.r0)) tan(z/(r0.r0)) dK^2
            // d2K = (2/(r0.r0)) tan(z/(r0.r0)) dK ( 1 + dK )

            T scalres = diffis;
            scaldiv(scalres,r(0));
            scaldiv(scalres,r(0));

            T scz = scalres;
            OP_sec(scz);
            scz *= scz;

            T taz = scalres;
            OP_tan(taz);

            res = scalres;
            OP_agd(res);

            xygrad  = taz;
            xygrad *= taz;
            xygrad *= -1.0;
            xygrad += 1.0;
            OP_einv(xygrad);
            xygrad *= scz;
            scaldiv(xygrad,r(0));
            scaldiv(xygrad,r(0));

            xyxygrad  = xygrad;
            xyxygrad += 1.0;
            xyxygrad *= xygrad;
            xyxygrad *= taz;
            xyxygrad *= 2.0;
            scaldiv(xyxygrad,r(0));
            scaldiv(xyxygrad,r(0));

            break;
        }

        case 43:
        {
            // K = log((1+r0.z)/(1-r0.z))
            // dK = r0*(1-r0.z)/(1+r0.z)*( 1/(1-r0.z) + (1+r0.z)/(1-r0.z)^2 )
            //    = r0*(1-r0.z)/(1+r0.z)*( (1-r0.z) + (1+r0.z) )/(1-r0.z)^2
            //    = r0*((1-r0.z)/(1+r0.z))/(1-r0.z)^2
            //    = r0/((1+r0.z)*(1-r0.z))
            // d2K = -r0*r0*( (1-r0.z) - (1+r0.z) )/((1+r0.z)^2*(1-r0.z)^2)
            //     = -2*r0*r0*( r0.z )/((1+r0.z)^2*(1-r0.z)^2)
            //     = -2*r0^3*z/((1+r0.z)^2*(1-r0.z)^2)
            //     = -2*r0*z*dK^2
            // ADDENDUM: r0 -> 1/(r0.r0)

            T tempa = xyprod;

            tempa  = xyprod;
            scaldiv(tempa,r(0));
            scaldiv(tempa,r(0));

            T tempb = tempa;

            tempa += 1.0;
            tempb -= 1.0;

            res  = tempa;
            res /= tempb;
            OP_log(res);

            xygrad  = tempa;
            xygrad *= tempb;
            OP_einv(xygrad);
            scaldiv(xygrad,r(0));
            scaldiv(xygrad,r(0));

            xyxygrad  = -2.0;
            scaldiv(xyxygrad,r(0));
            scaldiv(xyxygrad,r(0));
            xyxygrad  = xyprod;
            xyxygrad  = xygrad;
            xyxygrad  = xygrad;

            break;
        }

        case 44:
        {
            // K = exp(z/(r0.r0))
            // dK = K/(r0.r0)
            // d2K = dK/(r0.r0)

            res = xyprod;
            scaldiv(res,r(0));
            scaldiv(res,r(0));
            scalsub(res,r(1));
            OP_exp(res);

            xygrad = res;
            scaldiv(xygrad,r(0));
            scaldiv(xygrad,r(0));

            xyxygrad = xygrad;
            scaldiv(xyxygrad,r(0));
            scaldiv(xyxygrad,r(0));

            break;
        }

        case 45:
        {
            // K = sinh(z/(r0.r0))
            // dK = cosh(z/(r0.r0))/(r0.r0)
            // d2K = K/(r0.r0.r0.r0)

            res = xyprod;
            scaldiv(res,r(0));
            scaldiv(res,r(0));
            OP_sinh(res);

            xygrad = xyprod;
            scaldiv(xygrad,r(0));
            scaldiv(xygrad,r(0));
            OP_cosh(xygrad);
            scaldiv(xygrad,r(0));
            scaldiv(xygrad,r(0));

            xyxygrad = res;
            scaldiv(xygrad,r(0));
            scaldiv(xygrad,r(0));
            scaldiv(xygrad,r(0));
            scaldiv(xygrad,r(0));

            break;
        }

        case 46:
        {
            // K = cosh(z/(r0.r0))
            // dK = sinh(z/(r0.r0))/(r0.r0)
            // d2K = K/(r0.r0.r0.r0)

            res = xyprod;
            scaldiv(res,r(0));
            scaldiv(res,r(0));
            OP_cosh(res);

            xygrad = xyprod;
            scaldiv(xygrad,r(0));
            scaldiv(xygrad,r(0));
            OP_sinh(xygrad);
            scaldiv(xygrad,r(0));
            scaldiv(xygrad,r(0));

            xyxygrad = res;
            scaldiv(xygrad,r(0));
            scaldiv(xygrad,r(0));
            scaldiv(xygrad,r(0));
            scaldiv(xygrad,r(0));

            break;
        }

        case 47:
        {
            // K = sinc(sqrt(d)/r0).cos(2*pi*sqrt(d)/(r0.r1))
            //
            // if d = 0 then dK,d2K = 0

            NiceThrow("bugger that");

            break;
        }

        case 49:
        {
            // K = exp(-d/(2.r0.r0)-r1)

            NiceThrow("When the sky falls...");

            break;
        }

        case 50:
        {
            // K = pi - arccos(z)
            // dK = 1/(r0.r0.sqrt(1-(z/r0.r0)^2))

            NiceThrow("Listen... to what the flower people say...");

            break;
        }

        case 51:
        {
            // K = pi - arccos(z)
            // dK = 1/(r0.r0.sqrt(1-(z/r0.r0)^2))

            NiceThrow("Philosoplically speaking I'm very agnostic.  I don't want to have any concrete set of beliefs because beliefs lead you to being sure that you're right and and you can't really know. - Asaf Karagila");

            break;
        }

        case 100:
        {
            // K = z/(r0.r0)

            res = xyprod;
            scaldiv(res,r(0));
            scaldiv(res,r(0));

            xygrad = 1.0;
            scaldiv(xygrad,r(0));
            scaldiv(xygrad,r(0));

            xyxygrad = 0.0;

            break;
        }

        case 103:
        {
            // K = 0 if real(z) < 0, 1 otherwise

            const static T zgt(0.0);

            if ( xyprod < zgt )
            {
                res = 0.0;
            }

            else
            {
                res = 1.0;
            }

            xygrad = 0.0;

            xyxygrad = 0.0;

            break;
        }

        case 104:
        {
            // K = 0 if real(z) < 0, z/(r0*r0) otherwise

            const static T zgt(0.0);

            if ( xyprod < zgt )
            {
                res = 0.0;

                xygrad = 0.0;
            }

            else
            {
                res = xyprod;
                scaldiv(res,r(0));
                scaldiv(res,r(0));

                xygrad = 1.0;
                scaldiv(xygrad,r(0));
                scaldiv(xygrad,r(0));
            }

            xyxygrad = 0.0;

            break;
        }

        case 106:
        {
            // K = r1*z/(r0*r0) if real(z) < 0, z/(r0*r0) otherwise

            const static T zgt(0.0);

            res = xyprod;
            scaldiv(res,r(0));
            scaldiv(res,r(0));

            xygrad = 1.0;
            scaldiv(xygrad,r(0));
            scaldiv(xygrad,r(0));

            if ( xyprod < zgt )
            {
                scalmul(res,r(1));
                scalmul(xygrad,r(1));
            }

            xyxygrad = 0.0;

            break;
        }

        case 200:
        {
            // K = z/(r0.r0) - 1

            res = xyprod;
            scaldiv(res,r(0));
            scaldiv(res,r(0));
            res -= 1.0;

            xygrad = 1.0;
            scaldiv(xygrad,r(0));
            scaldiv(xygrad,r(0));

            xyxygrad = 0.0;

            break;
        }

        case 203:
        {
            // K = -1 if real(z) < 0, 1 otherwise

            const static T zgt(0.0);

            if ( xyprod < zgt )
            {
                res = -1.0;
            }

            else
            {
                res = 1.0;
            }

            xygrad = 0.0;

            xyxygrad = 0.0;

            break;
        }

        case 204:
        {
            // K = 0 if real(z) < 0, z/(r0*r0) otherwise    - 1

            const static T zgt(0.0);

            if ( xyprod < zgt )
            {
                res = -1.0;

                xygrad = 0.0;
            }

            else
            {
                res = xyprod;
                scaldiv(res,r(0));
                scaldiv(res,r(0));
                res -= 1.0;

                xygrad = 1.0;
                scaldiv(xygrad,r(0));
                scaldiv(xygrad,r(0));
            }

            xyxygrad = 0.0;

            break;
        }

        case 206:
        {
            // K = r1*z/(r0*r0) if real(z) < 0, z/(r0*r0) otherwise

            const static T zgt(0.0);

            res = xyprod;
            scaldiv(res,r(0));
            scaldiv(res,r(0));

            xygrad = 1.0;
            scaldiv(xygrad,r(0));
            scaldiv(xygrad,r(0));

            if ( xyprod < zgt )
            {
                scalmul(res,r(1));
                scalmul(xygrad,r(1));
            }

            res -= 1.0;

            xyxygrad = 0.0;

            break;
        }

        default:
        {
            NiceThrow("fe fi fo fum");

            break;
        }
    }

    res *= (const T &) weight;

    xygrad   *= (const T &) weight;
    diffgrad *= (const T &) weight;

    xyxygrad     *= (const T &) weight;
    diffdiffgrad *= (const T &) weight;
}



//KERNELSHERE

// gd(0): x'x derivative count
// gd(1): y'y derivative count
// gd(2): <x,y> derivative count
template <class T>
void MercerKernel::dnKKpro(T &res, const Vector<int> &gd, const T &xyprod, const T &diffis, int i, int j, int locindstart, int locindend, int xdim, int m, int isfirstcalc, T &scratch) const
{
    (void) locindend;

    NiceAssert( locindstart == locindend );

    res = 0.0;

    int ii,jj;
    int z = 0;
    int ind = locindstart;
    {
        retVector<gentype> tmpva;

        const Vector<gentype> &r = dRealConstants(ind)(1,1,dRealConstants(ind).size()-1,tmpva);
        const Vector<int> &ic = dIntConstants(ind);

        int ktype = cType(ind);

        if ( ktype == 0 )
        {
            // K = r1
            // dK = 0
            // d2K = 0

            if ( ( gd(z) == z ) && ( gd(1) == z ) && ( gd(2) == z ) )
            {
                res = r(1);
            }
        }

        else if ( ktype == 1 )
        {
            // K = z/(r0.r0)
            // dK = 1/(r0.r0)
            // d2K = 0

            if ( ( gd(z) == z ) && ( gd(1) == z ) && ( gd(2) == z ) )
            {
                res = xyprod;
                scaldiv(res,r(0));
                scaldiv(res,r(0));
            }

            else if ( ( gd(z) == z ) && ( gd(1) == z ) && ( gd(2) == 1 ) )
            {
                res = 1.0;
                scaldiv(res,r(0));
                scaldiv(res,r(0));
            }
        }

        else if ( ktype == 2 )
        {
            // K = ( r1 + z/(r0.r0) )^i0
            // dK = i0/(r0.r0) * ( r1 + z/(r0.r0) )^(i0-1)               if ( i0 >= 1 )
            // d2K = i0.(i0-1)/(r0.r0.r0.r0) * ( r1 + z/(r0.r0) )^(i0-2) if ( i0 >= 2 )

            if ( ( gd(z) == z ) && ( gd(1) == z ) && ( gd(2) <= ic(z) ) )
            {
                ii = ic(z);
                res = 1.0;

                for ( jj = 0 ; jj < gd(2) ; ++jj )
                {
                    res *= ii;
                    scaldiv(res,r(0));
                    scaldiv(res,r(0));
                    --ii;
                }

                if ( ii )
                {
                    T temp(xyprod);

                    scaldiv(temp,r(0));
                    scaldiv(temp,r(0));
                    scaladd(temp,r(1));
                    raiseto(temp,ii);

                    res *= temp;
                }
            }
        }

        else if ( ktype == 3 )
        {
            // K = exp(-d/(2.r0.r0))
            // dK = -K/(2*r0*r0)
            // d2K = -dK/(2*r0*r0)

            if ( isfirstcalc )
            {
                scratch  = diffis;
                scratch *= -0.5;
                scaldiv(scratch,r(0));
                scaldiv(scratch,r(0));
                scratch += log(AltDiffNormConst(xdim,m,r(0)));
                scalsub(res,r(1));
                OP_exp(scratch);
            }

            res = scratch;

            int n01 = gd(z)+gd(1);
            int n2  = gd(2);

            for ( jj = 0 ; jj < n01 ; ++jj )
            {
                res *= -0.5;
                scaldiv(res,r(0));
                scaldiv(res,r(0));
            }

            for ( jj = 0 ; jj < n2 ; ++jj )
            {
                scaldiv(res,r(0));
                scaldiv(res,r(0));
            }
        }

        else if ( ktype == 32 )
        {
            // K = r1 if i == j >= 0, 0 otherwise
            // dK = 0.0
            // d2K = 0.0

            if ( ( gd(z) == z ) && ( gd(1) == z ) && ( gd(2) == z ) && ( i == j ) && ( i >= 0 ) )
            {
                res = r(1);
            }
        }

        else if ( ktype == 33 )
        {
            // K = 1/(2.r0) ( 1 if real(sqrt(d)) < r0, 0 otherwise )
            // dK = 0
            // d2K = 0

            //if ( ( gd(z) == z ) && ( gd(1) == z ) && ( gd(2) == z ) && ( real(sqrt(diffis)-r(0)) < zerogentype() ) )
            if ( ( gd(z) == z ) && ( gd(1) == z ) && ( gd(2) == z ) && ( real(sqrt(diffis)-r(0)) < 0.0_gent ) )
            {
                res = 0.5/r(0);
            }
        }

        else if ( ktype == 44 )
        {
            // K = exp(z/(r0.r0))
            // dK = K/(r0.r0)
            // d2K = dK/(r0.r0)

            if ( isfirstcalc )
            {
                scratch = xyprod;
                scaldiv(scratch,r(0));
                scaldiv(scratch,r(0));
                scalsub(res,r(1));
                OP_exp(scratch);
            }

            if ( ( gd(z) == z ) && ( gd(1) == z ) )
            {
                res = scratch;

                for ( jj = 0 ; jj < gd(2) ; ++jj )
                {
                    scaldiv(res,r(0));
                    scaldiv(res,r(0));
                }
            }
        }

        else if ( ktype == 45 )
        {
            // K = sinh(z/(r0.r0))
            // dK = cosh(z/(r0.r0))/(r0.r0)
            // d2K = K/(r0.r0.r0.r0)

            if ( ( gd(z) == z ) && ( gd(1) == z ) )
            {
                res = xyprod;
                scaldiv(res,r(0));
                scaldiv(res,r(0));

                if ( gd(2)%2 )
                {
                    OP_cosh(res);
                }

                else
                {
                    OP_sinh(res);
                }

                for ( jj = 0 ; jj < gd(2) ; ++jj )
                {
                    scaldiv(res,r(0));
                    scaldiv(res,r(0));
                }
            }
        }

        else if ( ktype == 46 )
        {
            // K = cosh(z/(r0.r0))
            // dK = sinh(z/(r0.r0))/(r0.r0)
            // d2K = K/(r0.r0.r0.r0)

            if ( ( gd(z) == z ) && ( gd(1) == z ) )
            {
                res = xyprod;
                scaldiv(res,r(0));
                scaldiv(res,r(0));

                if ( gd(2)%2 )
                {
                    OP_sinh(res);
                }

                else
                {
                    OP_cosh(res);
                }

                for ( jj = 0 ; jj < gd(2) ; ++jj )
                {
                    scaldiv(res,r(0));
                    scaldiv(res,r(0));
                }
            }
        }

        else if ( ktype == 100 )
        {
            // K = z/(r0.r0)

            if ( ( gd(z) == z ) && ( gd(1) == z ) && ( gd(2) == z ) )
            {
                res = xyprod;
                scaldiv(res,r(0));
                scaldiv(res,r(0));
            }

            else if ( ( gd(z) == z ) && ( gd(1) == z ) && ( gd(2) == 1 ) )
            {
                res = 1.0;
                scaldiv(res,r(0));
                scaldiv(res,r(0));
            }
        }

        else if ( ktype == 103 )
        {
            // K = 0 if real(z) < 0, 1 otherwise

            if ( ( gd(z) == z ) && ( gd(1) == z ) && ( gd(2) == z ) )
            {
                const static T zgt(0.0);

                if ( xyprod < zgt )
                {
                    res = 0.0;
                }

                else
                {
                    res = 1.0;
                }
            }
        }

        else if ( ktype == 104 )
        {
            // K = 0 if real(z) < 0, z/(r0*r0) otherwise

            if ( ( gd(z) == z ) && ( gd(1) == z ) && ( gd(2) == z ) )
            {
                const static T zgt(0.0);

                if ( xyprod < zgt )
                {
                    res = 0.0;
                }

                else
                {
                    res = xyprod;
                    scaldiv(res,r(0));
                    scaldiv(res,r(0));
                }
            }

            else if ( ( gd(z) == z ) && ( gd(1) == z ) && ( gd(2) == 1 ) )
            {
                const static T zgt(0.0);

                if ( xyprod < zgt )
                {
                    res = 0.0;
                }

                else
                {
                    res = 1.0;
                    scaldiv(res,r(0));
                    scaldiv(res,r(0));
                }
            }
        }

        else if ( ktype == 106 )
        {
            // K = r1*z/(r0*r0) if real(z) < 0, z/(r0*r0) otherwise

            if ( ( gd(z) == z ) && ( gd(1) == z ) && ( gd(2) == z ) )
            {
                const static T zgt(0.0);

                res = xyprod;
                scaldiv(res,r(0));
                scaldiv(res,r(0));

                if ( xyprod < zgt )
                {
                    scalmul(res,r(1));
                }
            }

            else if ( ( gd(z) == z ) && ( gd(1) == z ) && ( gd(2) == 1 ) )
            {
                const static T zgt(0.0);

                res = 1.0;
                scaldiv(res,r(0));
                scaldiv(res,r(0));

                if ( xyprod < zgt )
                {
                    scalmul(res,r(1));
                }
            }
        }

        else if ( ktype == 200 )
        {
            // K = z/(r0.r0) - 1

            if ( ( gd(z) == z ) && ( gd(1) == z ) && ( gd(2) == z ) )
            {
                res = xyprod;
                scaldiv(res,r(0));
                scaldiv(res,r(0));
                res -= 1.0;
            }

            else if ( ( gd(z) == z ) && ( gd(1) == z ) && ( gd(2) == 1 ) )
            {
                res = 1.0;
                scaldiv(res,r(0));
                scaldiv(res,r(0));
            }
        }

        else if ( ktype == 203 )
        {
            // K = -1 if real(z) < 0, 1 otherwise

            if ( ( gd(z) == z ) && ( gd(1) == z ) && ( gd(2) == z ) )
            {
                const static T zgt(0.0);

                if ( xyprod < zgt )
                {
                    res = -1.0;
                }

                else
                {
                    res = 1.0;
                }
            }
        }

        else if ( ktype == 204 )
        {
            // K = 0 if real(z) < 0, z/(r0*r0) otherwise    - 1

            if ( ( gd(z) == z ) && ( gd(1) == z ) && ( gd(2) == z ) )
            {
                const static T zgt(0.0);

                if ( xyprod < zgt )
                {
                    res = -1.0;
                }

                else
                {
                    res = xyprod;
                    scaldiv(res,r(0));
                    scaldiv(res,r(0));
                    res -= 1.0;
                }
            }

            else if ( ( gd(z) == z ) && ( gd(1) == z ) && ( gd(2) == 1 ) )
            {
                const static T zgt(0.0);

                if ( xyprod < zgt )
                {
                    res = 0.0;
                }

                else
                {
                    res = 1.0;
                    scaldiv(res,r(0));
                    scaldiv(res,r(0));
                }
            }
        }

        else if ( ktype == 206 )
        {
            // K = r1*z/(r0*r0) if real(z) < 0, z/(r0*r0) otherwise

            if ( ( gd(z) == z ) && ( gd(1) == z ) && ( gd(2) == z ) )
            {
                const static T zgt(0.0);

                res = xyprod;
                scaldiv(res,r(0));
                scaldiv(res,r(0));

                if ( xyprod < zgt )
                {
                    scalmul(res,r(1));
                }

                res -= 1.0;
            }

            else if ( ( gd(z) == z ) && ( gd(1) == z ) && ( gd(2) == 1 ) )
            {
                const static T zgt(0.0);

                res = 1.0;
                scaldiv(res,r(0));
                scaldiv(res,r(0));

                if ( xyprod < zgt )
                {
                    scalmul(res,r(1));
                }
            }
        }

        else
        {
            NiceThrow("fe fi fo fum");
        }

        res *= (const T &) cWeight(locindstart);
    }
}

















// Pre-process checks

template <class T> 
void MercerKernel::yyydKK2( T &xygrad, T &xnormgrad, int &minmaxind, const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, const vecInfo &xainfo, const vecInfo &xbinfo, const T &bias, const gentype **pxyprod, int ia, int ib, int xdim, int xconsist, int assumreal, int mlid, const double *xy00, const double *xy10, const double *xy11, int deepDeriv) const
{
    yyyadKK2(xygrad,xnormgrad,minmaxind,xa,xb,xainfo,xbinfo,bias,pxyprod,ia,ib,xdim,xconsist,assumreal,mlid,xy00,xy10,xy11,deepDeriv);
}

template <class T> 
void MercerKernel::yyyd2KK2(T &xygrad, T &xnormgrad, T &xyxygrad, T &xyxnormgrad, T &xyynormgrad, T &xnormxnormgrad, T &xnormynormgrad, T &ynormynormgrad, int &minmaxind, const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, const vecInfo &xainfo, const vecInfo &xbinfo, const T &bias, const gentype **pxyprod, int ia, int ib, int xdim, int xconsist, int assumreal, int mlid, const double *xy00, const double *xy10, const double *xy11, int deepDeriv) const
{
    yyyad2KK2(xygrad,xnormgrad,xyxygrad,xyxnormgrad,xyynormgrad,xnormxnormgrad,xnormynormgrad,ynormynormgrad,minmaxind,xa,xb,xainfo,xbinfo,bias,pxyprod,ia,ib,xdim,xconsist,assumreal,mlid,xy00,xy10,xy11,deepDeriv);
}

template <class T> 
void MercerKernel::yyydnKK2del(Vector<T> &sc, Vector<Vector<int> > &n, int &minmaxind, const Vector<int> &q, const SparseVector<gentype> &x, const SparseVector<gentype> &y, const vecInfo &xinfo, const vecInfo &yinfo, const T &bias, const gentype **pxyprod, int i, int j, int xdim, int xconsist, int assumreal, int mlid, const double *xy00, const double *xy10, const double *xy11, int deepDeriv) const
{
    yyyadnKK2del(sc,n,minmaxind,q,x,y,xinfo,yinfo,bias,pxyprod,i,j,xdim,xconsist,assumreal,mlid,xy00,xy10,xy11,deepDeriv);
}
















// How to treat distributions, diagonal override:

template <class T> 
void MercerKernel::yyyadKK2(T &xygrad, T &xnormgrad, int &minmaxind, 
                          const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, 
                          const vecInfo &xainfo, const vecInfo &xbinfo, 
                          const T &bias, const gentype **pxyprod, 
                          int ia, int ib, 
                          int xdim, int xconsist, int assumreal, int mlid, 
                          const double *xy00, const double *xy10, const double *xy11, int deepDeriv) const
{
    int iaset = ( xa.isf4indpresent(8) && !(xa.f4(8).isValNull()) ) ? 1 : 0;
    int ibset = ( xb.isf4indpresent(8) && !(xb.f4(8).isValNull()) ) ? 1 : 0;

    int xadiagr  = ( xa.isf4indpresent(4) && !(xa.f4(4).isValNull()) ) ? 1 : 0;
    int xbdiagr  = ( xb.isf4indpresent(4) && !(xb.f4(4).isValNull()) ) ? 1 : 0;

    if ( xadiagr || xbdiagr )
    {
        minmaxind = -1;

        xygrad    = 0.0;
        xnormgrad = 0.0;
    }

    else
    {
        yyybdKK2(xygrad,xnormgrad,minmaxind,xa,xb,xainfo,xbinfo,bias,pxyprod,ia,ib,xdim,xconsist,assumreal,mlid,xy00,xy10,xy11,deepDeriv,iaset,ibset);
    }
}

template <class T> 
void MercerKernel::yyyad2KK2(T &xygrad, T &xnormgrad, T &xyxygrad, T &xyxnormgrad, T &xyynormgrad, T &xnormxnormgrad, T &xnormynormgrad, T &ynormynormgrad, int &minmaxind, 
                           const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, 
                           const vecInfo &xainfo, const vecInfo &xbinfo, 
                           const T &bias, const gentype **pxyprod, 
                           int ia, int ib, 
                           int xdim, int xconsist, int assumreal, int mlid, 
                           const double *xy00, const double *xy10, const double *xy11, int deepDeriv) const
{
    int iaset = ( xa.isf4indpresent(8) && !(xa.f4(8).isValNull()) ) ? 1 : 0;
    int ibset = ( xb.isf4indpresent(8) && !(xb.f4(8).isValNull()) ) ? 1 : 0;

    int xadiagr  = ( xa.isf4indpresent(4) && !(xa.f4(4).isValNull()) ) ? 1 : 0;
    int xbdiagr  = ( xb.isf4indpresent(4) && !(xb.f4(4).isValNull()) ) ? 1 : 0;

    if ( xadiagr || xbdiagr )
    {
        minmaxind = -1;

        xygrad         = 0.0;
        xnormgrad      = 0.0;
        xyxygrad       = 0.0;
        xyxnormgrad    = 0.0;
        xyynormgrad    = 0.0;
        xnormxnormgrad = 0.0;
        xnormynormgrad = 0.0;
        ynormynormgrad = 0.0;
    }

    else
    {
        yyybd2KK2(xygrad,xnormgrad,xyxygrad,xyxnormgrad,xyynormgrad,xnormxnormgrad,xnormynormgrad,ynormynormgrad,minmaxind,xa,xb,xainfo,xbinfo,bias,pxyprod,ia,ib,xdim,xconsist,assumreal,mlid,xy00,xy10,xy11,deepDeriv,iaset,ibset);
    }
}

template <class T> 
void MercerKernel::yyyadnKK2del(Vector<T> &sc, Vector<Vector<int> > &n, int &minmaxind, const Vector<int> &q, 
                                const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, 
                                const vecInfo &xainfo, const vecInfo &xbinfo, 
                                const T &bias, const gentype **pxyprod, 
                                int ia, int ib, 
                                int xdim, int xconsist, int assumreal, int mlid, const double *xy00, const double *xy10, const double *xy11, int deepDeriv) const
{
    int iaset = ( xa.isf4indpresent(8) && !(xa.f4(8).isValNull()) ) ? 1 : 0;
    int ibset = ( xb.isf4indpresent(8) && !(xb.f4(8).isValNull()) ) ? 1 : 0;

    int xadiagr  = ( xa.isf4indpresent(4) && !(xa.f4(4).isValNull()) ) ? 1 : 0;
    int xbdiagr  = ( xb.isf4indpresent(4) && !(xb.f4(4).isValNull()) ) ? 1 : 0;

    if ( xadiagr || xbdiagr )
    {
        minmaxind = -1;

        sc.resize(0);
        n.resize(0);
    }

    else
    {
        yyybdnKK2del(sc,n,minmaxind,q,xa,xb,xainfo,xbinfo,bias,pxyprod,ia,ib,xdim,xconsist,assumreal,mlid,xy00,xy10,xy11,deepDeriv,iaset,ibset);
    }
}

template <class T>
T &MercerKernel::yyyaK0(T &res,
                    const T &bias,
                    const gentype **pxyprod,
                    int xdim, int xconsist, int xresmode, int mlid, int assumreal, int justcalcip) const
{
    yyybK0(res,bias,pxyprod,xdim,xconsist,xresmode,mlid,assumreal,justcalcip);

    return res;
}

template <class T>
T &MercerKernel::yyyaK1(T &res,
                    const SparseVector<gentype> &xa,
                    const vecInfo &xainfo,
                    int xaignorefarfar,
                    int xaignorefarfarfar,
                    int xagradordadd,
                    int xagradordaddR,
                    const T &bias,
                    const gentype **pxyprod,
                    int ia,
                    int xdim, int xconsist, int resmode, int mlid,
                    const double *xy00, int assumreal, int justcalcip) const
{
    int iaset = ( xa.isf4indpresent(8) && !(xa.f4(8).isValNull()) ) ? 1 : 0;

    int xadiagr = ( xa.isf4indpresent(4) && !(xa.f4(4).isValNull()) ) ? 1 : 0;

    int xafarpresent = xa.isf1offindpresent() ? 1 : 0;

    int xafarfarpresent = xa.isf2offindpresent() ? 1 : 0;

    int xafarfarfarpresent = xa.isf3offindpresent() ? 1 : 0;

    int xaind6present = xa.isf4indpresent(6) && !(xa.f4(6).isValNull());

    int xaind16present = xa.isf4indpresent(16) && !(xa.f4(16).isValNull());

    int xaind9present = xa.isf4indpresent(9) && !(xa.f4(9).isValNull());

    int xaind10present = xa.isf4indpresent(10) && !(xa.f4(10).isValNull());

    int xaind11present = xa.isf4indpresent(11) && !(xa.f4(11).isValNull());

    int xaind12present = xa.isf4indpresent(12) && !(xa.f4(12).isValNull());

    int xaind13present = xa.isf4indpresent(13) && !(xa.f4(13).isValNull());

    int xaind14present = xa.isf4indpresent(14) && !(xa.f4(14).isValNull());

    int xagradOrder = xaind6present ? ( (int) xa.f4(6) ) : ( xafarfarpresent ? 1 : 0 );

    int xagradOrderR = xaind16present ? ( (int) xa.f4(16) ) : ( xafarfarfarpresent ? 1 : 0 );

    int xagradup = xaind9present ? ( (int) xa.f4(9) ) : 0;

    int xagradupR = xaind10present ? ( (int) xa.f4(10) ) : 0;

    int iaupm = xa.nupsize();

    int adensetype = xaind11present ? 2 : ( xaind12present ? 1 : 0 ); // 1 is dense integration, 2 dense diff, -n deriv -n-1 of dense int

    double xarankw = xaind13present ?  ((double) xa.f4(13)) : 1.0;

    double xArankw = xaind14present ?  ((double) xa.f4(14)) : 1.0;

    if ( adensetype )
    {
        NiceThrow("Dense kernel transforms only implemented for K2");
    }

    xagradOrder += xagradordadd;

    xagradOrderR += xagradordaddR;

    if ( xadiagr )
    {
        NiceAssert( !justcalcip );

        res = (T) xa.f4(4);

        if ( xagradOrder || ( ia < 0 ) )
        {
            res *= 0.0;
        }
    }

    else if ( !xafarpresent && !xagradOrder && !xagradOrderR && ( iaupm == 1 ) )
    {
        xKKK1(res,xa.n(),xainfo,0,xa,bias,pxyprod,ia,xdim,xconsist,assumreal,resmode,mlid,xy00,justcalcip,iaset);

        res *= xarankw;
    }

    else
    {
        yyybK1(res,xa,xainfo,xagradOrder,xagradOrderR,iaupm,xafarpresent,xarankw,xArankw,xafarfarpresent,xafarfarfarpresent,xagradup,xagradupR,xaignorefarfar,xaignorefarfarfar,bias,pxyprod,ia,xdim,xconsist,resmode,mlid,xy00,iaset,assumreal,justcalcip);
    }

    return res;
}

template <class T>
T &MercerKernel::yyyaK2(T &res,
                    const SparseVector<gentype> &xa, const SparseVector<gentype> &xb,
                    const vecInfo &xainfo, const vecInfo &xbinfo,
                    int xaignorefarfar, int xbignorefarfar,
                    int xaignorefarfarfar, int xbignorefarfarfar,
                    int xagradordadd, int xbgradordadd,
                    int xagradordaddR, int xbgradordaddR,
                    const T &bias,
                    const gentype **pxyprod,
                    int ia, int ib,
                    int xdim, int xconsist, int resmode, int mlid, 
                    const double *xy00, const double *xy10, const double *xy11, int assumreal, int justcalcip) const
{
    int iaset = ( xa.isf4indpresent(8) && !(xa.f4(8).isValNull()) ) ? 1 : 0;
    int ibset = ( xb.isf4indpresent(8) && !(xb.f4(8).isValNull()) ) ? 1 : 0;

    int xadiagr = ( xa.isf4indpresent(4) && !(xa.f4(4).isValNull()) ) ? 1 : 0;
    int xbdiagr = ( xb.isf4indpresent(4) && !(xb.f4(4).isValNull()) ) ? 1 : 0;

    int xafarpresent = xa.isf1offindpresent() ? 1 : 0;
    int xbfarpresent = xb.isf1offindpresent() ? 1 : 0;

    int xafarfarpresent = xa.isf2offindpresent() ? 1 : 0;
    int xbfarfarpresent = xb.isf2offindpresent() ? 1 : 0;

    int xafarfarfarpresent = xa.isf3offindpresent() ? 1 : 0;
    int xbfarfarfarpresent = xb.isf3offindpresent() ? 1 : 0;

    int xaind6present = xa.isf4indpresent(6) && !(xa.f4(6).isValNull());
    int xbind6present = xb.isf4indpresent(6) && !(xb.f4(6).isValNull());

    int xaind16present = xa.isf4indpresent(16) && !(xa.f4(16).isValNull());
    int xbind16present = xb.isf4indpresent(16) && !(xb.f4(16).isValNull());

    int xaind9present = xa.isf4indpresent(9) && !(xa.f4(9).isValNull());
    int xbind9present = xb.isf4indpresent(9) && !(xb.f4(9).isValNull());

    int xaind10present = xa.isf4indpresent(10) && !(xa.f4(10).isValNull());
    int xbind10present = xb.isf4indpresent(10) && !(xb.f4(10).isValNull());

    int xaind11present = xa.isf4indpresent(11) && !(xa.f4(11).isValNull());
    int xbind11present = xb.isf4indpresent(11) && !(xb.f4(11).isValNull());

    int xaind12present = xa.isf4indpresent(12) && !(xa.f4(12).isValNull());
    int xbind12present = xb.isf4indpresent(12) && !(xb.f4(12).isValNull());

    int xaind13present = xa.isf4indpresent(13) && !(xa.f4(13).isValNull());
    int xbind13present = xb.isf4indpresent(13) && !(xb.f4(13).isValNull());

    int xaind14present = xa.isf4indpresent(14) && !(xa.f4(14).isValNull());
    int xbind14present = xb.isf4indpresent(14) && !(xb.f4(14).isValNull());

    int xagradOrder = xaind6present ? ( (int) xa.f4(6) ) : ( xafarfarpresent ? 1 : 0 );
    int xbgradOrder = xbind6present ? ( (int) xb.f4(6) ) : ( xbfarfarpresent ? 1 : 0 );

    int xagradOrderR = xaind16present ? ( (int) xa.f4(16) ) : ( xafarfarfarpresent ? 1 : 0 );
    int xbgradOrderR = xbind16present ? ( (int) xb.f4(16) ) : ( xbfarfarfarpresent ? 1 : 0 );

    int xagradup = xaind9present ? ( (int) xa.f4(9) ) : 0;
    int xbgradup = xbind9present ? ( (int) xb.f4(9) ) : 0;

    int xagradupR = xaind10present ? ( (int) xa.f4(10) ) : 0;
    int xbgradupR = xbind10present ? ( (int) xb.f4(10) ) : 0;

    int iaupm = xa.nupsize();
    int ibupm = xb.nupsize();

    int adensetype = xaind11present ? 2 : ( xaind12present ? 1 : 0 ); // 1 is dense integration, 2 dense diff
    int bdensetype = xbind11present ? 2 : ( xbind12present ? 1 : 0 ); // 1 is dense integration, 2 dense diff

    double xarankw = xaind13present ?  ((double) xa.f4(13)) : 1.0;
    double xbrankw = xbind13present ?  ((double) xb.f4(13)) : 1.0;

    double xArankw = xaind14present ?  ((double) xa.f4(14)) : 1.0;
    double xBrankw = xbind14present ?  ((double) xb.f4(14)) : 1.0;

    //int densetype = adensetype ? adensetype : -bdensetype;

    xagradOrder += xagradordadd;
    xbgradOrder += xbgradordadd;

    xagradOrderR += xagradordaddR;
    xbgradOrderR += xbgradordaddR;

    if ( xadiagr || xbdiagr )
    {
        NiceAssert( !justcalcip );

        if ( xadiagr && xbdiagr )
        {
            res =  (T) xa.f4(4);
            res *= (T) xb.f4(4);
        }

        else if ( xadiagr )
        {
            res = (T) xa.f4(4);
        }

        else if ( xbdiagr )
        {
            res = (T) xb.f4(4);
        }

        if ( xagradOrder || xbgradOrder || xagradOrderR || xbgradOrderR || ( ia < 0 ) || ( ib < 0 ) || ( ia != ib ) || !xadiagr || !xbdiagr )
        {
            res *= 0.0;
        }
    }

    else if ( !xafarpresent && !xbfarpresent && !xagradOrder && !xbgradOrder && !xagradOrderR && !xbgradOrderR && ( iaupm == 1 ) && ( ibupm == 1 ) )
    {
        xKKK2(res,xa.n(),xb.n(),xainfo,xbinfo,0,0,xa,xb,bias,pxyprod,ia,ib,xdim,xconsist,assumreal,resmode,mlid,xy00,xy10,xy11,justcalcip,iaset,ibset,adensetype,bdensetype);

        res *= xarankw;
        res *= xbrankw;
    }

    else
    {
        yyybK2(res,xa,xb,xainfo,xbinfo,xagradOrder,xbgradOrder,xagradOrderR,xbgradOrderR,iaupm,ibupm,xafarpresent,xbfarpresent,xarankw,xbrankw,xArankw,xBrankw,xafarfarpresent,xbfarfarpresent,xafarfarfarpresent,xbfarfarfarpresent,xagradup,xbgradup,xagradupR,xbgradupR,xaignorefarfar,xbignorefarfar,xaignorefarfarfar,xbignorefarfarfar,bias,pxyprod,ia,ib,xdim,xconsist,resmode,mlid,xy00,xy10,xy11,iaset,ibset,assumreal,justcalcip,adensetype,bdensetype);
NiceAssert(!testisvnan(res) && !testisinf(res));
    }

    return res;
}

template <class T>
T &MercerKernel::yyyaK2x2(T &res,
                          const SparseVector<gentype> &x, const SparseVector<gentype> &xa, const SparseVector<gentype> &xb,
                          const vecInfo &xinfo, const vecInfo &xainfo, const vecInfo &xbinfo,
                          int xignorefarfar, int xaignorefarfar, int xbignorefarfar,
                          int xignorefarfarfar, int xaignorefarfarfar, int xbignorefarfarfar,
                          int xgradordadd, int xagradordadd, int xbgradordadd,
                          int xgradordaddR, int xagradordaddR, int xbgradordaddR,
                          const T &bias,
                          int i, int ia, int ib,
                          int xdim, int xbonsist, int resmode, int mlid,
                          const double *xy00, const double *xy10, const double *xy11, const double *xy20, const double *xy21, const double *xy22,
                          int assumreal, int justcalcip) const
{
    int iset  = ( x.isf4indpresent(8)  && !(x.f4(8).isValNull())  ) ? 1 : 0;
    int iaset = ( xa.isf4indpresent(8) && !(xa.f4(8).isValNull()) ) ? 1 : 0;
    int ibset = ( xb.isf4indpresent(8) && !(xb.f4(8).isValNull()) ) ? 1 : 0;

    int xdiagr  = ( x.isf4indpresent(4)  && !(x.f4(4).isValNull())  ) ? 1 : 0;
    int xadiagr = ( xa.isf4indpresent(4) && !(xa.f4(4).isValNull()) ) ? 1 : 0;
    int xbdiagr = ( xb.isf4indpresent(4) && !(xb.f4(4).isValNull()) ) ? 1 : 0;

    int xfarpresent  = x.isf1offindpresent()  ? 1 : 0;
    int xafarpresent = xa.isf1offindpresent() ? 1 : 0;
    int xbfarpresent = xb.isf1offindpresent() ? 1 : 0;

    int xfarfarpresent  = x.isf2offindpresent()  ? 1 : 0;
    int xafarfarpresent = xa.isf2offindpresent() ? 1 : 0;
    int xbfarfarpresent = xb.isf2offindpresent() ? 1 : 0;

    int xfarfarfarpresent  = x.isf3offindpresent()  ? 1 : 0;
    int xafarfarfarpresent = xa.isf3offindpresent() ? 1 : 0;
    int xbfarfarfarpresent = xb.isf3offindpresent() ? 1 : 0;

    int xind6present  = x.isf4indpresent(6)  && !(x.f4(6).isValNull());
    int xaind6present = xa.isf4indpresent(6) && !(xa.f4(6).isValNull());
    int xbind6present = xb.isf4indpresent(6) && !(xb.f4(6).isValNull());

    int xind16present  = x.isf4indpresent(16)  && !(x.f4(16).isValNull());
    int xaind16present = xa.isf4indpresent(16) && !(xa.f4(16).isValNull());
    int xbind16present = xb.isf4indpresent(16) && !(xb.f4(16).isValNull());

    int xind9present  = x.isf4indpresent(9)  && !(x.f4(9).isValNull());
    int xaind9present = xa.isf4indpresent(9) && !(xa.f4(9).isValNull());
    int xbind9present = xb.isf4indpresent(9) && !(xb.f4(9).isValNull());

    int xind10present  = x.isf4indpresent(10)  && !(x.f4(10).isValNull());
    int xaind10present = xa.isf4indpresent(10) && !(xa.f4(10).isValNull());
    int xbind10present = xb.isf4indpresent(10) && !(xb.f4(10).isValNull());

    int xind11present  = x.isf4indpresent(11)  && !(x.f4(11).isValNull());
    int xaind11present = xa.isf4indpresent(11) && !(xa.f4(11).isValNull());
    int xbind11present = xb.isf4indpresent(11) && !(xb.f4(11).isValNull());

    int xind12present  = x.isf4indpresent(12)  && !(x.f4(12).isValNull());
    int xaind12present = xa.isf4indpresent(12) && !(xa.f4(12).isValNull());
    int xbind12present = xb.isf4indpresent(12) && !(xb.f4(12).isValNull());

    int xind13present  = x.isf4indpresent(13)  && !(x.f4(13).isValNull());
    int xaind13present = xa.isf4indpresent(13) && !(xa.f4(13).isValNull());
    int xbind13present = xb.isf4indpresent(13) && !(xb.f4(13).isValNull());

    //int xind14present  = x.isf4indpresent(14)  && !(x.f4(14).isValNull());
    int xaind14present = xa.isf4indpresent(14) && !(xa.f4(14).isValNull());
    int xbind14present = xb.isf4indpresent(14) && !(xb.f4(14).isValNull());

    int xgradOrder  = xind6present  ? ( (int) x.f4(6)  ) : ( xfarfarpresent  ? 1 : 0 );
    int xagradOrder = xaind6present ? ( (int) xa.f4(6) ) : ( xafarfarpresent ? 1 : 0 );
    int xbgradOrder = xbind6present ? ( (int) xb.f4(6) ) : ( xbfarfarpresent ? 1 : 0 );

    int xgradOrderR  = xind16present  ? ( (int) x.f4(16)  ) : ( xfarfarfarpresent  ? 1 : 0 );
    int xagradOrderR = xaind16present ? ( (int) xa.f4(16) ) : ( xafarfarfarpresent ? 1 : 0 );
    int xbgradOrderR = xbind16present ? ( (int) xb.f4(16) ) : ( xbfarfarfarpresent ? 1 : 0 );

    int xgradup  = xind9present  ? ( (int) x.f4(9)  ) : 0;
    int xagradup = xaind9present ? ( (int) xa.f4(9) ) : 0;
    int xbgradup = xbind9present ? ( (int) xb.f4(9) ) : 0;

    int xgradupR  = xind10present  ? ( (int) x.f4(10)  ) : 0;
    int xagradupR = xaind10present ? ( (int) xa.f4(10) ) : 0;
    int xbgradupR = xbind10present ? ( (int) xb.f4(10) ) : 0;

    int iupm  = x.nupsize();
    int iaupm = xa.nupsize();
    int ibupm = xb.nupsize();

    int  densetype =  xind11present ? 2 : (  xind12present ? 1 : 0 ); // 1 is dense integration, 2 dense diff
    int adensetype = xaind11present ? 2 : ( xaind12present ? 1 : 0 ); // 1 is dense integration, 2 dense diff
    int bdensetype = xbind11present ? 2 : ( xbind12present ? 1 : 0 ); // 1 is dense integration, 2 dense diff

    double xrankw  = xind13present  ?  ((double) x.f4(13))  : 1.0;
    double xarankw = xaind13present ?  ((double) xa.f4(13)) : 1.0;
    double xbrankw = xbind13present ?  ((double) xb.f4(13)) : 1.0;

    //double xrankw  = xind14present  ?  ((double) x.f4(14))  : 1.0;
    double xArankw = xaind14present ?  ((double) xa.f4(14)) : 1.0;
    double xBrankw = xbind14present ?  ((double) xb.f4(14)) : 1.0;

    xgradOrder  += xgradordadd;
    xagradOrder += xagradordadd;
    xbgradOrder += xbgradordadd;

    xgradOrderR  += xgradordaddR;
    xagradOrderR += xagradordaddR;
    xbgradOrderR += xbgradordaddR;

    if ( ( xdiagr && ( !xadiagr || !xbdiagr ) ) || ( !xdiagr && ( xadiagr || xbdiagr ) ) )
    {
        NiceAssert( !justcalcip );

        res *= 0.0;
    }

    else if ( xdiagr && xadiagr && xbdiagr )
    {
        NiceAssert( !justcalcip );

        res =  (T) x.f4(4);
        res *= (T) xa.f4(4);
        res *= (T) xb.f4(4);

        if ( xgradOrder || xagradOrder || xbgradOrder || xgradOrderR || xagradOrderR || xbgradOrderR || ( i < 0 ) || ( ia < 0 ) || ( ib < 0 ) || ( i != ia ) || ( i != ib ) || ( ia != ib ) )
        {
            res *= 0.0;
        }
    }

//    else if ( !xfarpresent && !xafarpresent && !xbfarpresent && !xgradOrder && !xagradOrder && !xbgradOrder && ( iupm == 1 ) && ( iaupm == 1 ) && ( ibupm == 1 ) && !densetype && !adensetype && !bdensetype )
//    {
//FIXME: at this point go straight to product form!
//    }

    else
    {
//errstream() << "phantomxyzabcabc yyyak2x2\n";
        yyybK2x2(res,x,xa,xb,xinfo,xainfo,xbinfo,xgradOrder,xagradOrder,xbgradOrder,xgradOrderR,xagradOrderR,xbgradOrderR,iupm,iaupm,ibupm,xfarpresent,xafarpresent,xbfarpresent,xrankw,xarankw,xbrankw,xArankw,xBrankw,xfarfarpresent,xafarfarpresent,xbfarfarpresent,xfarfarfarpresent,xafarfarfarpresent,xbfarfarfarpresent,xgradup,xagradup,xbgradup,xgradupR,xagradupR,xbgradupR,xignorefarfar,xaignorefarfar,xbignorefarfar,xignorefarfarfar,xaignorefarfarfar,xbignorefarfarfar,bias,i,ia,ib,xdim,xbonsist,resmode,mlid,xy00,xy10,xy11,xy20,xy21,xy22,iset,iaset,ibset,assumreal,justcalcip,densetype,adensetype,bdensetype);
    }

    return res;
}


template <class T>
T &MercerKernel::yyyaK3(T &res,
                    const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, const SparseVector<gentype> &xc,
                    const vecInfo &xainfo, const vecInfo &xbinfo, const vecInfo &xcinfo,
                    int xaignorefarfar, int xbignorefarfar, int xcignorefarfar,
                    int xaignorefarfarfar, int xbignorefarfarfar, int xcignorefarfarfar,
                    int xagradordadd, int xbgradordadd, int xcgradordadd,
                    int xagradordaddR, int xbgradordaddR, int xcgradordaddR,
                    const T &bias,
                    const gentype **pxyprod,
                    int ia, int ib, int ic,
                    int xdim, int xconsist, int xresmode, int mlid,
                    const double *xy00, const double *xy10, const double *xy11, const double *xy20, const double *xy21, const double *xy22, int assumreal, int justcalcip) const
{
    int iaset = ( xa.isf4indpresent(8) && !(xa.f4(8).isValNull()) ) ? 1 : 0;
    int ibset = ( xb.isf4indpresent(8) && !(xb.f4(8).isValNull()) ) ? 1 : 0;
    int icset = ( xc.isf4indpresent(8) && !(xc.f4(8).isValNull()) ) ? 1 : 0;

    int xadiagr = ( xa.isf4indpresent(4) && !(xa.f4(4).isValNull()) ) ? 1 : 0;
    int xbdiagr = ( xb.isf4indpresent(4) && !(xb.f4(4).isValNull()) ) ? 1 : 0;
    int xcdiagr = ( xc.isf4indpresent(4) && !(xc.f4(4).isValNull()) ) ? 1 : 0;

    int xafarpresent = xa.isf1offindpresent() ? 1 : 0;
    int xbfarpresent = xb.isf1offindpresent() ? 1 : 0;
    int xcfarpresent = xc.isf1offindpresent() ? 1 : 0;

    int xafarfarpresent = xa.isf2offindpresent() ? 1 : 0;
    int xbfarfarpresent = xb.isf2offindpresent() ? 1 : 0;
    int xcfarfarpresent = xc.isf2offindpresent() ? 1 : 0;

    int xafarfarfarpresent = xa.isf3offindpresent() ? 1 : 0;
    int xbfarfarfarpresent = xb.isf3offindpresent() ? 1 : 0;
    int xcfarfarfarpresent = xc.isf3offindpresent() ? 1 : 0;

    int xaind6present = xa.isf4indpresent(6) && !(xa.f4(6).isValNull());
    int xbind6present = xb.isf4indpresent(6) && !(xb.f4(6).isValNull());
    int xcind6present = xc.isf4indpresent(6) && !(xc.f4(6).isValNull());

    int xaind16present = xa.isf4indpresent(16) && !(xa.f4(16).isValNull());
    int xbind16present = xb.isf4indpresent(16) && !(xb.f4(16).isValNull());
    int xcind16present = xc.isf4indpresent(16) && !(xc.f4(16).isValNull());

    int xaind9present = xa.isf4indpresent(9) && !(xa.f4(9).isValNull());
    int xbind9present = xb.isf4indpresent(9) && !(xb.f4(9).isValNull());
    int xcind9present = xc.isf4indpresent(9) && !(xc.f4(9).isValNull());

    int xaind10present = xa.isf4indpresent(10) && !(xa.f4(10).isValNull());
    int xbind10present = xb.isf4indpresent(10) && !(xb.f4(10).isValNull());
    int xcind10present = xc.isf4indpresent(10) && !(xc.f4(10).isValNull());

    int xaind11present = xa.isf4indpresent(11) && !(xa.f4(11).isValNull());
    int xbind11present = xb.isf4indpresent(11) && !(xb.f4(11).isValNull());
    int xcind11present = xc.isf4indpresent(11) && !(xc.f4(11).isValNull());

    int xaind12present = xa.isf4indpresent(12) && !(xa.f4(12).isValNull());
    int xbind12present = xb.isf4indpresent(12) && !(xb.f4(12).isValNull());
    int xcind12present = xc.isf4indpresent(12) && !(xc.f4(12).isValNull());

    int xaind13present = xa.isf4indpresent(13) && !(xa.f4(13).isValNull());
    int xbind13present = xb.isf4indpresent(13) && !(xb.f4(13).isValNull());
    int xcind13present = xc.isf4indpresent(13) && !(xc.f4(13).isValNull());

    int xaind14present = xa.isf4indpresent(14) && !(xa.f4(14).isValNull());
    int xbind14present = xb.isf4indpresent(14) && !(xb.f4(14).isValNull());
    int xcind14present = xc.isf4indpresent(14) && !(xc.f4(14).isValNull());

    int xagradOrder = xaind6present ? ( (int) xa.f4(6) ) : ( xafarfarpresent ? 1 : 0 );
    int xbgradOrder = xbind6present ? ( (int) xb.f4(6) ) : ( xbfarfarpresent ? 1 : 0 );
    int xcgradOrder = xcind6present ? ( (int) xc.f4(6) ) : ( xcfarfarpresent ? 1 : 0 );

    int xagradOrderR = xaind16present ? ( (int) xa.f4(16) ) : ( xafarfarfarpresent ? 1 : 0 );
    int xbgradOrderR = xbind16present ? ( (int) xb.f4(16) ) : ( xbfarfarfarpresent ? 1 : 0 );
    int xcgradOrderR = xcind16present ? ( (int) xc.f4(16) ) : ( xcfarfarfarpresent ? 1 : 0 );

    int xagradup = xaind9present ? ( (int) xa.f4(9) ) : 0;
    int xbgradup = xbind9present ? ( (int) xb.f4(9) ) : 0;
    int xcgradup = xcind9present ? ( (int) xc.f4(9) ) : 0;

    int xagradupR = xaind10present ? ( (int) xa.f4(10) ) : 0;
    int xbgradupR = xbind10present ? ( (int) xb.f4(10) ) : 0;
    int xcgradupR = xcind10present ? ( (int) xc.f4(10) ) : 0;

    int iaupm = xa.nupsize();
    int ibupm = xb.nupsize();
    int icupm = xc.nupsize();

    int adensetype = xaind11present ? 2 : ( xaind12present ? 1 : 0 ); // 1 is dense integration, 2 dense diff
    int bdensetype = xbind11present ? 2 : ( xbind12present ? 1 : 0 ); // 1 is dense integration, 2 dense diff
    int cdensetype = xcind11present ? 2 : ( xcind12present ? 1 : 0 ); // 1 is dense integration, 2 dense diff

    double xarankw = xaind13present ?  ((double) xa.f4(13)) : 1.0;
    double xbrankw = xbind13present ?  ((double) xb.f4(13)) : 1.0;
    double xcrankw = xcind13present ?  ((double) xc.f4(13)) : 1.0;

    double xArankw = xaind14present ?  ((double) xa.f4(14)) : 1.0;
    double xBrankw = xbind14present ?  ((double) xb.f4(14)) : 1.0;
    double xCrankw = xcind14present ?  ((double) xc.f4(14)) : 1.0;

    if ( adensetype || bdensetype || cdensetype )
    {
        NiceThrow("Dense kernel transforms only implemented for K2");
    }

    xagradOrder += xagradordadd;
    xbgradOrder += xbgradordadd;
    xcgradOrder += xcgradordadd;

    xagradOrderR += xagradordaddR;
    xbgradOrderR += xbgradordaddR;
    xcgradOrderR += xcgradordaddR;

    if ( xadiagr || xbdiagr || xcdiagr )
    {
        NiceAssert( !justcalcip );

        if ( xadiagr && xbdiagr && xcdiagr )
        {
            res =  (T) xa.f4(4);
            res *= (T) xb.f4(4);
            res *= (T) xc.f4(4);
        }

        else if ( xadiagr && xbdiagr )
        {
            res =  (T) xa.f4(4);
            res *= (T) xb.f4(4);
        }

        else if ( xadiagr && xcdiagr )
        {
            res =  (T) xa.f4(4);
            res *= (T) xc.f4(4);
        }

        else if ( xbdiagr && xcdiagr )
        {
            res =  (T) xb.f4(4);
            res *= (T) xc.f4(4);
        }

        else if ( xadiagr )
        {
            res = (T) xa.f4(4);
        }

        else if ( xbdiagr )
        {
            res = (T) xb.f4(4);
        }

        else if ( xcdiagr )
        {
            res = (T) xc.f4(4);
        }

        if ( xagradOrder || xbgradOrder || xcgradOrder || xagradOrderR || xbgradOrderR || xcgradOrderR || ( ia < 0 ) || ( ib < 0 ) || ( ic < 0 ) || ( ia != ib ) || ( ia != ic ) || ( ib != ic ) || !xadiagr || !xbdiagr || !xcdiagr )
        {
            res *= 0.0;
        }
    }

    else if ( !xafarpresent && !xbfarpresent && !xcfarpresent && !xagradOrder && !xbgradOrder && !xcgradOrder && !xagradOrderR && !xbgradOrderR && !xcgradOrderR && ( iaupm == 1 ) && ( ibupm == 1 ) && ( icupm == 1 ) )
    {
        xKKK3(res,xa.n(),xb.n(),xc.n(),xainfo,xbinfo,xcinfo,0,0,0,xa,xb,xc,bias,pxyprod,ia,ib,ic,xdim,xconsist,assumreal,xresmode,mlid,xy00,xy10,xy11,xy20,xy21,xy22,justcalcip,iaset,ibset,icset);

        res *= xarankw;
        res *= xbrankw;
        res *= xcrankw;
    }

    else
    {
        yyybK3(res,xa,xb,xc,xainfo,xbinfo,xcinfo,xagradOrder,xbgradOrder,xcgradOrder,xagradOrderR,xbgradOrderR,xcgradOrderR,iaupm,ibupm,icupm,xafarpresent,xbfarpresent,xcfarpresent,xarankw,xbrankw,xcrankw,xArankw,xBrankw,xCrankw,xafarfarpresent,xbfarfarpresent,xcfarfarpresent,xafarfarfarpresent,xbfarfarfarpresent,xcfarfarfarpresent,xagradup,xbgradup,xcgradup,xagradupR,xbgradupR,xcgradupR,xaignorefarfar,xbignorefarfar,xcignorefarfar,xaignorefarfarfar,xbignorefarfarfar,xcignorefarfarfar,bias,pxyprod,ia,ib,ic,xdim,xconsist,xresmode,mlid,xy00,xy10,xy11,xy20,xy21,xy22,iaset,ibset,icset,assumreal,justcalcip);
    }

    return res;
}

template <class T>
T &MercerKernel::yyyaK4(T &res,
                    const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, const SparseVector<gentype> &xc, const SparseVector<gentype> &xd,
                    const vecInfo &xainfo, const vecInfo &xbinfo, const vecInfo &xcinfo, const vecInfo &xdinfo,
                    int xaignorefarfar, int xbignorefarfar, int xcignorefarfar, int xdignorefarfar,
                    int xaignorefarfarfar, int xbignorefarfarfar, int xcignorefarfarfar, int xdignorefarfarfar,
                    int xagradordadd, int xbgradordadd, int xcgradordadd, int xdgradordadd,
                    int xagradordaddR, int xbgradordaddR, int xcgradordaddR, int xdgradordaddR,
                    const T &bias,
                    const gentype **pxyprod,
                    int ia, int ib, int ic, int id,
                    int xdim, int xconsist, int xresmode, int mlid,
                    const double *xy00, const double *xy10, const double *xy11, const double *xy20, const double *xy21, const double *xy22, const double *xy30, const double *xy31, const double *xy32, const double *xy33, int assumreal, int justcalcip) const
{
    int iaset = ( xa.isf4indpresent(8) && !(xa.f4(8).isValNull()) ) ? 1 : 0;
    int ibset = ( xb.isf4indpresent(8) && !(xb.f4(8).isValNull()) ) ? 1 : 0;
    int icset = ( xc.isf4indpresent(8) && !(xc.f4(8).isValNull()) ) ? 1 : 0;
    int idset = ( xd.isf4indpresent(8) && !(xd.f4(8).isValNull()) ) ? 1 : 0;

    int xadiagr = ( xa.isf4indpresent(4) && !(xa.f4(4).isValNull()) ) ? 1 : 0;
    int xbdiagr = ( xb.isf4indpresent(4) && !(xb.f4(4).isValNull()) ) ? 1 : 0;
    int xcdiagr = ( xc.isf4indpresent(4) && !(xc.f4(4).isValNull()) ) ? 1 : 0;
    int xddiagr = ( xd.isf4indpresent(4) && !(xd.f4(4).isValNull()) ) ? 1 : 0;

    int xafarpresent = xa.isf1offindpresent() ? 1 : 0;
    int xbfarpresent = xb.isf1offindpresent() ? 1 : 0;
    int xcfarpresent = xc.isf1offindpresent() ? 1 : 0;
    int xdfarpresent = xd.isf1offindpresent() ? 1 : 0;

    int xafarfarpresent = xa.isf2offindpresent() ? 1 : 0;
    int xbfarfarpresent = xb.isf2offindpresent() ? 1 : 0;
    int xcfarfarpresent = xc.isf2offindpresent() ? 1 : 0;
    int xdfarfarpresent = xd.isf2offindpresent() ? 1 : 0;

    int xafarfarfarpresent = xa.isf3offindpresent() ? 1 : 0;
    int xbfarfarfarpresent = xb.isf3offindpresent() ? 1 : 0;
    int xcfarfarfarpresent = xc.isf3offindpresent() ? 1 : 0;
    int xdfarfarfarpresent = xd.isf3offindpresent() ? 1 : 0;

    int xaind6present = xa.isf4indpresent(6) && !(xa.f4(6).isValNull());
    int xbind6present = xb.isf4indpresent(6) && !(xb.f4(6).isValNull());
    int xcind6present = xc.isf4indpresent(6) && !(xc.f4(6).isValNull());
    int xdind6present = xd.isf4indpresent(6) && !(xd.f4(6).isValNull());

    int xaind16present = xa.isf4indpresent(16) && !(xa.f4(16).isValNull());
    int xbind16present = xb.isf4indpresent(16) && !(xb.f4(16).isValNull());
    int xcind16present = xc.isf4indpresent(16) && !(xc.f4(16).isValNull());
    int xdind16present = xd.isf4indpresent(16) && !(xd.f4(16).isValNull());

    int xaind9present = xa.isf4indpresent(9) && !(xa.f4(9).isValNull());
    int xbind9present = xb.isf4indpresent(9) && !(xb.f4(9).isValNull());
    int xcind9present = xc.isf4indpresent(9) && !(xc.f4(9).isValNull());
    int xdind9present = xd.isf4indpresent(9) && !(xd.f4(9).isValNull());

    int xaind10present = xa.isf4indpresent(10) && !(xa.f4(10).isValNull());
    int xbind10present = xb.isf4indpresent(10) && !(xb.f4(10).isValNull());
    int xcind10present = xc.isf4indpresent(10) && !(xc.f4(10).isValNull());
    int xdind10present = xd.isf4indpresent(10) && !(xd.f4(10).isValNull());

    int xaind11present = xa.isf4indpresent(11) && !(xa.f4(11).isValNull());
    int xbind11present = xb.isf4indpresent(11) && !(xb.f4(11).isValNull());
    int xcind11present = xc.isf4indpresent(11) && !(xc.f4(11).isValNull());
    int xdind11present = xd.isf4indpresent(11) && !(xd.f4(11).isValNull());

    int xaind12present = xa.isf4indpresent(12) && !(xa.f4(12).isValNull());
    int xbind12present = xb.isf4indpresent(12) && !(xb.f4(12).isValNull());
    int xcind12present = xc.isf4indpresent(12) && !(xc.f4(12).isValNull());
    int xdind12present = xd.isf4indpresent(12) && !(xd.f4(12).isValNull());

    int xaind13present = xa.isf4indpresent(13) && !(xa.f4(13).isValNull());
    int xbind13present = xb.isf4indpresent(13) && !(xb.f4(13).isValNull());
    int xcind13present = xc.isf4indpresent(13) && !(xc.f4(13).isValNull());
    int xdind13present = xd.isf4indpresent(13) && !(xd.f4(13).isValNull());

    int xaind14present = xa.isf4indpresent(14) && !(xa.f4(14).isValNull());
    int xbind14present = xb.isf4indpresent(14) && !(xb.f4(14).isValNull());
    int xcind14present = xc.isf4indpresent(14) && !(xc.f4(14).isValNull());
    int xdind14present = xd.isf4indpresent(14) && !(xd.f4(14).isValNull());

    int xagradOrder = xaind6present ? ( (int) xa.f4(6) ) : ( xafarfarpresent ? 1 : 0 );
    int xbgradOrder = xbind6present ? ( (int) xb.f4(6) ) : ( xbfarfarpresent ? 1 : 0 );
    int xcgradOrder = xcind6present ? ( (int) xc.f4(6) ) : ( xcfarfarpresent ? 1 : 0 );
    int xdgradOrder = xdind6present ? ( (int) xd.f4(6) ) : ( xdfarfarpresent ? 1 : 0 );

    int xagradOrderR = xaind16present ? ( (int) xa.f4(16) ) : ( xafarfarfarpresent ? 1 : 0 );
    int xbgradOrderR = xbind16present ? ( (int) xb.f4(16) ) : ( xbfarfarfarpresent ? 1 : 0 );
    int xcgradOrderR = xcind16present ? ( (int) xc.f4(16) ) : ( xcfarfarfarpresent ? 1 : 0 );
    int xdgradOrderR = xdind16present ? ( (int) xd.f4(16) ) : ( xdfarfarfarpresent ? 1 : 0 );

    int xagradup = xaind9present ? ( (int) xa.f4(9) ) : 0;
    int xbgradup = xbind9present ? ( (int) xb.f4(9) ) : 0;
    int xcgradup = xcind9present ? ( (int) xc.f4(9) ) : 0;
    int xdgradup = xdind9present ? ( (int) xd.f4(9) ) : 0;

    int xagradupR = xaind10present ? ( (int) xa.f4(10) ) : 0;
    int xbgradupR = xbind10present ? ( (int) xb.f4(10) ) : 0;
    int xcgradupR = xcind10present ? ( (int) xc.f4(10) ) : 0;
    int xdgradupR = xdind10present ? ( (int) xd.f4(10) ) : 0;

    int iaupm = xa.nupsize();
    int ibupm = xb.nupsize();
    int icupm = xc.nupsize();
    int idupm = xd.nupsize();

    int adensetype = xaind11present ? 2 : ( xaind12present ? 1 : 0 ); // 1 is dense integration, 2 dense diff
    int bdensetype = xbind11present ? 2 : ( xbind12present ? 1 : 0 ); // 1 is dense integration, 2 dense diff
    int cdensetype = xcind11present ? 2 : ( xcind12present ? 1 : 0 ); // 1 is dense integration, 2 dense diff
    int ddensetype = xdind11present ? 2 : ( xdind12present ? 1 : 0 ); // 1 is dense integration, 2 dense diff

    double xarankw = xaind13present ?  ((double) xa.f4(13)) : 1.0;
    double xbrankw = xbind13present ?  ((double) xb.f4(13)) : 1.0;
    double xcrankw = xcind13present ?  ((double) xc.f4(13)) : 1.0;
    double xdrankw = xdind13present ?  ((double) xd.f4(13)) : 1.0;

    double xArankw = xaind14present ?  ((double) xa.f4(14)) : 1.0;
    double xBrankw = xbind14present ?  ((double) xb.f4(14)) : 1.0;
    double xCrankw = xcind14present ?  ((double) xc.f4(14)) : 1.0;
    double xDrankw = xdind14present ?  ((double) xd.f4(14)) : 1.0;

    if ( adensetype || bdensetype || cdensetype || ddensetype )
    {
        NiceThrow("Dense kernel transforms only implemented for K2");
    }

    xagradOrder += xagradordadd;
    xbgradOrder += xbgradordadd;
    xcgradOrder += xcgradordadd;
    xdgradOrder += xdgradordadd;

    xagradOrderR += xagradordaddR;
    xbgradOrderR += xbgradordaddR;
    xcgradOrderR += xcgradordaddR;
    xdgradOrderR += xdgradordaddR;

    if ( xadiagr || xbdiagr || xcdiagr || xddiagr )
    {
        NiceAssert( !justcalcip );

        if ( xadiagr && xbdiagr && xcdiagr && xddiagr )
        {
            res =  (T) xa.f4(4);
            res *= (T) xb.f4(4);
            res *= (T) xc.f4(4);
            res *= (T) xd.f4(4);
        }

        else if ( xadiagr && xbdiagr && xcdiagr )
        {
            res =  (T) xa.f4(4);
            res *= (T) xb.f4(4);
            res *= (T) xc.f4(4);
        }

        else if ( xadiagr && xbdiagr && xddiagr )
        {
            res =  (T) xa.f4(4);
            res *= (T) xb.f4(4);
            res *= (T) xd.f4(4);
        }

        else if ( xadiagr && xcdiagr && xddiagr )
        {
            res =  (T) xa.f4(4);
            res *= (T) xc.f4(4);
            res *= (T) xd.f4(4);
        }

        else if ( xbdiagr && xcdiagr && xddiagr )
        {
            res =  (T) xb.f4(4);
            res *= (T) xc.f4(4);
            res *= (T) xd.f4(4);
        }

        else if ( xadiagr && xbdiagr )
        {
            res =  (T) xa.f4(4);
            res *= (T) xb.f4(4);
        }

        else if ( xadiagr && xcdiagr )
        {
            res =  (T) xa.f4(4);
            res *= (T) xc.f4(4);
        }

        else if ( xadiagr && xddiagr )
        {
            res =  (T) xa.f4(4);
            res *= (T) xd.f4(4);
        }

        else if ( xbdiagr && xcdiagr )
        {
            res =  (T) xb.f4(4);
            res *= (T) xc.f4(4);
        }

        else if ( xbdiagr && xddiagr )
        {
            res =  (T) xb.f4(4);
            res *= (T) xd.f4(4);
        }

        else if ( xcdiagr && xddiagr )
        {
            res =  (T) xc.f4(4);
            res *= (T) xd.f4(4);
        }

        else if ( xadiagr )
        {
            res = (T) xa.f4(4);
        }

        else if ( xbdiagr )
        {
            res = (T) xb.f4(4);
        }

        else if ( xcdiagr )
        {
            res = (T) xc.f4(4);
        }

        else if ( xddiagr )
        {
            res = (T) xd.f4(4);
        }

        if ( xagradOrder || xbgradOrder || xcgradOrder || xdgradOrder || xagradOrderR || xbgradOrderR || xcgradOrderR || xdgradOrderR || ( ia < 0 ) || ( ib < 0 ) || ( ic < 0 ) || ( id <= 0 ) || ( ia != ib ) || ( ia != ic ) || ( ia != id ) || ( ib != ic ) || ( ib != id ) || ( ic != id ) || !xadiagr || !xbdiagr || !xcdiagr || !xddiagr )
        {
            res *= 0.0;
        }
    }

    else if ( !xafarpresent && !xbfarpresent && !xcfarpresent && !xcfarpresent && !xdfarpresent && !xagradOrder && !xbgradOrder && !xcgradOrder && !xdgradOrder && !xagradOrderR && !xbgradOrderR && !xcgradOrderR && !xdgradOrderR && ( iaupm == 1 ) && ( ibupm == 1 ) && ( icupm == 1 ) && ( idupm == 1 ) )
    {
        xKKK4(res,xa.n(),xb.n(),xc.n(),xd.n(),xainfo,xbinfo,xcinfo,xdinfo,0,0,0,0,xa,xb,xc,xd,bias,pxyprod,ia,ib,ic,id,xdim,xconsist,assumreal,xresmode,mlid,xy00,xy10,xy11,xy20,xy21,xy22,xy30,xy31,xy32,xy33,justcalcip,iaset,ibset,icset,idset);

        res *= xarankw;
        res *= xbrankw;
        res *= xcrankw;
        res *= xdrankw;
    }

    else
    {
        yyybK4(res,xa,xb,xc,xd,xainfo,xbinfo,xcinfo,xdinfo,xagradOrder,xbgradOrder,xcgradOrder,xdgradOrder,xagradOrderR,xbgradOrderR,xcgradOrderR,xdgradOrderR,iaupm,ibupm,icupm,idupm,xafarpresent,xbfarpresent,xcfarpresent,xdfarpresent,xarankw,xbrankw,xcrankw,xdrankw,xArankw,xBrankw,xCrankw,xDrankw,xafarfarpresent,xbfarfarpresent,xcfarfarpresent,xdfarfarpresent,xafarfarfarpresent,xbfarfarfarpresent,xcfarfarfarpresent,xdfarfarfarpresent,xagradup,xbgradup,xcgradup,xdgradup,xagradupR,xbgradupR,xcgradupR,xdgradupR,xaignorefarfar,xbignorefarfar,xcignorefarfar,xdignorefarfar,xaignorefarfarfar,xbignorefarfarfar,xcignorefarfarfar,xdignorefarfarfar,bias,pxyprod,ia,ib,ic,id,xdim,xconsist,xresmode,mlid,xy00,xy10,xy11,xy20,xy21,xy22,xy30,xy31,xy32,xy33,iaset,ibset,icset,idset,assumreal,justcalcip);
    }

    return res;
}

template <class T>
T &MercerKernel::yyyaKm(int m, T &res,
                    Vector<const SparseVector<gentype> *> &x,
                    Vector<const vecInfo *> &xinfo,
                    Vector<int> &xignorefarfar,
                    Vector<int> &xignorefarfarfar,
                    Vector<int> &xgradordadd,
                    Vector<int> &xgradordaddR,
                    const T &bias,
                    Vector<int> &i,
                    const gentype **pxyprod, int xdim, int xconsist, int resmode, int mlid,
                    const Matrix<double> *xy, int assumreal, int justcalcip) const
{
    Vector<int> iiset(x.size());
    Vector<int> xdiagr(x.size());
    Vector<int> xfarpresent(x.size());
    Vector<int> xfarfarpresent(x.size());
    Vector<int> xfarfarfarpresent(x.size());
    Vector<int> xind6present(x.size());
    Vector<int> xind16present(x.size());
    Vector<int> xind9present(x.size());
    Vector<int> xind10present(x.size());
    Vector<int> xind11present(x.size());
    Vector<int> xind12present(x.size());
    Vector<int> xind13present(x.size());
    Vector<int> xind14present(x.size());
    Vector<int> xgradOrder(x.size());
    Vector<int> xgradOrderR(x.size());
    Vector<int> xgradup(x.size());
    Vector<int> xgradupR(x.size());
    Vector<int> iupm(x.size());
    Vector<int> densetype(x.size());
    Vector<double> xxrankw(x.size());
    Vector<double> xXrankw(x.size());

    int ii;
    int farcnt   = 0;
    int gradcnt  = 0;
    int diagcnt  = 0;
    int iupcntnu = 0;
    int inecnt   = 0;
    int inegcnt  = 0;
    bool firstterm = true;
    double simplerankprod = 1;

    {
        for ( ii = 0 ; ii < x.size() ; ++ii )
        {
            iiset("&",ii)             = ( (*(x(ii))).isf4indpresent(8) && !((*(x(ii))).f4(8).isValNull()) ) ? 1 : 0;
            xdiagr("&",ii)            = ( (*(x(ii))).isf4indpresent(4) && !((*(x(ii))).f4(4).isValNull()) ) ? 1 : 0;
            xfarpresent("&",ii)       = (*(x(ii))).isf1offindpresent() ? 1 : 0;
            xfarfarpresent("&",ii)    = (*(x(ii))).isf2offindpresent() ? 1 : 0;
            xfarfarfarpresent("&",ii) = (*(x(ii))).isf3offindpresent() ? 1 : 0;
            xind6present("&",ii)      = (*(x(ii))).isf4indpresent(6)  && !((*(x(ii))).f4(6).isValNull());
            xind16present("&",ii)     = (*(x(ii))).isf4indpresent(6)  && !((*(x(ii))).f4(6).isValNull());
            xind9present("&",ii)      = (*(x(ii))).isf4indpresent(9)  && !((*(x(ii))).f4(9).isValNull());
            xind10present("&",ii)     = (*(x(ii))).isf4indpresent(10) && !((*(x(ii))).f4(10).isValNull());
            xind11present("&",ii)     = (*(x(ii))).isf4indpresent(11) && !((*(x(ii))).f4(11).isValNull());
            xind12present("&",ii)     = (*(x(ii))).isf4indpresent(12) && !((*(x(ii))).f4(12).isValNull());
            xind13present("&",ii)     = (*(x(ii))).isf4indpresent(13) && !((*(x(ii))).f4(13).isValNull());
            xind14present("&",ii)     = (*(x(ii))).isf4indpresent(14) && !((*(x(ii))).f4(14).isValNull());
            xgradOrder("&",ii)        = xind6present(ii)  ? ( (int) (*(x(ii))).f4(6)  ) : ( xfarfarpresent(ii)    ? 1 : 0 );
            xgradOrderR("&",ii)       = xind16present(ii) ? ( (int) (*(x(ii))).f4(16) ) : ( xfarfarfarpresent(ii) ? 1 : 0 );
            xgradup("&",ii)           = xind9present(ii)  ? ( (int) (*(x(ii))).f4(9)  ) : 0;
            xgradupR("&",ii)          = xind10present(ii) ? ( (int) (*(x(ii))).f4(10) ) : 0;
            iupm("&",ii)              = (*(x(ii))).nupsize();
            densetype("&",ii)         = xind11present(ii) ? 2 : ( xind12present(ii) ? 1 : 0 );
            xxrankw("&",ii)           = xind13present(ii) ? ((double) (*(x(ii))).f4(13)) : 1.0;
            xXrankw("&",ii)           = xind14present(ii) ? ((double) (*(x(ii))).f4(14)) : 1.0;

            simplerankprod *= xxrankw(ii);

            xgradOrder("&",ii)  += xgradordadd(ii);
            xgradOrderR("&",ii) += xgradordaddR(ii);

            if ( xdiagr(ii) )
            {
                if ( firstterm ) { res  = (T) (*(x(ii))).f4(4); }
                else             { res *= (T) (*(x(ii))).f4(4); }

                firstterm = false;
                ++diagcnt;
            }

            farcnt   += xfarpresent(ii);
            gradcnt  += xgradOrder(ii);
            gradcnt  += xgradOrderR(ii);
            iupcntnu += ( ( iupm(ii) != 1    ) ? 1 : 0 );
            inecnt   += ( ( i(ii)    != i(0) ) ? 1 : 0 );
            inegcnt  += ( ( i(ii)    <  0    ) ? 1 : 0 );
        }

        if ( sum(densetype) )
        {
            NiceThrow("Dense kernel transforms only implemented for K2");
        }
    }

    if ( diagcnt )
    {
        NiceAssert( !justcalcip );

        // res already set!

        if ( !gradcnt || inegcnt || inecnt || ( diagcnt != x.size() ) )
        {
            res *= 0.0;
        }
    }

    else if ( !x.size() || ( !farcnt && !gradcnt && !iupcntnu ) )
    {
        Vector<const SparseVector<gentype> *> xn(x);

        for ( ii = 0 ; ii < x.size() ; ++ii )
        {
            xn("&",ii) = &((*x(ii)).n());
        }

        yyyKKm(m,res,xn,xinfo,xgradOrder,xgradup,iupm,x,bias,i,pxyprod,xdim,xconsist,resmode,mlid,xy,&iiset,assumreal,justcalcip);

        res *= simplerankprod;
    }

    else
    {
        yyybKm(m,res,x,xinfo,xgradOrder,xgradOrderR,iupm,xfarpresent,xxrankw,xXrankw,xfarfarpresent,xfarfarfarpresent,xgradup,xgradupR,xignorefarfar,xignorefarfarfar,bias,i,pxyprod,xdim,xconsist,resmode,mlid,xy,&iiset,assumreal,justcalcip);
    }

    return res;
}

template <class T>
int MercerKernel::yyyaphim(int m, Vector<T>  &res, const SparseVector<gentype> &xa, const vecInfo &xainfo, int xaignorefarfar, int xaignorefarfarfar, int xagradordadd, int xagradordaddR, int ia, int allowfinite, int xdim, int xconsist, int assumreal) const
{
    int dres = 0;

    int iaset              = ( xa.isf4indpresent(8) && !(xa.f4(8).isValNull()) ) ? 1 : 0;
    int xadiagr            = ( xa.isf4indpresent(4) && !(xa.f4(4).isValNull()) ) ? 1 : 0;
    int xafarpresent       = xa.isf1offindpresent() ? 1 : 0;
    int xafarfarpresent    = xa.isf2offindpresent() ? 1 : 0;
    int xafarfarfarpresent = xa.isf3offindpresent() ? 1 : 0;
    int xaind6present      = xa.isf4indpresent(6)  && !(xa.f4(6).isValNull());
    int xaind16present     = xa.isf4indpresent(16) && !(xa.f4(16).isValNull());
    int xaind9present      = xa.isf4indpresent(9)  && !(xa.f4(9).isValNull());
    int xaind10present     = xa.isf4indpresent(10) && !(xa.f4(10).isValNull());
    int xagradOrder        = xaind6present  ? ( (int) xa.f4(6)  ) : ( xafarfarpresent    ? 1 : 0 );
    int xagradOrderR       = xaind16present ? ( (int) xa.f4(16) ) : ( xafarfarfarpresent ? 1 : 0 );
    int xagradup           = xaind9present  ? ( (int) xa.f4(9)  ) : 0;
    int xagradupR          = xaind10present ? ( (int) xa.f4(10) ) : 0;
    int iaupm              = xa.nupsize();

    xagradOrder  += xagradordadd;
    xagradOrderR += xagradordaddR;

    if ( m == -1 )
    {
        dres = yyyPphim(m,res,xa,xainfo,ia,allowfinite,xdim,xconsist,assumreal,iaset,xagradOrder,xagradup,iaupm);
    }

    else if ( xadiagr )
    {
        NiceThrow("Can't do diagonal feature maps");
    }

    else if ( !xafarpresent && !xagradOrder && ( iaupm == 1 ) )
    {
        dres = yyyPphim(m,res,xa.n(),xainfo,ia,allowfinite,xdim,xconsist,assumreal,iaset,xagradOrder,xagradup,iaupm);
    }

    else
    {
        dres = yyybphim(m,res,xa,xainfo,xaignorefarfar,xaignorefarfarfar,ia,xagradOrder,xagradOrderR,iaupm,xafarpresent,xafarfarpresent,xafarfarfarpresent,xagradup,xagradupR,allowfinite,xdim,xconsist,assumreal,iaset);
    }

    return dres;
}















// Pre-process Rank
//
// NB: n actually just returns the vector itself, so gradient parts are passed through by this

template <class T>
void MercerKernel::yyybdKK2(T &xygrad, T &xnormgrad, int &minmaxind,
                            const SparseVector<gentype> &xa, const SparseVector<gentype> &xb,
                            const vecInfo &xainfo, const vecInfo &xbinfo,
                            const T &bias, const gentype **pxyprod,
                            int ia, int ib,
                            int xdim, int xconsist, int assumreal, int mlid, const double *xy00, const double *xy10, const double *xy11, int deepDeriv, int iaset, int ibset) const
{
#ifndef NDEBUG
    int xafarpresent = xa.isf1offindpresent() ? 1 : 0;
    int xbfarpresent = xb.isf1offindpresent() ? 1 : 0;

    NiceAssert( !xafarpresent );
    NiceAssert( !xbfarpresent );
#endif

    yyycdKK2(xygrad,xnormgrad,minmaxind,xa,xb,xainfo,xbinfo,bias,pxyprod,ia,ib,xdim,xconsist,assumreal,mlid,xy00,xy10,xy11,deepDeriv,iaset,ibset);
}

template <class T>
void MercerKernel::yyybd2KK2(T &xygrad, T &xnormgrad, T &xyxygrad, T &xyxnormgrad, T &xyynormgrad, T &xnormxnormgrad, T &xnormynormgrad, T &ynormynormgrad, int &minmaxind,
                             const SparseVector<gentype> &xa, const SparseVector<gentype> &xb,
                             const vecInfo &xainfo, const vecInfo &xbinfo,
                             const T &bias, const gentype **pxyprod,
                             int ia, int ib, int xdim, int xconsist, int assumreal, int mlid, const double *xy00, const double *xy10, const double *xy11, int deepDeriv, int iaset, int ibset) const
{
#ifndef NDEBUG
    int xafarpresent = xa.isf1offindpresent() ? 1 : 0;
    int xbfarpresent = xb.isf1offindpresent() ? 1 : 0;

    NiceAssert( !xafarpresent );
    NiceAssert( !xbfarpresent );
#endif

    yyycd2KK2(xygrad,xnormgrad,xyxygrad,xyxnormgrad,xyynormgrad,xnormxnormgrad,xnormynormgrad,ynormynormgrad,minmaxind,xa,xb,xainfo,xbinfo,bias,pxyprod,ia,ib,xdim,xconsist,assumreal,mlid,xy00,xy10,xy11,deepDeriv,iaset,ibset);
}

template <class T>
void MercerKernel::yyybdnKK2del(Vector<T> &sc, Vector<Vector<int> > &n, int &minmaxind, const Vector<int> &q,
                               const SparseVector<gentype> &xa, const SparseVector<gentype> &xb,
                               const vecInfo &xainfo, const vecInfo &xbinfo,
                               const T &bias, const gentype **pxyprod,
                               int ia, int ib, int xdim, int xconsist, int assumreal, int mlid, const double *xy00, const double *xy10, const double *xy11, int deepDeriv, int iaset, int ibset) const
{
#ifndef NDEBUG
    int xafarpresent = xa.isf1offindpresent() ? 1 : 0;
    int xbfarpresent = xb.isf1offindpresent() ? 1 : 0;

    NiceAssert( !xafarpresent );
    NiceAssert( !xbfarpresent );
#endif

    yyycdnKK2del(sc,n,minmaxind,q,xa,xb,xainfo,xbinfo,bias,pxyprod,ia,ib,xdim,xconsist,assumreal,mlid,xy00,xy10,xy11,deepDeriv,iaset,ibset);
}



template <class T>
T &MercerKernel::yyybK0(T &res,
                    const T &bias,
                    const gentype **pxyprod,
                    int xdim, int xconsist, int xresmode, int mlid, int assumreal, int justcalcip) const
{
    return yyycK0(res,bias,pxyprod,xdim,xconsist,xresmode,mlid,assumreal,justcalcip);
}

template <class T>
T &MercerKernel::yyybK1(T &res,
                    const SparseVector<gentype> &xa,
                    const vecInfo &xainfo,
                    int xagradOrder,
                    int xagradOrderR,
                    int iaupm,
                    int xafarpresent,
                    double xarankw,
                    double xArankw,
                    int xafarfarpresent,
                    int xafarfarfarpresent,
                    int xagradup,
                    int xagradupR,
                    int xaignorefarfar,
                    int xaignorefarfarfar,
                    const T &bias,
                    const gentype **pxyprod,
                    int ia,
                    int xdim, int xconsist, int resmode, int mlid,
                    const double *xy00, int iaset, int assumreal, int justcalcip) const
{
    static const SparseVector<gentype> dummy;

    const SparseVector<gentype> &xan = xa.n();

    const SparseVector<gentype> &xaff = ( xafarfarpresent && !xaignorefarfar ) ? xa.f2() : dummy;

    const SparseVector<gentype> &xafff = ( xafarfarfarpresent && !xaignorefarfarfar ) ? xa.f3() : dummy;

    //const SparseVector<gentype> &xan = xafarfarpresent ? xa.n() : xa;

    NiceAssert( !( justcalcip && xafarpresent ) );

    if ( xafarpresent )
    {
        const SparseVector<gentype> &xanear = xa.n();
        const SparseVector<gentype> &xafar  = xa.f1();
        const SparseVector<gentype> &xaffnear = xaff;
        const SparseVector<gentype> &xafffar  = xafff;
        const vecInfo &xanearinfo = xainfo(0,-1);
        const vecInfo &xafarinfo  = xainfo(1,-1);
        int xagradOrdernear = xagradOrder;
        int xagradOrderfar  = xagradOrderR;
        int xagradupnear = xagradup;
        int xagradupfar  = xagradupR;
        int iaupmnear = iaupm;
        int iaupmfar  = xa.f1upsize();
        int ianear = ia;
        int iafar  = -(((ia+1)*100)+1);

        T resa; yyycK1(resa,xanear,xanearinfo,xagradOrdernear,xagradupnear,iaupmnear,xaffnear,bias,nullptr,ianear,xdim,xconsist,resmode,mlid,nullptr,iaset,assumreal,justcalcip);
        T resA; yyycK1(resA,xafar ,xafarinfo ,xagradOrderfar ,xagradupfar ,iaupmfar, xafffar ,bias,nullptr,iafar ,xdim,xconsist,resmode,mlid,nullptr,iaset,assumreal,justcalcip);

        resa *= xarankw;
        resA *= xArankw;

        if ( xranktype == 0 )
        {
            // varphi(x,x') = varphi(x) - varphi(x')

            res = resa-resA;
        }

        else if ( xranktype == 1 )
        {
            // varphi(x,x') = varphi(x) + varphi(x')

            res = resa+resA;
        }

        else if ( xranktype == 2 )
        {
            // varphi(x,x') = varphi(x) \otimes varphi(x') - varphi(x') \otimes varphi(x)

            res =  (resa*resA) - (resA*resa);
        }

         else
         {
            // varphi(x,x') = varphi(x) \otimes varphi(x') + varphi(x') \otimes varphi(x)

            res =  (resa*resA) + (resA*resa);
        }
    }

    else
    {
        yyycK1(res,xan,xainfo,xagradOrder,xagradup,iaupm,xaff,bias,pxyprod,ia,xdim,xconsist,resmode,mlid,xy00,iaset,assumreal,justcalcip);

        res *= xarankw;
    }

    return res;
}

template <class T>
T &MercerKernel::yyybK2(T &res,
                    const SparseVector<gentype> &xa, const SparseVector<gentype> &xb,
                    const vecInfo &xainfo, const vecInfo &xbinfo,
                    int xagradOrder, int xbgradOrder,
                    int xagradOrderR, int xbgradOrderR,
                    int iaupm, int ibupm,
                    int xafarpresent, int xbfarpresent,
                    double xarankw, double xbrankw,
                    double xArankw, double xBrankw,
                    int xafarfarpresent, int xbfarfarpresent,
                    int xafarfarfarpresent, int xbfarfarfarpresent,
                    int xagradup, int xbgradup,
                    int xagradupR, int xbgradupR,
                    int xaignorefarfar, int xbignorefarfar,
                    int xaignorefarfarfar, int xbignorefarfarfar,
                    const T &bias,
                    const gentype **pxyprod,
                    int ia, int ib,
                    int xdim, int xconsist, int resmode, int mlid,
                    const double *xy00, const double *xy10, const double *xy11, int iaset, int ibset, int assumreal, int justcalcip,
                    int adensetype, int bdensetype) const
{
    static const SparseVector<gentype> dummy;

    const SparseVector<gentype> &xan = xa.n();
    const SparseVector<gentype> &xbn = xb.n();

    const SparseVector<gentype> &xaff = ( xafarfarpresent && !xaignorefarfar ) ? xa.f2() : dummy;
    const SparseVector<gentype> &xbff = ( xbfarfarpresent && !xbignorefarfar ) ? xb.f2() : dummy;

    const SparseVector<gentype> &xafff = ( xafarfarfarpresent && !xaignorefarfarfar ) ? xa.f3() : dummy;
    const SparseVector<gentype> &xbfff = ( xbfarfarfarpresent && !xbignorefarfarfar ) ? xb.f3() : dummy;

    //const SparseVector<gentype> &xan = xafarfarpresent ? xa.n() : xa;
    //const SparseVector<gentype> &xbn = xbfarfarpresent ? xb.n() : xb;

    NiceAssert( !( justcalcip && ( xafarpresent || xbfarpresent ) ) );

    if ( xafarpresent && xbfarpresent )
    {
        const SparseVector<gentype> &xanear = xa.n();
        const SparseVector<gentype> &xafar  = xa.f1();
        const SparseVector<gentype> &xaffnear = xaff;
        const SparseVector<gentype> &xafffar  = xafff;
        const vecInfo &xanearinfo = xainfo(0,-1);
        const vecInfo &xafarinfo  = xainfo(1,-1);
        int xagradOrdernear = xagradOrder;
        int xagradOrderfar  = xagradOrderR;
        int xagradupnear = xagradup;
        int xagradupfar  = xagradupR;
        int iaupmnear = iaupm;
        int iaupmfar  = xa.f1upsize();
        int ianear = ia;
        int iafar  = -(((ia+1)*100)+1);

        const SparseVector<gentype> &xbnear = xb.n();
        const SparseVector<gentype> &xbfar  = xb.f1();
        const SparseVector<gentype> &xbffnear = xbff;
        const SparseVector<gentype> &xbfffar  = xbfff;
        const vecInfo &xbnearinfo = xbinfo(0,-1);
        const vecInfo &xbfarinfo  = xbinfo(1,-1);
        int xbgradOrdernear = xbgradOrder;
        int xbgradOrderfar  = xbgradOrderR;
        int xbgradupnear = xbgradup;
        int xbgradupfar  = xbgradupR;
        int ibupmnear = ibupm;
        int ibupmfar  = xb.f1upsize();
        int ibnear = ib;
        int ibfar  = -(((ib+1)*100)+1);

        T resab; yyycK2(resab,xanear,xbnear,xanearinfo,xbnearinfo,xagradOrdernear,xbgradOrdernear,xagradupnear,xbgradupnear,iaupmnear,ibupmnear,xaffnear,xbffnear,bias,nullptr,ianear,ibnear,xdim,xconsist,resmode,mlid,nullptr,nullptr,nullptr,iaset,ibset,assumreal,justcalcip,adensetype,bdensetype);
        T resaB; yyycK2(resaB,xanear,xbfar ,xanearinfo,xbfarinfo ,xagradOrdernear,xbgradOrderfar ,xagradupnear,xbgradupfar ,iaupmnear,ibupmfar ,xaffnear,xbfffar ,bias,nullptr,ianear,ibfar ,xdim,xconsist,resmode,mlid,nullptr,nullptr,nullptr,iaset,ibset,assumreal,justcalcip,adensetype,bdensetype);
        T resAb; yyycK2(resAb,xafar ,xbnear,xafarinfo ,xbnearinfo,xagradOrderfar ,xbgradOrdernear,xagradupfar ,xbgradupnear,iaupmfar ,ibupmnear,xafffar ,xbffnear,bias,nullptr,iafar ,ibnear,xdim,xconsist,resmode,mlid,nullptr,nullptr,nullptr,iaset,ibset,assumreal,justcalcip,adensetype,bdensetype);
        T resAB; yyycK2(resAB,xafar ,xbfar ,xafarinfo ,xbfarinfo ,xagradOrderfar ,xbgradOrderfar ,xagradupfar ,xbgradupfar ,iaupmfar ,ibupmfar ,xafffar ,xbfffar ,bias,nullptr,iafar ,ibfar ,xdim,xconsist,resmode,mlid,nullptr,nullptr,nullptr,iaset,ibset,assumreal,justcalcip,adensetype,bdensetype);

        resab *= (xarankw*xbrankw);
        resaB *= (xarankw*xBrankw);
        resAb *= (xArankw*xbrankw);
        resAB *= (xArankw*xBrankw);

        if ( xranktype == 0 )
        {
            // varphi(x,x') = varphi(x) - varphi(x')

            res = resab-resaB-resAb+resAB;
        }

        else if ( xranktype == 1 )
        {
            // varphi(x,x') = varphi(x) + varphi(x')

            res = resab+resaB+resAb+resAB;
        }

        else if ( xranktype == 2 )
        {
            // varphi(x,x') = varphi(x) \otimes varphi(x') - varphi(x') \otimes varphi(x)

            res = (resab*resAB) - (resaB*resAb) - (resAb*resaB) + (resAB*resab);
        }

        else
        {
            // varphi(x,x') = varphi(x) \otimes varphi(x') + varphi(x') \otimes varphi(x)

            res = (resab*resAB) + (resAB*resab) + (resaB*resAb) + (resAb*resaB);
        }
    }

    else if ( xafarpresent )
    {
        const SparseVector<gentype> &xanear = xa.n();
        const SparseVector<gentype> &xafar  = xa.f1();
        const SparseVector<gentype> &xaffnear = xaff;
        const SparseVector<gentype> &xafffar  = xafff;
        const vecInfo &xanearinfo = xainfo(0,-1);
        const vecInfo &xafarinfo  = xainfo(1,-1);
        int xagradOrdernear = xagradOrder;
        int xagradOrderfar  = xagradOrderR;
        int xagradupnear = xagradup;
        int xagradupfar  = xagradupR;
        int iaupmnear = iaupm;
        int iaupmfar  = xa.f1upsize();
        int ianear = ia;
        int iafar  = -(((ia+1)*100)+1);

        T resab; yyycK2(resab,xanear,xbn,xanearinfo,xbinfo,xagradOrdernear,xbgradOrder,xagradupnear,xbgradup,iaupmnear,ibupm,xaffnear,xbff,bias,nullptr,ianear,ib,xdim,xconsist,resmode,mlid,nullptr,nullptr,nullptr,iaset,ibset,assumreal,justcalcip,adensetype,bdensetype);
        T resAb; yyycK2(resAb,xafar ,xbn,xafarinfo ,xbinfo,xagradOrderfar ,xbgradOrder,xagradupfar ,xbgradup,iaupmfar ,ibupm,xafffar ,xbff,bias,nullptr,iafar ,ib,xdim,xconsist,resmode,mlid,nullptr,nullptr,nullptr,iaset,ibset,assumreal,justcalcip,adensetype,bdensetype);

        resab *= (xarankw*xbrankw);
        resAb *= (xArankw*xbrankw);

        if ( xranktype == 0 )
        {
            // varphi(x,x') = varphi(x) - varphi(x')

            res = resab-resAb;
        }

        else if ( xranktype == 1 )
        {
            // varphi(x,x') = varphi(x) + varphi(x')

            res = resab+resAb;
        }

        else if ( xranktype == 2 )
        {
            // ill-defined

            NiceThrow("No latent function in this case 1");
        }

        else
        {
            // ill-defined

            NiceThrow("No latent function in this case 2");
        }
    }

    else if ( xbfarpresent )
    {
        const SparseVector<gentype> &xbnear = xb.n();
        const SparseVector<gentype> &xbfar  = xb.f1();
        const SparseVector<gentype> &xbffnear = xbff;
        const SparseVector<gentype> &xbfffar  = xbfff;
        const vecInfo &xbnearinfo = xbinfo(0,-1);
        const vecInfo &xbfarinfo  = xbinfo(1,-1);
        int xbgradOrdernear = xbgradOrder;
        int xbgradOrderfar  = xbgradOrderR;
        int xbgradupnear = xbgradup;
        int xbgradupfar  = xbgradupR;
        int ibupmnear = ibupm;
        int ibupmfar  = xa.f1upsize();
        int ibnear = ib;
        int ibfar  = -(((ib+1)*100)+1);

        T resab; yyycK2(resab,xan,xbnear,xainfo,xbnearinfo,xagradOrder,xbgradOrdernear,xagradup,xbgradupnear,iaupm,ibupmnear,xaff,xbffnear,bias,nullptr,ia,ibnear,xdim,xconsist,resmode,mlid,nullptr,nullptr,nullptr,iaset,ibset,assumreal,justcalcip,adensetype,bdensetype);
        T resaB; yyycK2(resaB,xan,xbfar ,xainfo,xbfarinfo ,xagradOrder,xbgradOrderfar ,xagradup,xbgradupfar ,iaupm,ibupmfar ,xaff,xbfffar ,bias,nullptr,ia,ibfar ,xdim,xconsist,resmode,mlid,nullptr,nullptr,nullptr,iaset,ibset,assumreal,justcalcip,adensetype,bdensetype);

        resab *= (xarankw*xbrankw);
        resaB *= (xarankw*xBrankw);

        if ( xranktype == 0 )
        {
            // varphi(x,x') = varphi(x) - varphi(x')

            res = resab-resaB;
        }

        else if ( xranktype == 1 )
        {
            // varphi(x,x') = varphi(x) + varphi(x')

            res = resab+resaB;
        }

        else if ( xranktype == 2 )
        {
            // ill-defined

            NiceThrow("No latent function in this case 3");
        }

        else
        {
            // ill-defined

            NiceThrow("No latent function in this case 4");
        }
    }

    else
    {
        yyycK2(res,xan,xbn,xainfo,xbinfo,xagradOrder,xbgradOrder,xagradup,xbgradup,iaupm,ibupm,xaff,xbff,bias,pxyprod,ia,ib,xdim,xconsist,resmode,mlid,xy00,xy10,xy11,iaset,ibset,assumreal,justcalcip,adensetype,bdensetype);

        res *= (xarankw*xbrankw);
NiceAssert(!testisvnan(res) && !testisinf(res));
    }

    return res;
}
template <class T>
T &MercerKernel::yyybK2x2(T &res,
                          const SparseVector<gentype> &x, const SparseVector<gentype> &xa, const SparseVector<gentype> &xb,
                          const vecInfo &xinfo, const vecInfo &xainfo, const vecInfo &xbinfo,
                          int xgradOrder, int xagradOrder, int xbgradOrder,
                          int xgradOrderR, int xagradOrderR, int xbgradOrderR,
                          int iupm, int iaupm, int ibupm,
                          int xfarpresent, int xafarpresent, int xbfarpresent,
                          double xrankw,
                          double xarankw, double xbrankw,
                          double xArankw, double xBrankw,
                          int xfarfarpresent, int xafarfarpresent, int xbfarfarpresent,
                          int xfarfarfarpresent, int xafarfarfarpresent, int xbfarfarfarpresent,
                          int xgradup, int xagradup, int xbgradup,
                          int xgradupR, int xagradupR, int xbgradupR,
                          int xignorefarfar, int xaignorefarfar, int xbignorefarfar,
                          int xignorefarfarfar, int xaignorefarfarfar, int xbignorefarfarfar,
                          const T &bias,
                          int i, int ia, int ib,
                          int xdim, int xbonsist, int resmode, int mlid,
                          const double *xy00, const double *xy10, const double *xy11, const double *xy20, const double *xy21, const double *xy22,
                          int iset, int iaset, int ibset,
                          int assumreal, int justcalcip,
                          int densetype, int adensetype, int bdensetype) const
{
    (void) xgradOrderR;
    (void) xgradupR;
    (void) xfarfarfarpresent;
    (void) xignorefarfarfar;

    static const SparseVector<gentype> dummy;

    const SparseVector<gentype> &xn  = x.n();
    const SparseVector<gentype> &xan = xa.n();
    const SparseVector<gentype> &xbn = xb.n();

    const SparseVector<gentype> &xff  = ( xfarfarpresent  && !xignorefarfar  ) ? x.f2()  : dummy;
    const SparseVector<gentype> &xaff = ( xafarfarpresent && !xaignorefarfar ) ? xa.f2() : dummy;
    const SparseVector<gentype> &xbff = ( xbfarfarpresent && !xbignorefarfar ) ? xb.f2() : dummy;

//    const SparseVector<gentype> &xfff  = ( xfarfarfarpresent  && !xignorefarfarfar  ) ? x.f3()  : dummy;
    const SparseVector<gentype> &xafff = ( xafarfarfarpresent && !xaignorefarfarfar ) ? xa.f3() : dummy;
    const SparseVector<gentype> &xbfff = ( xbfarfarfarpresent && !xbignorefarfarfar ) ? xb.f3() : dummy;

    NiceAssert( !( justcalcip && ( xfarpresent || xafarpresent || xbfarpresent ) ) );

    if ( xfarpresent && xafarpresent && xbfarpresent )
    {
        NiceThrow("Ranking not dense not supported 0.");

            // varphi(x,x') = varphi(x) - varphi(x')
            // K(x,xa) = K(x,xa) - K(x,xa') - K(x',xa) + K(x',xa')
            // K(x,xb) = K(x,xb) - K(x,xb') - K(x',xb) + K(x',xb')
            // K(x,xa).K(x,xb) = K(x ,xa ).K(x,xb) - K(x ,xa ).K(x,xb') - K(x ,xa ).K(x',xb) + K(x ,xa ).K(x',xb')
            //                 - K(x ,xa').K(x,xb) + K(x ,xa').K(x,xb') + K(x ,xa').K(x',xb) - K(x ,xa').K(x',xb')
            //                 - K(x',xa ).K(x,xb) + K(x',xa ).K(x,xb') + K(x',xa ).K(x',xb) - K(x',xa ).K(x',xb')
            //                 + K(x',xa').K(x,xb) - K(x',xa').K(x,xb') - K(x',xa').K(x',xb) + K(x',xa').K(x',xb')
            // .....
            // See the problem?
    }

    else if ( xfarpresent && xafarpresent )
    {
        NiceThrow("Ranking not dense not supported 1.");
    }

    else if ( xfarpresent && xbfarpresent )
    {
        NiceThrow("Ranking not dense not supported 2.");
    }

    else if ( xafarpresent && xbfarpresent )
    {
        const SparseVector<gentype> &xanear = xa.n();
        const SparseVector<gentype> &xafar  = xa.f1();
        const SparseVector<gentype> &xaffnear = xaff;
        const SparseVector<gentype> &xafffar  = xafff;
        const vecInfo &xanearinfo = xainfo(0,-1);
        const vecInfo &xafarinfo  = xainfo(1,-1);
        int xagradOrdernear = xagradOrder;
        int xagradOrderfar  = xagradOrderR;
        int xagradupnear = xagradup;
        int xagradupfar  = xagradupR;
        int iaupmnear = iaupm;
        int iaupmfar  = xa.f1upsize();
        int ianear = ia;
        int iafar  = -(((ia+1)*100)+1);

        const SparseVector<gentype> &xbnear = xb.n();
        const SparseVector<gentype> &xbfar  = xb.f1();
        const SparseVector<gentype> &xbffnear = xbff;
        const SparseVector<gentype> &xbfffar  = xbfff;
        const vecInfo &xbnearinfo = xbinfo(0,-1);
        const vecInfo &xbfarinfo  = xbinfo(1,-1);
        int xbgradOrdernear = xbgradOrder;
        int xbgradOrderfar  = xbgradOrderR;
        int xbgradupnear = xbgradup;
        int xbgradupfar  = xbgradupR;
        int ibupmnear = ibupm;
        int ibupmfar  = xb.f1upsize();
        int ibnear = ib;
        int ibfar  = -(((ib+1)*100)+1);

        T resab; yyycK2x2(resab,xn,xanear,xbnear,xinfo,xanearinfo,xbnearinfo,xgradOrder,xagradOrdernear,xbgradOrdernear,xgradup,xagradupnear,xbgradupnear,iupm,iaupmnear,ibupmnear,xff,xaffnear,xbffnear,bias,i,ianear,ibnear,xdim,xbonsist,resmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iset,iaset,ibset,assumreal,justcalcip,densetype,adensetype,bdensetype);
        T resaB; yyycK2x2(resaB,xn,xanear,xbfar ,xinfo,xanearinfo,xbfarinfo ,xgradOrder,xagradOrdernear,xbgradOrderfar ,xgradup,xagradupnear,xbgradupfar ,iupm,iaupmnear,ibupmfar ,xff,xaffnear,xbfffar ,bias,i,ianear,ibfar ,xdim,xbonsist,resmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iset,iaset,ibset,assumreal,justcalcip,densetype,adensetype,bdensetype);
        T resAb; yyycK2x2(resAb,xn,xafar ,xbnear,xinfo,xafarinfo ,xbnearinfo,xgradOrder,xagradOrderfar ,xbgradOrdernear,xgradup,xagradupfar ,xbgradupnear,iupm,iaupmfar ,ibupmnear,xff,xafffar ,xbffnear,bias,i,iafar ,ibnear,xdim,xbonsist,resmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iset,iaset,ibset,assumreal,justcalcip,densetype,adensetype,bdensetype);
        T resAB; yyycK2x2(resAB,xn,xafar ,xbfar ,xinfo,xafarinfo ,xbfarinfo ,xgradOrder,xagradOrderfar ,xbgradOrderfar ,xgradup,xagradupfar ,xbgradupfar ,iupm,iaupmfar ,ibupmfar ,xff,xafffar ,xbfffar ,bias,i,iafar ,ibfar ,xdim,xbonsist,resmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iset,iaset,ibset,assumreal,justcalcip,densetype,adensetype,bdensetype);

        resab *= (xrankw*xarankw*xbrankw);
        resaB *= (xrankw*xarankw*xBrankw);
        resAb *= (xrankw*xArankw*xbrankw);
        resAB *= (xrankw*xArankw*xBrankw);

        if ( xranktype == 0 )
        {
            // varphi(x,x') = varphi(x) - varphi(x')
            // K(x,xa) = K(x,xa) - K(x,xa')
            // K(x,xb) = K(x,xb) - K(x,xb')
            // K(x,xa).K(x,xb) = K(x ,xa ).K(x,xb) - K(x ,xa ).K(x,xb')
            //                 - K(x ,xa').K(x,xb) + K(x ,xa').K(x,xb')

            res = resab-resaB-resAb+resAB;
        }

        else if ( xranktype == 1 )
        {
            // varphi(x,x') = varphi(x) + varphi(x')

            res = resab+resaB+resAb+resAB;
        }

        else if ( xranktype == 2 )
        {
            NiceThrow("No latent function in this case 6 2x2");
        }

        else
        {
            NiceThrow("No latent function in this case 7 2x2");
        }
    }

    else if ( xfarpresent )
    {
        NiceThrow("Ranking not dense not supported 3.");
    }

    else if ( xafarpresent )
    {
        const SparseVector<gentype> &xanear = xa.n();
        const SparseVector<gentype> &xafar  = xa.f1();
        const SparseVector<gentype> &xaffnear = xaff;
        const SparseVector<gentype> &xafffar  = xafff;
        const vecInfo &xanearinfo = xainfo(0,-1);
        const vecInfo &xafarinfo  = xainfo(1,-1);
        int xagradOrdernear = xagradOrder;
        int xagradOrderfar  = xagradOrderR;
        int xagradupnear = xagradup;
        int xagradupfar  = xagradupR;
        int iaupmnear = iaupm;
        int iaupmfar  = xa.f1upsize();
        int ianear = ia;
        int iafar  = -(((ia+1)*100)+1);

        T resab; yyycK2x2(resab,xn,xanear,xbn,xinfo,xanearinfo,xbinfo,xgradOrder,xagradOrdernear,xbgradOrder,xgradup,xagradupnear,xbgradup,iupm,iaupmnear,ibupm,xff,xaffnear,xbff,bias,i,ianear,ib,xdim,xbonsist,resmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iset,iaset,ibset,assumreal,justcalcip,densetype,adensetype,bdensetype);
        T resAb; yyycK2x2(resAb,xn,xafar ,xbn,xinfo,xafarinfo ,xbinfo,xgradOrder,xagradOrderfar ,xbgradOrder,xgradup,xagradupfar ,xbgradup,iupm,iaupmfar ,ibupm,xff,xafffar ,xbff,bias,i,iafar ,ib,xdim,xbonsist,resmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iset,iaset,ibset,assumreal,justcalcip,densetype,adensetype,bdensetype);

        resab *= (xrankw*xarankw*xbrankw);
        resAb *= (xrankw*xArankw*xbrankw);

        if ( xranktype == 0 )
        {
            // varphi(x,x') = varphi(x) - varphi(x')

            res = resab-resAb;
        }

        else if ( xranktype == 1 )
        {
            // varphi(x,x') = varphi(x) + varphi(x')

            res = resab+resAb;
        }

        else if ( xranktype == 2 )
        {
            NiceThrow("No latent function in this case 10 2x2");
        }

        else
        {
            NiceThrow("No latent function in this case 11 2x2");
        }
    }

    else if ( xbfarpresent )
    {
        const SparseVector<gentype> &xbnear = xb.n();
        const SparseVector<gentype> &xbfar  = xb.f1();
        const SparseVector<gentype> &xbffnear = xbff;
        const SparseVector<gentype> &xbfffar  = xbfff;
        const vecInfo &xbnearinfo = xbinfo(0,-1);
        const vecInfo &xbfarinfo  = xbinfo(1,-1);
        int xbgradOrdernear = xbgradOrder;
        int xbgradOrderfar  = xbgradOrderR;
        int xbgradupnear = xbgradup;
        int xbgradupfar  = xbgradupR;
        int ibupmnear = ibupm;
        int ibupmfar  = xb.f1upsize();
        int ibnear = ib;
        int ibfar  = -(((ib+1)*100)+1);

        T resab; yyycK2x2(resab,xn,xan,xbnear,xinfo,xainfo,xbnearinfo,xgradOrder,xagradOrder,xbgradOrdernear,xgradup,xagradup,xbgradupnear,iupm,iaupm,ibupmnear,xff,xaff,xbffnear,bias,i,ia,ibnear,xdim,xbonsist,resmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iset,iaset,ibset,assumreal,justcalcip,densetype,adensetype,bdensetype);
        T resaB; yyycK2x2(resaB,xn,xan,xbfar ,xinfo,xainfo,xbfarinfo ,xgradOrder,xagradOrder,xbgradOrderfar ,xgradup,xagradup,xbgradupfar ,iupm,iaupm,ibupmfar ,xff,xaff,xbfffar ,bias,i,ia,ibfar ,xdim,xbonsist,resmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iset,iaset,ibset,assumreal,justcalcip,densetype,adensetype,bdensetype);

        resab *= (xrankw*xarankw*xbrankw);
        resaB *= (xrankw*xarankw*xBrankw);

        if ( xranktype == 0 )
        {
            // varphi(x,x') = varphi(x) - varphi(x')

            res = resab-resaB;
        }

        else if ( xranktype == 1 )
        {
            // varphi(x,x') = varphi(x) + varphi(x')

            res = resab+resaB;
        }

        else if ( xranktype == 2 )
        {
            NiceThrow("No latent function in this case 12 2x2");
        }

        else
        {
            NiceThrow("No latent function in this case 13 2x2");
        }
    }

    else
    {
//errstream() << "phantomxyzabcabc yyybk2x2\n";
        yyycK2x2(res,xn,xan,xbn,xinfo,xainfo,xbinfo,xgradOrder,xagradOrder,xbgradOrder,xgradup,xagradup,xbgradup,iupm,iaupm,ibupm,xff,xaff,xbff,bias,i,ia,ib,xdim,xbonsist,resmode,mlid,xy00,xy10,xy11,xy20,xy21,xy22,iset,iaset,ibset,assumreal,justcalcip,densetype,adensetype,bdensetype);

        res *= (xrankw*xarankw*xbrankw);
    }

    return res;
}

template <class T>
T &MercerKernel::yyybK3(T &res,
                    const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, const SparseVector<gentype> &xc,
                    const vecInfo &xainfo, const vecInfo &xbinfo, const vecInfo &xcinfo,
                    int xagradOrder, int xbgradOrder, int xcgradOrder,
                    int xagradOrderR, int xbgradOrderR, int xcgradOrderR,
                    int iaupm, int ibupm, int icupm,
                    int xafarpresent, int xbfarpresent, int xcfarpresent,
                    double xarankw, double xbrankw, double xcrankw,
                    double xArankw, double xBrankw, double xCrankw,
                    int xafarfarpresent, int xbfarfarpresent, int xcfarfarpresent,
                    int xafarfarfarpresent, int xbfarfarfarpresent, int xcfarfarfarpresent,
                    int xagradup, int xbgradup, int xcgradup,
                    int xagradupR, int xbgradupR, int xcgradupR,
                    int xaignorefarfar, int xbignorefarfar, int xcignorefarfar,
                    int xaignorefarfarfar, int xbignorefarfarfar, int xcignorefarfarfar,
                    const T &bias,
                    const gentype **pxyprod,
                    int ia, int ib, int ic,
                    int xdim, int xconsist, int xresmode, int mlid,
                    const double *xy00, const double *xy10, const double *xy11, const double *xy20, const double *xy21, const double *xy22, int iaset, int ibset, int icset, int assumreal, int justcalcip) const
{
    static const SparseVector<gentype> dummy;

    const SparseVector<gentype> &xan = xa.n();
    const SparseVector<gentype> &xbn = xb.n();
    const SparseVector<gentype> &xcn = xc.n();

    const SparseVector<gentype> &xaff = ( xafarfarpresent && !xaignorefarfar ) ? xa.f2() : dummy;
    const SparseVector<gentype> &xbff = ( xbfarfarpresent && !xbignorefarfar ) ? xb.f2() : dummy;
    const SparseVector<gentype> &xcff = ( xcfarfarpresent && !xcignorefarfar ) ? xc.f2() : dummy;

    const SparseVector<gentype> &xafff = ( xafarfarfarpresent && !xaignorefarfarfar ) ? xa.f3() : dummy;
    const SparseVector<gentype> &xbfff = ( xbfarfarfarpresent && !xbignorefarfarfar ) ? xb.f3() : dummy;
    const SparseVector<gentype> &xcfff = ( xcfarfarfarpresent && !xcignorefarfarfar ) ? xc.f3() : dummy;

    //const SparseVector<gentype> &xan = xafarfarpresent ? xa.n() : xa;
    //const SparseVector<gentype> &xbn = xbfarfarpresent ? xb.n() : xb;
    //const SparseVector<gentype> &xcn = xcfarfarpresent ? xc.n() : xc;

    NiceAssert( !( justcalcip && ( xafarpresent || xbfarpresent || xcfarpresent ) ) );

    if ( xafarpresent && xbfarpresent && xcfarpresent )
    {
        const SparseVector<gentype> &xanear = xa.n();
        const SparseVector<gentype> &xafar  = xa.f1();
        const SparseVector<gentype> &xaffnear = xaff;
        const SparseVector<gentype> &xafffar  = xafff;
        const vecInfo &xanearinfo = xainfo(0,-1);
        const vecInfo &xafarinfo  = xainfo(1,-1);
        int xagradOrdernear = xagradOrder;
        int xagradOrderfar  = xagradOrderR;
        int xagradupnear = xagradup;
        int xagradupfar  = xagradupR;
        int iaupmnear = iaupm;
        int iaupmfar  = xa.f1upsize();
        int ianear = ia;
        int iafar  = -(((ia+1)*100)+1);

        const SparseVector<gentype> &xbnear = xb.n();
        const SparseVector<gentype> &xbfar  = xb.f1();
        const SparseVector<gentype> &xbffnear = xbff;
        const SparseVector<gentype> &xbfffar  = xbfff;
        const vecInfo &xbnearinfo = xbinfo(0,-1);
        const vecInfo &xbfarinfo  = xbinfo(1,-1);
        int xbgradOrdernear = xbgradOrder;
        int xbgradOrderfar  = xbgradOrderR;
        int xbgradupnear = xbgradup;
        int xbgradupfar  = xbgradupR;
        int ibupmnear = ibupm;
        int ibupmfar  = xb.f1upsize();
        int ibnear = ib;
        int ibfar  = -(((ib+1)*100)+1);

        const SparseVector<gentype> &xcnear = xc.n();
        const SparseVector<gentype> &xcfar  = xc.f1();
        const SparseVector<gentype> &xcffnear = xcff;
        const SparseVector<gentype> &xcfffar  = xcfff;
        const vecInfo &xcnearinfo = xcinfo(0,-1);
        const vecInfo &xcfarinfo  = xcinfo(1,-1);
        int xcgradOrdernear = xcgradOrder;
        int xcgradOrderfar  = xcgradOrderR;
        int xcgradupnear = xcgradup;
        int xcgradupfar  = xcgradupR;
        int icupmnear = icupm;
        int icupmfar  = xc.f1upsize();
        int icnear = ic;
        int icfar  = -(((ic+1)*100)+1);

        T resabc; yyycK3(resabc,xanear,xbnear,xcnear,xanearinfo,xbnearinfo,xcnearinfo,xagradOrdernear,xbgradOrdernear,xcgradOrdernear,xagradupnear,xbgradupnear,xcgradupnear,iaupmnear,ibupmnear,icupmnear,xaffnear,xbffnear,xcffnear,bias,nullptr,ianear,ibnear,icnear,xdim,xconsist,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iaset,ibset,icset,assumreal,justcalcip);
        T resabC; yyycK3(resabC,xanear,xbnear,xcfar ,xanearinfo,xbnearinfo,xcfarinfo ,xagradOrdernear,xbgradOrdernear,xcgradOrderfar ,xagradupnear,xbgradupnear,xcgradupfar ,iaupmnear,ibupmnear,icupmfar ,xaffnear,xbffnear,xcfffar ,bias,nullptr,ianear,ibnear,icfar ,xdim,xconsist,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iaset,ibset,icset,assumreal,justcalcip);
        T resaBc; yyycK3(resaBc,xanear,xbfar ,xcnear,xanearinfo,xbfarinfo ,xcnearinfo,xagradOrdernear,xbgradOrderfar ,xcgradOrdernear,xagradupnear,xbgradupfar ,xcgradupnear,iaupmnear,ibupmfar ,icupmnear,xaffnear,xbfffar ,xcffnear,bias,nullptr,ianear,ibfar ,icnear,xdim,xconsist,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iaset,ibset,icset,assumreal,justcalcip);
        T resaBC; yyycK3(resaBC,xanear,xbfar ,xcfar ,xanearinfo,xbfarinfo ,xcfarinfo ,xagradOrdernear,xbgradOrderfar ,xcgradOrderfar ,xagradupnear,xbgradupfar ,xcgradupfar ,iaupmnear,ibupmfar ,icupmfar ,xaffnear,xbfffar ,xcfffar ,bias,nullptr,ianear,ibfar ,icfar ,xdim,xconsist,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iaset,ibset,icset,assumreal,justcalcip);
        T resAbc; yyycK3(resAbc,xafar ,xbnear,xcnear,xafarinfo ,xbnearinfo,xcnearinfo,xagradOrderfar ,xbgradOrdernear,xcgradOrdernear,xagradupfar ,xbgradupnear,xcgradupnear,iaupmfar ,ibupmnear,icupmnear,xafffar ,xbffnear,xcffnear,bias,nullptr,iafar ,ibnear,icnear,xdim,xconsist,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iaset,ibset,icset,assumreal,justcalcip);
        T resAbC; yyycK3(resAbC,xafar ,xbnear,xcfar ,xafarinfo ,xbnearinfo,xcfarinfo ,xagradOrderfar ,xbgradOrdernear,xcgradOrderfar ,xagradupfar ,xbgradupnear,xcgradupfar ,iaupmfar ,ibupmnear,icupmfar ,xafffar ,xbffnear,xcfffar ,bias,nullptr,iafar ,ibnear,icfar ,xdim,xconsist,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iaset,ibset,icset,assumreal,justcalcip);
        T resABc; yyycK3(resABc,xafar ,xbfar ,xcnear,xafarinfo ,xbfarinfo ,xcnearinfo,xagradOrderfar ,xbgradOrderfar ,xcgradOrdernear,xagradupfar ,xbgradupfar ,xcgradupnear,iaupmfar ,ibupmfar ,icupmnear,xafffar ,xbfffar ,xcffnear,bias,nullptr,iafar ,ibfar ,icnear,xdim,xconsist,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iaset,ibset,icset,assumreal,justcalcip);
        T resABC; yyycK3(resABC,xafar ,xbfar ,xcfar ,xafarinfo ,xbfarinfo ,xcfarinfo ,xagradOrderfar ,xbgradOrderfar ,xcgradOrderfar ,xagradupfar ,xbgradupfar ,xcgradupfar ,iaupmfar ,ibupmfar ,icupmfar ,xafffar ,xbfffar ,xcfffar ,bias,nullptr,iafar ,ibfar ,icfar ,xdim,xconsist,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iaset,ibset,icset,assumreal,justcalcip);

        resabc *= (xarankw*xbrankw*xcrankw);
        resabC *= (xarankw*xbrankw*xCrankw);
        resaBc *= (xarankw*xBrankw*xcrankw);
        resaBC *= (xarankw*xBrankw*xCrankw);
        resAbc *= (xArankw*xbrankw*xcrankw);
        resAbC *= (xArankw*xbrankw*xCrankw);
        resABc *= (xArankw*xBrankw*xcrankw);
        resABC *= (xArankw*xBrankw*xCrankw);

        if ( xranktype == 0 )
        {
            // varphi(x,x') = varphi(x) - varphi(x')

            res = resabc-resabC-resaBc+resaBC-resAbc+resAbC+resABc-resABC;
        }

        else if ( xranktype == 1 )
        {
            // varphi(x,x') = varphi(x) + varphi(x')

            res = resabc+resabC+resaBc+resaBC+resAbc+resAbC+resABc+resABC;
        }

        else if ( xranktype == 2 )
        {
            // varphi(x,x') = varphi(x) \otimes varphi(x') - varphi(x') \otimes varphi(x)

            res = (resabc*resABC) - (resabC*resABc) - (resaBc*resAbC) + (resaBC*resAbc) - (resAbc*resaBC) + (resAbC*resaBc) + (resABc*resabC) - (resABC*resabc);
        }

        else
        {
            // varphi(x,x') = varphi(x) \otimes varphi(x') + varphi(x') \otimes varphi(x)

            res = (resabc*resABC) + (resabC*resABc) + (resaBc*resAbC) + (resaBC*resAbc) + (resAbc*resaBC) + (resAbC*resaBc) + (resABc*resabC) + (resABC*resabc);
        }
    }

    else if ( xafarpresent && xbfarpresent )
    {
        const SparseVector<gentype> &xanear = xa.n();
        const SparseVector<gentype> &xafar  = xa.f1();
        const SparseVector<gentype> &xaffnear = xaff;
        const SparseVector<gentype> &xafffar  = xafff;
        const vecInfo &xanearinfo = xainfo(0,-1);
        const vecInfo &xafarinfo  = xainfo(1,-1);
        int xagradOrdernear = xagradOrder;
        int xagradOrderfar  = xagradOrderR;
        int xagradupnear = xagradup;
        int xagradupfar  = xagradupR;
        int iaupmnear = iaupm;
        int iaupmfar  = xa.f1upsize();
        int ianear = ia;
        int iafar  = -(((ia+1)*100)+1);

        const SparseVector<gentype> &xbnear = xb.n();
        const SparseVector<gentype> &xbfar  = xb.f1();
        const SparseVector<gentype> &xbffnear = xbff;
        const SparseVector<gentype> &xbfffar  = xbfff;
        const vecInfo &xbnearinfo = xbinfo(0,-1);
        const vecInfo &xbfarinfo  = xbinfo(1,-1);
        int xbgradOrdernear = xbgradOrder;
        int xbgradOrderfar  = xbgradOrderR;
        int xbgradupnear = xbgradup;
        int xbgradupfar  = xbgradupR;
        int ibupmnear = ibupm;
        int ibupmfar  = xb.f1upsize();
        int ibnear = ib;
        int ibfar  = -(((ib+1)*100)+1);

        T resabc; yyycK3(resabc,xanear,xbnear,xcn,xanearinfo,xbnearinfo,xcinfo,xagradOrdernear,xbgradOrdernear,xcgradOrder,xagradupnear,xbgradupnear,xcgradup,iaupmnear,ibupmnear,icupm,xaffnear,xbffnear,xcff,bias,nullptr,ianear,ibnear,ic,xdim,xconsist,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iaset,ibset,icset,assumreal,justcalcip);
        T resaBc; yyycK3(resaBc,xanear,xbfar ,xcn,xanearinfo,xbfarinfo ,xcinfo,xagradOrdernear,xbgradOrderfar ,xcgradOrder,xagradupnear,xbgradupfar ,xcgradup,iaupmnear,ibupmfar ,icupm,xaffnear,xbfffar ,xcff,bias,nullptr,ianear,ibfar ,ic,xdim,xconsist,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iaset,ibset,icset,assumreal,justcalcip);
        T resAbc; yyycK3(resAbc,xafar ,xbnear,xcn,xafarinfo ,xbnearinfo,xcinfo,xagradOrderfar ,xbgradOrdernear,xcgradOrder,xagradupfar ,xbgradupnear,xcgradup,iaupmfar ,ibupmnear,icupm,xafffar ,xbffnear,xcff,bias,nullptr,iafar ,ibnear,ic,xdim,xconsist,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iaset,ibset,icset,assumreal,justcalcip);
        T resABc; yyycK3(resABc,xafar ,xbfar ,xcn,xafarinfo ,xbfarinfo ,xcinfo,xagradOrderfar ,xbgradOrderfar ,xcgradOrder,xagradupfar ,xbgradupfar ,xcgradup,iaupmfar ,ibupmfar ,icupm,xafffar ,xbfffar ,xcff,bias,nullptr,iafar ,ibfar ,ic,xdim,xconsist,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iaset,ibset,icset,assumreal,justcalcip);

        resabc *= (xarankw*xbrankw*xcrankw);
        resaBc *= (xarankw*xBrankw*xcrankw);
        resAbc *= (xArankw*xbrankw*xcrankw);
        resABc *= (xArankw*xBrankw*xcrankw);

        if ( xranktype == 0 )
        {
            // varphi(x,x') = varphi(x) - varphi(x')

            res = resabc-resaBc-resAbc+resABc;
        }

        else if ( xranktype == 1 )
        {
            // varphi(x,x') = varphi(x) + varphi(x')

            res = resabc+resaBc+resAbc+resABc;
        }

        else if ( xranktype == 2 )
        {
            // ill-defined

            NiceThrow("No latent function in this case 5");
        }

        else
        {
            // ill-defined

            NiceThrow("No latent function in this case 6");
        }
    }

    else if ( xafarpresent && xcfarpresent )
    {
        const SparseVector<gentype> &xanear = xa.n();
        const SparseVector<gentype> &xafar  = xa.f1();
        const SparseVector<gentype> &xaffnear = xaff;
        const SparseVector<gentype> &xafffar  = xafff;
        const vecInfo &xanearinfo = xainfo(0,-1);
        const vecInfo &xafarinfo  = xainfo(1,-1);
        int xagradOrdernear = xagradOrder;
        int xagradOrderfar  = xagradOrderR;
        int xagradupnear = xagradup;
        int xagradupfar  = xagradupR;
        int iaupmnear = iaupm;
        int iaupmfar  = xa.f1upsize();
        int ianear = ia;
        int iafar  = -(((ia+1)*100)+1);

        const SparseVector<gentype> &xcnear = xc.n();
        const SparseVector<gentype> &xcfar  = xc.f1();
        const SparseVector<gentype> &xcffnear = xcff;
        const SparseVector<gentype> &xcfffar  = xcfff;
        const vecInfo &xcnearinfo = xcinfo(0,-1);
        const vecInfo &xcfarinfo  = xcinfo(1,-1);
        int xcgradOrdernear = xcgradOrder;
        int xcgradOrderfar  = xcgradOrderR;
        int xcgradupnear = xcgradup;
        int xcgradupfar  = xcgradupR;
        int icupmnear = icupm;
        int icupmfar  = xc.f1upsize();
        int icnear = ic;
        int icfar  = -(((ic+1)*100)+1);

        T resabc; yyycK3(resabc,xanear,xbn,xcnear,xanearinfo,xbinfo,xcnearinfo,xagradOrdernear,xbgradOrder,xcgradOrdernear,xagradupnear,xbgradup,xcgradupnear,iaupmnear,ibupm,icupmnear,xaffnear,xbff,xcffnear,bias,nullptr,ianear,ib,icnear,xdim,xconsist,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iaset,ibset,icset,assumreal,justcalcip);
        T resabC; yyycK3(resabC,xanear,xbn,xcfar ,xanearinfo,xbinfo,xcfarinfo ,xagradOrdernear,xbgradOrder,xcgradOrderfar ,xagradupnear,xbgradup,xcgradupfar ,iaupmnear,ibupm,icupmfar ,xaffnear,xbff,xcfffar ,bias,nullptr,ianear,ib,icfar ,xdim,xconsist,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iaset,ibset,icset,assumreal,justcalcip);
        T resAbc; yyycK3(resAbc,xafar ,xbn,xcnear,xafarinfo ,xbinfo,xcnearinfo,xagradOrderfar ,xbgradOrder,xcgradOrdernear,xagradupfar ,xbgradup,xcgradupnear,iaupmfar ,ibupm,icupmnear,xafffar ,xbff,xcffnear,bias,nullptr,iafar ,ib,icnear,xdim,xconsist,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iaset,ibset,icset,assumreal,justcalcip);
        T resAbC; yyycK3(resAbC,xafar ,xbn,xcfar ,xafarinfo ,xbinfo,xcfarinfo ,xagradOrderfar ,xbgradOrder,xcgradOrderfar ,xagradupfar ,xbgradup,xcgradupfar ,iaupmfar ,ibupm,icupmfar ,xafffar ,xbff,xcfffar ,bias,nullptr,iafar ,ib,icfar ,xdim,xconsist,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iaset,ibset,icset,assumreal,justcalcip);

        resabc *= (xarankw*xbrankw*xcrankw);
        resabC *= (xarankw*xbrankw*xCrankw);
        resAbc *= (xArankw*xbrankw*xcrankw);
        resAbC *= (xArankw*xbrankw*xCrankw);

        if ( xranktype == 0 )
        {
            // varphi(x,x') = varphi(x) - varphi(x')

            res = resabc-resabC-resAbc+resAbC;
        }

        else if ( xranktype == 1 )
        {
            // varphi(x,x') = varphi(x) + varphi(x')

            res = resabc+resabC+resAbc+resAbC;
        }

        else if ( xranktype == 2 )
        {
            // ill-defined

            NiceThrow("No latent function in this case 7");
        }

        else
        {
            // ill-defined

            NiceThrow("No latent function in this case 8");
        }
    }

    else if ( xbfarpresent && xcfarpresent )
    {
        const SparseVector<gentype> &xbnear = xb.n();
        const SparseVector<gentype> &xbfar  = xb.f1();
        const SparseVector<gentype> &xbffnear = xbff;
        const SparseVector<gentype> &xbfffar  = xbfff;
        const vecInfo &xbnearinfo = xbinfo(0,-1);
        const vecInfo &xbfarinfo  = xbinfo(1,-1);
        int xbgradOrdernear = xbgradOrder;
        int xbgradOrderfar  = xbgradOrderR;
        int xbgradupnear = xbgradup;
        int xbgradupfar  = xbgradupR;
        int ibupmnear = ibupm;
        int ibupmfar  = xb.f1upsize();
        int ibnear = ib;
        int ibfar  = -(((ib+1)*100)+1);

        const SparseVector<gentype> &xcnear = xc.n();
        const SparseVector<gentype> &xcfar  = xc.f1();
        const SparseVector<gentype> &xcffnear = xcff;
        const SparseVector<gentype> &xcfffar  = xcfff;
        const vecInfo &xcnearinfo = xcinfo(0,-1);
        const vecInfo &xcfarinfo  = xcinfo(1,-1);
        int xcgradOrdernear = xcgradOrder;
        int xcgradOrderfar  = xcgradOrderR;
        int xcgradupnear = xcgradup;
        int xcgradupfar  = xcgradupR;
        int icupmnear = icupm;
        int icupmfar  = xc.f1upsize();
        int icnear = ic;
        int icfar  = -(((ic+1)*100)+1);

        T resabc; yyycK3(resabc,xan,xbnear,xcnear,xainfo,xbnearinfo,xcnearinfo,xagradOrder,xbgradOrdernear,xcgradOrdernear,xagradup,xbgradupnear,xcgradupnear,iaupm,ibupmnear,icupmnear,xaff,xbffnear,xcffnear,bias,nullptr,ia,ibnear,icnear,xdim,xconsist,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iaset,ibset,icset,assumreal,justcalcip);
        T resabC; yyycK3(resabC,xan,xbnear,xcfar ,xainfo,xbnearinfo,xcfarinfo ,xagradOrder,xbgradOrdernear,xcgradOrderfar ,xagradup,xbgradupnear,xcgradupfar ,iaupm,ibupmnear,icupmfar ,xaff,xbffnear,xcfffar ,bias,nullptr,ia,ibnear,icfar ,xdim,xconsist,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iaset,ibset,icset,assumreal,justcalcip);
        T resaBc; yyycK3(resaBc,xan,xbfar ,xcnear,xainfo,xbfarinfo ,xcnearinfo,xagradOrder,xbgradOrderfar ,xcgradOrdernear,xagradup,xbgradupfar ,xcgradupnear,iaupm,ibupmfar ,icupmnear,xaff,xbfffar ,xcffnear,bias,nullptr,ia,ibfar ,icnear,xdim,xconsist,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iaset,ibset,icset,assumreal,justcalcip);
        T resaBC; yyycK3(resaBC,xan,xbfar ,xcfar ,xainfo,xbfarinfo ,xcfarinfo ,xagradOrder,xbgradOrderfar ,xcgradOrderfar ,xagradup,xbgradupfar ,xcgradupfar ,iaupm,ibupmfar ,icupmfar ,xaff,xbfffar ,xcfffar ,bias,nullptr,ia,ibfar ,icfar ,xdim,xconsist,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iaset,ibset,icset,assumreal,justcalcip);

        resabc *= (xarankw*xbrankw*xcrankw);
        resabC *= (xarankw*xbrankw*xCrankw);
        resaBc *= (xarankw*xBrankw*xcrankw);
        resaBC *= (xarankw*xBrankw*xCrankw);

        if ( xranktype == 0 )
        {
            // varphi(x,x') = varphi(x) - varphi(x')

            res = resabc-resabC-resaBc+resaBC;
        }

        else if ( xranktype == 1 )
        {
            // varphi(x,x') = varphi(x) + varphi(x')

            res = resabc+resabC+resaBc+resaBC;
        }

        else if ( xranktype == 2 )
        {
            // ill-defined

            NiceThrow("No latent function in this case 9");
        }

        else
        {
            // ill-defined

            NiceThrow("No latent function in this case 10");
        }
    }

    else if ( xafarpresent )
    {
        const SparseVector<gentype> &xanear = xa.n();
        const SparseVector<gentype> &xafar  = xa.f1();
        const SparseVector<gentype> &xaffnear = xaff;
        const SparseVector<gentype> &xafffar  = xafff;
        const vecInfo &xanearinfo = xainfo(0,-1);
        const vecInfo &xafarinfo  = xainfo(1,-1);
        int xagradOrdernear = xagradOrder;
        int xagradOrderfar  = xagradOrderR;
        int xagradupnear = xagradup;
        int xagradupfar  = xagradupR;
        int iaupmnear = iaupm;
        int iaupmfar  = xa.f1upsize();
        int ianear = ia;
        int iafar  = -(((ia+1)*100)+1);

        T resabc; yyycK3(resabc,xanear,xbn,xcn,xanearinfo,xbinfo,xcinfo,xagradOrdernear,xbgradOrder,xcgradOrder,xagradupnear,xbgradup,xcgradup,iaupmnear,ibupm,icupm,xaffnear,xbff,xcff,bias,nullptr,ianear,ib,ic,xdim,xconsist,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iaset,ibset,icset,assumreal,justcalcip);
        T resAbc; yyycK3(resAbc,xafar ,xbn,xcn,xafarinfo ,xbinfo,xcinfo,xagradOrderfar ,xbgradOrder,xcgradOrder,xagradupfar ,xbgradup,xcgradup,iaupmfar ,ibupm,icupm,xafffar ,xbff,xcff,bias,nullptr,iafar ,ib,ic,xdim,xconsist,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iaset,ibset,icset,assumreal,justcalcip);

        resabc *= (xarankw*xbrankw*xcrankw);
        resAbc *= (xArankw*xbrankw*xcrankw);

        if ( xranktype == 0 )
        {
            // varphi(x,x') = varphi(x) - varphi(x')

            res = resabc-resAbc;
        }

        else if ( xranktype == 1 )
        {
            // varphi(x,x') = varphi(x) + varphi(x')

            res = resabc+resAbc;
        }

        else if ( xranktype == 2 )
        {
            // ill-defined

            NiceThrow("No latent function in this case 11");
        }

        else
        {
            // ill-defined

            NiceThrow("No latent function in this case 12");
        }
    }

    else if ( xbfarpresent )
    {
        const SparseVector<gentype> &xbnear = xb.n();
        const SparseVector<gentype> &xbfar  = xb.f1();
        const SparseVector<gentype> &xbffnear = xbff;
        const SparseVector<gentype> &xbfffar  = xbfff;
        const vecInfo &xbnearinfo = xbinfo(0,-1);
        const vecInfo &xbfarinfo  = xbinfo(1,-1);
        int xbgradOrdernear = xbgradOrder;
        int xbgradOrderfar  = xbgradOrderR;
        int xbgradupnear = xbgradup;
        int xbgradupfar  = xbgradupR;
        int ibupmnear = ibupm;
        int ibupmfar  = xb.f1upsize();
        int ibnear = ib;
        int ibfar  = -(((ib+1)*100)+1);

        T resabc; yyycK3(resabc,xan,xbnear,xcn,xainfo,xbnearinfo,xcinfo,xagradOrder,xbgradOrdernear,xcgradOrder,xagradup,xbgradupnear,xcgradup,iaupm,ibupmnear,icupm,xaff,xbffnear,xcff,bias,nullptr,ia,ibnear,ic,xdim,xconsist,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iaset,ibset,icset,assumreal,justcalcip);
        T resaBc; yyycK3(resaBc,xan,xbfar ,xcn,xainfo,xbfarinfo ,xcinfo,xagradOrder,xbgradOrderfar ,xcgradOrder,xagradup,xbgradupfar ,xcgradup,iaupm,ibupmfar ,icupm,xaff,xbfffar ,xcff,bias,nullptr,ia,ibfar ,ic,xdim,xconsist,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iaset,ibset,icset,assumreal,justcalcip);

        resabc *= (xarankw*xbrankw*xcrankw);
        resaBc *= (xarankw*xBrankw*xcrankw);

        if ( xranktype == 0 )
        {
            // varphi(x,x') = varphi(x) - varphi(x')

            res = resabc-resaBc;
        }

        else if ( xranktype == 1 )
        {
            // varphi(x,x') = varphi(x) + varphi(x')

            res = resabc+resaBc;
        }

        else if ( xranktype == 2 )
        {
            // ill-defined

            NiceThrow("No latent function in this case 13");
        }

        else
        {
            // ill-defined

            NiceThrow("No latent function in this case 14");
        }
    }

    else if ( xcfarpresent )
    {
        const SparseVector<gentype> &xcnear = xc.n();
        const SparseVector<gentype> &xcfar  = xc.f1();
        const SparseVector<gentype> &xcffnear = xcff;
        const SparseVector<gentype> &xcfffar  = xcfff;
        const vecInfo &xcnearinfo = xcinfo(0,-1);
        const vecInfo &xcfarinfo  = xcinfo(1,-1);
        int xcgradOrdernear = xcgradOrder;
        int xcgradOrderfar  = xcgradOrderR;
        int xcgradupnear = xcgradup;
        int xcgradupfar  = xcgradupR;
        int icupmnear = icupm;
        int icupmfar  = xc.f1upsize();
        int icnear = ic;
        int icfar  = -(((ic+1)*100)+1);

        T resabc; yyycK3(resabc,xan,xbn,xcnear,xainfo,xbinfo,xcnearinfo,xagradOrder,xbgradOrder,xcgradOrdernear,xagradup,xbgradup,xcgradupnear,iaupm,ibupm,icupmnear,xaff,xbff,xcffnear,bias,nullptr,ia,ib,icnear,xdim,xconsist,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iaset,ibset,icset,assumreal,justcalcip);
        T resabC; yyycK3(resabC,xan,xbn,xcfar ,xainfo,xbinfo,xcfarinfo ,xagradOrder,xbgradOrder,xcgradOrderfar ,xagradup,xbgradup,xcgradupfar ,iaupm,ibupm,icupmfar ,xaff,xbff,xcfffar ,bias,nullptr,ia,ib,icfar ,xdim,xconsist,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iaset,ibset,icset,assumreal,justcalcip);

        resabc *= (xarankw*xbrankw*xcrankw);
        resabC *= (xarankw*xbrankw*xCrankw);

        if ( xranktype == 0 )
        {
            // varphi(x,x') = varphi(x) - varphi(x')

            res = resabc-resabC;
        }

        else if ( xranktype == 1 )
        {
            // varphi(x,x') = varphi(x) + varphi(x')

            res = resabc+resabC;
        }

        else if ( xranktype == 2 )
        {
            // ill-defined

            NiceThrow("No latent function in this case 15");
        }

        else
        {
            // ill-defined

            NiceThrow("No latent function in this case 16");
        }
    }

    else
    {
        yyycK3(res,xan,xbn,xcn,xainfo,xbinfo,xcinfo,xagradOrder,xbgradOrder,xcgradOrder,xagradup,xbgradup,xcgradup,iaupm,ibupm,icupm,xaff,xbff,xcff,bias,pxyprod,ia,ib,ic,xdim,xconsist,xresmode,mlid,xy00,xy10,xy11,xy20,xy21,xy22,iaset,ibset,icset,assumreal,justcalcip);

        res *= (xarankw*xbrankw*xcrankw);
    }

    return res;
}

template <class T>
T &MercerKernel::yyybK4(T &res,
                    const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, const SparseVector<gentype> &xc, const SparseVector<gentype> &xd,
                    const vecInfo &xainfo, const vecInfo &xbinfo, const vecInfo &xcinfo, const vecInfo &xdinfo,
                    int xagradOrder, int xbgradOrder, int xcgradOrder, int xdgradOrder,
                    int xagradOrderR, int xbgradOrderR, int xcgradOrderR, int xdgradOrderR,
                    int iaupm, int ibupm, int icupm, int idupm,
                    int xafarpresent, int xbfarpresent, int xcfarpresent, int xdfarpresent,
                    double xarankw, double xbrankw, double xcrankw, double xdrankw,
                    double xArankw, double xBrankw, double xCrankw, double xDrankw,
                    int xafarfarpresent, int xbfarfarpresent, int xcfarfarpresent, int xdfarfarpresent,
                    int xafarfarfarpresent, int xbfarfarfarpresent, int xcfarfarfarpresent, int xdfarfarfarpresent,
                    int xagradup, int xbgradup, int xcgradup, int xdgradup,
                    int xagradupR, int xbgradupR, int xcgradupR, int xdgradupR,
                    int xaignorefarfar, int xbignorefarfar, int xcignorefarfar, int xdignorefarfar,
                    int xaignorefarfarfar, int xbignorefarfarfar, int xcignorefarfarfar, int xdignorefarfarfar,
                    const T &bias,
                    const gentype **pxyprod,
                    int ia, int ib, int ic, int id,
                    int xdim, int xconsist, int xresmode, int mlid,
                    const double *xy00, const double *xy10, const double *xy11, const double *xy20, const double *xy21, const double *xy22, const double *xy30, const double *xy31, const double *xy32, const double *xy33, int iaset, int ibset, int icset, int idset, int assumreal, int justcalcip) const
{
    static const SparseVector<gentype> dummy;

    const SparseVector<gentype> &xan = xa.n();
    const SparseVector<gentype> &xbn = xb.n();
    const SparseVector<gentype> &xcn = xc.n();
    const SparseVector<gentype> &xdn = xd.n();

    const SparseVector<gentype> &xaff = ( xafarfarpresent && !xaignorefarfar ) ? xa.f2() : dummy;
    const SparseVector<gentype> &xbff = ( xbfarfarpresent && !xbignorefarfar ) ? xb.f2() : dummy;
    const SparseVector<gentype> &xcff = ( xcfarfarpresent && !xcignorefarfar ) ? xc.f2() : dummy;
    const SparseVector<gentype> &xdff = ( xdfarfarpresent && !xdignorefarfar ) ? xd.f2() : dummy;

    const SparseVector<gentype> &xafff = ( xafarfarfarpresent && !xaignorefarfarfar ) ? xa.f3() : dummy;
    const SparseVector<gentype> &xbfff = ( xbfarfarfarpresent && !xbignorefarfarfar ) ? xb.f3() : dummy;
    const SparseVector<gentype> &xcfff = ( xcfarfarfarpresent && !xcignorefarfarfar ) ? xc.f3() : dummy;
    const SparseVector<gentype> &xdfff = ( xdfarfarfarpresent && !xdignorefarfarfar ) ? xd.f3() : dummy;

    //const SparseVector<gentype> &xan = xafarfarpresent ? xa.n() : xa;
    //const SparseVector<gentype> &xbn = xbfarfarpresent ? xb.n() : xb;
    //const SparseVector<gentype> &xcn = xcfarfarpresent ? xc.n() : xc;
    //const SparseVector<gentype> &xdn = xdfarfarpresent ? xd.n() : xd;

    NiceAssert( !( justcalcip && ( xafarpresent || xbfarpresent || xcfarpresent || xdfarpresent ) ) );

    if ( xafarpresent && xbfarpresent && xcfarpresent && xdfarpresent )
    {
        const SparseVector<gentype> &xanear = xa.n();
        const SparseVector<gentype> &xafar  = xa.f1();
        const SparseVector<gentype> &xaffnear = xaff;
        const SparseVector<gentype> &xafffar  = xafff;
        const vecInfo &xanearinfo = xainfo(0,-1);
        const vecInfo &xafarinfo  = xainfo(1,-1);
        int xagradOrdernear = xagradOrder;
        int xagradOrderfar  = xagradOrderR;
        int xagradupnear = xagradup;
        int xagradupfar  = xagradupR;
        int iaupmnear = iaupm;
        int iaupmfar  = xa.f1upsize();
        int ianear = ia;
        int iafar  = -(((ia+1)*100)+1);

        const SparseVector<gentype> &xbnear = xb.n();
        const SparseVector<gentype> &xbfar  = xb.f1();
        const SparseVector<gentype> &xbffnear = xbff;
        const SparseVector<gentype> &xbfffar  = xbfff;
        const vecInfo &xbnearinfo = xbinfo(0,-1);
        const vecInfo &xbfarinfo  = xbinfo(1,-1);
        int xbgradOrdernear = xbgradOrder;
        int xbgradOrderfar  = xbgradOrderR;
        int xbgradupnear = xbgradup;
        int xbgradupfar  = xbgradupR;
        int ibupmnear = ibupm;
        int ibupmfar  = xb.f1upsize();
        int ibnear = ib;
        int ibfar  = -(((ib+1)*100)+1);

        const SparseVector<gentype> &xcnear = xc.n();
        const SparseVector<gentype> &xcfar  = xc.f1();
        const SparseVector<gentype> &xcffnear = xcff;
        const SparseVector<gentype> &xcfffar  = xcfff;
        const vecInfo &xcnearinfo = xcinfo(0,-1);
        const vecInfo &xcfarinfo  = xcinfo(1,-1);
        int xcgradOrdernear = xcgradOrder;
        int xcgradOrderfar  = xcgradOrderR;
        int xcgradupnear = xcgradup;
        int xcgradupfar  = xcgradupR;
        int icupmnear = icupm;
        int icupmfar  = xc.f1upsize();
        int icnear = ic;
        int icfar  = -(((ic+1)*100)+1);

        const SparseVector<gentype> &xdnear = xd.n();
        const SparseVector<gentype> &xdfar  = xd.f1();
        const SparseVector<gentype> &xdffnear = xdff;
        const SparseVector<gentype> &xdfffar  = xdfff;
        const vecInfo &xdnearinfo = xdinfo(0,-1);
        const vecInfo &xdfarinfo  = xdinfo(1,-1);
        int xdgradOrdernear = xdgradOrder;
        int xdgradOrderfar  = xdgradOrderR;
        int xdgradupnear = xdgradup;
        int xdgradupfar  = xdgradupR;
        int idupmnear = idupm;
        int idupmfar  = xd.f1upsize();
        int idnear = id;
        int idfar  = -(((id+1)*100)+1);

        T resabcd; yyycK4(resabcd,xanear,xbnear,xcnear,xdnear,xanearinfo,xbnearinfo,xcnearinfo,xdnearinfo,xagradOrdernear,xbgradOrdernear,xcgradOrdernear,xdgradOrdernear,xagradupnear,xbgradupnear,xcgradupnear,xdgradupnear,iaupmnear,ibupmnear,icupmnear,idupmnear,xaffnear,xbffnear,xcffnear,xdffnear,bias,nullptr,ianear,ibnear,icnear,idnear,xdim,xconsist,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iaset,ibset,icset,idset,assumreal,justcalcip);
        T resabcD; yyycK4(resabcD,xanear,xbnear,xcnear,xdfar ,xanearinfo,xbnearinfo,xcnearinfo,xdfarinfo ,xagradOrdernear,xbgradOrdernear,xcgradOrdernear,xdgradOrderfar ,xagradupnear,xbgradupnear,xcgradupnear,xdgradupfar ,iaupmnear,ibupmnear,icupmnear,idupmfar ,xaffnear,xbffnear,xcffnear,xdfffar ,bias,nullptr,ianear,ibnear,icnear,idfar ,xdim,xconsist,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iaset,ibset,icset,idset,assumreal,justcalcip);
        T resabCd; yyycK4(resabCd,xanear,xbnear,xcfar ,xdnear,xanearinfo,xbnearinfo,xcfarinfo ,xdnearinfo,xagradOrdernear,xbgradOrdernear,xcgradOrderfar ,xdgradOrdernear,xagradupnear,xbgradupnear,xcgradupfar ,xdgradupnear,iaupmnear,ibupmnear,icupmfar ,idupmnear,xaffnear,xbffnear,xcfffar ,xdffnear,bias,nullptr,ianear,ibnear,icfar ,idnear,xdim,xconsist,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iaset,ibset,icset,idset,assumreal,justcalcip);
        T resabCD; yyycK4(resabCD,xanear,xbnear,xcfar ,xdfar ,xanearinfo,xbnearinfo,xcfarinfo ,xdfarinfo ,xagradOrdernear,xbgradOrdernear,xcgradOrderfar ,xdgradOrderfar ,xagradupnear,xbgradupnear,xcgradupfar ,xdgradupfar ,iaupmnear,ibupmnear,icupmfar ,idupmfar ,xaffnear,xbffnear,xcfffar ,xdfffar ,bias,nullptr,ianear,ibnear,icfar ,idfar ,xdim,xconsist,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iaset,ibset,icset,idset,assumreal,justcalcip);
        T resaBcd; yyycK4(resaBcd,xanear,xbfar ,xcnear,xdnear,xanearinfo,xbfarinfo ,xcnearinfo,xdnearinfo,xagradOrdernear,xbgradOrderfar ,xcgradOrdernear,xdgradOrdernear,xagradupnear,xbgradupfar ,xcgradupnear,xdgradupnear,iaupmnear,ibupmfar ,icupmnear,idupmnear,xaffnear,xbfffar ,xcffnear,xdffnear,bias,nullptr,ianear,ibfar ,icnear,idnear,xdim,xconsist,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iaset,ibset,icset,idset,assumreal,justcalcip);
        T resaBcD; yyycK4(resaBcD,xanear,xbfar ,xcnear,xdfar ,xanearinfo,xbfarinfo ,xcnearinfo,xdfarinfo ,xagradOrdernear,xbgradOrderfar ,xcgradOrdernear,xdgradOrderfar ,xagradupnear,xbgradupfar ,xcgradupnear,xdgradupfar ,iaupmnear,ibupmfar ,icupmnear,idupmfar ,xaffnear,xbfffar ,xcffnear,xdfffar ,bias,nullptr,ianear,ibfar ,icnear,idfar ,xdim,xconsist,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iaset,ibset,icset,idset,assumreal,justcalcip);
        T resaBCd; yyycK4(resaBCd,xanear,xbfar ,xcfar ,xdnear,xanearinfo,xbfarinfo ,xcfarinfo ,xdnearinfo,xagradOrdernear,xbgradOrderfar ,xcgradOrderfar ,xdgradOrdernear,xagradupnear,xbgradupfar ,xcgradupfar ,xdgradupnear,iaupmnear,ibupmfar ,icupmfar ,idupmnear,xaffnear,xbfffar ,xcfffar ,xdffnear,bias,nullptr,ianear,ibfar ,icfar ,idnear,xdim,xconsist,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iaset,ibset,icset,idset,assumreal,justcalcip);
        T resaBCD; yyycK4(resaBCD,xanear,xbfar ,xcfar ,xdfar ,xanearinfo,xbfarinfo ,xcfarinfo ,xdfarinfo ,xagradOrdernear,xbgradOrderfar ,xcgradOrderfar ,xdgradOrderfar ,xagradupnear,xbgradupfar ,xcgradupfar ,xdgradupfar ,iaupmnear,ibupmfar ,icupmfar ,idupmfar ,xaffnear,xbfffar ,xcfffar ,xdfffar ,bias,nullptr,ianear,ibfar ,icfar ,idfar ,xdim,xconsist,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iaset,ibset,icset,idset,assumreal,justcalcip);
        T resAbcd; yyycK4(resAbcd,xafar ,xbnear,xcnear,xdnear,xafarinfo ,xbnearinfo,xcnearinfo,xdnearinfo,xagradOrderfar ,xbgradOrdernear,xcgradOrdernear,xdgradOrdernear,xagradupfar ,xbgradupnear,xcgradupnear,xdgradupnear,iaupmfar ,ibupmnear,icupmnear,idupmnear,xafffar ,xbffnear,xcffnear,xdffnear,bias,nullptr,iafar ,ibnear,icnear,idnear,xdim,xconsist,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iaset,ibset,icset,idset,assumreal,justcalcip);
        T resAbcD; yyycK4(resAbcD,xafar ,xbnear,xcnear,xdfar ,xafarinfo ,xbnearinfo,xcnearinfo,xdfarinfo ,xagradOrderfar ,xbgradOrdernear,xcgradOrdernear,xdgradOrderfar ,xagradupfar ,xbgradupnear,xcgradupnear,xdgradupfar ,iaupmfar ,ibupmnear,icupmnear,idupmfar ,xafffar ,xbffnear,xcffnear,xdfffar ,bias,nullptr,iafar ,ibnear,icnear,idfar ,xdim,xconsist,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iaset,ibset,icset,idset,assumreal,justcalcip);
        T resAbCd; yyycK4(resAbCd,xafar ,xbnear,xcfar ,xdnear,xafarinfo ,xbnearinfo,xcfarinfo ,xdnearinfo,xagradOrderfar ,xbgradOrdernear,xcgradOrderfar ,xdgradOrdernear,xagradupfar ,xbgradupnear,xcgradupfar ,xdgradupnear,iaupmfar ,ibupmnear,icupmfar ,idupmnear,xafffar ,xbffnear,xcfffar ,xdffnear,bias,nullptr,iafar ,ibnear,icfar ,idnear,xdim,xconsist,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iaset,ibset,icset,idset,assumreal,justcalcip);
        T resAbCD; yyycK4(resAbCD,xafar ,xbnear,xcfar ,xdfar ,xafarinfo ,xbnearinfo,xcfarinfo ,xdfarinfo ,xagradOrderfar ,xbgradOrdernear,xcgradOrderfar ,xdgradOrderfar ,xagradupfar ,xbgradupnear,xcgradupfar ,xdgradupfar ,iaupmfar ,ibupmnear,icupmfar ,idupmfar ,xafffar ,xbffnear,xcfffar ,xdfffar ,bias,nullptr,iafar ,ibnear,icfar ,idfar ,xdim,xconsist,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iaset,ibset,icset,idset,assumreal,justcalcip);
        T resABcd; yyycK4(resABcd,xafar ,xbfar ,xcnear,xdnear,xafarinfo ,xbfarinfo ,xcnearinfo,xdnearinfo,xagradOrderfar ,xbgradOrderfar ,xcgradOrdernear,xdgradOrdernear,xagradupfar ,xbgradupfar ,xcgradupnear,xdgradupnear,iaupmfar ,ibupmfar ,icupmnear,idupmnear,xafffar ,xbfffar ,xcffnear,xdffnear,bias,nullptr,iafar ,ibfar ,icnear,idnear,xdim,xconsist,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iaset,ibset,icset,idset,assumreal,justcalcip);
        T resABcD; yyycK4(resABcD,xafar ,xbfar ,xcnear,xdfar ,xafarinfo ,xbfarinfo ,xcnearinfo,xdfarinfo ,xagradOrderfar ,xbgradOrderfar ,xcgradOrdernear,xdgradOrderfar ,xagradupfar ,xbgradupfar ,xcgradupnear,xdgradupfar ,iaupmfar ,ibupmfar ,icupmnear,idupmfar ,xafffar ,xbfffar ,xcffnear,xdfffar ,bias,nullptr,iafar ,ibfar ,icnear,idfar ,xdim,xconsist,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iaset,ibset,icset,idset,assumreal,justcalcip);
        T resABCd; yyycK4(resABCd,xafar ,xbfar ,xcfar ,xdnear,xafarinfo ,xbfarinfo ,xcfarinfo ,xdnearinfo,xagradOrderfar ,xbgradOrderfar ,xcgradOrderfar ,xdgradOrdernear,xagradupfar ,xbgradupfar ,xcgradupfar ,xdgradupnear,iaupmfar ,ibupmfar ,icupmfar ,idupmnear,xafffar ,xbfffar ,xcfffar ,xdffnear,bias,nullptr,iafar ,ibfar ,icfar ,idnear,xdim,xconsist,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iaset,ibset,icset,idset,assumreal,justcalcip);
        T resABCD; yyycK4(resABCD,xafar ,xbfar ,xcfar ,xdfar ,xafarinfo ,xbfarinfo ,xcfarinfo ,xdfarinfo ,xagradOrderfar ,xbgradOrderfar ,xcgradOrderfar ,xdgradOrderfar ,xagradupfar ,xbgradupfar ,xcgradupfar ,xdgradupfar ,iaupmfar ,ibupmfar ,icupmfar ,idupmfar ,xafffar ,xbfffar ,xcfffar ,xdfffar ,bias,nullptr,iafar ,ibfar ,icfar ,idfar ,xdim,xconsist,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iaset,ibset,icset,idset,assumreal,justcalcip);

        resabcd *= (xarankw*xbrankw*xcrankw*xdrankw);
        resabcD *= (xarankw*xbrankw*xcrankw*xDrankw);
        resabCd *= (xarankw*xbrankw*xCrankw*xdrankw);
        resabCD *= (xarankw*xbrankw*xCrankw*xDrankw);
        resaBcd *= (xarankw*xBrankw*xcrankw*xdrankw);
        resaBcD *= (xarankw*xBrankw*xcrankw*xDrankw);
        resaBCd *= (xarankw*xBrankw*xCrankw*xdrankw);
        resaBCD *= (xarankw*xBrankw*xCrankw*xDrankw);
        resAbcd *= (xArankw*xbrankw*xcrankw*xdrankw);
        resAbcD *= (xArankw*xbrankw*xcrankw*xDrankw);
        resAbCd *= (xArankw*xbrankw*xCrankw*xdrankw);
        resAbCD *= (xArankw*xbrankw*xCrankw*xDrankw);
        resABcd *= (xArankw*xBrankw*xcrankw*xdrankw);
        resABcD *= (xArankw*xBrankw*xcrankw*xDrankw);
        resABCd *= (xArankw*xBrankw*xCrankw*xdrankw);
        resABCD *= (xArankw*xBrankw*xCrankw*xDrankw);

        if ( xranktype == 0 )
        {
            // varphi(x,x') = varphi(x) - varphi(x')

            res = resabcd-resabcD-resabCd+resabCD-resaBcd+resaBcD+resaBCd-resaBCD-resAbcd+resAbcD+resAbCd-resAbCD+resABcd-resABcD-resABCd+resABCD;
        }

        else if ( xranktype == 1 )
        {
            // varphi(x,x') = varphi(x) + varphi(x')

            res = resabcd+resabcD+resabCd+resabCD+resaBcd+resaBcD+resaBCd+resaBCD+resAbcd+resAbcD+resAbCd+resAbCD+resABcd+resABcD+resABCd+resABCD;
        }

        else if ( xranktype == 2 )
        {
            // varphi(x,x') = varphi(x) \otimes varphi(x') - varphi(x') \otimes varphi(x)

            res =  (resabcd*resABCD)-(resabcD*resABCd)-(resabCd*resABcD)+(resabCD*resABcd)-(resaBcd*resAbCD)+(resaBcD*resAbCd)+(resaBCd*resAbcD)-(resaBCD*resAbcd)
                  -(resAbcd*resaBCD)+(resAbcD*resaBCd)+(resAbCd*resaBcD)-(resAbCD*resaBcd)+(resABcd*resabCD)-(resABcD*resabCd)-(resABCd*resabcD)+(resABCD*resabcd);
        }

        else
        {
            // varphi(x,x') = varphi(x) \otimes varphi(x') + varphi(x') \otimes varphi(x)

            res =  (resabcd*resABCD)+(resabcD*resABCd)+(resabCd*resABcD)+(resabCD*resABcd)+(resaBcd*resAbCD)+(resaBcD*resAbCd)+(resaBCd*resAbcD)+(resaBCD*resAbcd)
                  +(resAbcd*resaBCD)+(resAbcD*resaBCd)+(resAbCd*resaBcD)+(resAbCD*resaBcd)+(resABcd*resabCD)+(resABcD*resabCd)+(resABCd*resabcD)+(resABCD*resabcd);
        }
    }

    else if ( xafarpresent && xbfarpresent && xcfarpresent )
    {
        const SparseVector<gentype> &xanear = xa.n();
        const SparseVector<gentype> &xafar  = xa.f1();
        const SparseVector<gentype> &xaffnear = xaff;
        const SparseVector<gentype> &xafffar  = xafff;
        const vecInfo &xanearinfo = xainfo(0,-1);
        const vecInfo &xafarinfo  = xainfo(1,-1);
        int xagradOrdernear = xagradOrder;
        int xagradOrderfar  = xagradOrderR;
        int xagradupnear = xagradup;
        int xagradupfar  = xagradupR;
        int iaupmnear = iaupm;
        int iaupmfar  = xa.f1upsize();
        int ianear = ia;
        int iafar  = -(((ia+1)*100)+1);

        const SparseVector<gentype> &xbnear = xb.n();
        const SparseVector<gentype> &xbfar  = xb.f1();
        const SparseVector<gentype> &xbffnear = xbff;
        const SparseVector<gentype> &xbfffar  = xbfff;
        const vecInfo &xbnearinfo = xbinfo(0,-1);
        const vecInfo &xbfarinfo  = xbinfo(1,-1);
        int xbgradOrdernear = xbgradOrder;
        int xbgradOrderfar  = xbgradOrderR;
        int xbgradupnear = xbgradup;
        int xbgradupfar  = xbgradupR;
        int ibupmnear = ibupm;
        int ibupmfar  = xb.f1upsize();
        int ibnear = ib;
        int ibfar  = -(((ib+1)*100)+1);

        const SparseVector<gentype> &xcnear = xc.n();
        const SparseVector<gentype> &xcfar  = xc.f1();
        const SparseVector<gentype> &xcffnear = xcff;
        const SparseVector<gentype> &xcfffar  = xcfff;
        const vecInfo &xcnearinfo = xcinfo(0,-1);
        const vecInfo &xcfarinfo  = xcinfo(1,-1);
        int xcgradOrdernear = xcgradOrder;
        int xcgradOrderfar  = xcgradOrderR;
        int xcgradupnear = xcgradup;
        int xcgradupfar  = xcgradupR;
        int icupmnear = icupm;
        int icupmfar  = xc.f1upsize();
        int icnear = ic;
        int icfar  = -(((ic+1)*100)+1);

        T resabcd; yyycK4(resabcd,xanear,xbnear,xcnear,xdn,xanearinfo,xbnearinfo,xcnearinfo,xdinfo,xagradOrdernear,xbgradOrdernear,xcgradOrdernear,xdgradOrder,xagradupnear,xbgradupnear,xcgradupnear,xdgradup,iaupmnear,ibupmnear,icupmnear,idupm,xaffnear,xbffnear,xcffnear,xdff,bias,nullptr,ianear,ibnear,icnear,id,xdim,xconsist,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iaset,ibset,icset,idset,assumreal,justcalcip);
        T resabCd; yyycK4(resabCd,xanear,xbnear,xcfar ,xdn,xanearinfo,xbnearinfo,xcfarinfo ,xdinfo,xagradOrdernear,xbgradOrdernear,xcgradOrderfar ,xdgradOrder,xagradupnear,xbgradupnear,xcgradupfar ,xdgradup,iaupmnear,ibupmnear,icupmfar ,idupm,xaffnear,xbffnear,xcfffar ,xdff,bias,nullptr,ianear,ibnear,icfar ,id,xdim,xconsist,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iaset,ibset,icset,idset,assumreal,justcalcip);
        T resaBcd; yyycK4(resaBcd,xanear,xbfar ,xcnear,xdn,xanearinfo,xbfarinfo ,xcnearinfo,xdinfo,xagradOrdernear,xbgradOrderfar ,xcgradOrdernear,xdgradOrder,xagradupnear,xbgradupfar ,xcgradupnear,xdgradup,iaupmnear,ibupmfar ,icupmnear,idupm,xaffnear,xbfffar ,xcffnear,xdff,bias,nullptr,ianear,ibfar ,icnear,id,xdim,xconsist,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iaset,ibset,icset,idset,assumreal,justcalcip);
        T resaBCd; yyycK4(resaBCd,xanear,xbfar ,xcfar ,xdn,xanearinfo,xbfarinfo ,xcfarinfo ,xdinfo,xagradOrdernear,xbgradOrderfar ,xcgradOrderfar ,xdgradOrder,xagradupnear,xbgradupfar ,xcgradupfar ,xdgradup,iaupmnear,ibupmfar ,icupmfar ,idupm,xaffnear,xbfffar ,xcfffar ,xdff,bias,nullptr,ianear,ibfar ,icfar ,id,xdim,xconsist,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iaset,ibset,icset,idset,assumreal,justcalcip);
        T resAbcd; yyycK4(resAbcd,xafar ,xbnear,xcnear,xdn,xafarinfo ,xbnearinfo,xcnearinfo,xdinfo,xagradOrderfar ,xbgradOrdernear,xcgradOrdernear,xdgradOrder,xagradupfar ,xbgradupnear,xcgradupnear,xdgradup,iaupmfar ,ibupmnear,icupmnear,idupm,xafffar ,xbffnear,xcffnear,xdff,bias,nullptr,iafar ,ibnear,icnear,id,xdim,xconsist,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iaset,ibset,icset,idset,assumreal,justcalcip);
        T resAbCd; yyycK4(resAbCd,xafar ,xbnear,xcfar ,xdn,xafarinfo ,xbnearinfo,xcfarinfo ,xdinfo,xagradOrderfar ,xbgradOrdernear,xcgradOrderfar ,xdgradOrder,xagradupfar ,xbgradupnear,xcgradupfar ,xdgradup,iaupmfar ,ibupmnear,icupmfar ,idupm,xafffar ,xbffnear,xcfffar ,xdff,bias,nullptr,iafar ,ibnear,icfar ,id,xdim,xconsist,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iaset,ibset,icset,idset,assumreal,justcalcip);
        T resABcd; yyycK4(resABcd,xafar ,xbfar ,xcnear,xdn,xafarinfo ,xbfarinfo ,xcnearinfo,xdinfo,xagradOrderfar ,xbgradOrderfar ,xcgradOrdernear,xdgradOrder,xagradupfar ,xbgradupfar ,xcgradupnear,xdgradup,iaupmfar ,ibupmfar ,icupmnear,idupm,xafffar ,xbfffar ,xcffnear,xdff,bias,nullptr,iafar ,ibfar ,icnear,id,xdim,xconsist,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iaset,ibset,icset,idset,assumreal,justcalcip);
        T resABCd; yyycK4(resABCd,xafar ,xbfar ,xcfar ,xdn,xafarinfo ,xbfarinfo ,xcfarinfo ,xdinfo,xagradOrderfar ,xbgradOrderfar ,xcgradOrderfar ,xdgradOrder,xagradupfar ,xbgradupfar ,xcgradupfar ,xdgradup,iaupmfar ,ibupmfar ,icupmfar ,idupm,xafffar ,xbfffar ,xcfffar ,xdff,bias,nullptr,iafar ,ibfar ,icfar ,id,xdim,xconsist,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iaset,ibset,icset,idset,assumreal,justcalcip);

        resabcd *= (xarankw*xbrankw*xcrankw*xdrankw);
        resabCd *= (xarankw*xbrankw*xCrankw*xdrankw);
        resaBcd *= (xarankw*xBrankw*xcrankw*xdrankw);
        resaBCd *= (xarankw*xBrankw*xCrankw*xdrankw);
        resAbcd *= (xArankw*xbrankw*xcrankw*xdrankw);
        resAbCd *= (xArankw*xbrankw*xCrankw*xdrankw);
        resABcd *= (xArankw*xBrankw*xcrankw*xdrankw);
        resABCd *= (xArankw*xBrankw*xCrankw*xdrankw);

        if ( xranktype == 0 )
        {
            // varphi(x,x') = varphi(x) - varphi(x')

            res = resabcd-resabCd-resaBcd+resaBCd-resAbcd+resAbCd+resABcd-resABCd;
        }

        else if ( xranktype == 1 )
        {
            // varphi(x,x') = varphi(x) + varphi(x')

            res = resabcd+resabCd+resaBcd+resaBCd+resAbcd+resAbCd+resABcd+resABCd;
        }

        else if ( xranktype == 2 )
        {
            // ill-defined

            NiceThrow("No latent function in this case 17");
        }

        else
        {
            // ill-defined

            NiceThrow("No latent function in this case 18");
        }
    }

    else if ( xafarpresent && xbfarpresent && xdfarpresent )
    {
        const SparseVector<gentype> &xanear = xa.n();
        const SparseVector<gentype> &xafar  = xa.f1();
        const SparseVector<gentype> &xaffnear = xaff;
        const SparseVector<gentype> &xafffar  = xafff;
        const vecInfo &xanearinfo = xainfo(0,-1);
        const vecInfo &xafarinfo  = xainfo(1,-1);
        int xagradOrdernear = xagradOrder;
        int xagradOrderfar  = xagradOrderR;
        int xagradupnear = xagradup;
        int xagradupfar  = xagradupR;
        int iaupmnear = iaupm;
        int iaupmfar  = xa.f1upsize();
        int ianear = ia;
        int iafar  = -(((ia+1)*100)+1);

        const SparseVector<gentype> &xbnear = xb.n();
        const SparseVector<gentype> &xbfar  = xb.f1();
        const SparseVector<gentype> &xbffnear = xbff;
        const SparseVector<gentype> &xbfffar  = xbfff;
        const vecInfo &xbnearinfo = xbinfo(0,-1);
        const vecInfo &xbfarinfo  = xbinfo(1,-1);
        int xbgradOrdernear = xbgradOrder;
        int xbgradOrderfar  = xbgradOrderR;
        int xbgradupnear = xbgradup;
        int xbgradupfar  = xbgradupR;
        int ibupmnear = ibupm;
        int ibupmfar  = xb.f1upsize();
        int ibnear = ib;
        int ibfar  = -(((ib+1)*100)+1);

        const SparseVector<gentype> &xdnear = xd.n();
        const SparseVector<gentype> &xdfar  = xd.f1();
        const SparseVector<gentype> &xdffnear = xdff;
        const SparseVector<gentype> &xdfffar  = xdfff;
        const vecInfo &xdnearinfo = xdinfo(0,-1);
        const vecInfo &xdfarinfo  = xdinfo(1,-1);
        int xdgradOrdernear = xdgradOrder;
        int xdgradOrderfar  = xdgradOrderR;
        int xdgradupnear = xdgradup;
        int xdgradupfar  = xdgradupR;
        int idupmnear = idupm;
        int idupmfar  = xd.f1upsize();
        int idnear = id;
        int idfar  = -(((id+1)*100)+1);

        T resabcd; yyycK4(resabcd,xanear,xbnear,xcn,xdnear,xanearinfo,xbnearinfo,xcinfo,xdnearinfo,xagradOrdernear,xbgradOrdernear,xcgradOrder,xdgradOrdernear,xagradupnear,xbgradupnear,xcgradup,xdgradupnear,iaupmnear,ibupmnear,icupm,idupmnear,xaffnear,xbffnear,xcff,xdffnear,bias,nullptr,ianear,ibnear,ic,idnear,xdim,xconsist,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iaset,ibset,icset,idset,assumreal,justcalcip);
        T resabcD; yyycK4(resabcD,xanear,xbnear,xcn,xdfar ,xanearinfo,xbnearinfo,xcinfo,xdfarinfo ,xagradOrdernear,xbgradOrdernear,xcgradOrder,xdgradOrderfar ,xagradupnear,xbgradupnear,xcgradup,xdgradupfar ,iaupmnear,ibupmnear,icupm,idupmfar ,xaffnear,xbffnear,xcff,xdfffar ,bias,nullptr,ianear,ibnear,ic,idfar ,xdim,xconsist,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iaset,ibset,icset,idset,assumreal,justcalcip);
        T resaBcd; yyycK4(resaBcd,xanear,xbfar ,xcn,xdnear,xanearinfo,xbfarinfo ,xcinfo,xdnearinfo,xagradOrdernear,xbgradOrderfar ,xcgradOrder,xdgradOrdernear,xagradupnear,xbgradupfar ,xcgradup,xdgradupnear,iaupmnear,ibupmfar ,icupm,idupmnear,xaffnear,xbfffar ,xcff,xdffnear,bias,nullptr,ianear,ibfar ,ic,idnear,xdim,xconsist,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iaset,ibset,icset,idset,assumreal,justcalcip);
        T resaBcD; yyycK4(resaBcD,xanear,xbfar ,xcn,xdfar ,xanearinfo,xbfarinfo ,xcinfo,xdfarinfo ,xagradOrdernear,xbgradOrderfar ,xcgradOrder,xdgradOrderfar ,xagradupnear,xbgradupfar ,xcgradup,xdgradupfar ,iaupmnear,ibupmfar ,icupm,idupmfar ,xaffnear,xbfffar ,xcff,xdfffar ,bias,nullptr,ianear,ibfar ,ic,idfar ,xdim,xconsist,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iaset,ibset,icset,idset,assumreal,justcalcip);
        T resAbcd; yyycK4(resAbcd,xafar ,xbnear,xcn,xdnear,xafarinfo ,xbnearinfo,xcinfo,xdnearinfo,xagradOrderfar ,xbgradOrdernear,xcgradOrder,xdgradOrdernear,xagradupfar ,xbgradupnear,xcgradup,xdgradupnear,iaupmfar ,ibupmnear,icupm,idupmnear,xafffar ,xbffnear,xcff,xdffnear,bias,nullptr,iafar ,ibnear,ic,idnear,xdim,xconsist,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iaset,ibset,icset,idset,assumreal,justcalcip);
        T resAbcD; yyycK4(resAbcD,xafar ,xbnear,xcn,xdfar ,xafarinfo ,xbnearinfo,xcinfo,xdfarinfo ,xagradOrderfar ,xbgradOrdernear,xcgradOrder,xdgradOrderfar ,xagradupfar ,xbgradupnear,xcgradup,xdgradupfar ,iaupmfar ,ibupmnear,icupm,idupmfar ,xafffar ,xbffnear,xcff,xdfffar ,bias,nullptr,iafar ,ibnear,ic,idfar ,xdim,xconsist,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iaset,ibset,icset,idset,assumreal,justcalcip);
        T resABcd; yyycK4(resABcd,xafar ,xbfar ,xcn,xdnear,xafarinfo ,xbfarinfo ,xcinfo,xdnearinfo,xagradOrderfar ,xbgradOrderfar ,xcgradOrder,xdgradOrdernear,xagradupfar ,xbgradupfar ,xcgradup,xdgradupnear,iaupmfar ,ibupmfar ,icupm,idupmnear,xafffar ,xbfffar ,xcff,xdffnear,bias,nullptr,iafar ,ibfar ,ic,idnear,xdim,xconsist,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iaset,ibset,icset,idset,assumreal,justcalcip);
        T resABcD; yyycK4(resABcD,xafar ,xbfar ,xcn,xdfar ,xafarinfo ,xbfarinfo ,xcinfo,xdfarinfo ,xagradOrderfar ,xbgradOrderfar ,xcgradOrder,xdgradOrderfar ,xagradupfar ,xbgradupfar ,xcgradup,xdgradupfar ,iaupmfar ,ibupmfar ,icupm,idupmfar ,xafffar ,xbfffar ,xcff,xdfffar ,bias,nullptr,iafar ,ibfar ,ic,idfar ,xdim,xconsist,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iaset,ibset,icset,idset,assumreal,justcalcip);

        resabcd *= (xarankw*xbrankw*xcrankw*xdrankw);
        resabcD *= (xarankw*xbrankw*xcrankw*xDrankw);
        resaBcd *= (xarankw*xBrankw*xcrankw*xdrankw);
        resaBcD *= (xarankw*xBrankw*xcrankw*xDrankw);
        resAbcd *= (xArankw*xbrankw*xcrankw*xdrankw);
        resAbcD *= (xArankw*xbrankw*xcrankw*xDrankw);
        resABcd *= (xArankw*xBrankw*xcrankw*xdrankw);
        resABcD *= (xArankw*xBrankw*xcrankw*xDrankw);

        if ( xranktype == 0 )
        {
            // varphi(x,x') = varphi(x) - varphi(x')

            res = resabcd-resabcD-resaBcd+resaBcD-resAbcd+resAbcD+resABcd-resABcD;
        }

        else if ( xranktype == 1 )
        {
            // varphi(x,x') = varphi(x) + varphi(x')

            res = resabcd+resabcD+resaBcd+resaBcD+resAbcd+resAbcD+resABcd+resABcD;
        }

        else if ( xranktype == 2 )
        {
            // ill-defined

            NiceThrow("No latent function in this case 19");
        }

        else
        {
            // ill-defined

            NiceThrow("No latent function in this case 20");
        }
    }

    else if ( xafarpresent && xcfarpresent && xdfarpresent )
    {
        const SparseVector<gentype> &xanear = xa.n();
        const SparseVector<gentype> &xafar  = xa.f1();
        const SparseVector<gentype> &xaffnear = xaff;
        const SparseVector<gentype> &xafffar  = xafff;
        const vecInfo &xanearinfo = xainfo(0,-1);
        const vecInfo &xafarinfo  = xainfo(1,-1);
        int xagradOrdernear = xagradOrder;
        int xagradOrderfar  = xagradOrderR;
        int xagradupnear = xagradup;
        int xagradupfar  = xagradupR;
        int iaupmnear = iaupm;
        int iaupmfar  = xa.f1upsize();
        int ianear = ia;
        int iafar  = -(((ia+1)*100)+1);

        const SparseVector<gentype> &xcnear = xc.n();
        const SparseVector<gentype> &xcfar  = xc.f1();
        const SparseVector<gentype> &xcffnear = xcff;
        const SparseVector<gentype> &xcfffar  = xcfff;
        const vecInfo &xcnearinfo = xcinfo(0,-1);
        const vecInfo &xcfarinfo  = xcinfo(1,-1);
        int xcgradOrdernear = xcgradOrder;
        int xcgradOrderfar  = xcgradOrderR;
        int xcgradupnear = xcgradup;
        int xcgradupfar  = xcgradupR;
        int icupmnear = icupm;
        int icupmfar  = xc.f1upsize();
        int icnear = ic;
        int icfar  = -(((ic+1)*100)+1);

        const SparseVector<gentype> &xdnear = xd.n();
        const SparseVector<gentype> &xdfar  = xd.f1();
        const SparseVector<gentype> &xdffnear = xdff;
        const SparseVector<gentype> &xdfffar  = xdfff;
        const vecInfo &xdnearinfo = xdinfo(0,-1);
        const vecInfo &xdfarinfo  = xdinfo(1,-1);
        int xdgradOrdernear = xdgradOrder;
        int xdgradOrderfar  = xdgradOrderR;
        int xdgradupnear = xdgradup;
        int xdgradupfar  = xdgradupR;
        int idupmnear = idupm;
        int idupmfar  = xd.f1upsize();
        int idnear = id;
        int idfar  = -(((id+1)*100)+1);

        T resabcd; yyycK4(resabcd,xanear,xbn,xcnear,xdnear,xanearinfo,xbinfo,xcnearinfo,xdnearinfo,xagradOrdernear,xbgradOrder,xcgradOrdernear,xdgradOrdernear,xagradupnear,xbgradup,xcgradupnear,xdgradupnear,iaupmnear,ibupm,icupmnear,idupmnear,xaffnear,xbff,xcffnear,xdffnear,bias,nullptr,ianear,ib,icnear,idnear,xdim,xconsist,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iaset,ibset,icset,idset,assumreal,justcalcip);
        T resabcD; yyycK4(resabcD,xanear,xbn,xcnear,xdfar ,xanearinfo,xbinfo,xcnearinfo,xdfarinfo ,xagradOrdernear,xbgradOrder,xcgradOrdernear,xdgradOrderfar ,xagradupnear,xbgradup,xcgradupnear,xdgradupfar ,iaupmnear,ibupm,icupmnear,idupmfar ,xaffnear,xbff,xcffnear,xdfffar ,bias,nullptr,ianear,ib,icnear,idfar ,xdim,xconsist,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iaset,ibset,icset,idset,assumreal,justcalcip);
        T resabCd; yyycK4(resabCd,xanear,xbn,xcfar ,xdnear,xanearinfo,xbinfo,xcfarinfo ,xdnearinfo,xagradOrdernear,xbgradOrder,xcgradOrderfar ,xdgradOrdernear,xagradupnear,xbgradup,xcgradupfar ,xdgradupnear,iaupmnear,ibupm,icupmfar ,idupmnear,xaffnear,xbff,xcfffar ,xdffnear,bias,nullptr,ianear,ib,icfar ,idnear,xdim,xconsist,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iaset,ibset,icset,idset,assumreal,justcalcip);
        T resabCD; yyycK4(resabCD,xanear,xbn,xcfar ,xdfar ,xanearinfo,xbinfo,xcfarinfo ,xdfarinfo ,xagradOrdernear,xbgradOrder,xcgradOrderfar ,xdgradOrderfar ,xagradupnear,xbgradup,xcgradupfar ,xdgradupfar ,iaupmnear,ibupm,icupmfar ,idupmfar ,xaffnear,xbff,xcfffar ,xdfffar ,bias,nullptr,ianear,ib,icfar ,idfar ,xdim,xconsist,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iaset,ibset,icset,idset,assumreal,justcalcip);
        T resAbcd; yyycK4(resAbcd,xafar ,xbn,xcnear,xdnear,xafarinfo ,xbinfo,xcnearinfo,xdnearinfo,xagradOrderfar ,xbgradOrder,xcgradOrdernear,xdgradOrdernear,xagradupfar ,xbgradup,xcgradupnear,xdgradupnear,iaupmfar ,ibupm,icupmnear,idupmnear,xafffar ,xbff,xcffnear,xdffnear,bias,nullptr,iafar ,ib,icnear,idnear,xdim,xconsist,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iaset,ibset,icset,idset,assumreal,justcalcip);
        T resAbcD; yyycK4(resAbcD,xafar ,xbn,xcnear,xdfar ,xafarinfo ,xbinfo,xcnearinfo,xdfarinfo ,xagradOrderfar ,xbgradOrder,xcgradOrdernear,xdgradOrderfar ,xagradupfar ,xbgradup,xcgradupnear,xdgradupfar ,iaupmfar ,ibupm,icupmnear,idupmfar ,xafffar ,xbff,xcffnear,xdfffar ,bias,nullptr,iafar ,ib,icnear,idfar ,xdim,xconsist,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iaset,ibset,icset,idset,assumreal,justcalcip);
        T resAbCd; yyycK4(resAbCd,xafar ,xbn,xcfar ,xdnear,xafarinfo ,xbinfo,xcfarinfo ,xdnearinfo,xagradOrderfar ,xbgradOrder,xcgradOrderfar ,xdgradOrdernear,xagradupfar ,xbgradup,xcgradupfar ,xdgradupnear,iaupmfar ,ibupm,icupmfar ,idupmnear,xafffar ,xbff,xcfffar ,xdffnear,bias,nullptr,iafar ,ib,icfar ,idnear,xdim,xconsist,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iaset,ibset,icset,idset,assumreal,justcalcip);
        T resAbCD; yyycK4(resAbCD,xafar ,xbn,xcfar ,xdfar ,xafarinfo ,xbinfo,xcfarinfo ,xdfarinfo ,xagradOrderfar ,xbgradOrder,xcgradOrderfar ,xdgradOrderfar ,xagradupfar ,xbgradup,xcgradupfar ,xdgradupfar ,iaupmfar ,ibupm,icupmfar ,idupmfar ,xafffar ,xbff,xcfffar ,xdfffar ,bias,nullptr,iafar ,ib,icfar ,idfar ,xdim,xconsist,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iaset,ibset,icset,idset,assumreal,justcalcip);

        resabcd *= (xarankw*xbrankw*xcrankw*xdrankw);
        resabcD *= (xarankw*xbrankw*xcrankw*xDrankw);
        resabCd *= (xarankw*xbrankw*xCrankw*xdrankw);
        resabCD *= (xarankw*xbrankw*xCrankw*xDrankw);
        resAbcd *= (xArankw*xbrankw*xcrankw*xdrankw);
        resAbcD *= (xArankw*xbrankw*xcrankw*xDrankw);
        resAbCd *= (xArankw*xbrankw*xCrankw*xdrankw);
        resAbCD *= (xArankw*xbrankw*xCrankw*xDrankw);

        if ( xranktype == 0 )
        {
            // varphi(x,x') = varphi(x) - varphi(x')

            res = resabcd-resabcD-resabCd+resabCD-resAbcd+resAbcD+resAbCd-resAbCD;
        }

        else if ( xranktype == 1 )
        {
            // varphi(x,x') = varphi(x) + varphi(x')

            res = resabcd+resabcD+resabCd+resabCD+resAbcd+resAbcD+resAbCd+resAbCD;
        }

        else if ( xranktype == 2 )
        {
            // ill-defined

            NiceThrow("No latent function in this case 21");
        }

        else
        {
            // ill-defined

            NiceThrow("No latent function in this case 22");
        }
    }

    else if ( xbfarpresent && xcfarpresent && xdfarpresent )
    {
        const SparseVector<gentype> &xbnear = xb.n();
        const SparseVector<gentype> &xbfar  = xb.f1();
        const SparseVector<gentype> &xbffnear = xbff;
        const SparseVector<gentype> &xbfffar  = xbfff;
        const vecInfo &xbnearinfo = xbinfo(0,-1);
        const vecInfo &xbfarinfo  = xbinfo(1,-1);
        int xbgradOrdernear = xbgradOrder;
        int xbgradOrderfar  = xbgradOrderR;
        int xbgradupnear = xbgradup;
        int xbgradupfar  = xbgradupR;
        int ibupmnear = ibupm;
        int ibupmfar  = xb.f1upsize();
        int ibnear = ib;
        int ibfar  = -(((ib+1)*100)+1);

        const SparseVector<gentype> &xcnear = xc.n();
        const SparseVector<gentype> &xcfar  = xc.f1();
        const SparseVector<gentype> &xcffnear = xcff;
        const SparseVector<gentype> &xcfffar  = xcfff;
        const vecInfo &xcnearinfo = xcinfo(0,-1);
        const vecInfo &xcfarinfo  = xcinfo(1,-1);
        int xcgradOrdernear = xcgradOrder;
        int xcgradOrderfar  = xcgradOrderR;
        int xcgradupnear = xcgradup;
        int xcgradupfar  = xcgradupR;
        int icupmnear = icupm;
        int icupmfar  = xc.f1upsize();
        int icnear = ic;
        int icfar  = -(((ic+1)*100)+1);

        const SparseVector<gentype> &xdnear = xd.n();
        const SparseVector<gentype> &xdfar  = xd.f1();
        const SparseVector<gentype> &xdffnear = xdff;
        const SparseVector<gentype> &xdfffar  = xdfff;
        const vecInfo &xdnearinfo = xdinfo(0,-1);
        const vecInfo &xdfarinfo  = xdinfo(1,-1);
        int xdgradOrdernear = xdgradOrder;
        int xdgradOrderfar  = xdgradOrderR;
        int xdgradupnear = xdgradup;
        int xdgradupfar  = xdgradupR;
        int idupmnear = idupm;
        int idupmfar  = xd.f1upsize();
        int idnear = id;
        int idfar  = -(((id+1)*100)+1);

        T resabcd; yyycK4(resabcd,xan,xbnear,xcnear,xdnear,xainfo,xbnearinfo,xcnearinfo,xdnearinfo,xagradOrder,xbgradOrdernear,xcgradOrdernear,xdgradOrdernear,xagradup,xbgradupnear,xcgradupnear,xdgradupnear,iaupm,ibupmnear,icupmnear,idupmnear,xaff,xbffnear,xcffnear,xdffnear,bias,nullptr,ia,ibnear,icnear,idnear,xdim,xconsist,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iaset,ibset,icset,idset,assumreal,justcalcip);
        T resabcD; yyycK4(resabcD,xan,xbnear,xcnear,xdfar ,xainfo,xbnearinfo,xcnearinfo,xdfarinfo ,xagradOrder,xbgradOrdernear,xcgradOrdernear,xdgradOrderfar ,xagradup,xbgradupnear,xcgradupnear,xdgradupfar ,iaupm,ibupmnear,icupmnear,idupmfar ,xaff,xbffnear,xcffnear,xdfffar ,bias,nullptr,ia,ibnear,icnear,idfar ,xdim,xconsist,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iaset,ibset,icset,idset,assumreal,justcalcip);
        T resabCd; yyycK4(resabCd,xan,xbnear,xcfar ,xdnear,xainfo,xbnearinfo,xcfarinfo ,xdnearinfo,xagradOrder,xbgradOrdernear,xcgradOrderfar ,xdgradOrdernear,xagradup,xbgradupnear,xcgradupfar ,xdgradupnear,iaupm,ibupmnear,icupmfar ,idupmnear,xaff,xbffnear,xcfffar ,xdffnear,bias,nullptr,ia,ibnear,icfar ,idnear,xdim,xconsist,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iaset,ibset,icset,idset,assumreal,justcalcip);
        T resabCD; yyycK4(resabCD,xan,xbnear,xcfar ,xdfar ,xainfo,xbnearinfo,xcfarinfo ,xdfarinfo ,xagradOrder,xbgradOrdernear,xcgradOrderfar ,xdgradOrderfar ,xagradup,xbgradupnear,xcgradupfar ,xdgradupfar ,iaupm,ibupmnear,icupmfar ,idupmfar ,xaff,xbffnear,xcfffar ,xdfffar ,bias,nullptr,ia,ibnear,icfar ,idfar ,xdim,xconsist,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iaset,ibset,icset,idset,assumreal,justcalcip);
        T resaBcd; yyycK4(resaBcd,xan,xbfar ,xcnear,xdnear,xainfo,xbfarinfo ,xcnearinfo,xdnearinfo,xagradOrder,xbgradOrderfar ,xcgradOrdernear,xdgradOrdernear,xagradup,xbgradupfar ,xcgradupnear,xdgradupnear,iaupm,ibupmfar ,icupmnear,idupmnear,xaff,xbfffar ,xcffnear,xdffnear,bias,nullptr,ia,ibfar ,icnear,idnear,xdim,xconsist,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iaset,ibset,icset,idset,assumreal,justcalcip);
        T resaBcD; yyycK4(resaBcD,xan,xbfar ,xcnear,xdfar ,xainfo,xbfarinfo ,xcnearinfo,xdfarinfo ,xagradOrder,xbgradOrderfar ,xcgradOrdernear,xdgradOrderfar ,xagradup,xbgradupfar ,xcgradupnear,xdgradupfar ,iaupm,ibupmfar ,icupmnear,idupmfar ,xaff,xbfffar ,xcffnear,xdfffar ,bias,nullptr,ia,ibfar ,icnear,idfar ,xdim,xconsist,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iaset,ibset,icset,idset,assumreal,justcalcip);
        T resaBCd; yyycK4(resaBCd,xan,xbfar ,xcfar ,xdnear,xainfo,xbfarinfo ,xcfarinfo ,xdnearinfo,xagradOrder,xbgradOrderfar ,xcgradOrderfar ,xdgradOrdernear,xagradup,xbgradupfar ,xcgradupfar ,xdgradupnear,iaupm,ibupmfar ,icupmfar ,idupmnear,xaff,xbfffar ,xcfffar ,xdffnear,bias,nullptr,ia,ibfar ,icfar ,idnear,xdim,xconsist,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iaset,ibset,icset,idset,assumreal,justcalcip);
        T resaBCD; yyycK4(resaBCD,xan,xbfar ,xcfar ,xdfar ,xainfo,xbfarinfo ,xcfarinfo ,xdfarinfo ,xagradOrder,xbgradOrderfar ,xcgradOrderfar ,xdgradOrderfar ,xagradup,xbgradupfar ,xcgradupfar ,xdgradupfar ,iaupm,ibupmfar ,icupmfar ,idupmfar ,xaff,xbfffar ,xcfffar ,xdfffar ,bias,nullptr,ia,ibfar ,icfar ,idfar ,xdim,xconsist,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iaset,ibset,icset,idset,assumreal,justcalcip);

        resabcd *= (xarankw*xbrankw*xcrankw*xdrankw);
        resabcD *= (xarankw*xbrankw*xcrankw*xDrankw);
        resabCd *= (xarankw*xbrankw*xCrankw*xdrankw);
        resabCD *= (xarankw*xbrankw*xCrankw*xDrankw);
        resaBcd *= (xarankw*xBrankw*xcrankw*xdrankw);
        resaBcD *= (xarankw*xBrankw*xcrankw*xDrankw);
        resaBCd *= (xarankw*xBrankw*xCrankw*xdrankw);
        resaBCD *= (xarankw*xBrankw*xCrankw*xDrankw);

        if ( xranktype == 0 )
        {
            // varphi(x,x') = varphi(x) - varphi(x')

            res = resabcd-resabcD-resabCd+resabCD-resaBcd+resaBcD+resaBCd-resaBCD;
        }

        else if ( xranktype == 1 )
        {
            // varphi(x,x') = varphi(x) + varphi(x')

            res = resabcd+resabcD+resabCd+resabCD+resaBcd+resaBcD+resaBCd+resaBCD;
        }

        else if ( xranktype == 2 )
        {
            // ill-defined

            NiceThrow("No latent function in this case 23");
        }

        else
        {
            // ill-defined

            NiceThrow("No latent function in this case 24");
        }
    }

    else if ( xafarpresent && xbfarpresent )
    {
        const SparseVector<gentype> &xanear = xa.n();
        const SparseVector<gentype> &xafar  = xa.f1();
        const SparseVector<gentype> &xaffnear = xaff;
        const SparseVector<gentype> &xafffar  = xafff;
        const vecInfo &xanearinfo = xainfo(0,-1);
        const vecInfo &xafarinfo  = xainfo(1,-1);
        int xagradOrdernear = xagradOrder;
        int xagradOrderfar  = xagradOrderR;
        int xagradupnear = xagradup;
        int xagradupfar  = xagradupR;
        int iaupmnear = iaupm;
        int iaupmfar  = xa.f1upsize();
        int ianear = ia;
        int iafar  = -(((ia+1)*100)+1);

        const SparseVector<gentype> &xbnear = xb.n();
        const SparseVector<gentype> &xbfar  = xb.f1();
        const SparseVector<gentype> &xbffnear = xbff;
        const SparseVector<gentype> &xbfffar  = xbfff;
        const vecInfo &xbnearinfo = xbinfo(0,-1);
        const vecInfo &xbfarinfo  = xbinfo(1,-1);
        int xbgradOrdernear = xbgradOrder;
        int xbgradOrderfar  = xbgradOrderR;
        int xbgradupnear = xbgradup;
        int xbgradupfar  = xbgradupR;
        int ibupmnear = ibupm;
        int ibupmfar  = xb.f1upsize();
        int ibnear = ib;
        int ibfar  = -(((ib+1)*100)+1);

        T resabcd; yyycK4(resabcd,xanear,xbnear,xcn,xdn,xanearinfo,xbnearinfo,xcinfo,xdinfo,xagradOrdernear,xbgradOrdernear,xcgradOrder,xdgradOrder,xagradupnear,xbgradupnear,xcgradup,xdgradup,iaupmnear,ibupmnear,icupm,idupm,xaffnear,xbffnear,xcff,xdff,bias,nullptr,ianear,ibnear,ic,id,xdim,xconsist,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iaset,ibset,icset,idset,assumreal,justcalcip);
        T resaBcd; yyycK4(resaBcd,xanear,xbfar ,xcn,xdn,xanearinfo,xbfarinfo ,xcinfo,xdinfo,xagradOrdernear,xbgradOrderfar ,xcgradOrder,xdgradOrder,xagradupnear,xbgradupfar ,xcgradup,xdgradup,iaupmnear,ibupmfar ,icupm,idupm,xaffnear,xbfffar ,xcff,xdff,bias,nullptr,ianear,ibfar ,ic,id,xdim,xconsist,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iaset,ibset,icset,idset,assumreal,justcalcip);
        T resAbcd; yyycK4(resAbcd,xafar ,xbnear,xcn,xdn,xafarinfo ,xbnearinfo,xcinfo,xdinfo,xagradOrderfar ,xbgradOrdernear,xcgradOrder,xdgradOrder,xagradupfar ,xbgradupnear,xcgradup,xdgradup,iaupmfar ,ibupmnear,icupm,idupm,xafffar ,xbffnear,xcff,xdff,bias,nullptr,iafar ,ibnear,ic,id,xdim,xconsist,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iaset,ibset,icset,idset,assumreal,justcalcip);
        T resABcd; yyycK4(resABcd,xafar ,xbfar ,xcn,xdn,xafarinfo ,xbfarinfo ,xcinfo,xdinfo,xagradOrderfar ,xbgradOrderfar ,xcgradOrder,xdgradOrder,xagradupfar ,xbgradupfar ,xcgradup,xdgradup,iaupmfar ,ibupmfar ,icupm,idupm,xafffar ,xbfffar ,xcff,xdff,bias,nullptr,iafar ,ibfar ,ic,id,xdim,xconsist,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iaset,ibset,icset,idset,assumreal,justcalcip);

        resabcd *= (xarankw*xbrankw*xcrankw*xdrankw);
        resaBcd *= (xarankw*xBrankw*xcrankw*xdrankw);
        resAbcd *= (xArankw*xbrankw*xcrankw*xdrankw);
        resABcd *= (xArankw*xBrankw*xcrankw*xdrankw);

        if ( xranktype == 0 )
        {
            // varphi(x,x') = varphi(x) - varphi(x')

            res = resabcd-resaBcd-resAbcd+resABcd;
        }

        else if ( xranktype == 1 )
        {
            // varphi(x,x') = varphi(x) + varphi(x')

            res = resabcd+resaBcd+resAbcd+resABcd;
        }

        else if ( xranktype == 2 )
        {
            // ill-defined

            NiceThrow("No latent function in this case 25");
        }

        else
        {
            // ill-defined

            NiceThrow("No latent function in this case 26");
        }
    }

    else if ( xafarpresent && xcfarpresent )
    {
        const SparseVector<gentype> &xanear = xa.n();
        const SparseVector<gentype> &xafar  = xa.f1();
        const SparseVector<gentype> &xaffnear = xaff;
        const SparseVector<gentype> &xafffar  = xafff;
        const vecInfo &xanearinfo = xainfo(0,-1);
        const vecInfo &xafarinfo  = xainfo(1,-1);
        int xagradOrdernear = xagradOrder;
        int xagradOrderfar  = xagradOrderR;
        int xagradupnear = xagradup;
        int xagradupfar  = xagradupR;
        int iaupmnear = iaupm;
        int iaupmfar  = xa.f1upsize();
        int ianear = ia;
        int iafar  = -(((ia+1)*100)+1);

        const SparseVector<gentype> &xcnear = xc.n();
        const SparseVector<gentype> &xcfar  = xc.f1();
        const SparseVector<gentype> &xcffnear = xcff;
        const SparseVector<gentype> &xcfffar  = xcfff;
        const vecInfo &xcnearinfo = xcinfo(0,-1);
        const vecInfo &xcfarinfo  = xcinfo(1,-1);
        int xcgradOrdernear = xcgradOrder;
        int xcgradOrderfar  = xcgradOrderR;
        int xcgradupnear = xcgradup;
        int xcgradupfar  = xcgradupR;
        int icupmnear = icupm;
        int icupmfar  = xc.f1upsize();
        int icnear = ic;
        int icfar  = -(((ic+1)*100)+1);

        T resabcd; yyycK4(resabcd,xanear,xbn,xcnear,xdn,xanearinfo,xbinfo,xcnearinfo,xdinfo,xagradOrdernear,xbgradOrder,xcgradOrdernear,xdgradOrder,xagradupnear,xbgradup,xcgradupnear,xdgradup,iaupmnear,ibupm,icupmnear,idupm,xaffnear,xbff,xcffnear,xdff,bias,nullptr,ianear,ib,icnear,id,xdim,xconsist,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iaset,ibset,icset,idset,assumreal,justcalcip);
        T resabCd; yyycK4(resabCd,xanear,xbn,xcfar ,xdn,xanearinfo,xbinfo,xcfarinfo ,xdinfo,xagradOrdernear,xbgradOrder,xcgradOrderfar ,xdgradOrder,xagradupnear,xbgradup,xcgradupfar ,xdgradup,iaupmnear,ibupm,icupmfar ,idupm,xaffnear,xbff,xcfffar ,xdff,bias,nullptr,ianear,ib,icfar ,id,xdim,xconsist,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iaset,ibset,icset,idset,assumreal,justcalcip);
        T resAbcd; yyycK4(resAbcd,xafar ,xbn,xcnear,xdn,xafarinfo ,xbinfo,xcnearinfo,xdinfo,xagradOrderfar ,xbgradOrder,xcgradOrdernear,xdgradOrder,xagradupfar ,xbgradup,xcgradupnear,xdgradup,iaupmfar ,ibupm,icupmnear,idupm,xafffar ,xbff,xcffnear,xdff,bias,nullptr,iafar ,ib,icnear,id,xdim,xconsist,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iaset,ibset,icset,idset,assumreal,justcalcip);
        T resAbCd; yyycK4(resAbCd,xafar ,xbn,xcfar ,xdn,xafarinfo ,xbinfo,xcfarinfo ,xdinfo,xagradOrderfar ,xbgradOrder,xcgradOrderfar ,xdgradOrder,xagradupfar ,xbgradup,xcgradupfar ,xdgradup,iaupmfar ,ibupm,icupmfar ,idupm,xafffar ,xbff,xcfffar ,xdff,bias,nullptr,iafar ,ib,icfar ,id,xdim,xconsist,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iaset,ibset,icset,idset,assumreal,justcalcip);

        resabcd *= (xarankw*xbrankw*xcrankw*xdrankw);
        resabCd *= (xarankw*xbrankw*xCrankw*xdrankw);
        resAbcd *= (xArankw*xbrankw*xcrankw*xdrankw);
        resAbCd *= (xArankw*xbrankw*xCrankw*xdrankw);

        if ( xranktype == 0 )
        {
            // varphi(x,x') = varphi(x) - varphi(x')

            res = resabcd-resabCd-resAbcd+resAbCd;
        }

        else if ( xranktype == 1 )
        {
            // varphi(x,x') = varphi(x) + varphi(x')

            res = resabcd+resabCd+resAbcd+resAbCd;
        }

        else if ( xranktype == 2 )
        {
            // ill-defined

            NiceThrow("No latent function in this case 27");
        }

        else
        {
            // ill-defined

            NiceThrow("No latent function in this case 28");
        }
    }

    else if ( xafarpresent && xdfarpresent )
    {
        const SparseVector<gentype> &xanear = xa.n();
        const SparseVector<gentype> &xafar  = xa.f1();
        const SparseVector<gentype> &xaffnear = xaff;
        const SparseVector<gentype> &xafffar  = xafff;
        const vecInfo &xanearinfo = xainfo(0,-1);
        const vecInfo &xafarinfo  = xainfo(1,-1);
        int xagradOrdernear = xagradOrder;
        int xagradOrderfar  = xagradOrderR;
        int xagradupnear = xagradup;
        int xagradupfar  = xagradupR;
        int iaupmnear = iaupm;
        int iaupmfar  = xa.f1upsize();
        int ianear = ia;
        int iafar  = -(((ia+1)*100)+1);

        const SparseVector<gentype> &xdnear = xd.n();
        const SparseVector<gentype> &xdfar  = xd.f1();
        const SparseVector<gentype> &xdffnear = xdff;
        const SparseVector<gentype> &xdfffar  = xdfff;
        const vecInfo &xdnearinfo = xdinfo(0,-1);
        const vecInfo &xdfarinfo  = xdinfo(1,-1);
        int xdgradOrdernear = xdgradOrder;
        int xdgradOrderfar  = xdgradOrderR;
        int xdgradupnear = xdgradup;
        int xdgradupfar  = xdgradupR;
        int idupmnear = idupm;
        int idupmfar  = xd.f1upsize();
        int idnear = id;
        int idfar  = -(((id+1)*100)+1);

        T resabcd; yyycK4(resabcd,xanear,xbn,xcn,xdnear,xanearinfo,xbinfo,xcinfo,xdnearinfo,xagradOrdernear,xbgradOrder,xcgradOrder,xdgradOrdernear,xagradupnear,xbgradup,xcgradup,xdgradupnear,iaupmnear,ibupm,icupm,idupmnear,xaffnear,xbff,xcff,xdffnear,bias,nullptr,ianear,ib,ic,idnear,xdim,xconsist,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iaset,ibset,icset,idset,assumreal,justcalcip);
        T resabcD; yyycK4(resabcD,xanear,xbn,xcn,xdfar ,xanearinfo,xbinfo,xcinfo,xdfarinfo ,xagradOrdernear,xbgradOrder,xcgradOrder,xdgradOrderfar ,xagradupnear,xbgradup,xcgradup,xdgradupfar ,iaupmnear,ibupm,icupm,idupmfar ,xaffnear,xbff,xcff,xdfffar ,bias,nullptr,ianear,ib,ic,idfar ,xdim,xconsist,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iaset,ibset,icset,idset,assumreal,justcalcip);
        T resAbcd; yyycK4(resAbcd,xafar ,xbn,xcn,xdnear,xafarinfo ,xbinfo,xcinfo,xdnearinfo,xagradOrderfar ,xbgradOrder,xcgradOrder,xdgradOrdernear,xagradupfar ,xbgradup,xcgradup,xdgradupnear,iaupmfar ,ibupm,icupm,idupmnear,xafffar ,xbff,xcff,xdffnear,bias,nullptr,iafar ,ib,ic,idnear,xdim,xconsist,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iaset,ibset,icset,idset,assumreal,justcalcip);
        T resAbcD; yyycK4(resAbcD,xafar ,xbn,xcn,xdfar ,xafarinfo ,xbinfo,xcinfo,xdfarinfo ,xagradOrderfar ,xbgradOrder,xcgradOrder,xdgradOrderfar ,xagradupfar ,xbgradup,xcgradup,xdgradupfar ,iaupmfar ,ibupm,icupm,idupmfar ,xafffar ,xbff,xcff,xdfffar ,bias,nullptr,iafar ,ib,ic,idfar ,xdim,xconsist,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iaset,ibset,icset,idset,assumreal,justcalcip);

        resabcd *= (xarankw*xbrankw*xcrankw*xdrankw);
        resabcD *= (xarankw*xbrankw*xcrankw*xDrankw);
        resAbcd *= (xArankw*xbrankw*xcrankw*xdrankw);
        resAbcD *= (xArankw*xbrankw*xcrankw*xDrankw);

        if ( xranktype == 0 )
        {
            // varphi(x,x') = varphi(x) - varphi(x')

            res = resabcd-resabcD-resAbcd+resAbcD;
        }

        else if ( xranktype == 1 )
        {
            // varphi(x,x') = varphi(x) + varphi(x')

            res = resabcd+resabcD+resAbcd+resAbcD;
        }

        else if ( xranktype == 2 )
        {
            // ill-defined

            NiceThrow("No latent function in this case 29");
        }

        else
        {
            // ill-defined

            NiceThrow("No latent function in this case 30");
        }
    }

    else if ( xbfarpresent && xcfarpresent )
    {
        const SparseVector<gentype> &xbnear = xb.n();
        const SparseVector<gentype> &xbfar  = xb.f1();
        const SparseVector<gentype> &xbffnear = xbff;
        const SparseVector<gentype> &xbfffar  = xbfff;
        const vecInfo &xbnearinfo = xbinfo(0,-1);
        const vecInfo &xbfarinfo  = xbinfo(1,-1);
        int xbgradOrdernear = xbgradOrder;
        int xbgradOrderfar  = xbgradOrderR;
        int xbgradupnear = xbgradup;
        int xbgradupfar  = xbgradupR;
        int ibupmnear = ibupm;
        int ibupmfar  = xb.f1upsize();
        int ibnear = ib;
        int ibfar  = -(((ib+1)*100)+1);

        const SparseVector<gentype> &xcnear = xc.n();
        const SparseVector<gentype> &xcfar  = xc.f1();
        const SparseVector<gentype> &xcffnear = xcff;
        const SparseVector<gentype> &xcfffar  = xcfff;
        const vecInfo &xcnearinfo = xcinfo(0,-1);
        const vecInfo &xcfarinfo  = xcinfo(1,-1);
        int xcgradOrdernear = xcgradOrder;
        int xcgradOrderfar  = xcgradOrderR;
        int xcgradupnear = xcgradup;
        int xcgradupfar  = xcgradupR;
        int icupmnear = icupm;
        int icupmfar  = xc.f1upsize();
        int icnear = ic;
        int icfar  = -(((ic+1)*100)+1);

        T resabcd; yyycK4(resabcd,xan,xbnear,xcnear,xdn,xainfo,xbnearinfo,xcnearinfo,xdinfo,xagradOrder,xbgradOrdernear,xcgradOrdernear,xdgradOrder,xagradup,xbgradupnear,xcgradupnear,xdgradup,iaupm,ibupmnear,icupmnear,idupm,xaff,xbffnear,xcffnear,xdff,bias,nullptr,ia,ibnear,icnear,id,xdim,xconsist,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iaset,ibset,icset,idset,assumreal,justcalcip);
        T resabCd; yyycK4(resabCd,xan,xbnear,xcfar ,xdn,xainfo,xbnearinfo,xcfarinfo ,xdinfo,xagradOrder,xbgradOrdernear,xcgradOrderfar ,xdgradOrder,xagradup,xbgradupnear,xcgradupfar ,xdgradup,iaupm,ibupmnear,icupmfar ,idupm,xaff,xbffnear,xcfffar ,xdff,bias,nullptr,ia,ibnear,icfar ,id,xdim,xconsist,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iaset,ibset,icset,idset,assumreal,justcalcip);
        T resaBcd; yyycK4(resaBcd,xan,xbfar ,xcnear,xdn,xainfo,xbfarinfo ,xcnearinfo,xdinfo,xagradOrder,xbgradOrderfar ,xcgradOrdernear,xdgradOrder,xagradup,xbgradupfar ,xcgradupnear,xdgradup,iaupm,ibupmfar ,icupmnear,idupm,xaff,xbfffar ,xcffnear,xdff,bias,nullptr,ia,ibfar ,icnear,id,xdim,xconsist,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iaset,ibset,icset,idset,assumreal,justcalcip);
        T resaBCd; yyycK4(resaBCd,xan,xbfar ,xcfar ,xdn,xainfo,xbfarinfo ,xcfarinfo ,xdinfo,xagradOrder,xbgradOrderfar ,xcgradOrderfar ,xdgradOrder,xagradup,xbgradupfar ,xcgradupfar ,xdgradup,iaupm,ibupmfar ,icupmfar ,idupm,xaff,xbfffar ,xcfffar ,xdff,bias,nullptr,ia,ibfar ,icfar ,id,xdim,xconsist,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iaset,ibset,icset,idset,assumreal,justcalcip);

        resabcd *= (xarankw*xbrankw*xcrankw*xdrankw);
        resabCd *= (xarankw*xbrankw*xCrankw*xdrankw);
        resaBcd *= (xarankw*xBrankw*xcrankw*xdrankw);
        resaBCd *= (xarankw*xBrankw*xCrankw*xdrankw);

        if ( xranktype == 0 )
        {
            // varphi(x,x') = varphi(x) - varphi(x')

            res = resabcd-resabCd-resaBcd+resaBCd;
        }

        else if ( xranktype == 1 )
        {
            // varphi(x,x') = varphi(x) + varphi(x')

            res = resabcd+resabCd+resaBcd+resaBCd;
        }

        else if ( xranktype == 2 )
        {
            // ill-defined

            NiceThrow("No latent function in this case 31");
        }

        else
        {
            // ill-defined

            NiceThrow("No latent function in this case 32");
        }
    }

    else if ( xbfarpresent && xdfarpresent )
    {
        const SparseVector<gentype> &xbnear = xb.n();
        const SparseVector<gentype> &xbfar  = xb.f1();
        const SparseVector<gentype> &xbffnear = xbff;
        const SparseVector<gentype> &xbfffar  = xbfff;
        const vecInfo &xbnearinfo = xbinfo(0,-1);
        const vecInfo &xbfarinfo  = xbinfo(1,-1);
        int xbgradOrdernear = xbgradOrder;
        int xbgradOrderfar  = xbgradOrderR;
        int xbgradupnear = xbgradup;
        int xbgradupfar  = xbgradupR;
        int ibupmnear = ibupm;
        int ibupmfar  = xb.f1upsize();
        int ibnear = ib;
        int ibfar  = -(((ib+1)*100)+1);

        const SparseVector<gentype> &xdnear = xd.n();
        const SparseVector<gentype> &xdfar  = xd.f1();
        const SparseVector<gentype> &xdffnear = xdff;
        const SparseVector<gentype> &xdfffar  = xdfff;
        const vecInfo &xdnearinfo = xdinfo(0,-1);
        const vecInfo &xdfarinfo  = xdinfo(1,-1);
        int xdgradOrdernear = xdgradOrder;
        int xdgradOrderfar  = xdgradOrderR;
        int xdgradupnear = xdgradup;
        int xdgradupfar  = xdgradupR;
        int idupmnear = idupm;
        int idupmfar  = xd.f1upsize();
        int idnear = id;
        int idfar  = -(((id+1)*100)+1);

        T resabcd; yyycK4(resabcd,xan,xbnear,xcn,xdnear,xainfo,xbnearinfo,xcinfo,xdnearinfo,xagradOrder,xbgradOrdernear,xcgradOrder,xdgradOrdernear,xagradup,xbgradupnear,xcgradup,xdgradupnear,iaupm,ibupmnear,icupm,idupmnear,xaff,xbffnear,xcff,xdffnear,bias,nullptr,ia,ibnear,ic,idnear,xdim,xconsist,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iaset,ibset,icset,idset,assumreal,justcalcip);
        T resabcD; yyycK4(resabcD,xan,xbnear,xcn,xdfar ,xainfo,xbnearinfo,xcinfo,xdfarinfo ,xagradOrder,xbgradOrdernear,xcgradOrder,xdgradOrderfar ,xagradup,xbgradupnear,xcgradup,xdgradupfar ,iaupm,ibupmnear,icupm,idupmfar ,xaff,xbffnear,xcff,xdfffar ,bias,nullptr,ia,ibnear,ic,idfar ,xdim,xconsist,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iaset,ibset,icset,idset,assumreal,justcalcip);
        T resaBcd; yyycK4(resaBcd,xan,xbfar ,xcn,xdnear,xainfo,xbfarinfo ,xcinfo,xdnearinfo,xagradOrder,xbgradOrderfar ,xcgradOrder,xdgradOrdernear,xagradup,xbgradupfar ,xcgradup,xdgradupnear,iaupm,ibupmfar ,icupm,idupmnear,xaff,xbfffar ,xcff,xdffnear,bias,nullptr,ia,ibfar ,ic,idnear,xdim,xconsist,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iaset,ibset,icset,idset,assumreal,justcalcip);
        T resaBcD; yyycK4(resaBcD,xan,xbfar ,xcn,xdfar ,xainfo,xbfarinfo ,xcinfo,xdfarinfo ,xagradOrder,xbgradOrderfar ,xcgradOrder,xdgradOrderfar ,xagradup,xbgradupfar ,xcgradup,xdgradupfar ,iaupm,ibupmfar ,icupm,idupmfar ,xaff,xbfffar ,xcff,xdfffar ,bias,nullptr,ia,ibfar ,ic,idfar ,xdim,xconsist,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iaset,ibset,icset,idset,assumreal,justcalcip);

        resabcd *= (xarankw*xbrankw*xcrankw*xdrankw);
        resabcD *= (xarankw*xbrankw*xcrankw*xDrankw);
        resaBcd *= (xarankw*xBrankw*xcrankw*xdrankw);
        resaBcD *= (xarankw*xBrankw*xcrankw*xDrankw);

        if ( xranktype == 0 )
        {
            // varphi(x,x') = varphi(x) - varphi(x')

            res = resabcd-resabcD-resaBcd+resaBcD;
        }

        else if ( xranktype == 1 )
        {
            // varphi(x,x') = varphi(x) + varphi(x')

            res = resabcd+resabcD+resaBcd+resaBcD;
        }

        else if ( xranktype == 2 )
        {
            // ill-defined

            NiceThrow("No latent function in this case 33");
        }

        else
        {
            // ill-defined

            NiceThrow("No latent function in this case 34");
        }
    }

    else if ( xcfarpresent && xdfarpresent )
    {
        const SparseVector<gentype> &xcnear = xc.n();
        const SparseVector<gentype> &xcfar  = xc.f1();
        const SparseVector<gentype> &xcffnear = xcff;
        const SparseVector<gentype> &xcfffar  = xcfff;
        const vecInfo &xcnearinfo = xcinfo(0,-1);
        const vecInfo &xcfarinfo  = xcinfo(1,-1);
        int xcgradOrdernear = xcgradOrder;
        int xcgradOrderfar  = xcgradOrderR;
        int xcgradupnear = xcgradup;
        int xcgradupfar  = xcgradupR;
        int icupmnear = icupm;
        int icupmfar  = xc.f1upsize();
        int icnear = ic;
        int icfar  = -(((ic+1)*100)+1);

        const SparseVector<gentype> &xdnear = xd.n();
        const SparseVector<gentype> &xdfar  = xd.f1();
        const SparseVector<gentype> &xdffnear = xdff;
        const SparseVector<gentype> &xdfffar  = xdfff;
        const vecInfo &xdnearinfo = xdinfo(0,-1);
        const vecInfo &xdfarinfo  = xdinfo(1,-1);
        int xdgradOrdernear = xdgradOrder;
        int xdgradOrderfar  = xdgradOrderR;
        int xdgradupnear = xdgradup;
        int xdgradupfar  = xdgradupR;
        int idupmnear = idupm;
        int idupmfar  = xd.f1upsize();
        int idnear = id;
        int idfar  = -(((id+1)*100)+1);

        T resabcd; yyycK4(resabcd,xan,xbn,xcnear,xdnear,xainfo,xbinfo,xcnearinfo,xdnearinfo,xagradOrder,xbgradOrder,xcgradOrdernear,xdgradOrdernear,xagradup,xbgradup,xcgradupnear,xdgradupnear,iaupm,ibupm,icupmnear,idupmnear,xaff,xbff,xcffnear,xdffnear,bias,nullptr,ia,ib,icnear,idnear,xdim,xconsist,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iaset,ibset,icset,idset,assumreal,justcalcip);
        T resabcD; yyycK4(resabcD,xan,xbn,xcnear,xdfar ,xainfo,xbinfo,xcnearinfo,xdfarinfo ,xagradOrder,xbgradOrder,xcgradOrdernear,xdgradOrderfar ,xagradup,xbgradup,xcgradupnear,xdgradupfar ,iaupm,ibupm,icupmnear,idupmfar ,xaff,xbff,xcffnear,xdfffar ,bias,nullptr,ia,ib,icnear,idfar ,xdim,xconsist,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iaset,ibset,icset,idset,assumreal,justcalcip);
        T resabCd; yyycK4(resabCd,xan,xbn,xcfar ,xdnear,xainfo,xbinfo,xcfarinfo ,xdnearinfo,xagradOrder,xbgradOrder,xcgradOrderfar ,xdgradOrdernear,xagradup,xbgradup,xcgradupfar ,xdgradupnear,iaupm,ibupm,icupmfar ,idupmnear,xaff,xbff,xcfffar ,xdffnear,bias,nullptr,ia,ib,icfar ,idnear,xdim,xconsist,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iaset,ibset,icset,idset,assumreal,justcalcip);
        T resabCD; yyycK4(resabCD,xan,xbn,xcfar ,xdfar ,xainfo,xbinfo,xcfarinfo ,xdfarinfo ,xagradOrder,xbgradOrder,xcgradOrderfar ,xdgradOrderfar ,xagradup,xbgradup,xcgradupfar ,xdgradupfar ,iaupm,ibupm,icupmfar ,idupmfar ,xaff,xbff,xcfffar ,xdfffar ,bias,nullptr,ia,ib,icfar ,idfar ,xdim,xconsist,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iaset,ibset,icset,idset,assumreal,justcalcip);

        resabcd *= (xarankw*xbrankw*xcrankw*xdrankw);
        resabcD *= (xarankw*xbrankw*xcrankw*xDrankw);
        resabCd *= (xarankw*xbrankw*xCrankw*xdrankw);
        resabCD *= (xarankw*xbrankw*xCrankw*xDrankw);

        if ( xranktype == 0 )
        {
            // varphi(x,x') = varphi(x) - varphi(x')

            res = resabcd-resabcD-resabCd+resabCD;
        }

        else if ( xranktype == 1 )
        {
            // varphi(x,x') = varphi(x) + varphi(x')

            res = resabcd+resabcD+resabCd+resabCD;
        }

        else if ( xranktype == 2 )
        {
            // ill-defined

            NiceThrow("No latent function in this case 35");
        }

        else
        {
            // ill-defined

            NiceThrow("No latent function in this case 36");
        }
    }

    else if ( xafarpresent )
    {
        const SparseVector<gentype> &xanear = xa.n();
        const SparseVector<gentype> &xafar  = xa.f1();
        const SparseVector<gentype> &xaffnear = xaff;
        const SparseVector<gentype> &xafffar  = xafff;
        const vecInfo &xanearinfo = xainfo(0,-1);
        const vecInfo &xafarinfo  = xainfo(1,-1);
        int xagradOrdernear = xagradOrder;
        int xagradOrderfar  = xagradOrderR;
        int xagradupnear = xagradup;
        int xagradupfar  = xagradupR;
        int iaupmnear = iaupm;
        int iaupmfar  = xa.f1upsize();
        int ianear = ia;
        int iafar  = -(((ia+1)*100)+1);

        T resabcd; yyycK4(resabcd,xanear,xbn,xcn,xdn,xanearinfo,xbinfo,xcinfo,xdinfo,xagradOrdernear,xbgradOrder,xcgradOrder,xdgradOrder,xagradupnear,xbgradup,xcgradup,xdgradup,iaupmnear,ibupm,icupm,idupm,xaffnear,xbff,xcff,xdff,bias,nullptr,ianear,ib,ic,id,xdim,xconsist,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iaset,ibset,icset,idset,assumreal,justcalcip);
        T resAbcd; yyycK4(resAbcd,xafar ,xbn,xcn,xdn,xafarinfo ,xbinfo,xcinfo,xdinfo,xagradOrderfar ,xbgradOrder,xcgradOrder,xdgradOrder,xagradupfar ,xbgradup,xcgradup,xdgradup,iaupmfar ,ibupm,icupm,idupm,xafffar ,xbff,xcff,xdff,bias,nullptr,iafar ,ib,ic,id,xdim,xconsist,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iaset,ibset,icset,idset,assumreal,justcalcip);

        resabcd *= (xarankw*xbrankw*xcrankw*xdrankw);
        resAbcd *= (xArankw*xbrankw*xcrankw*xdrankw);

        if ( xranktype == 0 )
        {
            // varphi(x,x') = varphi(x) - varphi(x')

            res = resabcd-resAbcd;
        }

        else if ( xranktype == 1 )
        {
            // varphi(x,x') = varphi(x) + varphi(x')

            res = resabcd+resAbcd;
        }

        else if ( xranktype == 2 )
        {
            // ill-defined

            NiceThrow("No latent function in this case 37");
        }

        else
        {
            // ill-defined

            NiceThrow("No latent function in this case 38");
        }
    }

    else if ( xbfarpresent )
    {
        const SparseVector<gentype> &xbnear = xb.n();
        const SparseVector<gentype> &xbfar  = xb.f1();
        const SparseVector<gentype> &xbffnear = xbff;
        const SparseVector<gentype> &xbfffar  = xbfff;
        const vecInfo &xbnearinfo = xbinfo(0,-1);
        const vecInfo &xbfarinfo  = xbinfo(1,-1);
        int xbgradOrdernear = xbgradOrder;
        int xbgradOrderfar  = xbgradOrderR;
        int xbgradupnear = xbgradup;
        int xbgradupfar  = xbgradupR;
        int ibupmnear = ibupm;
        int ibupmfar  = xb.f1upsize();
        int ibnear = ib;
        int ibfar  = -(((ib+1)*100)+1);

        T resabcd; yyycK4(resabcd,xan,xbnear,xcn,xdn,xainfo,xbnearinfo,xcinfo,xdinfo,xagradOrder,xbgradOrdernear,xcgradOrder,xdgradOrder,xagradup,xbgradupnear,xcgradup,xdgradup,iaupm,ibupmnear,icupm,idupm,xaff,xbffnear,xcff,xdff,bias,nullptr,ia,ibnear,ic,id,xdim,xconsist,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iaset,ibset,icset,idset,assumreal,justcalcip);
        T resaBcd; yyycK4(resaBcd,xan,xbfar ,xcn,xdn,xainfo,xbfarinfo ,xcinfo,xdinfo,xagradOrder,xbgradOrderfar ,xcgradOrder,xdgradOrder,xagradup,xbgradupfar ,xcgradup,xdgradup,iaupm,ibupmfar ,icupm,idupm,xaff,xbfffar ,xcff,xdff,bias,nullptr,ia,ibfar ,ic,id,xdim,xconsist,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iaset,ibset,icset,idset,assumreal,justcalcip);

        resabcd *= (xarankw*xbrankw*xcrankw*xdrankw);
        resaBcd *= (xarankw*xBrankw*xcrankw*xdrankw);

        if ( xranktype == 0 )
        {
            // varphi(x,x') = varphi(x) - varphi(x')

            res = resabcd-resaBcd;
        }

        else if ( xranktype == 1 )
        {
            // varphi(x,x') = varphi(x) + varphi(x')

            res = resabcd+resaBcd;
        }

        else if ( xranktype == 2 )
        {
            // ill-defined

            NiceThrow("No latent function in this case 39");
        }

        else
        {
            // ill-defined

            NiceThrow("No latent function in this case 40");
        }
    }

    else if ( xcfarpresent )
    {
        const SparseVector<gentype> &xcnear = xc.n();
        const SparseVector<gentype> &xcfar  = xc.f1();
        const SparseVector<gentype> &xcffnear = xcff;
        const SparseVector<gentype> &xcfffar  = xcfff;
        const vecInfo &xcnearinfo = xcinfo(0,-1);
        const vecInfo &xcfarinfo  = xcinfo(1,-1);
        int xcgradOrdernear = xcgradOrder;
        int xcgradOrderfar  = xcgradOrderR;
        int xcgradupnear = xcgradup;
        int xcgradupfar  = xcgradupR;
        int icupmnear = icupm;
        int icupmfar  = xc.f1upsize();
        int icnear = ic;
        int icfar  = -(((ic+1)*100)+1);

        T resabcd; yyycK4(resabcd,xan,xbn,xcnear,xdn,xainfo,xbinfo,xcnearinfo,xdinfo,xagradOrder,xbgradOrder,xcgradOrdernear,xdgradOrder,xagradup,xbgradup,xcgradupnear,xdgradup,iaupm,ibupm,icupmnear,idupm,xaff,xbff,xcffnear,xdff,bias,nullptr,ia,ib,icnear,id,xdim,xconsist,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iaset,ibset,icset,idset,assumreal,justcalcip);
        T resabCd; yyycK4(resabCd,xan,xbn,xcfar ,xdn,xainfo,xbinfo,xcfarinfo ,xdinfo,xagradOrder,xbgradOrder,xcgradOrderfar ,xdgradOrder,xagradup,xbgradup,xcgradupfar ,xdgradup,iaupm,ibupm,icupmfar ,idupm,xaff,xbff,xcfffar ,xdff,bias,nullptr,ia,ib,icfar ,id,xdim,xconsist,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iaset,ibset,icset,idset,assumreal,justcalcip);

        resabcd *= (xarankw*xbrankw*xcrankw*xdrankw);
        resabCd *= (xarankw*xbrankw*xCrankw*xdrankw);

        if ( xranktype == 0 )
        {
            // varphi(x,x') = varphi(x) - varphi(x')

            res = resabcd-resabCd;
        }

        else if ( xranktype == 1 )
        {
            // varphi(x,x') = varphi(x) + varphi(x')

            res = resabcd+resabCd;
        }

        else if ( xranktype == 2 )
        {
            // ill-defined

            NiceThrow("No latent function in this case 41");
        }

        else
        {
            // ill-defined

            NiceThrow("No latent function in this case 42");
        }
    }

    else if ( xdfarpresent )
    {
        const SparseVector<gentype> &xdnear = xd.n();
        const SparseVector<gentype> &xdfar  = xd.f1();
        const SparseVector<gentype> &xdffnear = xdff;
        const SparseVector<gentype> &xdfffar  = xdfff;
        const vecInfo &xdnearinfo = xdinfo(0,-1);
        const vecInfo &xdfarinfo  = xdinfo(1,-1);
        int xdgradOrdernear = xdgradOrder;
        int xdgradOrderfar  = xdgradOrderR;
        int xdgradupnear = xdgradup;
        int xdgradupfar  = xdgradupR;
        int idupmnear = idupm;
        int idupmfar  = xd.f1upsize();
        int idnear = id;
        int idfar  = -(((id+1)*100)+1);

        T resabcd; yyycK4(resabcd,xan,xbn,xcn,xdnear,xainfo,xbinfo,xcinfo,xdnearinfo,xagradOrder,xbgradOrder,xcgradOrder,xdgradOrdernear,xagradup,xbgradup,xcgradup,xdgradupnear,iaupm,ibupm,icupm,idupmnear,xaff,xbff,xcff,xdffnear,bias,nullptr,ia,ib,ic,idnear,xdim,xconsist,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iaset,ibset,icset,idset,assumreal,justcalcip);
        T resabcD; yyycK4(resabcD,xan,xbn,xcn,xdfar ,xainfo,xbinfo,xcinfo,xdfarinfo ,xagradOrder,xbgradOrder,xcgradOrder,xdgradOrderfar ,xagradup,xbgradup,xcgradup,xdgradupfar ,iaupm,ibupm,icupm,idupmfar ,xaff,xbff,xcff,xdfffar ,bias,nullptr,ia,ib,ic,idfar ,xdim,xconsist,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,iaset,ibset,icset,idset,assumreal,justcalcip);

        resabcd *= (xarankw*xbrankw*xcrankw*xdrankw);
        resabcD *= (xarankw*xbrankw*xcrankw*xDrankw);

        if ( xranktype == 0 )
        {
            // varphi(x,x') = varphi(x) - varphi(x')

            res = resabcd-resabcD;
        }

        else if ( xranktype == 1 )
        {
            // varphi(x,x') = varphi(x) + varphi(x')

            res = resabcd+resabcD;
        }

        else if ( xranktype == 2 )
        {
            // ill-defined

            NiceThrow("No latent function in this case 43");
        }

        else
        {
            // ill-defined

            NiceThrow("No latent function in this case 44");
        }
    }

    else
    {
        yyycK4(res,xan,xbn,xcn,xdn,xainfo,xbinfo,xcinfo,xdinfo,xagradOrder,xbgradOrder,xcgradOrder,xdgradOrder,xagradup,xbgradup,xcgradup,xdgradup,iaupm,ibupm,icupm,idupm,xaff,xbff,xcff,xdff,bias,pxyprod,ia,ib,ic,id,xdim,xconsist,xresmode,mlid,xy00,xy10,xy11,xy20,xy21,xy22,xy30,xy31,xy32,xy33,iaset,ibset,icset,idset,assumreal,justcalcip);

        res *= (xarankw*xbrankw*xcrankw*xdrankw);
    }

    return res;
}

template <class T>
T &MercerKernel::yyybKm(int m, T &res,
                    Vector<const SparseVector<gentype> *> &x,
                    Vector<const vecInfo *> &xinfo,
                    Vector<int> &xgradOrder,
                    Vector<int> &xgradOrderR,
                    Vector<int> &iupm,
                    Vector<int> &xfarpresent,
                    Vector<double> &xxrankw,
                    Vector<double> &xXrankw,
                    Vector<int> &xfarfarpresent,
                    Vector<int> &xfarfarfarpresent,
                    Vector<int> &xgradup,
                    Vector<int> &xgradupR,
                    Vector<int> &xignorefarfar,
                    Vector<int> &xignorefarfarfar,
                    const T &bias,
                    Vector<int> &i,
                    const gentype **pxyprod, int xdim, int xconsist, int resmode, int mlid,
                    const Matrix<double> *xy, const Vector<int> *iiset, int assumreal, int justcalcip) const
{
    static const SparseVector<gentype> dummy;

    Vector<const SparseVector<gentype> *> xn(x);
    Vector<const SparseVector<gentype> *> xf(x);
    Vector<const SparseVector<gentype> *> xff(x);
    Vector<const SparseVector<gentype> *> xfff(x);

    int ii;

    for ( ii = 0 ; ii < x.size() ; ++ii )
    {
        xn("&",ii)   = &((*(x(ii))).n());
        xf("&",ii)   = &((*(x(ii))).f1());
        xff("&",ii)  = &( ( xfarfarpresent(ii)    && !xignorefarfar(ii)    ) ? (*(x(ii))).f2() : dummy );
        xfff("&",ii) = &( ( xfarfarfarpresent(ii) && !xignorefarfarfar(ii) ) ? (*(x(ii))).f3() : dummy );
    }

    return yyybKmb(m,res,x,xn,xf,xff,xfff,xinfo,xgradOrder,xgradOrderR,iupm,xfarpresent,xxrankw,xXrankw,xgradup,xgradupR,bias,i,pxyprod,xdim,xconsist,resmode,mlid,xy,iiset,assumreal,justcalcip);
}

template <class T>
T &MercerKernel::yyybKmb(int m, T &res,
                    Vector<const SparseVector<gentype> *> &x,
                    Vector<const SparseVector<gentype> *> &xn,
                    Vector<const SparseVector<gentype> *> &xf,
                    Vector<const SparseVector<gentype> *> &xff,
                    Vector<const SparseVector<gentype> *> &xfff,
                    Vector<const vecInfo *> &xinfo,
                    Vector<int> &xgradOrder,
                    Vector<int> &xgradOrderR,
                    Vector<int> &iupm,
                    Vector<int> &xfarpresent,
                    Vector<double> &xxrankw,
                    Vector<double> &xXrankw,
                    Vector<int> &xgradup,
                    Vector<int> &xgradupR,
                    const T &bias,
                    Vector<int> &i,
                    const gentype **pxyprod, int xdim, int xconsist, int resmode, int mlid,
                    const Matrix<double> *xy, const Vector<int> *iiset, int assumreal, int justcalcip) const
{
    int hasrank = sum(xfarpresent);

    NiceAssert( !( justcalcip && hasrank ) );

    if ( !hasrank )
    {
        yyycKm(m,res,xn,xinfo,xgradOrder,xgradup,iupm,xff,bias,i,pxyprod,xdim,xconsist,resmode,mlid,xy,iiset,assumreal,justcalcip);

        res *= prod(xxrankw);
    }

    else if ( ( xranktype == 0 ) || ( xranktype == 1 ) )
    {
        static const SparseVector<gentype> dummy;

        int j = 0;
        double resscale = 1;

        for ( j = 0 ; j < x.size() ; ++j )
        {
            if ( xfarpresent(j) )
            {
                break;
            }

            else
            {
                resscale *= xxrankw(j);
            }
        }

        double xxrankwj = xxrankw(j);
        double xXrankwj = xXrankw(j);

        // Recursed calls will always have larger j, so changes we make up to and including j will "stick", allowing us to overwrite arguments

        xfarpresent("&",j) = 0; // This removes this argument from the "still to be computed" set of rank constraints

        xxrankw("&",j) = 1; // "
        xXrankw("&",j) = 1; // "

        const SparseVector<gentype> *xj    = x(j);
        const SparseVector<gentype> *xjn   = xn(j);
        const SparseVector<gentype> *xjf   = xf(j);
        const SparseVector<gentype> *xjff  = xff(j);
        const SparseVector<gentype> *xjfff = xfff(j);

        const vecInfo *xjinfo = xinfo(j);

        int xjgradOrder  = xgradOrder(j);
        int xjgradOrderR = xgradOrderR(j);
        int ijupm        = iupm(j);
        int xjgradup     = xgradup(j);
        int xjgradupR    = xgradupR(j);
        int ij           = i(j);

        const SparseVector<gentype> &xjnear = *xjn;
        const SparseVector<gentype> &xjfar  = *xjf;

        const SparseVector<gentype> &xjffnear = *xjff;
        const SparseVector<gentype> &xjfffar  = *xjfff;

        const vecInfo &xjnearinfo = (*xjinfo)(0,-1);
        const vecInfo &xjfarinfo  = (*xjinfo)(1,-1);

        int xjgradOrdernear = xjgradOrder;
        int xjgradOrderfar  = xjgradOrderR;

        int xjgradupnear = xjgradup;
        int xjgradupfar  = xjgradupR;

        int ijupmnear = ijupm;
        int ijupmfar  = (*xj).f1upsize();

        int ijnear = ij;
        int ijfar  = -(((ij+1)*100)+1);

        x("&",j)           = &xjnear;
        xff("&",j)         = &xjffnear;
        xinfo("&",j)       = &xjnearinfo;
        xgradOrder("&",j)  = xjgradOrdernear;
        iupm("&",j)        = ijupmnear;
        xgradup("&",j)     = xjgradupnear;
        i("&",j)           = ijnear;

        yyybKmb(m,res,x,xn,xf,xff,xfff,xinfo,xgradOrder,xgradOrderR,iupm,xfarpresent,xxrankw,xXrankw,xgradup,xgradupR,bias,i,nullptr,xdim,xconsist,resmode,mlid,nullptr,iiset,assumreal,justcalcip);

        x("&",j)           = &xjfar;
        xff("&",j)         = &xjfffar;
        xinfo("&",j)       = &xjfarinfo;
        xgradOrder("&",j)  = xjgradOrderfar;
        iupm("&",j)        = ijupmfar;
        xgradup("&",j)     = xjgradupfar;
        i("&",j)           = ijfar;

        if ( xranktype == 0 )
        {
            T tmp;

            res -= yyybKmb(m,tmp,x,xn,xf,xff,xfff,xinfo,xgradOrder,xgradOrderR,iupm,xfarpresent,xxrankw,xXrankw,xgradup,xgradupR,bias,i,nullptr,xdim,xconsist,resmode,mlid,nullptr,iiset,assumreal,justcalcip);
        }

        else if ( xranktype == 1 )
        {
            T tmp;

            res += yyybKmb(m,tmp,x,xn,xf,xff,xfff,xinfo,xgradOrder,xgradOrderR,iupm,xfarpresent,xxrankw,xXrankw,xgradup,xgradupR,bias,i,nullptr,xdim,xconsist,resmode,mlid,nullptr,iiset,assumreal,justcalcip);
        }

        res *= resscale*xxrankwj*xXrankwj;

        x("&",j)          = xj;
        xff("&",j)        = xjff;
        xinfo("&",j)      = xjinfo;
        xgradOrder("&",j) = xjgradOrder;
        iupm("&",j)       = ijupm;
        xgradup("&",j)    = xjgradup;
        i("&",j)          = ij;
    }

    else
    {
        static const SparseVector<gentype> dummy;

        int j,k,l;

        for ( j = 0 ; j < x.size() ; ++j )
        {
            if ( !xfarpresent(j) )
            {
                NiceThrow("No latent function in this case 100");
            }
        }

        // In this case the result is combinatoric, no recursive solution possible.

        Vector<const SparseVector<gentype> *> nx(x);
        Vector<const SparseVector<gentype> *> nxff(xff);
        Vector<const SparseVector<gentype> *> nxfff(xfff);
        Vector<const vecInfo *> nxinfo(xinfo);
        Vector<int> nxgradOrder(xgradOrder);
        Vector<int> nxgradOrderR(xgradOrderR);
        Vector<int> niupm(iupm);
        Vector<int> nxgradup(xgradup);
        Vector<int> nxgradupR(xgradupR);
        Vector<int> ni(i);

        Vector<const SparseVector<gentype> *> fx(x);
        Vector<const SparseVector<gentype> *> fxff(xff);
        Vector<const SparseVector<gentype> *> fxfff(xfff);
        Vector<const vecInfo *> fxinfo(xinfo);
        Vector<int> fxgradOrder(xgradOrder);
        Vector<int> fxgradOrderR(xgradOrderR);
        Vector<int> fiupm(iupm);
        Vector<int> fxgradup(xgradup);
        Vector<int> fxgradupR(xgradupR);
        Vector<int> fi(i);

        xfarpresent = 0; // no further recurse

        // Outer loop goes through all possible combinations of near/far,
        // where k is to be interpretted as a binary with 0 for no near/far
        // flip, 1 otherwise.  k has m bits, so m < 32 or 64 is implied.
        //
        // every flip negates the sign in the sum
        //
        // inner loop goes over every bit in k and sets up vectors accordingly

        int numcombs = 1<<m;

        for ( k = 0 ; k < numcombs ; ++k )
        {
            int ressgn = 1; // will be +1 if an even number of flips happen, -1 otherwise

            for ( j = 0, l = 1 ; j < m ; ++j, l *= 2 )
            {
                NiceAssert( xxrankw(j) == 1 );
                NiceAssert( xXrankw(j) == 1 );

                const SparseVector<gentype> *xj    = x(j);
                const SparseVector<gentype> *xjn   = xn(j);
                const SparseVector<gentype> *xjf   = xf(j);
                const SparseVector<gentype> *xjff  = xff(j);
                const SparseVector<gentype> *xjfff = xfff(j);

                const vecInfo *xjinfo = xinfo(j);

                int xjgradOrder  = xgradOrder(j);
                int xjgradOrderR = xgradOrderR(j);
                int ijupm        = iupm(j);
                int xjgradup     = xgradup(j);
                int xjgradupR    = xgradupR(j);
                int ij           = i(j);

                const SparseVector<gentype> &xjnear = *xjn;
                const SparseVector<gentype> &xjfar  = *xjf;

                const SparseVector<gentype> &xjffnear = *xjff;
                const SparseVector<gentype> &xjfffar  = *xjfff;

                const vecInfo &xjnearinfo = (*xjinfo)(0,-1);
                const vecInfo &xjfarinfo  = (*xjinfo)(1,-1);

                int xjgradOrdernear = xjgradOrder;
                int xjgradOrderfar  = xjgradOrderR;

                int xjgradupnear = xjgradup;
                int xjgradupfar  = xjgradupR;

                int ijupmnear = ijupm;
                int ijupmfar  = (*xj).f1upsize();

                int ijnear = ij;
                int ijfar  = -(((ij+1)*100)+1);

                if ( !( k & l ) )
                {
                    nx("&",j)          = &xjnear;
                    nxff("&",j)        = &xjffnear;
                    nxinfo("&",j)      = &xjnearinfo;
                    nxgradOrder("&",j) = xjgradOrdernear;
                    niupm("&",j)       = ijupmnear;
                    nxgradup("&",j)    = xjgradupnear;
                    ni("&",j)          = ijnear;

                    fx("&",j)          = &xjfar;
                    fxff("&",j)        = &xjfffar;
                    fxinfo("&",j)      = &xjfarinfo;
                    fxgradOrder("&",j) = xjgradOrderfar;
                    fiupm("&",j)       = ijupmfar;
                    fxgradup("&",j)    = xjgradupfar;
                    fi("&",j)          = ijfar;
                }

                else
                {
                    fx("&",j)          = &xjnear;
                    fxff("&",j)        = &xjffnear;
                    fxinfo("&",j)      = &xjnearinfo;
                    fxgradOrder("&",j) = xjgradOrdernear;
                    fiupm("&",j)       = ijupmnear;
                    fxgradup("&",j)    = xjgradupnear;
                    fi("&",j)          = ijnear;

                    nx("&",j)          = &xjfar;
                    nxff("&",j)        = &xjfffar;
                    nxinfo("&",j)      = &xjfarinfo;
                    nxgradOrder("&",j) = xjgradOrderfar;
                    niupm("&",j)       = ijupmfar;
                    nxgradup("&",j)    = xjgradupfar;
                    ni("&",j)          = ijfar;

                    ressgn *= -1;
                }

                T crs,tmp;

                       yyybKmb(m,crs,nx,xn,xf,nxff,nxfff,nxinfo,nxgradOrder,nxgradOrderR,niupm,xfarpresent,xxrankw,xXrankw,nxgradup,xgradupR,bias,ni,nullptr,xdim,xconsist,resmode,mlid,nullptr,iiset,assumreal,justcalcip);
                crs *= yyybKmb(m,tmp,fx,xn,xf,fxff,nxfff,fxinfo,fxgradOrder,nxgradOrderR,fiupm,xfarpresent,xxrankw,xXrankw,fxgradup,xgradupR,bias,fi,nullptr,xdim,xconsist,resmode,mlid,nullptr,iiset,assumreal,justcalcip);

                if ( !k )
                {
                    res = crs;
                }

                else if ( ( xranktype == 2 ) && ( ressgn == -1 ) )
                {
                    res -= crs;
                }

                else
                {
                    res += crs;
                }
            }
        }
    }

    return res;
}



template <class T>
int MercerKernel::yyybphim(int m, Vector<T>  &res,
                           const SparseVector<gentype> &xa,
                           const vecInfo &xainfo,
                           int xaignorefarfar,
                           int xaignorefarfarfar,
                           int ia,
                           int xagradOrder,
                           int xagradOrderR,
                           int iaupm,
                           int xafarpresent,
                           int xafarfarpresent,
                           int xafarfarfarpresent,
                           int xagradup,
                           int xagradupR,
                           int allowfinite, int xdim, int xconsist, int assumreal, int iaset) const
{
    int dres = 0;

    static const SparseVector<gentype> dummy;

    const SparseVector<gentype> &xaff = ( xafarfarpresent && !xaignorefarfar ) ? xa.f2() : dummy;

    const SparseVector<gentype> &xafff = ( xafarfarfarpresent && !xaignorefarfarfar ) ? xa.f3() : dummy;

//FIXME: up to here
    if ( xafarpresent )
    {
        const SparseVector<gentype> &xanear = xa.n();
        const SparseVector<gentype> &xafar  = xa.f1();

        const SparseVector<gentype> &xaffnear = xaff;
        const SparseVector<gentype> &xafffar  = xafff;

        const vecInfo &xanearinfo = xainfo(0,-1);
        const vecInfo &xafarinfo  = xainfo(1,-1);

        int xagradOrdernear = xagradOrder;
        int xagradOrderfar  = xagradOrderR;

        int xagradupnear = xagradup;
        int xagradupfar  = xagradupR;

        int iaupmnear = iaupm;
        int iaupmfar  = xa.f1upsize();

        int ianear = ia;
        int iafar  = -(((ia+1)*100)+1);

        Vector<T> tmp;

        yyycphim(m,res,xanear,xanearinfo,ianear,xagradOrdernear,iaupmnear,xagradupnear,xaffnear,allowfinite,xdim,xconsist,assumreal,iaset);
        yyycphim(m,tmp,xafar ,xafarinfo, iafar ,xagradOrderfar, iaupmfar, xagradupfar, xafffar ,allowfinite,xdim,xconsist,assumreal,iaset);

        if ( xranktype == 0 )
        {
            res -= tmp;
        }

        else if ( xranktype == 1 )
        {
            res += tmp;
        }

        else if ( xranktype == 2 )
        {
            Vector<T> parta;
            Vector<T> partb;

            kronprod(parta,res,tmp);
            kronprod(partb,tmp,res);

            res  = parta;
            res -= partb;
        }

        else
        {
            Vector<T> parta;
            Vector<T> partb;

            kronprod(parta,res,tmp);
            kronprod(partb,tmp,res);

            res  = parta;
            res += partb;
        }

        dres = res.size();
    }

    else
    {
        dres = yyycphim(m,res,xa,xainfo,ia,xagradOrder,iaupm,xagradup,xaff,allowfinite,xdim,xconsist,assumreal,iaset);
    }

    return dres;
}

















// Pre-process Gradients

// Functions to allow different types to be treated "as if" they were matrices or vectors

inline double  &resizeZeroMat(double  &x, int i, int j);
inline gentype &resizeZeroMat(gentype &x, int i, int j);

inline double  &resizeZeroVec(double  &x, int i);
inline gentype &resizeZeroVec(gentype &x, int i);

inline double  &getMatElm(double  &x, int i, int j);
inline gentype &getMatElm(gentype &x, int i, int j);

inline double  &getVecElm(double  &x, int i);
inline gentype &getVecElm(gentype &x, int i);

inline double &resizeZeroMat(double &x, int i, int j)
{
    if ( ( i != 1 ) || ( j != 1 ) )
    {
        NiceThrow("Attempt to resize double as matrix");
    }

    return x = 0.0;
}

inline gentype &resizeZeroMat(gentype &x, int i, int j)
{
    x.force_matrix().resize(i,j);
    x.dir_matrix().zero();

    return x;
}

inline double &resizeZeroVec(double &x, int i)
{
    if ( i != 1 )
    {
        NiceThrow("Attempt to resize double as vector");
    }

    return x = 0.0;
}

inline gentype &resizeZeroVec(gentype &x, int i)
{
    x.force_vector().resize(i);
    x.dir_vector().zero();

    return x;
}

inline double &getMatElm(double &x, int i, int j)
{
    if ( ( i != 0 ) || ( j != 0 ) )
    {
        NiceThrow("Attempt to dereference double as matrix");
    }

    return x;
}

inline gentype &getMatElm(gentype &x, int i, int j)
{
    return x("&",i,j);
}

inline double &getVecElm(double &x, int i)
{
    if ( i != 0 )
    {
        NiceThrow("Attempt to dereference double as vector");
    }

    return x;
}

inline gentype &getVecElm(gentype &x, int i)
{
    return x("&",i);
}



template <class T> 
void MercerKernel::yyycdKK2( T &xygrad, T &xnormgrad, int &minmaxind, const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, const vecInfo &xainfo, const vecInfo &xbinfo, const T &bias, const gentype **pxyprod, int ia, int ib, int xdim, int xconsist, int assumreal, int mlid, const double *xy00, const double *xy10, const double *xy11, int deepDeriv, int iaset, int ibset) const
{
#ifndef NDEBUG
    int xafarfarpresent = xa.isf2offindpresent() ? 1 : 0;
    int xbfarfarpresent = xb.isf2offindpresent() ? 1 : 0;

    int xaind6present = xa.isf4indpresent(6) && !(xa.f4(6).isValNull());
    int xbind6present = xb.isf4indpresent(6) && !(xb.f4(6).isValNull());

    int xagradOrder = xaind6present ? ( (int) xa.f4(6) ) : ( xafarfarpresent ? 1 : 0 );
    int xbgradOrder = xbind6present ? ( (int) xb.f4(6) ) : ( xbfarfarpresent ? 1 : 0 );

    NiceAssert( !xagradOrder );
    NiceAssert( !xbgradOrder );
#endif

    xdKK2(xygrad,xnormgrad,minmaxind,xa,xb,xainfo,xbinfo,bias,pxyprod,ia,ib,xdim,xconsist,assumreal,mlid,xy00,xy10,xy11,deepDeriv,iaset,ibset);
}

template <class T> 
void MercerKernel::yyycd2KK2(T &xygrad, T &xnormgrad, T &xyxygrad, T &xyxnormgrad, T &xyynormgrad, T &xnormxnormgrad, T &xnormynormgrad, T &ynormynormgrad, int &minmaxind, const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, const vecInfo &xainfo, const vecInfo &xbinfo, const T &bias, const gentype **pxyprod, int ia, int ib, int xdim, int xconsist, int assumreal, int mlid, const double *xy00, const double *xy10, const double *xy11, int deepDeriv, int iaset, int ibset) const
{
#ifndef NDEBUG
    int xafarfarpresent = xa.isf2offindpresent() ? 1 : 0;
    int xbfarfarpresent = xb.isf2offindpresent() ? 1 : 0;

    int xaind6present = xa.isf4indpresent(6) && !(xa.f4(6).isValNull());
    int xbind6present = xb.isf4indpresent(6) && !(xb.f4(6).isValNull());

    int xagradOrder = xaind6present ? ( (int) xa.f4(6) ) : ( xafarfarpresent ? 1 : 0 );
    int xbgradOrder = xbind6present ? ( (int) xb.f4(6) ) : ( xbfarfarpresent ? 1 : 0 );

    NiceAssert( !xagradOrder );
    NiceAssert( !xbgradOrder );
#endif

    xd2KK2(xygrad,xnormgrad,xyxygrad,xyxnormgrad,xyynormgrad,xnormxnormgrad,xnormynormgrad,ynormynormgrad,minmaxind,xa,xb,xainfo,xbinfo,bias,pxyprod,ia,ib,xdim,xconsist,assumreal,mlid,xy00,xy10,xy11,deepDeriv,iaset,ibset);
}

template <class T> 
void MercerKernel::yyycdnKK2del(Vector<T> &sc, Vector<Vector<int> > &n, int &minmaxind, const Vector<int> &q, const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, const vecInfo &xainfo, const vecInfo &xbinfo, const T &bias, const gentype **pxyprod, int ia, int ib, int xdim, int xconsist, int assumreal, int mlid, const double *xy00, const double *xy10, const double *xy11, int deepDeriv, int iaset, int ibset) const
{
#ifndef NDEBUG
    int xafarfarpresent = xa.isf2offindpresent() ? 1 : 0;
    int xbfarfarpresent = xb.isf2offindpresent() ? 1 : 0;

    int xaind6present = xa.isf4indpresent(6) && !(xa.f4(6).isValNull());
    int xbind6present = xb.isf4indpresent(6) && !(xb.f4(6).isValNull());

    int xagradOrder = xaind6present ? ( (int) xa.f4(6) ) : ( xafarfarpresent ? 1 : 0 );
    int xbgradOrder = xbind6present ? ( (int) xb.f4(6) ) : ( xbfarfarpresent ? 1 : 0 );

    NiceAssert( !xagradOrder );
    NiceAssert( !xbgradOrder );
#endif

    xdnKK2del(sc,n,minmaxind,q,xa,xb,xainfo,xbinfo,bias,pxyprod,ia,ib,xdim,xconsist,assumreal,mlid,xy00,xy10,xy11,deepDeriv,iaset,ibset);
}





template <class T>
void MercerKernel::qqqdK2delx(T &xscaleres, T &yscaleres,  int &minmaxind,
                          const SparseVector<gentype> &x, const SparseVector<gentype> &y, 
                          const vecInfo &xinfo, const vecInfo &yinfo, 
                          const T &bias, 
                          const gentype **pxyprod,
                          int i, int j, 
                          int xdim, int xconsist, int mlid, 
                          const double *xy00, const double *xy10, const double *xy11, int iaset, int ibset, int assumreal) const
{
    T xygrad;
    T xnormgrad;

    xdKK2(xygrad,xnormgrad,minmaxind,x,y,xinfo,yinfo,bias,pxyprod,i,j,xdim,xconsist,assumreal,mlid,xy00,xy10,xy11,1,iaset,ibset);

    xscaleres  = xnormgrad;
    xscaleres *= 2.0;
    yscaleres  = xygrad;
}

template <class T>
void MercerKernel::qqqdnK2del(Vector<T> &sc, Vector<Vector<int> > &n, int &minmaxind,
                          const Vector<int> &q,
                          const SparseVector<gentype> &x, const SparseVector<gentype> &y,
                          const vecInfo &xinfo, const vecInfo &yinfo,
                          const T &bias,
                          const gentype **pxyprod,
                          int i, int j,
                          int xdim, int xconsist, int mlid,
                          const double *xy00, const double *xy10, const double *xy11, int deepDerive, int iaset, int ibset, int assumreal) const
{
    int z = 0;

    if ( q.size() == 0 )
    {
        // "no gradient" case

        minmaxind = -1;

        sc.resize(1);
        n.resize(1);

        n("&",z).resize(z);

        yyyKK2(sc("&",z),x,y,xinfo,yinfo,0,0,0,0,x.nupsize(),y.nupsize(),x,y,bias,pxyprod,i,j,xdim,xconsist,0,mlid,xy00,xy10,xy11,iaset,ibset,assumreal,0,0,0);
    }

    else if ( q.size() == 1 )
    {
        if ( q(z) == 0 )
        {
            // d/dx case - result is sc(0).x + sc(1).y

            sc.resize(2);
            n.resize(2);

            n("&",z).resize(1);
            n("&",1).resize(1);

            n("&",z)("&",z) = z;
            n("&",1)("&",z) = 1;

            qqqdK2delx(sc("&",z),sc("&",1),minmaxind,x,y,xinfo,yinfo,bias,pxyprod,i,j,xdim,xconsist,mlid,xy00,xy10,xy11,iaset,ibset,assumreal);
        }

        else
        {
            // d/dy case - result is sc(0).x + sc(1).y
            // We assume symmetry to evaluate this

            sc.resize(2);
            n.resize(2);

            n("&",z).resize(1);
            n("&",1).resize(1);

            n("&",z)("&",z) = z;
            n("&",1)("&",z) = 1;

            qqqdK2delx(sc("&",1),sc("&",z),minmaxind,y,x,yinfo,xinfo,bias,nullptr,j,i,xdim,xconsist,mlid,nullptr,nullptr,nullptr,iaset,ibset,assumreal);
        }
    }

    else if ( q.size() == 2 )
    {
        if ( ( q(z) == 0 ) && ( q(1) == 0 ) )
        {
            // d^2/dx^2 case - result is sc(0).x.x' + sc(1).y.y' + sc(2).x.y' + sc(3).y.x' + sc(4).I

            sc.resize(5);
            n.resize(5);

            n("&",z).resize(2);
            n("&",1).resize(2);
            n("&",2).resize(2);
            n("&",3).resize(2);
            n("&",4).resize(2);

            n("&",z)("&",z) = z;  n("&",z)("&",1) = z;
            n("&",1)("&",z) = 1;  n("&",1)("&",1) = 1;
            n("&",2)("&",z) = z;  n("&",2)("&",1) = 1;
            n("&",3)("&",z) = 1;  n("&",3)("&",1) = z;
            n("&",4)("&",z) = -1; n("&",4)("&",1) = -1;

            qqqd2K2delxdelx(sc("&",z),sc("&",1),sc("&",2),sc("&",3),sc("&",4),minmaxind,x,y,xinfo,yinfo,bias,pxyprod,i,j,xdim,xconsist,mlid,xy00,xy10,xy11,deepDerive,iaset,ibset,assumreal);
        }

        else if ( ( q(z) == 0 ) && ( q(1) == 1 ) )
        {
            // d/dx d/dy case - result is sc(0).x.x' + sc(1).y.y' + sc(2).x.y' + sc(3).y.x' + sc(4).I

            sc.resize(5);
            n.resize(5);

            n("&",z).resize(2);
            n("&",1).resize(2);
            n("&",2).resize(2);
            n("&",3).resize(2);
            n("&",4).resize(2);

            n("&",z)("&",z) = z;  n("&",z)("&",1) = z;
            n("&",1)("&",z) = 1;  n("&",1)("&",1) = 1;
            n("&",2)("&",z) = z;  n("&",2)("&",1) = 1;
            n("&",3)("&",z) = 1;  n("&",3)("&",1) = z;
            n("&",4)("&",z) = -1; n("&",4)("&",1) = -1;

            qqqd2K2delxdely(sc("&",z),sc("&",1),sc("&",2),sc("&",3),sc("&",4),minmaxind,x,y,xinfo,yinfo,bias,pxyprod,i,j,xdim,xconsist,mlid,xy00,xy10,xy11,deepDerive,iaset,ibset,assumreal);
        }

        else if ( ( q(z) == 1 ) && ( q(1) == 0 ) )
        {
            // d/dy d/dx case - result is sc(0).x.x' + sc(1).y.y' + sc(2).x.y' + sc(3).y.x' + sc(4).I
            // We assume symmetry to evaluate this

            sc.resize(5);
            n.resize(5);

            n("&",z).resize(2);
            n("&",1).resize(2);
            n("&",2).resize(2);
            n("&",3).resize(2);
            n("&",4).resize(2);

            n("&",z)("&",z) = z;  n("&",z)("&",1) = z;
            n("&",1)("&",z) = 1;  n("&",1)("&",1) = 1;
            n("&",2)("&",z) = z;  n("&",2)("&",1) = 1;
            n("&",3)("&",z) = 1;  n("&",3)("&",1) = z;
            n("&",4)("&",z) = -1; n("&",4)("&",1) = -1;

            qqqd2K2delxdely(sc("&",1),sc("&",z),sc("&",3),sc("&",2),sc("&",4),minmaxind,y,x,yinfo,xinfo,bias,nullptr,j,i,xdim,xconsist,mlid,nullptr,nullptr,nullptr,deepDerive,iaset,ibset,assumreal);
        }

        else
        {
            // d/dy d/dy case - result is sc(0).x.x' + sc(1).y.y' + sc(2).x.y' + sc(3).y.x' + sc(4).I
            // We assume symmetry to evaluate this

            sc.resize(5);
            n.resize(5);

            n("&",z).resize(2);
            n("&",1).resize(2);
            n("&",2).resize(2);
            n("&",3).resize(2);
            n("&",4).resize(2);

            n("&",z)("&",z) = z;  n("&",z)("&",1) = z;
            n("&",1)("&",z) = 1;  n("&",1)("&",1) = 1;
            n("&",2)("&",z) = z;  n("&",2)("&",1) = 1;
            n("&",3)("&",z) = 1;  n("&",3)("&",1) = z;
            n("&",4)("&",z) = -1; n("&",4)("&",1) = -1;

            qqqd2K2delxdelx(sc("&",1),sc("&",z),sc("&",3),sc("&",2),sc("&",4),minmaxind,y,x,yinfo,xinfo,bias,nullptr,j,i,xdim,xconsist,mlid,nullptr,nullptr,nullptr,deepDerive,iaset,ibset,assumreal);
        }
    }

    else
    {
        xdnKK2del(sc,n,minmaxind,q,x,y,xinfo,yinfo,bias,pxyprod,i,j,xdim,xconsist,assumreal,mlid,xy00,xy10,xy11,deepDerive,iaset,ibset);
    }
}

template <class T>
void MercerKernel::qqqd2K2delxdelx(T &xxscaleres, T &yyscaleres, T &xyscaleres, T &yxscaleres, T &constres, int &minmaxind, 
                 const SparseVector<gentype> &x, const SparseVector<gentype> &y, 
                 const vecInfo &xinfo, const vecInfo &yinfo, 
                 const T &bias, 
                 const gentype **pxyprod, 
                 int i, int j, 
                 int xdim, int xconsist, int mlid, 
                 const double *xy00, const double *xy10, const double *xy11, int deepDeriv, int iaset, int ibset, int assumreal) const
{
    // Assume any kernel can be written as:
    //
    // K(x,y) = K(a,z,b)
    //
    // where a = ||x||^2
    //       b = ||y||^2
    //       z = x'y
    //
    // dK/dx_j = dK/da da/dx_j + dK/dz dz/dx_j
    //         = dK/da 2x_j + dK/dz y_j
    //
    // d2K/dx_idx_j = d2K/dada da/dx_i 2x_j + d2K/dzda dz/dx_i 2x_j + dK/da 2 delta_{ij} + d2K/dadz da/dx_i y_j + d2K/dzdz dz/dx_i y_j
    //              = d2K/dada 2x_i 2x_j + d2K/dzda y_i 2x_j + dK/da 2 delta_{ij} + d2K/dadz 2x_i y_j + d2K/dzdz y_i y_j
    //
    // d2K/dxdx = 4 d2K/dada x.x' + 2 d2K/dzda y.x' + 2 d2K/dadz x.y' + d2K/dzdz y.y' + 2 dK/da I

    T xygrad;
    T xnormgrad;
    T xyxygrad;
    T xyxnormgrad;
    T xyynormgrad;
    T xnormxnormgrad;
    T xnormynormgrad;
    T ynormynormgrad;

    xd2KK2(xygrad,xnormgrad,xyxygrad,xyxnormgrad,xyynormgrad,xnormxnormgrad,xnormynormgrad,ynormynormgrad,minmaxind,x,y,xinfo,yinfo,bias,pxyprod,i,j,xdim,xconsist,assumreal,mlid,xy00,xy10,xy11,deepDeriv,iaset,ibset);

    xxscaleres = 4.0*xnormxnormgrad;
    xyscaleres = 2.0*xyxnormgrad;
    yxscaleres = xyscaleres;
    yyscaleres = xyxygrad;
    constres   = 2.0*xnormgrad;
}

template <class T>
void MercerKernel::qqqd2K2delxdely(T &xxscaleres, T &yyscaleres, T &xyscaleres, T &yxscaleres, T &constres, int &minmaxind, 
                 const SparseVector<gentype> &x, const SparseVector<gentype> &y, 
                 const vecInfo &xinfo, const vecInfo &yinfo, 
                 const T &bias, 
                 const gentype **pxyprod, 
                 int i, int j, 
                 int xdim, int xconsist, int mlid, 
                 const double *xy00, const double *xy10, const double *xy11, int deepDeriv, int iaset, int ibset, int assumreal) const
{
    // Assume any kernel can be written as:
    //
    // K(x,y) = K(a,z,b)
    //
    // where a = ||x||^2
    //       b = ||y||^2
    //       z = x'y
    //
    // dK/dx_j = dK/da da/dx_j + dK/dz dz/dx_j
    //         = dK/da 2x_j + dK/dz y_j
    //
    // d2K/dy_idx_j = d2K/dzda dz/dy_i 2x_j + d2K/dbda db/dy_i 2x_j + d2K/dzdz dz/dy_i y_j + d2K/dbdz db/dy_i y_j + dK/dz delta_{ij}
    //              = d2K/dzda x_i     2x_j + d2K/dbda 2y_i    2x_j + d2K/dzdz x_i     y_j + d2K/dbdz 2y_i    y_j + dK/dz delta_{ij}
    //              = 2 d2K/dzda x_i x_j + 4 d2K/dbda y_i x_j + d2K/dzdz x_i y_j + 2 d2K/dbdz y_i y_j + dK/dz delta_{ij}
    //
    // d2K/dx_idy_j = 2 d2K/dzda x_i x_j + 4 d2K/dbda x_i y_j + d2K/dzdz y_i x_j + 2 d2K/dbdz y_i y_j + dK/dz delta_{ij}
    //
    // d2K/dxdy = 2 d2K/dzda x.x' + 4 d2K/dbda x.y' + d2K/dzdz y.x' + 2 d2K/dbdz y.y' + dK/dz I

    T xygrad;
    T xnormgrad;
    T xyxygrad;
    T xyxnormgrad;
    T xyynormgrad;
    T xnormxnormgrad;
    T xnormynormgrad;
    T ynormynormgrad;

    xd2KK2(xygrad,xnormgrad,xyxygrad,xyxnormgrad,xyynormgrad,xnormxnormgrad,xnormynormgrad,ynormynormgrad,minmaxind,x,y,xinfo,yinfo,bias,pxyprod,i,j,xdim,xconsist,assumreal,mlid,xy00,xy10,xy11,deepDeriv,iaset,ibset);

    xxscaleres = 2.0*xyxnormgrad;
    xyscaleres = 4.0*xnormynormgrad;
    yxscaleres = xyxygrad;
    yyscaleres = 2.0*xyynormgrad;
    constres   = xygrad;
}







template <class T>
T &MercerKernel::yyycK0(T &res,
                    const T &bias,
                    const gentype **pxyprod,
                    int xdim, int xconsist, int xresmode, int mlid, int assumreal, int justcalcip) const
{
    return yyyKK0(res,bias,pxyprod,xdim,xconsist,xresmode,mlid,assumreal,justcalcip);
}

template <class T>
T &MercerKernel::yyycK1(T &res,
                    const SparseVector<gentype> &xa,
                    const vecInfo &xainfo,
                    int xagradOrder,
                    int xagradup,
                    int iaupm,
                    const SparseVector<gentype> &xaff,
                    const T &bias,
                    const gentype **pxyprod,
                    int ia,
                    int xdim, int xconsist, int resmode, int mlid,
                    const double *xy00, int iaset, int assumreal, int justcalcip) const
{
    return yyyKK1(res,xa,xainfo,xagradOrder,xagradup,iaupm,xaff,bias,pxyprod,ia,xdim,xconsist,resmode,mlid,xy00,iaset,assumreal,justcalcip);
}

template <class T>
T &MercerKernel::yyycK2(T &res,
                    const SparseVector<gentype> &xa, const SparseVector<gentype> &xb,
                    const vecInfo &xainfo, const vecInfo &xbinfo,
                    int xagradOrder, int xbgradOrder,
                    int xagradup, int xbgradup,
                    int iaupm, int ibupm,
                    const SparseVector<gentype> &xaff, const SparseVector<gentype> &xbff,
                    const T &bias,
                    const gentype **pxyprod,
                    int ia, int ib,
                    int xdim, int xconsist, int resmode, int mlid,
                    const double *xy00, const double *xy10, const double *xy11, int iaset, int ibset, int assumreal, int justcalcip,
                    int adensetype, int bdensetype) const
{
    return yyyKK2(res,xa,xb,xainfo,xbinfo,xagradOrder,xbgradOrder,xagradup,xbgradup,iaupm,ibupm,xaff,xbff,bias,pxyprod,ia,ib,xdim,xconsist,resmode,mlid,xy00,xy10,xy11,iaset,ibset,assumreal,justcalcip,adensetype,bdensetype);
}

template <class T>
T &MercerKernel::yyycK2x2(T &res,
                          const SparseVector<gentype> &x, const SparseVector<gentype> &xa, const SparseVector<gentype> &xb,
                          const vecInfo &xinfo, const vecInfo &xainfo, const vecInfo &xbinfo,
                          int xgradOrder, int xagradOrder, int xbgradOrder,
                          int xgradup, int xagradup, int xbgradup,
                          int iupm, int iaupm, int ibupm,
                          const SparseVector<gentype> &xff, const SparseVector<gentype> &xaff, const SparseVector<gentype> &xbff,
                          const T &bias,
                          int i, int ia, int ib,
                          int xdim, int xconsist, int resmode, int mlid,
                          const double *xy00, const double *xy10, const double *xy11, const double *xy20, const double *xy21, const double *xy22,
                          int iset, int iaset, int ibset,
                          int assumreal, int justcalcip,
                          int densetype, int adensetype, int bdensetype) const
{
//errstream() << "phantomxyzabcabc yyyck2x2\n";
    return yyyKK2x2(res,x,xa,xb,xinfo,xainfo,xbinfo,xgradOrder,xagradOrder,xbgradOrder,xgradup,xagradup,xbgradup,iupm,iaupm,ibupm,xff,xaff,xbff,bias,i,ia,ib,xdim,xconsist,resmode,mlid,xy00,xy10,xy11,xy20,xy21,xy22,iset,iaset,ibset,assumreal,justcalcip,densetype,adensetype,bdensetype);
}

template <class T>
T &MercerKernel::yyycK3(T &res,
                    const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, const SparseVector<gentype> &xc,
                    const vecInfo &xainfo, const vecInfo &xbinfo, const vecInfo &xcinfo,
                    int xagradOrder, int xbgradOrder, int xcgradOrder,
                    int xagradup, int xbgradup, int xcgradup,
                    int iaupm, int ibupm, int icupm,
                    const SparseVector<gentype> &xaff, const SparseVector<gentype> &xbff, const SparseVector<gentype> &xcff,
                    const T &bias,
                    const gentype **pxyprod,
                    int ia, int ib, int ic,
                    int xdim, int xconsist, int xresmode, int mlid,
                    const double *xy00, const double *xy10, const double *xy11, const double *xy20, const double *xy21, const double *xy22, int iaset, int ibset, int icset, int assumreal, int justcalcip) const
{
    return yyyKK3(res,xa,xb,xc,xainfo,xbinfo,xcinfo,xagradOrder,xbgradOrder,xcgradOrder,xagradup,xbgradup,xcgradup,iaupm,ibupm,icupm,xaff,xbff,xcff,bias,pxyprod,ia,ib,ic,xdim,xconsist,xresmode,mlid,xy00,xy10,xy11,xy20,xy21,xy22,iaset,ibset,icset,assumreal,justcalcip);
}

template <class T>
T &MercerKernel::yyycK4(T &res,
                    const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, const SparseVector<gentype> &xc, const SparseVector<gentype> &xd,
                    const vecInfo &xainfo, const vecInfo &xbinfo, const vecInfo &xcinfo, const vecInfo &xdinfo,
                    int xagradOrder, int xbgradOrder, int xcgradOrder, int xdgradOrder,
                    int xagradup, int xbgradup, int xcgradup, int xdgradup,
                    int iaupm, int ibupm, int icupm, int idupm,
                    const SparseVector<gentype> &xaff, const SparseVector<gentype> &xbff, const SparseVector<gentype> &xcff, const SparseVector<gentype> &xdff,
                    const T &bias,
                    const gentype **pxyprod,
                    int ia, int ib, int ic, int id,
                    int xdim, int xconsist, int xresmode, int mlid,
                    const double *xy00, const double *xy10, const double *xy11, const double *xy20, const double *xy21, const double *xy22, const double *xy30, const double *xy31, const double *xy32, const double *xy33, int iaset, int ibset, int icset, int idset, int assumreal, int justcalcip) const
{
    return yyyKK4(res,xa,xb,xc,xd,xainfo,xbinfo,xcinfo,xdinfo,xagradOrder,xbgradOrder,xcgradOrder,xdgradOrder,xagradup,xbgradup,xcgradup,xdgradup,iaupm,ibupm,icupm,idupm,xaff,xbff,xcff,xdff,bias,pxyprod,ia,ib,ic,id,xdim,xconsist,xresmode,mlid,xy00,xy10,xy11,xy20,xy21,xy22,xy30,xy31,xy32,xy33,iaset,ibset,icset,idset,assumreal,justcalcip);
}

template <class T>
T &MercerKernel::yyycKm(int m, T &res,
                    Vector<const SparseVector<gentype> *> &x,
                    Vector<const vecInfo *> &xinfo,
                    Vector<int> &xgradOrder,
                    Vector<int> &xgradup,
                    Vector<int> &xupm,
                    Vector<const SparseVector<gentype> *> &xff,
                    const T &bias,
                    Vector<int> &i,
                    const gentype **pxyprod, int xdim, int xconsist, int resmode, int mlid,
                    const Matrix<double> *xy, const Vector<int> *iiset, int assumreal, int justcalcip) const
{
    return yyyKKm(m,res,x,xinfo,xgradOrder,xgradup,xupm,xff,bias,i,pxyprod,xdim,xconsist,resmode,mlid,xy,iiset,assumreal,justcalcip);
}

template <class T>
int MercerKernel::yyycphim(int m, Vector<T> &res,
                           const SparseVector<gentype> &xa,
                           const vecInfo &xainfo,
                           int ia,
                           int xagradOrder,
                           int iaupm,
                           int xagradup,
                           const SparseVector<gentype> &xaff,
                           int allowfinite, int xdim, int xconsist, int assumreal, int iaset) const
{
    (void) xaff;

    return yyyPphim(m,res,xa,xainfo,ia,allowfinite,xdim,xconsist,assumreal,iaset,xagradOrder,xagradup,iaupm);
}













// Pre-process [ xa ~ xb ~ ... ] forms

inline int UPNTVI(int i, int off);
inline int UPNTVI(int i, int off)
{
//    static size_t ind = 0;
//
//    return -(((ind++)%81)+10);
    return -((10*off)+i);
}



template <class T>
T &MercerKernel::yyyKK0(T &res,
                    const T &bias,
                    const gentype **pxyprod,
                    int xdim, int xconsist, int xresmode, int mlid, int assumreal, int justcalcip) const
{
    return xKKK0(res,bias,pxyprod,xdim,xconsist,assumreal,xresmode,mlid,justcalcip);
}

template <class T>
T &MercerKernel::yyyKK1(T &res,
                    const SparseVector<gentype> &xa,
                    const vecInfo &xainfo,
                    int xagradOrder,
                    int xagradup,
                    int aupm,
                    const SparseVector<gentype> &xaff,
                    const T &bias,
                    const gentype **pxyprod,
                    int ia,
                    int xdim, int xconsist, int resmode, int mlid,
                    const double *xy, int iaset, int assumreal, int justcalcip) const
{
//    return xKKK1(res,xa,xainfo,bias,pxyprod,i,xdim,xconsist,resmode,assumreal,mlid,xy,justcalcip,iset);

        NiceAssert( !isSymmSet() );

        if ( aupm == 1 )
        {
            int rxagradOrder = ( 0 == xagradup ) ? xagradOrder : 0;

            xKKK1(res,xa.n(),xainfo,rxagradOrder,xaff,bias,pxyprod,ia,xdim,xconsist,assumreal,resmode,mlid,xy,justcalcip,iaset);
        }

        else if ( aupm == 2 )
        {
            const SparseVector<gentype> &rxa = xa.nup(0);
            const SparseVector<gentype> &rxb = xa.nup(1);

            const vecInfo &rxainfo = xainfo(-1,0);
            const vecInfo &rxbinfo = xainfo(-1,1);

            int ixa = ia;
            int ixb = UPNTVI(ia,1);

            int ixaset = iaset;
            int ixbset = iaset;

            int rxagradOrder = ( 0 == xagradup ) ? xagradOrder : 0;
            int rxbgradOrder = ( 1 == xagradup ) ? xagradOrder : 0;

            const SparseVector<gentype> &rxaff = xaff.nup(0);
            const SparseVector<gentype> &rxbff = xaff.nup( ( xaff.nupsize() <= 1 ) ? (xaff.nupsize()-1) : 1 );

            xKKK2(res,rxa,rxb,rxainfo,rxbinfo,rxagradOrder,rxbgradOrder,rxaff,rxbff,bias,nullptr,ixa,ixb,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,justcalcip,ixaset,ixbset,0,0);
        }

        else if ( aupm == 3 )
        {
            const SparseVector<gentype> &rxa = xa.nup(0);
            const SparseVector<gentype> &rxb = xa.nup(1);
            const SparseVector<gentype> &rxc = xa.nup(2);

            const vecInfo &rxainfo = xainfo(-1,0);
            const vecInfo &rxbinfo = xainfo(-1,1);
            const vecInfo &rxcinfo = xainfo(-1,2);

            int ixa = ia;
            int ixb = UPNTVI(ia,1);
            int ixc = UPNTVI(ia,2);

            int ixaset = iaset;
            int ixbset = iaset;
            int ixcset = iaset;

            int rxagradOrder = ( 0 == xagradup ) ? xagradOrder : 0;
            int rxbgradOrder = ( 1 == xagradup ) ? xagradOrder : 0;
            int rxcgradOrder = ( 2 == xagradup ) ? xagradOrder : 0;

            const SparseVector<gentype> &rxaff = xaff.nup(0);
            const SparseVector<gentype> &rxbff = xaff.nup( ( xaff.nupsize() <= 1 ) ? (xaff.nupsize()-1) : 1 );
            const SparseVector<gentype> &rxcff = xaff.nup( ( xaff.nupsize() <= 2 ) ? (xaff.nupsize()-1) : 2 );

            xKKK3(res,rxa,rxb,rxc,rxainfo,rxbinfo,rxcinfo,rxagradOrder,rxbgradOrder,rxcgradOrder,rxaff,rxbff,rxcff,bias,nullptr,ixa,ixb,ixc,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,justcalcip,ixaset,ixbset,ixcset);
        }

        else if ( aupm == 4 )
        {
            const SparseVector<gentype> &rxa = xa.nup(0);
            const SparseVector<gentype> &rxb = xa.nup(1);
            const SparseVector<gentype> &rxc = xa.nup(2);
            const SparseVector<gentype> &rxd = xa.nup(3);

            const vecInfo &rxainfo = xainfo(-1,0);
            const vecInfo &rxbinfo = xainfo(-1,1);
            const vecInfo &rxcinfo = xainfo(-1,2);
            const vecInfo &rxdinfo = xainfo(-1,3);

            int ixa = ia;
            int ixb = UPNTVI(ia,1);
            int ixc = UPNTVI(ia,2);
            int ixd = UPNTVI(ia,3);

            int ixaset = iaset;
            int ixbset = iaset;
            int ixcset = iaset;
            int ixdset = iaset;

            int rxagradOrder = ( 0 == xagradup ) ? xagradOrder : 0;
            int rxbgradOrder = ( 1 == xagradup ) ? xagradOrder : 0;
            int rxcgradOrder = ( 2 == xagradup ) ? xagradOrder : 0;
            int rxdgradOrder = ( 3 == xagradup ) ? xagradOrder : 0;

            const SparseVector<gentype> &rxaff = xaff.nup(0);
            const SparseVector<gentype> &rxbff = xaff.nup( ( xaff.nupsize() <= 1 ) ? (xaff.nupsize()-1) : 1 );
            const SparseVector<gentype> &rxcff = xaff.nup( ( xaff.nupsize() <= 2 ) ? (xaff.nupsize()-1) : 2 );
            const SparseVector<gentype> &rxdff = xaff.nup( ( xaff.nupsize() <= 3 ) ? (xaff.nupsize()-1) : 3 );

            xKKK4(res,rxa,rxb,rxc,rxd,rxainfo,rxbinfo,rxcinfo,rxdinfo,rxagradOrder,rxbgradOrder,rxcgradOrder,rxdgradOrder,rxaff,rxbff,rxcff,rxdff,bias,nullptr,ixa,ixb,ixc,ixd,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,justcalcip,ixaset,ixbset,ixcset,ixdset);
        }

        else
        {
            int ii;

            Vector<int> iv(aupm);
            Vector<const SparseVector<gentype> *> xv(aupm);
            Vector<const vecInfo *> xvinfo(aupm);
            Vector<int> ivset(aupm);
            Vector<int> rvgradOrder(aupm);
            Vector<const SparseVector<gentype> *> xvff(aupm);

            if ( aupm )
            {
                for ( ii = 0 ; ii < aupm ; ++ii )
                {
                    iv("&",ii) = ii ? UPNTVI(ia,ii) : ia;
                    xv("&",ii) = &(xa.nup(ii));
                    xvinfo("&",ii) = &(xainfo(-1,ii));
                    ivset("&",ii) = iaset;
                    rvgradOrder("&",ii) = ( ii == xagradup ) ? xagradOrder : 0;
                    xvff("&",ii) = &(xaff.nup( ( xaff.nupsize() <= ii ) ? (xaff.nupsize()-1) : ii ));
                }
            }

            xKKKm(aupm,res,xv,xvinfo,rvgradOrder,xvff,bias,iv,nullptr,xdim,xconsist,assumreal,resmode,mlid,nullptr,justcalcip,&ivset);
        }

    return res;
}

inline double calcKRBFSymmKern(double dvaris, int xdim,
                        double r0, double r1,
                        int adensetype, int bdensetype,
                        int rxagradOrder, int rxbgradOrder,
                        double *xdiff, double *xalb, double *xblb, double *xadir, double *xbdir);

template <class T>
T &MercerKernel::yyyKK2(T &res,
                    const SparseVector<gentype> &xa, const SparseVector<gentype> &xb,
                    const vecInfo &xainfo, const vecInfo &xbinfo,
                    int xagradOrder, int xbgradOrder,
                    int xagradup, int xbgradup,
                    int aupm, int bupm,
                    const SparseVector<gentype> &xaff, const SparseVector<gentype> &xbff,
                    const T &bias,
                    const gentype **pxyprod,
                    int ia, int ib,
                    int xdim, int xconsist, int resmode, int mlid,
                    const double *xy00, const double *xy10, const double *xy11, int iaset, int ibset, int assumreal, int justcalcip,
                    int adensetype,int bdensetype) const
{
//    return xKKK2(res,x,y,xinfo,yinfo,bias,pxyprod,i,j,xdim,xconsist,assumreal,resmode,mlid,xy,0,iset,jset);

//errstream() << "phantomxyzabc 0: xa = " << xa << "\n";
//errstream() << "phantomxyzabc 0: xb = " << xb << "\n";
//errstream() << "phantomxyzabc 0: aupm = " << aupm << "\n";
//errstream() << "phantomxyzabc 0: bupm = " << bupm << "\n";
//errstream() << "phantomxyzabc 0: xagradup = " << xagradup << "\n";
//errstream() << "phantomxyzabc 0: xbgradup = " << xbgradup << "\n";
        if ( ( aupm == 1 ) && ( bupm == 1 ) )
        {
            int rxagradOrder = ( 0 == xagradup ) ? xagradOrder : 0;
            int rxbgradOrder = ( 0 == xbgradup ) ? xbgradOrder : 0;

            if ( isSymmSet() )
            {
                int modxconsist = xconsist || ( ( xa.size() == xa.indsize() ) &&
                                                ( xb.size() == xb.indsize() ) &&
                                                ( xaff.size() == xaff.indsize() ) &&
                                                ( xbff.size() == xbff.indsize() ) &&
                                                ( xa.size() == xb.size() ) );

                if ( modxconsist && assumreal && ( xdim <= 128 ) && unadornedRBFKernel(1) && ( 1 != adensetype ) && ( 1 != bdensetype ) && ( ( rxagradOrder == 0 ) || ( ( rxagradOrder == 1 ) && xaff.size() ) ) && ( ( rxbgradOrder == 0 ) || ( ( rxbgradOrder == 1 ) && xbff.size() ) ) )
                {
                    // K(xa,xb) = K((xa,xa),(xb,xb))

                    int i;

                    double r0 = (double) dRealConstants(0)(1+0);
                    double r1 = (double) dRealConstants(0)(1+1);

                    double dvaris = AltDiffNormConst(xdim,2,r0)*exp(-r1);

                    double xdiff[128];
                    double xalb[128];
                    double xblb[128];
                    double xadir[128];
                    double xbdir[128];

                    for ( i = 0 ; i < xdim ; i++ )
                    {
                        xdiff[i] = (((double) xa.direcref(i))-((double) xb.direcref(i)))/r0;
                    }

                    if ( adensetype )
                    {
                        for ( i = 0 ; i < xdim ; i++ )
                        {
                            xalb[i] = xdenseZeroPoint-(((double) xb.direcref(i))/r0);
                        }
                    }

                    if ( bdensetype )
                    {
                        for ( i = 0 ; i < xdim ; i++ )
                        {
                            xblb[i] = (((double) xa.direcref(i))/r0)-xdenseZeroPoint;
                        }
                    }

                    if ( xagradOrder )
                    {
                        for ( i = 0 ; i < xdim ; i++ )
                        {
                            xadir[i] = ((double) xaff.direcref(i));
                        }
                    }

                    if ( xbgradOrder )
                    {
                        for ( i = 0 ; i < xdim ; i++ )
                        {
                            xbdir[i] = ((double) xbff.direcref(i));
                        }
                    }

                    res = calcKRBFSymmKern(dvaris,xdim,r0,r1,adensetype,bdensetype,rxagradOrder,rxbgradOrder,xdiff,xalb,xblb,xadir,xbdir);
NiceAssert(!testisvnan(res) && !testisinf(res));
                }

                else
                {
                    NiceAssert( !adensetype );
                    NiceAssert( !bdensetype );
                    NiceAssert( !xagradOrder );
                    NiceAssert( !xbgradOrder );

                    xKKK2(res,xa,xb,xainfo,xbinfo,rxagradOrder,rxbgradOrder,xaff,xbff,bias,pxyprod,ia,ib,xdim,xconsist,assumreal,resmode,mlid,xy00,xy10,xy11,justcalcip,iaset,ibset,adensetype,bdensetype);

                    res *= res;
NiceAssert(!testisvnan(res) && !testisinf(res));
                }
            }

            else
            {
                xKKK2(res,xa,xb,xainfo,xbinfo,rxagradOrder,rxbgradOrder,xaff,xbff,bias,pxyprod,ia,ib,xdim,xconsist,assumreal,resmode,mlid,xy00,xy10,xy11,justcalcip,iaset,ibset,adensetype,bdensetype);
NiceAssert(!testisvnan(res) && !testisinf(res));
            }
        }

        else if ( ( aupm == 1 ) && ( bupm == 2 ) )
        {
//NB: order of vectors is very important here (see splits, ns, below)
            const SparseVector<gentype> &rxa = xa.nup(0);
            const SparseVector<gentype> &rxb = xb.nup(0);
            const SparseVector<gentype> &rxc = xb.nup(1);

            const vecInfo &rxainfo = xainfo(-1,0);
            const vecInfo &rxbinfo = xbinfo(-1,0);
            const vecInfo &rxcinfo = xbinfo(-1,1);

            int ixa = ia;
            int ixb = ib;
            int ixc = UPNTVI(ib,1);

            int ixaset = iaset;
            int ixbset = ibset;
            int ixcset = ibset;

            int rxagradOrder = ( 0 == xagradup ) ? xagradOrder : 0;
            int rxbgradOrder = ( 0 == xbgradup ) ? xbgradOrder : 0;
            int rxcgradOrder = ( 1 == xbgradup ) ? xbgradOrder : 0;

            const SparseVector<gentype> &rxaff = xaff.nup(0);
            const SparseVector<gentype> &rxbff = xbff.nup(0);
            const SparseVector<gentype> &rxcff = xbff.nup( ( xbff.nupsize() <= 1 ) ? (xbff.nupsize()-1) : 1 );

            if ( xbff.nupsize() == 2 )
            {
                if ( ( rxbff.size() > 0 ) && ( rxcff.size() == 0 ) )
                {
                    rxcgradOrder = 0;
                }

                else if ( ( rxbff.size() == 0 ) && ( rxcff.size() > 0 ) )
                {
                    rxbgradOrder = 0;
                }
            }

//errstream() << "phantomxyzabc 1: rxa = " << rxa << "\n";
//errstream() << "phantomxyzabc 1: rxb = " << rxb << "\n";
//errstream() << "phantomxyzabc 1: rxc = " << rxc << "\n";

//errstream() << "phantomxyzabc 1: ixa = " << ixa << "\n";
//errstream() << "phantomxyzabc 1: ixb = " << ixb << "\n";
//errstream() << "phantomxyzabc 1: ixc = " << ixc << "\n";

//errstream() << "phantomxyzabc 1: rxagradOrder = " << rxagradOrder << "\n";
//errstream() << "phantomxyzabc 1: rxbgradOrder = " << rxbgradOrder << "\n";
//errstream() << "phantomxyzabc 1: rxcgradOrder = " << rxcgradOrder << "\n";

//errstream() << "phantomxyzabc 1: rxaff = " << rxaff << "\n";
//errstream() << "phantomxyzabc 1: rxbff = " << rxbff << "\n";
//errstream() << "phantomxyzabc 1: rxcff = " << rxcff << "\n";

            if ( isSymmSet() )
            {
                int modxconsist = xconsist || ( ( rxa.size() == rxa.indsize() ) &&
                                                ( rxb.size() == rxb.indsize() ) &&
                                                ( rxc.size() == rxc.indsize() ) &&
                                                ( rxaff.size() == rxaff.indsize() ) &&
                                                ( rxbff.size() == rxbff.indsize() ) &&
                                                ( rxcff.size() == rxcff.indsize() ) &&
                                                ( rxa.size() == rxb.size() ) &&
                                                ( rxa.size() == rxc.size() ) );

                if ( modxconsist && assumreal && ( xdim <= 128 ) && unadornedRBFKernel(1) && ( 1 != adensetype ) && ( 1 != bdensetype ) &&
                     ( ( rxagradOrder == 0 ) || ( ( rxagradOrder == 1 ) && xaff.size() ) ) &&
                     ( ( rxbgradOrder == 0 ) || ( ( rxbgradOrder == 1 ) && xbff.size() ) )    )
                {
                    // K(xa,xb) = K((rxa,rxa),(rxb,rxc))
                    //          = sqrt(K(rxa,rxb)).sqrt(K(rxa,rxb)).sqrt(K(rxa,rxc)).sqrt(K(rxa,rxc))
                    //          = K(rxa,rxb).K(rxa,rxc)

                    int i;

                    double r0 = (double) dRealConstants(0)(1+0);
                    double r1 = (double) dRealConstants(0)(1+1);

                    double dvaris = AltDiffNormConst(xdim,2,r0)*exp(-r1/2);

                    double xdiff[128];
                    double xalb[128];
                    double xblb[128];
                    double xadir[128];
                    double xbdir[128];

                    for ( i = 0 ; i < xdim ; i++ )
                    {
                        xdiff[i] = (((double) rxa.direcref(i))-((((double) rxb.direcref(i))+((double) rxc.direcref(i)))/2))/r0;
                    }

                    if ( adensetype )
                    {
                        for ( i = 0 ; i < xdim ; i++ )
                        {
                            xalb[i] = xdenseZeroPoint-(((((double) rxb.direcref(i))+((double) rxc.direcref(i)))/2)/r0);
                        }
                    }

                    if ( bdensetype )
                    {
                        for ( i = 0 ; i < xdim ; i++ )
                        {
                            xblb[i] = (((double) rxa.direcref(i))/r0)-xdenseZeroPoint;
                        }
                    }

                    if ( xagradOrder ) // intentionally *not* rxagradOrder
                    {
                        for ( i = 0 ; i < xdim ; i++ )
                        {
                            xadir[i] = ((double) rxaff.direcref(i));
                        }
                    }

                    NiceAssert( !xbgradOrder );

//                    if ( xbgradOrder ) // intentionally *not* rxbgradOrder
//                    {
//                        for ( i = 0 ; i < xdim ; i++ )
//                        {
//                            xbdir[i] = rxbgradOrder ? ((double) rxbff.direcref(i)) : ((double) rxcff.direcref(i));
//                        }
//                    }

                    xKKK2(res,rxb,rxc,rxbinfo,rxcinfo,0,0,rxbff,rxcff,bias,nullptr,ixb,ixc,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,justcalcip,ixbset,ixcset,0,0);

                    OP_sqrt(res);

                    res *= calcKRBFSymmKern(dvaris,xdim,r0,r1,adensetype,bdensetype,rxagradOrder,rxbgradOrder,xdiff,xalb,xblb,xadir,xbdir);
NiceAssert(!testisvnan(res) && !testisinf(res));
                }

                else
                {
                    NiceAssert( !adensetype );
                    NiceAssert( !bdensetype );
                    NiceAssert( !xagradOrder );
                    NiceAssert( !xbgradOrder );

                    T tmpresb;

                    xKKK2(res    ,rxa,rxb,rxainfo,rxbinfo,rxagradOrder,rxbgradOrder,rxaff,rxbff,bias,nullptr,ixa,ixb,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,justcalcip,ixaset,ixbset,adensetype,bdensetype);
                    xKKK2(tmpresb,rxa,rxc,rxainfo,rxcinfo,rxagradOrder,rxcgradOrder,rxaff,rxcff,bias,nullptr,ixa,ixc,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,justcalcip,ixaset,ixcset,adensetype,bdensetype);

                    res *= tmpresb;
                }
            }

            else
            {
                NiceAssert( !adensetype );

                xKKK3(res,rxa,rxb,rxc,rxainfo,rxbinfo,rxcinfo,rxagradOrder,rxbgradOrder,rxcgradOrder,rxaff,rxbff,rxcff,bias,nullptr,ixa,ixb,ixc,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,justcalcip,ixaset,ixbset,ixcset);
            }
        }

        else if ( ( aupm == 2 ) && ( bupm == 1 ) )
        {
            const SparseVector<gentype> &rxa = xa.nup(0);
            const SparseVector<gentype> &rxb = xa.nup(1);
            const SparseVector<gentype> &rxc = xb.nup(0);

            const vecInfo &rxainfo = xainfo(-1,0);
            const vecInfo &rxbinfo = xainfo(-1,1);
            const vecInfo &rxcinfo = xbinfo(-1,0);

            int ixa = ia;
            int ixb = UPNTVI(ia,1);
            int ixc = ib;

            int ixaset = iaset;
            int ixbset = iaset;
            int ixcset = ibset;

            int rxagradOrder = ( 0 == xagradup ) ? xagradOrder : 0;
            int rxbgradOrder = ( 1 == xagradup ) ? xagradOrder : 0;
            int rxcgradOrder = ( 0 == xbgradup ) ? xbgradOrder : 0;

            const SparseVector<gentype> &rxaff = xaff.nup(0);
            const SparseVector<gentype> &rxbff = xaff.nup( ( xaff.nupsize() <= 1 ) ? (xaff.nupsize()-1) : 1 );
            const SparseVector<gentype> &rxcff = xbff.nup(0);

            if ( xaff.nupsize() == 2 )
            {
                if ( ( rxaff.size() > 0 ) && ( rxbff.size() == 0 ) )
                {
                    rxbgradOrder = 0;
                }

                else if ( ( rxaff.size() == 0 ) && ( rxbff.size() > 0 ) )
                {
                    rxagradOrder = 0;
                }
            }

            if ( isSymmSet() )
            {
                int modxconsist = xconsist || ( ( rxa.size() == rxa.indsize() ) &&
                                                ( rxb.size() == rxb.indsize() ) &&
                                                ( rxc.size() == rxc.indsize() ) &&
                                                ( rxaff.size() == rxaff.indsize() ) &&
                                                ( rxbff.size() == rxbff.indsize() ) &&
                                                ( rxcff.size() == rxcff.indsize() ) &&
                                                ( rxa.size() == rxb.size() ) &&
                                                ( rxa.size() == rxc.size() ) );

                if ( modxconsist && assumreal && ( xdim <= 128 ) && unadornedRBFKernel(1) && ( 1 != adensetype ) && ( 1 != bdensetype ) &&
                     ( ( rxagradOrder == 0 ) || ( ( rxagradOrder == 1 ) && xaff.size() ) ) &&
                     ( ( rxbgradOrder == 0 ) || ( ( rxbgradOrder == 1 ) && xbff.size() ) )    )
                {
                    // K(xa,xb) = K((rxa,rxb),(rxc,rxc))

                    int i;

                    double r0 = (double) dRealConstants(0)(1+0);
                    double r1 = (double) dRealConstants(0)(1+1);

                    double dvaris = AltDiffNormConst(xdim,2,r0)*exp(-r1/2);

                    double xdiff[128];
                    double xalb[128];
                    double xblb[128];
                    double xadir[128];
                    double xbdir[128];

                    for ( i = 0 ; i < xdim ; i++ )
                    {
                        xdiff[i] = (((((double) rxa.direcref(i))+((double) rxb.direcref(i)))/2)-((double) rxc.direcref(i)))/r0;
                    }

                    if ( adensetype )
                    {
                        for ( i = 0 ; i < xdim ; i++ )
                        {
                            xalb[i] = xdenseZeroPoint-((((double) rxc.direcref(i)))/r0);
                        }
                    }

                    if ( bdensetype )
                    {
                        for ( i = 0 ; i < xdim ; i++ )
                        {
                            xblb[i] = (((((double) rxa.direcref(i))+((double) rxb.direcref(i)))/2)/r0)-xdenseZeroPoint;
                        }
                    }

                    NiceAssert( !xagradOrder );

//                    if ( xagradOrder ) // intentionally *not* rxagradOrder
//                    {
//                        for ( i = 0 ; i < xdim ; i++ )
//                        {
//                            xadir[i] = raxgradOrder ? ((double) rxaff.direcref(i)) : ((double) rxbff.direcref(i));
//                        }
//                    }

                    if ( xbgradOrder ) // intentionally *not* rxbgradOrder
                    {
                        for ( i = 0 ; i < xdim ; i++ )
                        {
                            xbdir[i] = ((double) rxcff.direcref(i));
                        }
                    }

                    xKKK2(res,rxa,rxb,rxainfo,rxbinfo,0,0,rxaff,rxbff,bias,nullptr,ixa,ixb,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,justcalcip,ixaset,ixbset,0,0);

                    OP_sqrt(res);

                    res *= calcKRBFSymmKern(dvaris,xdim,r0,r1,adensetype,bdensetype,rxagradOrder,rxbgradOrder,xdiff,xalb,xblb,xadir,xbdir);
NiceAssert(!testisvnan(res) && !testisinf(res));
                }

                else
                {
                    NiceAssert( !adensetype );
                    NiceAssert( !bdensetype );
                    NiceAssert( !xagradOrder );
                    NiceAssert( !xbgradOrder );

                    T tmpresb;

                    xKKK2(res    ,rxa,rxc,rxainfo,rxcinfo,rxagradOrder,rxcgradOrder,rxaff,rxcff,bias,nullptr,ixa,ixc,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,justcalcip,ixaset,ixcset,adensetype,bdensetype);
                    xKKK2(tmpresb,rxb,rxc,rxbinfo,rxcinfo,rxbgradOrder,rxcgradOrder,rxbff,rxcff,bias,nullptr,ixb,ixc,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,justcalcip,ixbset,ixcset,adensetype,bdensetype);

                    res *= tmpresb;
                }
            }

            else
            {
                NiceAssert( !bdensetype );

                xKKK3(res,rxa,rxb,rxc,rxainfo,rxbinfo,rxcinfo,rxagradOrder,rxbgradOrder,rxcgradOrder,rxaff,rxbff,rxcff,bias,nullptr,ixa,ixb,ixc,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,justcalcip,ixaset,ixbset,ixcset);
            }
        }

        else if ( ( aupm == 2 ) && ( bupm == 2 ) )
        {
            const SparseVector<gentype> &rxa = xa.nup(0);
            const SparseVector<gentype> &rxb = xa.nup(1);
            const SparseVector<gentype> &rxc = xb.nup(0);
            const SparseVector<gentype> &rxd = xb.nup(1);

            const vecInfo &rxainfo = xainfo(-1,0);
            const vecInfo &rxbinfo = xainfo(-1,1);
            const vecInfo &rxcinfo = xbinfo(-1,0);
            const vecInfo &rxdinfo = xbinfo(-1,1);

            int ixa = ia;
            int ixb = UPNTVI(ia,1);
            int ixc = ib;
            int ixd = UPNTVI(ib,1);

            int ixaset = iaset;
            int ixbset = iaset;
            int ixcset = ibset;
            int ixdset = ibset;

            int rxagradOrder = ( 0 == xagradup ) ? xagradOrder : 0;
            int rxbgradOrder = ( 1 == xagradup ) ? xagradOrder : 0;
            int rxcgradOrder = ( 0 == xbgradup ) ? xbgradOrder : 0;
            int rxdgradOrder = ( 1 == xbgradup ) ? xbgradOrder : 0;

            const SparseVector<gentype> &rxaff = xaff.nup(0);
            const SparseVector<gentype> &rxbff = xaff.nup( ( xaff.nupsize() <= 1 ) ? (xaff.nupsize()-1) : 1 );
            const SparseVector<gentype> &rxcff = xbff.nup(0);
            const SparseVector<gentype> &rxdff = xbff.nup( ( xbff.nupsize() <= 1 ) ? (xbff.nupsize()-1) : 1 );

            if ( xaff.nupsize() == 2 )
            {
                if ( ( rxaff.size() > 0 ) && ( rxbff.size() == 0 ) )
                {
                    rxbgradOrder = 0;
                }

                else if ( ( rxaff.size() == 0 ) && ( rxbff.size() > 0 ) )
                {
                    rxagradOrder = 0;
                }
            }

            if ( xbff.nupsize() == 2 )
            {
                if ( ( rxcff.size() > 0 ) && ( rxdff.size() == 0 ) )
                {
                    rxdgradOrder = 0;
                }

                else if ( ( rxcff.size() == 0 ) && ( rxdff.size() > 0 ) )
                {
                    rxcgradOrder = 0;
                }
            }

//errstream() << "phantomxyzabc 1: rxa = " << rxa << "\n";
//errstream() << "phantomxyzabc 1: rxb = " << rxb << "\n";
//errstream() << "phantomxyzabc 1: rxc = " << rxc << "\n";
//errstream() << "phantomxyzabc 1: rxd = " << rxd << "\n";

//errstream() << "phantomxyzabc 1: ixa = " << ixa << "\n";
//errstream() << "phantomxyzabc 1: ixb = " << ixb << "\n";
//errstream() << "phantomxyzabc 1: ixc = " << ixc << "\n";
//errstream() << "phantomxyzabc 1: ixd = " << ixd << "\n";

//errstream() << "phantomxyzabc 1: rxagradOrder = " << rxagradOrder << "\n";
//errstream() << "phantomxyzabc 1: rxbgradOrder = " << rxbgradOrder << "\n";
//errstream() << "phantomxyzabc 1: rxcgradOrder = " << rxcgradOrder << "\n";
//errstream() << "phantomxyzabc 1: rxdgradOrder = " << rxdgradOrder << "\n";

//errstream() << "phantomxyzabc 1: rxaff = " << rxaff << "\n";
//errstream() << "phantomxyzabc 1: rxbff = " << rxbff << "\n";
//errstream() << "phantomxyzabc 1: rxcff = " << rxcff << "\n";
//errstream() << "phantomxyzabc 1: rxdff = " << rxdff << "\n";

            NiceAssert( !adensetype && !bdensetype );

            if ( isSymmSet() )
            {
                int modxconsist = xconsist || ( ( rxa.size() == rxa.indsize() ) &&
                                                ( rxb.size() == rxb.indsize() ) &&
                                                ( rxc.size() == rxc.indsize() ) &&
                                                ( rxd.size() == rxd.indsize() ) &&
                                                ( rxaff.size() == rxaff.indsize() ) &&
                                                ( rxbff.size() == rxbff.indsize() ) &&
                                                ( rxcff.size() == rxcff.indsize() ) &&
                                                ( rxdff.size() == rxdff.indsize() ) &&
                                                ( rxa.size() == rxb.size() ) &&
                                                ( rxa.size() == rxc.size() ) &&
                                                ( rxa.size() == rxd.size() ) );

                if ( modxconsist && assumreal && ( xdim <= 128 ) && unadornedRBFKernel(1) && ( 1 != adensetype ) && ( 1 != bdensetype ) &&
                     ( ( rxagradOrder == 0 ) || ( ( rxagradOrder == 1 ) && xaff.size() ) ) &&
                     ( ( rxbgradOrder == 0 ) || ( ( rxbgradOrder == 1 ) && xbff.size() ) )    )
                {
                    // K(xa,xb) = K((rxa,rxb),(rxc,rxd))

                    int i;

                    double r0 = (double) dRealConstants(0)(1+0);
                    double r1 = (double) dRealConstants(0)(1+1);

                    double dvaris = AltDiffNormConst(xdim,2,r0);

                    double xdiff[128];
                    double xalb[128];
                    double xblb[128];
                    double xadir[128];
                    double xbdir[128];

                    for ( i = 0 ; i < xdim ; i++ )
                    {
                        xdiff[i] = (((((double) rxa.direcref(i))+((double) rxb.direcref(i)))/2)-((((double) rxc.direcref(i))+((double) rxd.direcref(i)))/2))/r0;
                    }

                    if ( adensetype )
                    {
                        for ( i = 0 ; i < xdim ; i++ )
                        {
                            xalb[i] = xdenseZeroPoint-((((((double) rxc.direcref(i))+((double) rxd.direcref(i)))/2))/r0);
                        }
                    }

                    if ( bdensetype )
                    {
                        for ( i = 0 ; i < xdim ; i++ )
                        {
                            xblb[i] = ((((((double) rxa.direcref(i))+((double) rxb.direcref(i)))/2))/r0)-xdenseZeroPoint;
                        }
                    }

                    NiceAssert( !xagradOrder );

//                    if ( xagradOrder ) // intentionally *not* rxagradOrder
//                    {
//                        for ( i = 0 ; i < xdim ; i++ )
//                        {
//                            xadir[i] = raxgradOrder ? ((double) rxaff.direcref(i)) : ((double) rxbff.direcref(i));
//                        }
//                    }

                    NiceAssert( !xbgradOrder );

//                    if ( xbgradOrder ) // intentionally *not* rxbgradOrder
//                    {
//                        for ( i = 0 ; i < xdim ; i++ )
//                        {
//                            xbdir[i] = rxbgradOrder ? ((double) rxcff.direcref(i)) : ((double) rxdff.direcref(i));
//                        }
//                    }

                    T resb;

                    xKKK2(res ,rxa,rxb,rxainfo,rxbinfo,0,0,rxaff,rxbff,bias,nullptr,ixa,ixb,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,justcalcip,ixaset,ixbset,0,0);
                    xKKK2(resb,rxc,rxd,rxcinfo,rxdinfo,0,0,rxcff,rxdff,bias,nullptr,ixc,ixd,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,justcalcip,ixcset,ixdset,0,0);

                    res *= resb;
                    OP_sqrt(res);

                    res *= calcKRBFSymmKern(dvaris,xdim,r0,r1,adensetype,bdensetype,rxagradOrder,rxbgradOrder,xdiff,xalb,xblb,xadir,xbdir);
NiceAssert(!testisvnan(res) && !testisinf(res));
                }

                else
                {
                    NiceAssert( !adensetype );
                    NiceAssert( !bdensetype );
                    NiceAssert( !xagradOrder );
                    NiceAssert( !xbgradOrder );

                    T tmpresb;
                    T tmpresc;
                    T tmpresd;

                    xKKK2(res    ,rxa,rxc,rxainfo,rxcinfo,rxagradOrder,rxcgradOrder,rxaff,rxcff,bias,nullptr,ixa,ixc,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,justcalcip,ixaset,ixcset,adensetype,bdensetype);
                    xKKK2(tmpresb,rxa,rxd,rxainfo,rxdinfo,rxagradOrder,rxdgradOrder,rxaff,rxdff,bias,nullptr,ixa,ixd,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,justcalcip,ixaset,ixdset,adensetype,bdensetype);
                    xKKK2(tmpresc,rxb,rxc,rxbinfo,rxcinfo,rxbgradOrder,rxcgradOrder,rxbff,rxcff,bias,nullptr,ixb,ixc,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,justcalcip,ixbset,ixcset,adensetype,bdensetype);
                    xKKK2(tmpresd,rxb,rxd,rxbinfo,rxdinfo,rxbgradOrder,rxdgradOrder,rxbff,rxdff,bias,nullptr,ixb,ixd,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,justcalcip,ixbset,ixdset,adensetype,bdensetype);

                    res *= tmpresb;
                    res *= tmpresc;
                    res *= tmpresd;

                    OP_sqrt(res);
                }
            }

            else
            {
                xKKK4(res,rxa,rxb,rxc,rxd,rxainfo,rxbinfo,rxcinfo,rxdinfo,rxagradOrder,rxbgradOrder,rxcgradOrder,rxdgradOrder,rxaff,rxbff,rxcff,rxdff,bias,nullptr,ixa,ixb,ixc,ixd,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,justcalcip,ixaset,ixbset,ixcset,ixdset);
            }
        }

        else if ( ( aupm == 1 ) && ( bupm == 3 ) )
        {
            NiceAssert( !isSymmSet() );

            const SparseVector<gentype> &rxa = xa.nup(0);
            const SparseVector<gentype> &rxb = xb.nup(0);
            const SparseVector<gentype> &rxc = xb.nup(1);
            const SparseVector<gentype> &rxd = xb.nup(2);

            const vecInfo &rxainfo = xainfo(-1,0);
            const vecInfo &rxbinfo = xbinfo(-1,0);
            const vecInfo &rxcinfo = xbinfo(-1,1);
            const vecInfo &rxdinfo = xbinfo(-1,2);

            int ixa = ia;
            int ixb = ib;
            int ixc = UPNTVI(ib,1);
            int ixd = UPNTVI(ib,2);

            int ixaset = iaset;
            int ixbset = ibset;
            int ixcset = ibset;
            int ixdset = ibset;

            int rxagradOrder = ( 0 == xagradup ) ? xagradOrder : 0;
            int rxbgradOrder = ( 0 == xbgradup ) ? xbgradOrder : 0;
            int rxcgradOrder = ( 1 == xbgradup ) ? xbgradOrder : 0;
            int rxdgradOrder = ( 2 == xbgradup ) ? xbgradOrder : 0;

            const SparseVector<gentype> &rxaff = xaff.nup(0);
            const SparseVector<gentype> &rxbff = xbff.nup(0);
            const SparseVector<gentype> &rxcff = xbff.nup( ( xbff.nupsize() <= 1 ) ? (xbff.nupsize()-1) : 1 );
            const SparseVector<gentype> &rxdff = xbff.nup( ( xbff.nupsize() <= 2 ) ? (xbff.nupsize()-1) : 2 );

            NiceAssert( !adensetype && !bdensetype );

            {
                xKKK4(res,rxa,rxb,rxc,rxd,rxainfo,rxbinfo,rxcinfo,rxdinfo,rxagradOrder,rxbgradOrder,rxcgradOrder,rxdgradOrder,rxaff,rxbff,rxcff,rxdff,bias,nullptr,ixa,ixb,ixc,ixd,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,justcalcip,ixaset,ixbset,ixcset,ixdset);
            }
        }

        else if ( ( aupm == 3 ) && ( bupm == 1 ) )
        {
            NiceAssert( !isSymmSet() );

            const SparseVector<gentype> &rxa = xa.nup(0);
            const SparseVector<gentype> &rxb = xa.nup(1);
            const SparseVector<gentype> &rxc = xa.nup(2);
            const SparseVector<gentype> &rxd = xb.nup(0);

            const vecInfo &rxainfo = xainfo(-1,0);
            const vecInfo &rxbinfo = xainfo(-1,1);
            const vecInfo &rxcinfo = xainfo(-1,2);
            const vecInfo &rxdinfo = xbinfo(-1,0);

            int ixa = ia;
            int ixb = UPNTVI(ia,1);
            int ixc = UPNTVI(ia,2);
            int ixd = ib;

            int ixaset = iaset;
            int ixbset = iaset;
            int ixcset = iaset;
            int ixdset = ibset;

            int rxagradOrder = ( 0 == xagradup ) ? xagradOrder : 0;
            int rxbgradOrder = ( 1 == xagradup ) ? xagradOrder : 0;
            int rxcgradOrder = ( 2 == xagradup ) ? xagradOrder : 0;
            int rxdgradOrder = ( 0 == xbgradup ) ? xbgradOrder : 0;

            const SparseVector<gentype> &rxaff = xaff.nup(0);
            const SparseVector<gentype> &rxbff = xaff.nup( ( xaff.nupsize() <= 1 ) ? (xaff.nupsize()-1) : 1 );
            const SparseVector<gentype> &rxcff = xaff.nup( ( xaff.nupsize() <= 2 ) ? (xaff.nupsize()-1) : 2 );
            const SparseVector<gentype> &rxdff = xbff.nup(0);

            NiceAssert( !adensetype && !bdensetype );

            {
                xKKK4(res,rxa,rxb,rxc,rxd,rxainfo,rxbinfo,rxcinfo,rxdinfo,rxagradOrder,rxbgradOrder,rxcgradOrder,rxdgradOrder,rxaff,rxbff,rxcff,rxdff,bias,nullptr,ixa,ixb,ixc,ixd,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,justcalcip,ixaset,ixbset,ixcset,ixdset);
            }
        }

        else
        {
            NiceAssert( !isSymmSet() );

            int ii;

            Vector<int> iv(aupm+bupm);
            Vector<const SparseVector<gentype> *> xv(aupm+bupm);
            Vector<const vecInfo *> xvinfo(aupm+bupm);
            Vector<int> ivset(aupm+bupm);
            Vector<int> rvgradOrder(aupm+bupm);
            Vector<const SparseVector<gentype> *> xvff(aupm+bupm);

            if ( aupm )
            {
                for ( ii = 0 ; ii < aupm ; ++ii )
                {
                    iv("&",ii) = ii ? UPNTVI(ia,ii) : ia;
                    xv("&",ii) = &(xa.nup(ii));
                    xvinfo("&",ii) = &(xainfo(-1,ii));
                    ivset("&",ii) = iaset;
                    rvgradOrder("&",ii) = ( ii == xagradup ) ? xagradOrder : 0;
                    xvff("&",ii) = &(xaff.nup( ( xaff.nupsize() <= ii ) ? (xaff.nupsize()-1) : ii ));
                }
            }

            if ( bupm )
            {
                for ( ii = 0 ; ii < bupm ; ++ii )
                {
                    iv("&",ii+aupm) = ii ? UPNTVI(ib,ii) : ib;
                    xv("&",ii+aupm) = &(xb.nup(ii));
                    xvinfo("&",ii+aupm) = &(xbinfo(-1,ii));
                    ivset("&",ii+aupm) = ibset;
                    rvgradOrder("&",ii+aupm) = ( ii == xbgradup ) ? xbgradOrder : 0;
                    xvff("&",ii+aupm) = &(xbff.nup( ( xbff.nupsize() <= ii ) ? (xbff.nupsize()-1) : ii ));
                }
            }

            NiceAssert( !adensetype && !bdensetype );

            {
                xKKKm(aupm+bupm,res,xv,xvinfo,rvgradOrder,xvff,bias,iv,nullptr,xdim,xconsist,assumreal,resmode,mlid,nullptr,justcalcip,&ivset);
            }
        }


    return res;
}



inline double calcKRBFSymmKern(double dvaris, int xdim,
                        double r0, double,
                        int adensetype, int bdensetype,
                        int rxagradOrder, int rxbgradOrder,
                        double *xdiff, double *xalb, double *xblb, double *xadir, double *xbdir)
{
                    int i,j,k;

                    double dres = dvaris;

                    if ( !adensetype && !bdensetype && !rxagradOrder && !rxbgradOrder )
                    {
                        for ( i = 0 ; i < xdim ; ++i )
                        {
                            dres *= exp(-xdiff[i]*xdiff[i]);
NiceAssert(!testisvnan(dres) && !testisinf(dres));
                        }
NiceAssert(!testisvnan(dres) && !testisinf(dres));
                    }

                    else if ( !adensetype && !bdensetype && rxagradOrder && !rxbgradOrder )
                    {
                        double scalefactor = 0.0;

                        for ( i = 0 ; i < xdim ; ++i )
                        {
                            dres *= exp(-xdiff[i]*xdiff[i]);
                            scalefactor += (xdiff[i]*xadir[i]);
NiceAssert(!testisvnan(dres) && !testisinf(dres));
NiceAssert(!testisvnan(scalefactor) && !testisinf(scalefactor));
                        }

                        dres *= -2*scalefactor/r0;
NiceAssert(!testisvnan(dres) && !testisinf(dres));
                    }

                    else if ( !adensetype && !bdensetype && !rxagradOrder && rxbgradOrder )
                    {
                        double scalefactor = 0.0;

                        for ( i = 0 ; i < xdim ; ++i )
                        {
                            dres *= exp(-xdiff[i]*xdiff[i]);
                            scalefactor += (xdiff[i]*xbdir[i]);
NiceAssert(!testisvnan(dres) && !testisinf(dres));
NiceAssert(!testisvnan(scalefactor) && !testisinf(scalefactor));
                        }

                        dres *= 2*scalefactor/r0;
NiceAssert(!testisvnan(dres) && !testisinf(dres));
                    }

                    else if ( !adensetype && !bdensetype && rxagradOrder && rxbgradOrder )
                    {
                        double scalefactor = 0.0;

                        for ( i = 0 ; i < xdim ; i++ )
                        {
                            dres *= exp(-xdiff[i]*xdiff[i]);
                            scalefactor += (0.5-((xdiff[i]*xdiff[i])*(xadir[i]*xbdir[i])));
NiceAssert(!testisvnan(dres) && !testisinf(dres));
NiceAssert(!testisvnan(scalefactor) && !testisinf(scalefactor));

                            for ( j = 0 ; j < xdim ; j++ )
                            {
                                if ( j != i )
                                {
                                    scalefactor -= ((xdiff[i]*xdiff[j])*(xadir[i]*xbdir[j]));
NiceAssert(!testisvnan(dres) && !testisinf(dres));
NiceAssert(!testisvnan(scalefactor) && !testisinf(scalefactor));
                                }
                            }
                        }

                        dres *= 4*scalefactor/(r0*r0);
NiceAssert(!testisvnan(dres) && !testisinf(dres));
                    }

// =================

                    else if ( adensetype && !bdensetype && !rxagradOrder && !rxbgradOrder )
                    {
                        for ( i = 0 ; i < xdim ; ++i )
                        {
                            dres *= (NUMBASE_SQRTPI/2)*r0*(erf(xdiff[i])-erf(xalb[i]));
NiceAssert(!testisvnan(dres) && !testisinf(dres));
                        }
NiceAssert(!testisvnan(dres) && !testisinf(dres));
                    }

                    else if ( adensetype && !bdensetype && rxagradOrder && !rxbgradOrder )
                    {
                        double deval[128];
                        double scalefactor = 0.0;
                        double tmpres = 0;

                        for ( i = 0 ; i < xdim ; ++i )
                        {
                            deval[i] = (NUMBASE_SQRTPI/2)*r0*(erf(xdiff[i])-erf(xalb[i]));
                        }

                        for ( i = 0 ; i < xdim ; ++i )
                        {
                            scalefactor = exp(-xdiff[i]*xdiff[i])*xadir[i];

                            for ( j = 0 ; j < xdim ; j++ )
                            {
                                if ( j != i )
                                {
                                    scalefactor *= deval[j];
                                }
                            }

                            tmpres += scalefactor;

NiceAssert(!testisvnan(dres) && !testisinf(dres));
NiceAssert(!testisvnan(scalefactor) && !testisinf(scalefactor));
                        }

                        dres *= tmpres;
NiceAssert(!testisvnan(dres) && !testisinf(dres));
                    }

                    else if ( adensetype && !bdensetype && !rxagradOrder && rxbgradOrder )
                    {
                        double deval[128];
                        double scalefactor = 0.0;
                        double tmpres = 0;

                        for ( i = 0 ; i < xdim ; ++i )
                        {
                            deval[i] = (NUMBASE_SQRTPI/2)*r0*(erf(xdiff[i])-erf(xalb[i]));
                        }

                        for ( i = 0 ; i < xdim ; ++i )
                        {
                            scalefactor = (exp(-xalb[i]*xalb[i])-exp(-xdiff[i]*xdiff[i]))*xbdir[i];

                            for ( j = 0 ; j < xdim ; j++ )
                            {
                                if ( j != i )
                                {
                                    scalefactor *= deval[j];
                                }
                            }

                            tmpres += scalefactor;

NiceAssert(!testisvnan(dres) && !testisinf(dres));
NiceAssert(!testisvnan(scalefactor) && !testisinf(scalefactor));
                        }

                        dres *= tmpres;
NiceAssert(!testisvnan(dres) && !testisinf(dres));
                    }

                    else if ( adensetype && !bdensetype && rxagradOrder && rxbgradOrder )
                    {
                        double partfactora[128];
                        double partfactorb[128];
                        double deval[128];

                        for ( i = 0 ; i < xdim ; ++i )
                        {
                            deval[i] = (NUMBASE_SQRTPI/2)*r0*(erf(xdiff[i])-erf(xalb[i]));

                            partfactora[i] = (exp(-xalb[i]*xalb[i])-exp(-xdiff[i]*xdiff[i]));
                            partfactorb[i] = exp(-xdiff[i]*xdiff[i]);
NiceAssert(!testisvnan(dres) && !testisinf(dres));
                        }

                        double scalefactor = 0.0;
                        double tmpres = 0;

                        for ( i = 0 ; i < xdim ; i++ )
                        {
                            scalefactor = 2*xdiff[i]*partfactorb[i]*xadir[i]*xbdir[i]/r0;

                            for ( j = 0 ; j < xdim ; j++ )
                            {
                                if ( j != i )
                                {
                                    scalefactor *= deval[j];
                                }
                            }

                            tmpres += scalefactor;
NiceAssert(!testisvnan(dres) && !testisinf(dres));
NiceAssert(!testisvnan(scalefactor) && !testisinf(scalefactor));
                        }

                        for ( i = 0 ; i < xdim ; i++ )
                        {
                            for ( j = 0 ; j < xdim ; j++ )
                            {
                                if ( j != i )
                                {
                                    scalefactor = partfactora[i]*partfactorb[j]*xadir[i]*xbdir[j];

                                    for ( k = 0 ; k < xdim ; k++ )
                                    {
                                        if ( ( k != i ) && ( k != j ) )
                                        {
                                            scalefactor *= deval[k];
                                        }
                                    }

                                    tmpres += scalefactor;
NiceAssert(!testisvnan(scalefactor) && !testisinf(scalefactor));
                                }
                            }
                        }

                        dres *= tmpres;
NiceAssert(!testisvnan(dres) && !testisinf(dres));
                    }

// =================

                    else if ( !adensetype && bdensetype && !rxagradOrder && !rxbgradOrder )
                    {
                        for ( i = 0 ; i < xdim ; ++i )
                        {
                            dres *= (NUMBASE_SQRTPI/2)*r0*(erf(xblb[i])-erf(xdiff[i]));
NiceAssert(!testisvnan(dres) && !testisinf(dres));
                        }
                    }

                    else if ( !adensetype && bdensetype && rxagradOrder && !rxbgradOrder )
                    {
                        double deval[128];
                        double scalefactor = 0.0;
                        double tmpres = 0;

                        for ( i = 0 ; i < xdim ; ++i )
                        {
                            deval[i] = (NUMBASE_SQRTPI/2)*r0*(erf(xblb[i])-erf(xdiff[i]));
                        }

                        for ( i = 0 ; i < xdim ; ++i )
                        {
                            scalefactor = (exp(-xblb[i]*xblb[i])-exp(-xdiff[i]*xdiff[i]))*xadir[i];

                            for ( j = 0 ; j < xdim ; j++ )
                            {
                                if ( j != i )
                                {
                                    scalefactor *= deval[j];
                                }
                            }

                            tmpres += scalefactor;

NiceAssert(!testisvnan(dres) && !testisinf(dres));
NiceAssert(!testisvnan(scalefactor) && !testisinf(scalefactor));
                        }

                        dres *= tmpres;
NiceAssert(!testisvnan(dres) && !testisinf(dres));
                    }

                    else if ( !adensetype && bdensetype && !rxagradOrder && rxbgradOrder )
                    {
                        double deval[128];
                        double scalefactor = 0.0;
                        double tmpres = 0;

                        for ( i = 0 ; i < xdim ; ++i )
                        {
                            deval[i] = (NUMBASE_SQRTPI/2)*r0*(erf(xblb[i])-erf(xdiff[i]));
                        }

                        for ( i = 0 ; i < xdim ; ++i )
                        {
                            scalefactor = exp(-xdiff[i]*xdiff[i])*xbdir[i];

                            for ( j = 0 ; j < xdim ; j++ )
                            {
                                if ( j != i )
                                {
                                    scalefactor *= deval[j];
                                }
                            }

                            tmpres += scalefactor;
NiceAssert(!testisvnan(dres) && !testisinf(dres));
NiceAssert(!testisvnan(scalefactor) && !testisinf(scalefactor));
                        }

                        dres *= tmpres;
NiceAssert(!testisvnan(dres) && !testisinf(dres));
                    }

                    else if ( !adensetype && bdensetype && rxagradOrder && rxbgradOrder )
                    {
                        double partfactora[128];
                        double partfactorb[128];
                        double deval[128];

                        for ( i = 0 ; i < xdim ; ++i )
                        {
                            deval[i] = (NUMBASE_SQRTPI/2)*r0*(erf(xblb[i])-erf(xdiff[i]));

                            partfactora[i] = (exp(-xblb[i]*xblb[i])-exp(-xdiff[i]*xdiff[i]));
                            partfactorb[i] = exp(-xdiff[i]*xdiff[i]);
NiceAssert(!testisvnan(dres) && !testisinf(dres));
                        }

                        double scalefactor = 0.0;
                        double tmpres = 0;

                        for ( i = 0 ; i < xdim ; i++ )
                        {
                            scalefactor = -2*xdiff[i]*partfactorb[i]*xadir[i]*xbdir[i]/r0;

                            for ( j = 0 ; j < xdim ; j++ )
                            {
                                if ( j != i )
                                {
                                    scalefactor *= deval[j];
                                }
                            }

                            tmpres += scalefactor;
NiceAssert(!testisvnan(scalefactor) && !testisinf(scalefactor));
                        }

                        for ( i = 0 ; i < xdim ; i++ )
                        {
                            for ( j = 0 ; j < xdim ; j++ )
                            {
                                if ( j != i )
                                {
                                    scalefactor = partfactora[i]*partfactorb[j]*xadir[i]*xbdir[j];

                                    for ( k = 0 ; k < xdim ; k++ )
                                    {
                                        if ( ( k != i ) && ( k != j ) )
                                        {
                                            scalefactor *= deval[k];
                                        }
                                    }

                                    tmpres += scalefactor;
NiceAssert(!testisvnan(scalefactor) && !testisinf(scalefactor));
                                }
                            }
                        }

                        dres *= tmpres;
NiceAssert(!testisvnan(scalefactor) && !testisinf(scalefactor));
NiceAssert(!testisvnan(dres) && !testisinf(dres));
                    }

// =================

                    else if ( adensetype && bdensetype && !rxagradOrder && !rxbgradOrder )
                    {
                        for ( i = 0 ; i < xdim ; ++i )
                        {
                            dres *= (NUMBASE_SQRTPI/2)*r0*r0*((xblb[i]*erf(xblb[i]))+(xalb[i]*erf(xalb[i]))-(xdiff[i]*erf(xdiff[i]))+((exp(-xalb[i]*xalb[i])+exp(-xblb[i]*xblb[i])-exp(-xdiff[i]*xdiff[i])-1)/NUMBASE_SQRTPI));
NiceAssert(!testisvnan(dres) && !testisinf(dres));
                        }
                    }

                    else if ( adensetype && bdensetype && rxagradOrder && !rxbgradOrder )
                    {
                        double deval[128];
                        double scalefactor = 0.0;
                        double tmpres = 0;

                        for ( i = 0 ; i < xdim ; ++i )
                        {
                            deval[i] = (NUMBASE_SQRTPI/2)*r0*r0*((xblb[i]*erf(xblb[i]))+(xalb[i]*erf(xalb[i]))-(xdiff[i]*erf(xdiff[i]))+((exp(-xalb[i]*xalb[i])+exp(-xblb[i]*xblb[i])-exp(-xdiff[i]*xdiff[i])-1)/NUMBASE_SQRTPI));
                        }

                        for ( i = 0 ; i < xdim ; i++ )
                        {
                            scalefactor = (NUMBASE_SQRTPI/2)*r0*(erf(xblb[i])-erf(xdiff[i]));

                            for ( j = 0 ; j < xdim ; j++ )
                            {
                                if ( j != i )
                                {
                                    scalefactor *= deval[j];
                                }
                            }

                            tmpres += scalefactor;
NiceAssert(!testisvnan(scalefactor) && !testisinf(scalefactor));
NiceAssert(!testisvnan(dres) && !testisinf(dres));
                        }

                        dres *= tmpres;
NiceAssert(!testisvnan(scalefactor) && !testisinf(scalefactor));
NiceAssert(!testisvnan(dres) && !testisinf(dres));
                    }

                    else if ( adensetype && bdensetype && !rxagradOrder && rxbgradOrder )
                    {
                        double deval[128];
                        double scalefactor = 0.0;
                        double tmpres = 0;

                        for ( i = 0 ; i < xdim ; ++i )
                        {
                            deval[i] = (NUMBASE_SQRTPI/2)*r0*r0*((xblb[i]*erf(xblb[i]))+(xalb[i]*erf(xalb[i]))-(xdiff[i]*erf(xdiff[i]))+((exp(-xalb[i]*xalb[i])+exp(-xblb[i]*xblb[i])-exp(-xdiff[i]*xdiff[i])-1)/NUMBASE_SQRTPI));
                        }

                        for ( i = 0 ; i < xdim ; ++i )
                        {
                            scalefactor = (NUMBASE_SQRTPI/2)*r0*(erf(xdiff[i])-erf(xalb[i]));

                            for ( j = 0 ; j < xdim ; j++ )
                            {
                                if ( j != i )
                                {
                                    scalefactor *= deval[j];
                                }
                            }

                            tmpres += scalefactor;
NiceAssert(!testisvnan(scalefactor) && !testisinf(scalefactor));
NiceAssert(!testisvnan(dres) && !testisinf(dres));
                        }

                        dres *= tmpres;
NiceAssert(!testisvnan(scalefactor) && !testisinf(scalefactor));
NiceAssert(!testisvnan(dres) && !testisinf(dres));
                    }

                    else if ( adensetype && bdensetype && rxagradOrder && rxbgradOrder )
                    {
                        double partfactora[128];
                        double partfactorb[128];
                        double deval[128];

                        for ( i = 0 ; i < xdim ; ++i )
                        {
                            deval[i] = (NUMBASE_SQRTPI/2)*r0*r0*((xblb[i]*erf(xblb[i]))+(xalb[i]*erf(xalb[i]))-(xdiff[i]*erf(xdiff[i]))+((exp(-xalb[i]*xalb[i])+exp(-xblb[i]*xblb[i])-exp(-xdiff[i]*xdiff[i])-1)/NUMBASE_SQRTPI));
                            dres *= deval[i];
NiceAssert(!testisvnan(dres) && !testisinf(dres));

                            partfactora[i] = ((NUMBASE_SQRTPI/2)*r0*(erf(xblb[i])-erf(xdiff[i])));
                            partfactorb[i] = ((NUMBASE_SQRTPI/2)*r0*(erf(xdiff[i])-erf(xalb[i])));
                        }

                        double scalefactor = 0.0;
                        double tmpres = 0;

                        for ( i = 0 ; i < xdim ; i++ )
                        {
                            scalefactor = exp(-xdiff[i]*xdiff[i])*xadir[i]*xbdir[i];

                            for ( j = 0 ; j < xdim ; j++ )
                            {
                                if ( j != i )
                                {
                                    scalefactor *= deval[j];
                                }
                            }

                            tmpres += scalefactor;
NiceAssert(!testisvnan(scalefactor) && !testisinf(scalefactor));
NiceAssert(!testisvnan(dres) && !testisinf(dres));
                        }

                        for ( i = 0 ; i < xdim ; i++ )
                        {
                            for ( j = 0 ; j < xdim ; j++ )
                            {
                                if ( j != i )
                                {
                                    scalefactor = partfactora[i]*partfactorb[j]*xadir[i]*xbdir[j];

                                    for ( k = 0 ; k < xdim ; k++ )
                                    {
                                        if ( ( k != i ) && ( k != j ) )
                                        {
                                            scalefactor *= deval[k];
                                        }
                                    }

                                    tmpres += tmpres;
NiceAssert(!testisvnan(scalefactor) && !testisinf(scalefactor));
NiceAssert(!testisvnan(dres) && !testisinf(dres));
                                }
                            }
                        }

                        dres *= tmpres;
NiceAssert(!testisvnan(scalefactor) && !testisinf(scalefactor));
NiceAssert(!testisvnan(dres) && !testisinf(dres));
                    }

                    return dres;
}





template <class T>
T &MercerKernel::yyyKK2x2(T &res,
                          const SparseVector<gentype> &x, const SparseVector<gentype> &xa, const SparseVector<gentype> &xb,
                          const vecInfo &xinfo, const vecInfo &xainfo, const vecInfo &xbinfo,
                          int xgradOrder, int xagradOrder, int xbgradOrder,
                          int xgradup, int xagradup, int xbgradup,
                          int iupm, int iaupm, int ibupm,
                          const SparseVector<gentype> &xff, const SparseVector<gentype> &xaff, const SparseVector<gentype> &xbff,
                          const T &bias,
                          int i, int ia, int ib,
                          int xdim, int xconsist, int resmode, int mlid,
                          const double *xy00, const double *xy10, const double *xy11, const double *xy20, const double *xy21, const double *xy22,
                          int iset, int iaset, int ibset,
                          int assumreal, int justcalcip,
                          int densetype, int adensetype, int bdensetype) const
{
    (void) xy21;

    NiceAssert( !isSymmSet() );
    NiceAssert( densetype >= 0 );
    NiceAssert( adensetype >= 0 );
    NiceAssert( bdensetype >= 0 );

//errstream() << "phantomxyzabcabc " << densetype << ", " << adensetype << ", " << bdensetype << ", " << iupm << ", " << iaupm << ", " << ibupm << "\n";
    if ( !densetype )
    {
        T resa;
        T resb;

        yyyKK2(resa,x,xa,xinfo,xainfo,xgradOrder,xagradOrder,xgradup,xagradup,iupm,iaupm,xff,xaff,bias,nullptr,i,ia,xdim,xconsist,resmode,mlid,xy00,xy10,xy11,iset,iaset,assumreal,justcalcip,densetype,adensetype);
        yyyKK2(resb,x,xb,xinfo,xbinfo,xgradOrder,xbgradOrder,xgradup,xbgradup,iupm,ibupm,xff,xbff,bias,nullptr,i,ib,xdim,xconsist,resmode,mlid,xy00,xy20,xy22,iset,ibset,assumreal,justcalcip,densetype,bdensetype);

        res = resa*resb;
//errstream() << "phantomxyzabcabc " << res << " = " << resa << " * " << resb << "\n";
    }

    else if ( ( densetype == 2 ) && !adensetype && !bdensetype && !resmode && !justcalcip && ( iupm == 1 ) && ( iaupm == 1 ) && ( ibupm == 1 ) )
    {
//errstream() << "phantomxyzabcabc " << densetype << ", " << adensetype << ", " << bdensetype << "\n";
        if ( unadornedRBFKernel() && !xgradOrder && !xagradOrder && !xbgradOrder )
        {
            const SparseVector<gentype> &xA = x;
            SparseVector<gentype> xB(xa); xB += xb; xB /= 2.0_gent;
            SparseVector<gentype> xD(xa); xD -= xb; xD /= 2.0_gent;

            double xaxbdiff = 0.0;

            innerProductDiverted(xaxbdiff,xD,xD,xconsist,assumreal);

            retVector<gentype> tmpva;
            const Vector<gentype> &r = dRealConstants(0)(1,1,dRealConstants(0).size()-1,tmpva);

            double r0 = (double) r(0);
            double r1 = (double) r(1);

            // For speed we skip the call stack and go straight to the kernel

            double dres = AltDiffNormConst(xdim,2,r(0))*exp(-(xaxbdiff/(r0*r0))-(2*r1));

            for ( int ii = 0 ; ii < xdim ; ++ii )
            {
                dres *= (1+erf((((double) xA(ii))-((double) xB(ii)))/r0))*NUMBASE_SQRTPI*r0/2;
            }

            res = dres;
        }

        if ( ( size() == 1 ) && ( cType() == 3 ) && xgradOrder && !xagradOrder && !xbgradOrder )
        {
            int j;

            Vector<double> vecres(xdim);

            const SparseVector<gentype> &xA = x;
            SparseVector<gentype> xB(xa); xB += xb; xB /= 2.0_gent;
            SparseVector<gentype> xD(xa); xD -= xb; xD /= 2.0_gent;

            double xaxbdiff = 0.0;

            innerProductDiverted(xaxbdiff,xD,xD,xconsist,assumreal);

            retVector<gentype> tmpva;
            const Vector<gentype> &r = dRealConstants(0)(1,1,dRealConstants(0).size()-1,tmpva);

            double r0 = (double) r(0);
            double r1 = (double) r(1);

            double ddddres = AltDiffNormConst(xdim,2,r(0))*exp(-(xaxbdiff/(r0*r0))-(2*r1));

            double xres = 0.0;

            for ( j = 0 ; j < xdim ; j++ )
            {
                // For speed we skip the call stack and go straight to the kernel

                double dres = ddddres;

                for ( int ii = 0 ; ii < xdim ; ++ii )
                {
                    if ( j != ii )
                    {
                        dres *= (1+erf((((double) xA(ii))-((double) xB(ii)))/r0))*NUMBASE_SQRTPI*r0/2;
                    }

                    else
                    {
                        dres *= exp(-((((double) xA(ii))-((double) xB(ii)))/r0)*((((double) xA(ii))-((double) xB(ii)))/r0));
                    }
                }

                xres += (dres*((double) xff(j))); // we just assume a directed derivative here!
            }

            res = xres;
//errstream() << "phantomxyzabcabc K(" << xA << "," << xB << ") = " << res << "\n";
        }

        else
        {
            NiceThrow("Kernel product dense not supported for this kernel.");
        }
    }

    else
    {
        NiceThrow("Kernel product dense not supported for this kernel b.");
    }

    return res;
}

template <class T>
T &MercerKernel::yyyKK3(T &res,
                    const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, const SparseVector<gentype> &xc,
                    const vecInfo &xainfo, const vecInfo &xbinfo, const vecInfo &xcinfo,
                    int xagradOrder, int xbgradOrder, int xcgradOrder,
                    int xagradup, int xbgradup, int xcgradup,
                    int aupm, int bupm, int cupm,
                    const SparseVector<gentype> &xaff, const SparseVector<gentype> &xbff, const SparseVector<gentype> &xcff,
                    const T &bias,
                    const gentype **pxyprod,
                    int ia, int ib, int ic,
                    int xdim, int xconsist, int xresmode, int mlid,
                    const double *xy00, const double *xy10, const double *xy11, const double *xy20, const double *xy21, const double *xy22, int iaset, int ibset, int icset, int assumreal, int justcalcip) const
{
//    return xKKK3(res,xa,xb,xc,xainfo,xbinfo,xcinfo,bias,pxyprod,ia,ib,ic,xdim,xconsist,assumreal,xresmode,mlid,xy,0,iaset,ibset,icset);

        NiceAssert( !isSymmSet() );

        if ( ( aupm == 1 ) && ( bupm == 1 ) && ( cupm == 1 ) )
        {
            int rxagradOrder = ( 0 == xagradup ) ? xagradOrder : 0;
            int rxbgradOrder = ( 0 == xbgradup ) ? xbgradOrder : 0;
            int rxcgradOrder = ( 0 == xcgradup ) ? xcgradOrder : 0;

            xKKK3(res,xa,xb,xc,xainfo,xbinfo,xcinfo,rxagradOrder,rxbgradOrder,rxcgradOrder,xaff,xbff,xcff,bias,pxyprod,ia,ib,ic,xdim,xconsist,assumreal,xresmode,mlid,xy00,xy10,xy11,xy20,xy21,xy22,justcalcip,iaset,ibset,icset);
        }

        else if ( ( aupm == 1 ) && ( bupm == 1 ) && ( cupm == 2 ) )
        {
            const SparseVector<gentype> &rxa = xa.nup(0);
            const SparseVector<gentype> &rxb = xb.nup(0);
            const SparseVector<gentype> &rxc = xc.nup(0);
            const SparseVector<gentype> &rxd = xc.nup(1);

            const vecInfo &rxainfo = xainfo(-1,0);
            const vecInfo &rxbinfo = xbinfo(-1,0);
            const vecInfo &rxcinfo = xcinfo(-1,0);
            const vecInfo &rxdinfo = xcinfo(-1,1);

            int ixa = ia;
            int ixb = ib;
            int ixc = ic;
            int ixd = UPNTVI(ic,1);

            int ixaset = iaset;
            int ixbset = ibset;
            int ixcset = icset;
            int ixdset = icset;

            int rxagradOrder = ( 0 == xagradup ) ? xagradOrder : 0;
            int rxbgradOrder = ( 0 == xbgradup ) ? xbgradOrder : 0;
            int rxcgradOrder = ( 0 == xcgradup ) ? xcgradOrder : 0;
            int rxdgradOrder = ( 1 == xcgradup ) ? xcgradOrder : 0;

            const SparseVector<gentype> &rxaff = xaff.nup(0);
            const SparseVector<gentype> &rxbff = xbff.nup(0);
            const SparseVector<gentype> &rxcff = xcff.nup(0);
            const SparseVector<gentype> &rxdff = xcff.nup( ( xcff.nupsize() <= 1 ) ? (xcff.nupsize()-1) : 1 );

            {
                xKKK4(res,rxa,rxb,rxc,rxd,rxainfo,rxbinfo,rxcinfo,rxdinfo,rxagradOrder,rxbgradOrder,rxcgradOrder,rxdgradOrder,rxaff,rxbff,rxcff,rxdff,bias,nullptr,ixa,ixb,ixc,ixd,xdim,xconsist,assumreal,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,justcalcip,ixaset,ixbset,ixcset,ixdset);
            }
        }

        else if ( ( aupm == 1 ) && ( bupm == 2 ) && ( cupm == 1 ) )
        {
            const SparseVector<gentype> &rxa = xa.nup(0);
            const SparseVector<gentype> &rxb = xb.nup(0);
            const SparseVector<gentype> &rxc = xb.nup(1);
            const SparseVector<gentype> &rxd = xc.nup(0);

            const vecInfo &rxainfo = xainfo(-1,0);
            const vecInfo &rxbinfo = xbinfo(-1,0);
            const vecInfo &rxcinfo = xbinfo(-1,1);
            const vecInfo &rxdinfo = xcinfo(-1,0);

            int ixa = ia;
            int ixb = ib;
            int ixc = UPNTVI(ib,1);
            int ixd = ic;

            int ixaset = iaset;
            int ixbset = ibset;
            int ixcset = ibset;
            int ixdset = icset;

            int rxagradOrder = ( 0 == xagradup ) ? xagradOrder : 0;
            int rxbgradOrder = ( 0 == xbgradup ) ? xbgradOrder : 0;
            int rxcgradOrder = ( 1 == xbgradup ) ? xbgradOrder : 0;
            int rxdgradOrder = ( 0 == xcgradup ) ? xcgradOrder : 0;

            const SparseVector<gentype> &rxaff = xaff.nup(0);
            const SparseVector<gentype> &rxbff = xbff.nup(0);
            const SparseVector<gentype> &rxcff = xbff.nup( ( xbff.nupsize() <= 1 ) ? (xbff.nupsize()-1) : 1 );
            const SparseVector<gentype> &rxdff = xcff.nup(0);

            {
                xKKK4(res,rxa,rxb,rxc,rxd,rxainfo,rxbinfo,rxcinfo,rxdinfo,rxagradOrder,rxbgradOrder,rxcgradOrder,rxdgradOrder,rxaff,rxbff,rxcff,rxdff,bias,nullptr,ixa,ixb,ixc,ixd,xdim,xconsist,assumreal,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,justcalcip,ixaset,ixbset,ixcset,ixdset);
            }
        }

        else if ( ( aupm == 2 ) && ( bupm == 1 ) && ( cupm == 1 ) )
        {
            const SparseVector<gentype> &rxa = xa.nup(0);
            const SparseVector<gentype> &rxb = xa.nup(1);
            const SparseVector<gentype> &rxc = xb.nup(0);
            const SparseVector<gentype> &rxd = xc.nup(0);

            const vecInfo &rxainfo = xainfo(-1,0);
            const vecInfo &rxbinfo = xainfo(-1,1);
            const vecInfo &rxcinfo = xbinfo(-1,0);
            const vecInfo &rxdinfo = xcinfo(-1,0);

            int ixa = ia;
            int ixb = UPNTVI(ia,1);
            int ixc = ib;
            int ixd = ic;

            int ixaset = iaset;
            int ixbset = iaset;
            int ixcset = ibset;
            int ixdset = icset;

            int rxagradOrder = ( 0 == xagradup ) ? xagradOrder : 0;
            int rxbgradOrder = ( 1 == xagradup ) ? xagradOrder : 0;
            int rxcgradOrder = ( 0 == xbgradup ) ? xbgradOrder : 0;
            int rxdgradOrder = ( 0 == xcgradup ) ? xcgradOrder : 0;

            const SparseVector<gentype> &rxaff = xaff.nup(0);
            const SparseVector<gentype> &rxbff = xaff.nup( ( xaff.nupsize() <= 1 ) ? (xaff.nupsize()-1) : 1 );
            const SparseVector<gentype> &rxcff = xbff.nup(0);
            const SparseVector<gentype> &rxdff = xcff.nup(0);

            {
                xKKK4(res,rxa,rxb,rxc,rxd,rxainfo,rxbinfo,rxcinfo,rxdinfo,rxagradOrder,rxbgradOrder,rxcgradOrder,rxdgradOrder,rxaff,rxbff,rxcff,rxdff,bias,nullptr,ixa,ixb,ixc,ixd,xdim,xconsist,assumreal,xresmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,justcalcip,ixaset,ixbset,ixcset,ixdset);
            }
        }

        else
        {
            int ii;

            Vector<int> iv(aupm+bupm+cupm);
            Vector<const SparseVector<gentype> *> xv(aupm+bupm+cupm);
            Vector<const vecInfo *> xvinfo(aupm+bupm+cupm);
            Vector<int> ivset(aupm+bupm+cupm);
            Vector<int> rvgradOrder(aupm+bupm+cupm);
            Vector<const SparseVector<gentype> *> xvff(aupm+bupm+cupm);

            if ( aupm )
            {
                for ( ii = 0 ; ii < aupm ; ++ii )
                {
                    iv("&",ii) = ii ? UPNTVI(ia,ii) : ia;
                    xv("&",ii) = &(xa.nup(ii));
                    xvinfo("&",ii) = &(xainfo(-1,ii));
                    ivset("&",ii) = iaset;
                    rvgradOrder("&",ii) = ( ii == xagradup ) ? xagradOrder : 0;
                    xvff("&",ii) = &(xaff.nup( ( xaff.nupsize() <= ii ) ? (xaff.nupsize()-1) : ii ));
                }
            }

            if ( bupm )
            {
                for ( ii = 0 ; ii < bupm ; ++ii )
                {
                    iv("&",ii+aupm) = ii ? UPNTVI(ib,ii) : ib;
                    xv("&",ii+aupm) = &(xb.nup(ii));
                    xvinfo("&",ii+aupm) = &(xbinfo(-1,ii));
                    ivset("&",ii+aupm) = ibset;
                    rvgradOrder("&",ii+aupm) = ( ii == xbgradup ) ? xbgradOrder : 0;
                    xvff("&",ii+aupm) = &(xbff.nup( ( xbff.nupsize() <= ii ) ? (xbff.nupsize()-1) : ii ));
                }
            }

            if ( cupm )
            {
                for ( ii = 0 ; ii < cupm ; ++ii )
                {
                    iv("&",ii+aupm+bupm) = ii ? UPNTVI(ic,ii) : ic;
                    xv("&",ii+aupm+bupm) = &(xc.nup(ii));
                    xvinfo("&",ii+aupm+bupm) = &(xcinfo(-1,ii));
                    ivset("&",ii+aupm+bupm) = icset;
                    rvgradOrder("&",ii+aupm+bupm) = ( ii == xcgradup ) ? xcgradOrder : 0;
                    xvff("&",ii+aupm+cupm) = &(xcff.nup( ( xcff.nupsize() <= ii ) ? (xcff.nupsize()-1) : ii ));
                }
            }

            else
            {
                xKKKm(aupm+bupm+cupm,res,xv,xvinfo,rvgradOrder,xvff,bias,iv,nullptr,xdim,xconsist,assumreal,xresmode,mlid,nullptr,justcalcip,&ivset);
            }
        }

    return res;
}

template <class T>
T &MercerKernel::yyyKK4(T &res,
                    const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, const SparseVector<gentype> &xc, const SparseVector<gentype> &xd,
                    const vecInfo &xainfo, const vecInfo &xbinfo, const vecInfo &xcinfo, const vecInfo &xdinfo,
                    int xagradOrder, int xbgradOrder, int xcgradOrder, int xdgradOrder,
                    int xagradup, int xbgradup, int xcgradup, int xdgradup,
                    int aupm, int bupm, int cupm, int dupm,
                    const SparseVector<gentype> &xaff, const SparseVector<gentype> &xbff, const SparseVector<gentype> &xcff, const SparseVector<gentype> &xdff,
                    const T &bias,
                    const gentype **pxyprod,
                    int ia, int ib, int ic, int id,
                    int xdim, int xconsist, int xresmode, int mlid,
                    const double *xy00, const double *xy10, const double *xy11, const double *xy20, const double *xy21, const double *xy22, const double *xy30, const double *xy31, const double *xy32, const double *xy33, int iaset, int ibset, int icset, int idset, int assumreal, int justcalcip) const
{
//    return xKKK4(res,xa,xb,xc,xd,xainfo,xbinfo,xcinfo,xdinfo,bias,pxyprod,ia,ib,ic,id,xdim,xconsist,assumreal,xresmode,mlid,0,xy00,xy10,xy11,xy20,xy21,xy22,xy30,xy31,xy32,xy33,iaset,ibset,icset,idset);

    NiceAssert( !isSymmSet() );

        if ( ( aupm == 1 ) && ( bupm == 1 ) && ( cupm == 1 ) && ( dupm == 1 ) )
        {
            int rxagradOrder = ( 0 == xagradup ) ? xagradOrder : 0;
            int rxbgradOrder = ( 0 == xbgradup ) ? xbgradOrder : 0;
            int rxcgradOrder = ( 0 == xcgradup ) ? xcgradOrder : 0;
            int rxdgradOrder = ( 0 == xdgradup ) ? xdgradOrder : 0;

            xKKK4(res,xa,xb,xc,xd,xainfo,xbinfo,xcinfo,xdinfo,rxagradOrder,rxbgradOrder,rxcgradOrder,rxdgradOrder,xaff,xbff,xcff,xdff,bias,pxyprod,ia,ib,ic,id,xdim,xconsist,assumreal,xresmode,mlid,xy00,xy10,xy11,xy20,xy21,xy22,xy30,xy31,xy32,xy33,justcalcip,iaset,ibset,icset,idset);
        }

        else
        {
            int ii;

            Vector<int> iv(aupm+bupm+cupm+dupm);
            Vector<const SparseVector<gentype> *> xv(aupm+bupm+cupm+dupm);
            Vector<const vecInfo *> xvinfo(aupm+bupm+cupm+dupm);
            Vector<int> ivset(aupm+bupm+cupm+dupm);
            Vector<int> rvgradOrder(aupm+bupm+cupm+dupm);
            Vector<const SparseVector<gentype> *> xvff(aupm+bupm+cupm+dupm);

            if ( aupm )
            {
                for ( ii = 0 ; ii < aupm ; ++ii )
                {
                    iv("&",ii) = ii ? UPNTVI(ia,ii) : ia;
                    xv("&",ii) = &(xa.nup(ii));
                    xvinfo("&",ii) = &(xainfo(-1,ii));
                    ivset("&",ii) = iaset;
                    rvgradOrder("&",ii) = ( ii == xagradup ) ? xagradOrder : 0;
                    xvff("&",ii) = &(xaff.nup( ( xaff.nupsize() <= ii ) ? (xaff.nupsize()-1) : ii ));
                }
            }

            if ( bupm )
            {
                for ( ii = 0 ; ii < bupm ; ++ii )
                {
                    iv("&",ii+aupm) = ii ? UPNTVI(ib,ii) : ib;
                    xv("&",ii+aupm) = &(xb.nup(ii));
                    xvinfo("&",ii+aupm) = &(xbinfo(-1,ii));
                    ivset("&",ii+aupm) = ibset;
                    rvgradOrder("&",ii+aupm) = ( ii == xbgradup ) ? xbgradOrder : 0;
                    xvff("&",ii+aupm) = &(xbff.nup( ( xbff.nupsize() <= ii ) ? (xbff.nupsize()-1) : ii ));
                }
            }

            if ( cupm )
            {
                for ( ii = 0 ; ii < cupm ; ++ii )
                {
                    iv("&",ii+aupm+bupm) = ii ? UPNTVI(ic,ii) : ic;
                    xv("&",ii+aupm+bupm) = &(xc.nup(ii));
                    xvinfo("&",ii+aupm+bupm) = &(xcinfo(-1,ii));
                    ivset("&",ii+aupm+bupm) = icset;
                    rvgradOrder("&",ii+aupm+bupm) = ( ii == xcgradup ) ? xcgradOrder : 0;
                    xvff("&",ii+aupm+bupm) = &(xcff.nup( ( xcff.nupsize() <= ii ) ? (xcff.nupsize()-1) : ii ));
                }
            }

            if ( dupm )
            {
                for ( ii = 0 ; ii < dupm ; ++ii )
                {
                    iv("&",ii+aupm+bupm+cupm) = ii ? UPNTVI(id,ii) : id;
                    xv("&",ii+aupm+bupm+cupm) = &(xd.nup(ii));
                    xvinfo("&",ii+aupm+bupm+cupm) = &(xdinfo(-1,ii));
                    ivset("&",ii+aupm+bupm+cupm) = idset;
                    rvgradOrder("&",ii+aupm+bupm+cupm) = ( ii == xdgradup ) ? xdgradOrder : 0;
                    xvff("&",ii+aupm+bupm+cupm) = &(xdff.nup( ( xdff.nupsize() <= ii ) ? (xdff.nupsize()-1) : ii ));
                }
            }

            else
            {
                xKKKm(aupm+bupm+cupm+dupm,res,xv,xvinfo,rvgradOrder,xvff,bias,iv,nullptr,xdim,xconsist,assumreal,xresmode,mlid,nullptr,justcalcip,&ivset);
            }
        }

    return res;
}


template <class T>
T &MercerKernel::yyyKKm(int m, T &res,
                    Vector<const SparseVector<gentype> *> &x,
                    Vector<const vecInfo *> &xinfo,
                    const Vector<int> &xgradOrder,
                    const Vector<int> &xgradup,
                    const Vector<int> &xupm,
                    Vector<const SparseVector<gentype> *> &xff,
                    const T &bias,
                    Vector<int> &i,
                    const gentype **pxyprod, int xdim, int xconsist, int resmode, int mlid,
                    const Matrix<double> *xy, const Vector<int> *iset, int assumreal, int justcalcip) const
{
//    return xKKKm(m,res,x,xinfo,bias,i,pxyprod,xdim,xconsist,assumreal,resmode,mlid,xy,0,iset);
    NiceAssert( !isSymmSet() );

    int needpreproc = 0;
    int ii;

    Vector<int> altiset;

    if ( !iset )
    {
        altiset.resize(m);
        altiset = 0;

        iset = &altiset;
    }

    if ( m )
    {
        for ( ii = 0 ; ii < m ; ++ii )
        {
            if ( xupm(ii) > 1 )
            {
                needpreproc = 1;

                break;
            }
        }
    }

    if ( !needpreproc )
    {
        xKKKm(m,res,x,xinfo,xgradOrder,xff,bias,i,pxyprod,xdim,xconsist,assumreal,resmode,mlid,xy,justcalcip,iset);
    }

    else
    {
        Vector<int> iv(i);
        Vector<const SparseVector<gentype> *> xv(x);
        Vector<const vecInfo *> xvinfo(xinfo);
        Vector<int> ivset(*iset);
        Vector<int> rvgradOrder(xgradOrder);
        Vector<const SparseVector<gentype> *> xvff(xff);

        // Fill in any missing data vectors

        int ii,jj,u;

        for ( ii = 0 ; ii < m ; ++ii )
        {
            if ( ( u = xupm(ii) ) > 1 )
            {
                for ( jj = 0 ; jj < u ; ++jj )
                {
                    if ( jj )
                    {
                        ++m;

                        iv.add(ii+jj);
                        xv.add(ii+jj);
                        xvinfo.add(ii+jj);
                        ivset.add(ii+jj);
                        rvgradOrder.add(ii+jj);
                        xvff.add(ii+jj);
                    }

                    iv("&",ii+jj) = jj ? UPNTVI(ii,jj) : ii;
                    xv("&",ii+jj) =  &((*(x(ii))).nup(jj));
                    xvinfo("&",ii+jj) = &((*(xinfo(ii)))(-1,jj));
                    ivset("&",ii+jj) = (*iset)(jj);
                    rvgradOrder("&",ii+jj) = ( jj == xgradup(ii) ) ? xgradOrder(ii) : 0;
                    xvff("&",ii+jj) = &((*(xvff(ii))).nup( ( (*(xvff(ii))).nupsize() <= jj ) ? ((*(xvff(ii))).nupsize()-1) : jj ));
                }
            }
        }

        //else
        {
            xKKKm(x.size(),res,xv,xvinfo,rvgradOrder,xvff,bias,iv,nullptr,xdim,xconsist,assumreal,resmode,mlid,nullptr,justcalcip,&ivset);
        }
    }

    return res;
}


template <class T>
int MercerKernel::yyyPphim(int m, Vector<T>  &res,
                           const SparseVector<gentype> &xa,
                           const vecInfo &xainfo,
                           int ia,
                           int allowfinite, int xdim, int xconsist, int assumreal,
                           int iaset,
                           int gradOrder,
                           int xagradup,
                           int iupm) const
{
    int dres = 0;
    int ns = numMulSplits();
    int q,r = 0;

    Vector<int> splitPoint(numMulSplits());
    Vector<int> splitType(numMulSplits());

    if ( numMulSplits() )
    {
        for ( q = 0 ; q < size() ; ++q )
        {
            if ( isMulSplit(q) )
            {
                NiceAssert( isMulSplit(q) != 2 ); // Not sure how to deal with this yet!

                splitPoint("&",r) = q;
                splitType("&",r) = isMulSplit(q);
                ++r;
            }
        }
    }

    for ( q = 0 ; q <= ns ; ++q )
    {
        int indstart = q ? (splitPoint(q-1)+1) : 0;
        int indend   = ( q < ns ) ? splitPoint(q) : size()-1;

        int tdres = 0;

        Vector<T> tempres;
        Vector<T> &resa = ( ( ns == 0 ) ? res : tempres );

        if ( iupm == 1 )
        {
            tdres = Pphim(m,resa,xa,xainfo,ia,allowfinite,xdim,xconsist,assumreal,iaset,gradOrder,xagradup,indstart,indend);
        }

        else if ( iupm == 2 )
        {
            const SparseVector<gentype> &rxa = xa.nup(0);
            const SparseVector<gentype> &rxb = xa.nup(1);

            int ixa = ia;
            int ixb = UPNTVI(ia,1);

            const vecInfo &rxainfo = xainfo(-1,0);
            const vecInfo &rxbinfo = xainfo(-1,1);

            Vector<T> resb;

            int ixaset = iaset;
            int ixbset = iaset;

            tdres = Pphim(2*m,resa,rxa,rxainfo,ixa,allowfinite,xdim,xconsist,assumreal,ixaset,gradOrder,xagradup,indstart,indend);

            if ( m >= 0 )
            {
                tdres = Pphim(2*m,resb,rxb,rxbinfo,ixb,allowfinite,xdim,xconsist,assumreal,ixbset,gradOrder,xagradup,indstart,indend);

                resa *= resb; // elementwise product (same for rest)
            }
        }

        else if ( iupm == 3 )
        {
            const SparseVector<gentype> &rxa = xa.nup(0);
            const SparseVector<gentype> &rxb = xa.nup(1);
            const SparseVector<gentype> &rxc = xa.nup(2);

            int ixa = ia;
            int ixb = UPNTVI(ia,1);
            int ixc = UPNTVI(ia,2);

            const vecInfo &rxainfo = xainfo(-1,0);
            const vecInfo &rxbinfo = xainfo(-1,1);
            const vecInfo &rxcinfo = xainfo(-1,2);

            Vector<T> resb;
            Vector<T> resc;

            int ixaset = iaset;
            int ixbset = iaset;
            int ixcset = iaset;

            tdres = Pphim(3*m,resa,rxa,rxainfo,ixa,allowfinite,xdim,xconsist,assumreal,ixaset,gradOrder,xagradup,indstart,indend);

            if ( m >= 0 )
            {
                tdres = Pphim(3*m,resb,rxb,rxbinfo,ixb,allowfinite,xdim,xconsist,assumreal,ixbset,gradOrder,xagradup,indstart,indend);
                tdres = Pphim(3*m,resc,rxc,rxcinfo,ixc,allowfinite,xdim,xconsist,assumreal,ixcset,gradOrder,xagradup,indstart,indend);

                resa *= resb;
                resa *= resc;
            }
        }

        else if ( iupm == 4 )
        {
            const SparseVector<gentype> &rxa = xa.nup(0);
            const SparseVector<gentype> &rxb = xa.nup(1);
            const SparseVector<gentype> &rxc = xa.nup(2);
            const SparseVector<gentype> &rxd = xa.nup(3);

            int ixa = ia;
            int ixb = UPNTVI(ia,1);
            int ixc = UPNTVI(ia,2);
            int ixd = UPNTVI(ia,3);

            const vecInfo &rxainfo = xainfo(-1,0);
            const vecInfo &rxbinfo = xainfo(-1,1);
            const vecInfo &rxcinfo = xainfo(-1,2);
            const vecInfo &rxdinfo = xainfo(-1,3);

            Vector<T> resb;
            Vector<T> resc;
            Vector<T> resd;

            int ixaset = iaset;
            int ixbset = iaset;
            int ixcset = iaset;
            int ixdset = iaset;

            tdres = Pphim(4*m,resa,rxa,rxainfo,ixa,allowfinite,xdim,xconsist,assumreal,ixaset,gradOrder,xagradup,indstart,indend);

            if ( m >= 0 )
            {
                tdres = Pphim(4*m,resb,rxb,rxbinfo,ixb,allowfinite,xdim,xconsist,assumreal,ixbset,gradOrder,xagradup,indstart,indend);
                tdres = Pphim(4*m,resc,rxc,rxcinfo,ixc,allowfinite,xdim,xconsist,assumreal,ixcset,gradOrder,xagradup,indstart,indend);
                tdres = Pphim(4*m,resd,rxd,rxdinfo,ixd,allowfinite,xdim,xconsist,assumreal,ixdset,gradOrder,xagradup,indstart,indend);

                resa *= resb;
                resa *= resc;
                resa *= resd;
            }
        }

        else
        {
            int ii;

            Vector<int> iv(iupm);
            Vector<const SparseVector<gentype> *> xxv(iupm);

            dres = 0;

            if ( iupm )
            {
                for ( ii = 0 ; ii < iupm ; ++ii )
                {
                    int ixa = ii ? UPNTVI(ia,ii) : ia;
                    const SparseVector<gentype> &rxa = xa.nup(ii);
                    const vecInfo &rxainfo = xainfo(-1,ii);
                    int ixaset = iaset;

                    Vector<T> tmpa;

                    tdres = Pphim(iupm*m,tmpa,rxa,rxainfo,ixa,allowfinite,xdim,xconsist,assumreal,ixaset,gradOrder,xagradup,indstart,indend);

                    if ( m >= 0 )
                    {
                        if ( !ii )
                        {
                            resa = tmpa;
                        }

                        else
                        {
                            resa *= tmpa;
                        }
                    }

                    if ( m == -1 )
                    {
                        break;
                    }
                }
            }
        }

        if ( ns )
        {
            if ( !q )
            {
                if ( m >= 0 )
                {
                    res = tempres;
                }

                dres = tdres;
            }

            else
            {
                if ( m >= 0 )
                {
                    kronprod(res,res,tempres); // Kronecker product!
                }

                if ( ( dres == -1 ) || ( tdres == -1 ) )
                {
                    dres = -1;
                }

                else
                {
                    dres *= tdres;
                }
            }
        }

        else
        {
            dres = tdres;
        }
    }

    if ( isfullnorm && ( m >= 0 ) )
    {
        double resnorm = res.absp(m);

        if ( resnorm == 0.0 )
        {
            res = (T) std::pow((double) res.size(),-1.0/m);
        }

        else
        {
            res.scale(1.0/resnorm);
        }
    }

    return dres;
}






// When normalising kernels we need to take care that the result isn't 0/0 = nan.
// Hack: waves wand... 0/0 = 1.  Take that, maths.
// As an aside, this means we need to do normalisation as a *single* division, not
// multiple divisions - so K(x,y)/sqrt((K(x,x).K(y,y)) rather than 
// (K(x,y)/sqrt(K(x,x)))/sqrt(K(y,y)), because, by the above magic, in the worst 
// case scenario:
//
// K(x,y)/sqrt((K(x,x).K(y,y)) = 0/sqrt(0*0) = 0/0 = 1
// (K(x,y)/sqrt(K(x,x)))/sqrt(K(y,y)) = (0/sqrt(0))/sqrt(0) = (0/0)/0 = 1/0 = inf
//
// The former makes sense (up to sign) as a limit, the latter is just plain wrong.

template <class T>
T &safedivby(T &a, const T &b);
template <class T>
T &safedivby(T &a, const T &b)
{
    a /= b;

    if ( testisvnan(a) )
    {
        setident(a);
    }

    return a;
}









// FIXME: Design decision: it actually isn't particularly hard to calculate the gradients
// for the mulSplit case, at least in principle.  We can just apply the product
// rule and go from there.  However in terms of code it is a royal pita, so until
// I find time or actually *need* it I'm leaving this incomplete!

template <class T> T &MercerKernel::xKKK0(T &res,
                                          const T &bias, const gentype **pxyprod,
                                          int xdim, int xconsist, int assumreal, int xresmode, int mlid,
                                          int justcalcip) const
{
    if ( numMulSplits() )
    {
        int q,r = 0;

        Vector<int> splitPoint(numMulSplits());
        Vector<int> splitType(numMulSplits());

        if ( numMulSplits() )
        {
            for ( q = 0 ; q < size() ; ++q )
            {
                if ( isMulSplit(q) )
                {
                    splitPoint("&",r) = q;
                    splitType("&",r) = isMulSplit(q);
                    ++r;
                }
            }
        }

        for ( q = 0 ; q <= numMulSplits() ; ++q )
        {
            int indstart = q ? splitPoint(q-1)+1 : 0;
            int indend   = ( q < numMulSplits() ) ? splitPoint(q) : size()-1;

            if ( !q )
            {
                xKK0(res,bias,pxyprod,xdim,xconsist,assumreal,xresmode,mlid,justcalcip,indstart,indend,calcnumSplits(indstart,indend));
            }

            else
            {
                T tempres;

                xKK0(tempres,bias,pxyprod,xdim,xconsist,assumreal,xresmode,mlid,justcalcip,indstart,indend,calcnumSplits(indstart,indend));

                if ( splitType(q-1) == 1 )
                {
                    res *= tempres;
                }

                else
                {
                    res += tempres;
                }
            }
        }
    }

    else
    {
        xKK0(res,bias,pxyprod,xdim,xconsist,assumreal,xresmode,mlid,justcalcip,0,size()-1,numSplits());
    }

    return res;
}

template <class T> T &MercerKernel::xKKK1(T &res,
                                          const SparseVector<gentype> &xa,
                                          const vecInfo &xainfo,
                                          int xagradOrder,
                                          const SparseVector<gentype> &xaff,
                                          const T &bias, const gentype **pxyprod,
                                          int ia,
                                          int xdim, int xconsist, int assumreal, int resmode, int mlid,
                                          const double *xy,
                                          int justcalcip, int iaset) const
{
    if ( numMulSplits() )
    {
        NiceAssert( !xagradOrder );

        int q,r = 0;

        Vector<int> splitPoint(numMulSplits());
        Vector<int> splitType(numMulSplits());

        if ( numMulSplits() )
        {
            for ( q = 0 ; q < size() ; ++q )
            {
                if ( isMulSplit(q) )
                {
                    splitPoint("&",r) = q;
                    splitType("&",r) = isMulSplit(q);
                    ++r;
                }
            }
        }

        for ( q = 0 ; q <= numMulSplits() ; ++q )
        {
            int indstart = q ? splitPoint(q-1)+1 : 0;
            int indend   = ( q < numMulSplits() ) ? splitPoint(q) : size()-1;

            if ( !q )
            {
                xKK1(res,xa,xainfo,xagradOrder,xaff,bias,pxyprod,ia,xdim,xconsist,assumreal,resmode,mlid,xy,justcalcip,iaset,indstart,indend,calcnumSplits(indstart,indend));
            }

            else
            {
                T tempres;

                xKK1(tempres,xa,xainfo,xagradOrder,xaff,bias,pxyprod,ia,xdim,xconsist,assumreal,resmode,mlid,xy,justcalcip,iaset,indstart,indend,calcnumSplits(indstart,indend));

                if ( splitType(q-1) == 1 )
                {
                    res *= tempres;
                }

                else
                {
                    res += tempres;
                }
            }
        }
    }

    else
    {
        xKK1(res,xa,xainfo,xagradOrder,xaff,bias,pxyprod,ia,xdim,xconsist,assumreal,resmode,mlid,xy,justcalcip,iaset,0,size()-1,numSplits());
    }

    return res;
}

template <class T> T &MercerKernel::xKKK2(T &res,
                                          const SparseVector<gentype> &xa, const SparseVector<gentype> &xb,
                                          const vecInfo &xainfo, const vecInfo &xbinfo,
                                          int xagradOrder, int xbgradOrder,
                                          const SparseVector<gentype> &xaff, const SparseVector<gentype> &xbff,
                                          const T &bias, const gentype **pxyprod,
                                          int ia, int ib,
                                          int xdim, int xconsist, int assumreal, int resmode, int mlid,
                                          const double *xy00, const double *xy10, const double *xy11,
                                          int justcalcip, int iset, int jset,
                                          int adensetype, int bdensetype) const
{
    NiceAssert( adensetype >= 0 );
    NiceAssert( bdensetype >= 0 );

    if ( numMulSplits() )
    {
        NiceAssert( !xagradOrder && !xbgradOrder );

        int q,r = 0;

        Vector<int> splitPoint(numMulSplits());
        Vector<int> splitType(numMulSplits());

        if ( numMulSplits() )
        {
            for ( q = 0 ; q < size() ; ++q )
            {
                if ( isMulSplit(q) )
                {
                    splitPoint("&",r) = q;
                    splitType("&",r) = isMulSplit(q);
                    ++r;
                }
            }
        }

        for ( q = 0 ; q <= numMulSplits() ; ++q )
        {
            int indstart = q ? splitPoint(q-1)+1 : 0;
            int indend   = ( q < numMulSplits() ) ? splitPoint(q) : size()-1;

            if ( !q )
            {
                xKK2(res,xa,xb,xainfo,xbinfo,xagradOrder,xbgradOrder,xaff,xbff,bias,pxyprod,ia,ib,xdim,xconsist,assumreal,resmode,mlid,xy00,xy10,xy11,justcalcip,iset,jset,indstart,indend,calcnumSplits(indstart,indend),adensetype,bdensetype);
            }

            else
            {
                T tempres;

                xKK2(tempres,xa,xb,xainfo,xbinfo,xagradOrder,xbgradOrder,xaff,xbff,bias,pxyprod,ia,ib,xdim,xconsist,assumreal,resmode,mlid,xy00,xy10,xy11,justcalcip,iset,jset,indstart,indend,calcnumSplits(indstart,indend),adensetype,bdensetype);

                if ( splitType(q-1) == 1 )
                {
                    res *= tempres;
                }

                else
                {
                    res += tempres;
                }
            }
        }
    }

    else
    {
        xKK2(res,xa,xb,xainfo,xbinfo,xagradOrder,xbgradOrder,xaff,xbff,bias,pxyprod,ia,ib,xdim,xconsist,assumreal,resmode,mlid,xy00,xy10,xy11,justcalcip,iset,jset,0,size()-1,numSplits(),adensetype,bdensetype);
    }

    return res;
}



template <class T> T &MercerKernel::xKKK3(T &res,
                                          const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, const SparseVector<gentype> &xc,
                                          const vecInfo &xainfo, const vecInfo &xbinfo, const vecInfo &xcinfo,
                                          int xagradOrder, int xbgradOrder, int xcgradOrder,
                                          const SparseVector<gentype> &xaff, const SparseVector<gentype> &xbff, const SparseVector<gentype> &xcff,
                                          const T &bias, const gentype **pxyprod,
                                          int ia, int ib, int ic,
                                          int xdim, int xconsist, int assumreal, int xresmode, int mlid,
                                          const double *xy00, const double *xy10, const double *xy11, const double *xy20, const double *xy21, const double *xy22,
                                          int justcalcip, int iaset, int ibset, int icset) const
{
    if ( numMulSplits() )
    {
        NiceAssert( !xagradOrder && !xbgradOrder && !xcgradOrder );

        int q,r = 0;

        Vector<int> splitPoint(numMulSplits());
        Vector<int> splitType(numMulSplits());

        if ( numMulSplits() )
        {
            for ( q = 0 ; q < size() ; ++q )
            {
                if ( isMulSplit(q) )
                {
                    splitPoint("&",r) = q;
                    splitType("&",r) = isMulSplit(q);
                    ++r;
                }
            }
        }

        for ( q = 0 ; q <= numMulSplits() ; ++q )
        {
            int indstart = q ? splitPoint(q-1)+1 : 0;
            int indend   = ( q < numMulSplits() ) ? splitPoint(q) : size()-1;

            if ( !q )
            {
                xKK3(res,xa,xb,xc,xainfo,xbinfo,xcinfo,xagradOrder,xbgradOrder,xcgradOrder,xaff,xbff,xcff,bias,pxyprod,ia,ib,ic,xdim,xconsist,assumreal,xresmode,mlid,xy00,xy10,xy11,xy20,xy21,xy22,justcalcip,iaset,ibset,icset,indstart,indend,calcnumSplits(indstart,indend));
            }

            else
            {
                T tempres;

                xKK3(tempres,xa,xb,xc,xainfo,xbinfo,xcinfo,xagradOrder,xbgradOrder,xcgradOrder,xaff,xbff,xcff,bias,pxyprod,ia,ib,ic,xdim,xconsist,assumreal,xresmode,mlid,xy00,xy10,xy11,xy20,xy21,xy22,justcalcip,iaset,ibset,icset,indstart,indend,calcnumSplits(indstart,indend));

                if ( splitType(q-1) == 1 )
                {
                    res *= tempres;
                }

                else
                {
                    res += tempres;
                }
            }
        }
    }

    else
    {
        xKK3(res,xa,xb,xc,xainfo,xbinfo,xcinfo,xagradOrder,xbgradOrder,xcgradOrder,xaff,xbff,xcff,bias,pxyprod,ia,ib,ic,xdim,xconsist,assumreal,xresmode,mlid,xy00,xy10,xy11,xy20,xy21,xy22,justcalcip,iaset,ibset,icset,0,size()-1,numSplits());
    }

    return res;
}

template <class T> T &MercerKernel::xKKK4(T &res,
                                          const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, const SparseVector<gentype> &xc, const SparseVector<gentype> &xd,
                                          const vecInfo &xainfo, const vecInfo &xbinfo, const vecInfo &xcinfo, const vecInfo &xdinfo,
                                          int xagradOrder, int xbgradOrder, int xcgradOrder, int xdgradOrder,
                                          const SparseVector<gentype> &xaff, const SparseVector<gentype> &xbff, const SparseVector<gentype> &xcff, const SparseVector<gentype> &xdff,
                                          const T &bias, const gentype **pxyprod,
                                          int ia, int ib, int ic, int id,
                                          int xdim, int xconsist, int assumreal, int xresmode, int mlid,
                                          const double *xy00, const double *xy10, const double *xy11, const double *xy20, const double *xy21, const double *xy22, const double *xy30, const double *xy31, const double *xy32, const double *xy33,
                                          int justcalcip, int iaset, int ibset, int icset, int idset) const
{
    if ( numMulSplits() )
    {
        NiceAssert( !xagradOrder && !xbgradOrder && !xcgradOrder && !xdgradOrder );

        int q,r = 0;

        Vector<int> splitPoint(numMulSplits()+1);
        Vector<int> splitType(numMulSplits()+1);

        if ( numMulSplits() )
        {
            for ( q = 0 ; q < size() ; ++q )
            {
                if ( isMulSplit(q) )
                {
                    splitPoint("&",r) = q;
                    splitType("&",r) = isMulSplit(q);
                    ++r;
                }
            }
        }

        for ( q = 0 ; q <= numMulSplits() ; ++q )
        {
            int indstart = q ? splitPoint(q-1)+1 : 0;
            int indend   = ( q < numMulSplits() ) ? splitPoint(q) : size()-1;

            if ( !q )
            {
                xKK4(res,xa,xb,xc,xd,xainfo,xbinfo,xcinfo,xdinfo,xagradOrder,xbgradOrder,xcgradOrder,xdgradOrder,xaff,xbff,xcff,xdff,bias,pxyprod,ia,ib,ic,id,xdim,xconsist,assumreal,xresmode,mlid,justcalcip,xy00,xy10,xy11,xy20,xy21,xy22,xy30,xy31,xy32,xy33,iaset,ibset,icset,idset,indstart,indend,calcnumSplits(indstart,indend));
            }

            else
            {
                T tempres;

                xKK4(tempres,xa,xb,xc,xd,xainfo,xbinfo,xcinfo,xdinfo,xagradOrder,xbgradOrder,xcgradOrder,xdgradOrder,xaff,xbff,xcff,xdff,bias,pxyprod,ia,ib,ic,id,xdim,xconsist,assumreal,xresmode,mlid,justcalcip,xy00,xy10,xy11,xy20,xy21,xy22,xy30,xy31,xy32,xy33,iaset,ibset,icset,idset,indstart,indend,calcnumSplits(indstart,indend));

                if ( splitType(q-1) == 1 )
                {
                    res *= tempres;
                }

                else
                {
                    res += tempres;
                }
            }
        }
    }

    else
    {
        xKK4(res,xa,xb,xc,xd,xainfo,xbinfo,xcinfo,xdinfo,xagradOrder,xbgradOrder,xcgradOrder,xdgradOrder,xaff,xbff,xcff,xdff,bias,pxyprod,ia,ib,ic,id,xdim,xconsist,assumreal,xresmode,mlid,justcalcip,xy00,xy10,xy11,xy20,xy21,xy22,xy30,xy31,xy32,xy33,iaset,ibset,icset,idset,0,size()-1,numSplits());
    }

    return res;
}

template <class T> T &MercerKernel::xKKKm(int m, T &res,
                                          Vector<const SparseVector<gentype> *> &x,
                                          Vector<const vecInfo *> &xinfo,
                                          const Vector<int> &xgradOrder,
                                          Vector<const SparseVector<gentype> *> &xff,
                                          const T &bias,
                                          Vector<int> &i,
                                          const gentype **pxyprod,
                                          int xdim, int xconsist, int assumreal, int resmode, int mlid,
                                          const Matrix<double> *xy,
                                          int justcalcip, const Vector<int> *iset) const
{
    if ( numMulSplits() )
    {
        NiceAssert( xgradOrder == 0 );

        int q,r = 0;

        Vector<int> splitPoint(numMulSplits());
        Vector<int> splitType(numMulSplits());

        if ( numMulSplits() )
        {
            for ( q = 0 ; q < size() ; ++q )
            {
                if ( isMulSplit(q) )
                {
                    splitPoint("&",r) = q;
                    splitType("&",r) = isMulSplit(q);
                    ++r;
                }
            }
        }

        for ( q = 0 ; q <= numMulSplits() ; ++q )
        {
            int indstart = q ? splitPoint(q-1)+1 : 0;
            int indend   = ( q < numMulSplits() ) ? splitPoint(q) : size()-1;

            if ( !q )
            {
                xKKm(m,res,x,xinfo,xgradOrder,xff,bias,i,pxyprod,xdim,xconsist,assumreal,resmode,mlid,xy,justcalcip,iset,indstart,indend,calcnumSplits(indstart,indend));
            }

            else
            {
                T tempres;

                xKKm(m,tempres,x,xinfo,xgradOrder,xff,bias,i,pxyprod,xdim,xconsist,assumreal,resmode,mlid,xy,justcalcip,iset,indstart,indend,calcnumSplits(indstart,indend));

                if ( splitType(q-1) == 1 )
                {
                    res *= tempres;
                }

                else
                {
                    res += tempres;
                }
            }
        }
    }

    else
    {
        xKKm(m,res,x,xinfo,xgradOrder,xff,bias,i,pxyprod,xdim,xconsist,assumreal,resmode,mlid,xy,justcalcip,iset,0,size()-1,numSplits());
    }

    return res;
}









//phantomx
template <class T>
T &MercerKernel::xKK0(T &res,
                     const T &bias,
                     const gentype **pxyprod,
                     int xdim, int xconsist, int assumreal, int resmode, int mlid, int justcalcip, int indstart, int indend, int ns) const
{
    T logres; logres = 0.0;
    int logresvalid = 0;
    //int ns = numSplits();

    if ( isfullnorm && !ns && !justcalcip )
    {
        res = 1.0;
    }

    else if ( isfullnorm && ns && !justcalcip )
    {
        res = 1.0; // Design decision: empty product evaluates to 1
    }

    else if ( !isfullnorm && ns && !justcalcip )
    {
        res = 1.0; // Design decision: empty product evaluates to 1
    }

    else
    {
        KK0(res,logres,logresvalid,bias,pxyprod,xdim,xconsist,assumreal,resmode,mlid,justcalcip,indstart,indend);
    }

    return res;
}

//phantomx
template <class T>
T &MercerKernel::xKK1(T &res,
                     const SparseVector<gentype> &xa,
                     const vecInfo &xainfo,
                     int xagradOrder,
                     const SparseVector<gentype> &xaff,
                     const T &bias,
                     const gentype **pxyprod,
                     int ia,
                     int xdim, int xconsist, int assumreal, int resmode, int mlid,
                     const double *xy, int justcalcip, int iset, int indstart, int indend, int ns) const
{
    T logres; logres = 0.0;
    int logresvalid = 0;
    //int ns = numSplits();

    if ( isfullnorm && !ns && !justcalcip )
    {
        res = xagradOrder ? 0.0 : 1.0;
    }

    else if ( isfullnorm && ns && !justcalcip )
    {
        res = xagradOrder ? 0.0 : 1.0;
    }

    else if ( !isfullnorm && ns && !justcalcip )
    {
        int indstarta = indstart;
        int indenda   = indend;

        if ( ns )
        {
            int q;

            for ( q = indstart ; q < indend ; ++q )
            {
                if ( isSplit(q) )
                {
                    indenda = q;
                    break;
                }
            }
        }

        KK1(res,logres,logresvalid,xa,xainfo,xagradOrder,xaff,bias,nullptr,ia,xdim,xconsist,assumreal,resmode,mlid,nullptr,justcalcip,indstarta,indenda,iset);
    }

    else
    {
        KK1(res,logres,logresvalid,xa,xainfo,xagradOrder,xaff,bias,pxyprod,ia,xdim,xconsist,assumreal,resmode,mlid,xy,justcalcip,indstart,indend,iset);
    }

    return res;
}

//phantomx
template <class T>
T &MercerKernel::xKK2(T &res,
                     const SparseVector<gentype> &xa, const SparseVector<gentype> &xb,
                     const vecInfo &xainfo, const vecInfo &xbinfo,
                     int xagradOrder, int xbgradOrder,
                     const SparseVector<gentype> &xaff, const SparseVector<gentype> &xbff,
                     const T &bias,
                     const gentype **pxyprod,
                     int ia, int ib,
                     int xdim, int xconsist, int assumreal, int resmode, int mlid,
                     const double *xy00, const double *xy10, const double *xy11, int justcalcip, int iset, int jset, int indstart, int indend, int ns,
                     int adensetype, int bdensetype) const
{
    // the ns stuff is designed to reflect splitting that occured in yyykk2() level functions

    NiceAssert( adensetype >= 0 );
    NiceAssert( bdensetype >= 0 );

    T logres; logres = 0.0;
    int logresvalid = 0;
    //int ns = numSplits();
    int q,r = 0;
    int z = 0;

    NiceAssert( !isfullnorm || ( !xagradOrder && !xbgradOrder ) );

    if ( isfullnorm && !ns && !justcalcip )
    {
        // 1:1, 2:2

        if ( xainfo.xusize() == 1 )
        {
            T tma;
            T tmb;

            T logtma;
            T logtmb;

            int logtmavalid = 0;
            int logtmbvalid = 0;

//            KK2(res,logres,logresvalid,xa,xb,xainfo,xbinfo,xagradOrder,xbgradOrder,xaff,xbff,bias,nullptr,ia,ib,xdim,xconsist,assumreal,resmode,mlid,xy00,xy10,xy11,justcalcip,indstart,indend,iset,jset);

            KK2(adensetype,adensetype,tma,logtma,logtmavalid,xa,xa,xainfo,xainfo,xagradOrder,xagradOrder,xaff,xaff,bias,nullptr,ia,ia,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,justcalcip,indstart,indend,iset,iset);
            KK2(bdensetype,bdensetype,tmb,logtmb,logtmbvalid,xb,xb,xbinfo,xbinfo,xbgradOrder,xbgradOrder,xbff,xbff,bias,nullptr,ib,ib,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,justcalcip,indstart,indend,jset,jset);

            if ( ( (double) abs2(tma) <= BADZEROTOL ) || ( (double) abs2(tmb) <= BADZEROTOL ) )
            {
                res = 1.0;
            }

            else
            {
                KK2(adensetype,bdensetype,res,logres,logresvalid,xa,xb,xainfo,xbinfo,xagradOrder,xbgradOrder,xaff,xbff,bias,nullptr,ia,ib,xdim,xconsist,assumreal,resmode,mlid,xy00,xy10,xy11,justcalcip,indstart,indend,iset,jset);

                if ( logresvalid && logtmavalid && logtmbvalid )
                {
                    logtma /= 2.0;
                    logtmb /= 2.0;

                    res = logres;

                    res -= logtma;
                    res -= logtmb;

                    OP_exp(res);
                }

                else
                {
                    tma *= tmb;
                    OP_sqrt(tma);
                    safedivby(res,tma); // res /= tma;
                }
            }
        }

        else
        {
            res = 1.0;
        }
    }

    else if ( !isfullnorm && ns && !justcalcip )
    {
        T tempres; tempres = 0.0;

        Vector<int> splitPoint(ns);
        Vector<int> splitType(ns);

        if ( ns )
        {
            for ( q = indstart ; q < indend ; ++q )
            {
                if ( isSplit(q) )
                {
                    splitPoint("&",r) = q;
                    splitType("&",r) = isSplit(q);
                    ++r;
                }
            }
        }

        int indstarta = indstart;
        int indenda   = indend;

        int indstartb = indstart;
        int indendb   = indend;

        if ( ns == 1 )
        {
            indstarta = indstart;
            indenda   = splitPoint(z);

            indstartb = splitPoint(z)+1;
            indendb   = indend;
        }

        else if ( ns >= 2 )
        {
            indstarta = indstart;
            indenda   = splitPoint(z);

            indstartb = splitPoint(z)+1;
            indendb   = splitPoint(1);
        }

        // 1:1, 2:2

        if ( xainfo.xusize() == 1 )
        {
            KK2(adensetype,bdensetype,res,logres,logresvalid,xa,xb,xainfo,xbinfo,xagradOrder,xbgradOrder,xaff,xbff,bias,nullptr,ia,ib,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,justcalcip,indstarta,indenda,iset,jset);
        }

        else
        {
            // xainfo.xusize() == 2

            NiceAssert( !adensetype && !bdensetype );

            KK1(    res,logres,logresvalid,xa,xainfo,xagradOrder,xaff,bias,nullptr,ia,xdim,xconsist,assumreal,resmode,mlid,nullptr,justcalcip,indstarta,indenda,iset);
            KK1(tempres,logres,logresvalid,xb,xbinfo,xbgradOrder,xbff,bias,nullptr,ib,xdim,xconsist,assumreal,resmode,mlid,nullptr,justcalcip,indstartb,indendb,jset);

            if ( splitType(0) == 1 )
            {
                res *= tempres;
            }

            else
            {
                res += tempres;
            }
        }
    }

    else if ( isfullnorm && ns && !justcalcip )
    {
        Vector<int> splitPoint(ns);

        if ( ns )
        {
            for ( q = indstart ; q < indend ; ++q )
            {
                if ( isSplit(q) )
                {
                    splitPoint("&",r) = q;
                    ++r;

                    NiceAssert( isSplit(q) == 1 );
                }
            }
        }

        int indstarta = indstart;
        int indenda   = indend;
//
//        int indstartb = indstart;
//        int indendb   = indend;
//
        if ( ns == 1 )
        {
            indstarta = indstart;
            indenda   = splitPoint(z);
//
//            indstartb = splitPoint(z)+1;
//            indendb   = indend;
        }

        else if ( ns >= 2 )
        {
            indstarta = indstart;
            indenda   = splitPoint(z);
//
//            indstartb = splitPoint(z)+1;
//            indendb   = splitPoint(1);
        }

        // 1:1, 2:2

        if ( xainfo.xusize() == 1 )
        {
            T tma;
            T tmb;

            T logtma;
            T logtmb;

            int logtmavalid = 0;
            int logtmbvalid = 0;

//            KK2(res,logres,logresvalid,xa,xb,xainfo,xbinfo,xagradOrder,xbgradOrder,xaff,xbff,bias,nullptr,ia,ib,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,justcalcip,indstarta,indenda,iset,jset);

            KK2(adensetype,adensetype,tma,logtma,logtmavalid,xa,xa,xainfo,xainfo,xagradOrder,xagradOrder,xaff,xaff,bias,nullptr,ia,ia,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,justcalcip,indstarta,indenda,iset,iset);
            KK2(bdensetype,bdensetype,tmb,logtmb,logtmbvalid,xb,xb,xbinfo,xbinfo,xbgradOrder,xbgradOrder,xbff,xbff,bias,nullptr,ib,ib,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,justcalcip,indstarta,indenda,jset,jset);

            if ( ( (double) abs2(tma) <= BADZEROTOL ) || ( (double) abs2(tmb) <= BADZEROTOL ) )
            {
                res = 1.0;
            }

            else
            {
                KK2(adensetype,bdensetype,res,logres,logresvalid,xa,xb,xainfo,xbinfo,xagradOrder,xbgradOrder,xaff,xbff,bias,nullptr,ia,ib,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,justcalcip,indstarta,indenda,iset,jset);

                if ( logresvalid && logtmavalid && logtmbvalid )
                {
                    logtma /= 2.0;
                    logtmb /= 2.0;

                    res = logres;

                    res -= logtma;
                    res -= logtmb;

                    OP_exp(res);
                }

                else
                {
                    tma *= tmb;
                    OP_sqrt(tma);
                    safedivby(res,tma); // res /= tma;
                }
            }
        }

        else
        {
            res = 1.0;
        }
    }

    else
    {
        KK2(adensetype,bdensetype,res,logres,logresvalid,xa,xb,xainfo,xbinfo,xagradOrder,xbgradOrder,xaff,xbff,bias,pxyprod,ia,ib,xdim,xconsist,assumreal,resmode,mlid,xy00,xy10,xy11,justcalcip,indstart,indend,iset,jset);
    }

    NiceAssert( !testisvnan(res) );
    NiceAssert( !testisinf(res) );

    return res;
}

//phantomx
template <class T>
T &MercerKernel::xKK3(T &res,
                     const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, const SparseVector<gentype> &xc,
                     const vecInfo &xainfo, const vecInfo &xbinfo, const vecInfo &xcinfo,
                     int xagradOrder, int xbgradOrder, int xcgradOrder,
                     const SparseVector<gentype> &xaff, const SparseVector<gentype> &xbff, const SparseVector<gentype> &xcff,
                     const T &bias,
                     const gentype **pxyprod,
                     int ia, int ib, int ic,
                     int xdim, int xconsist, int assumreal, int resmode, int mlid,
                     const double *xy00, const double *xy10, const double *xy11, const double *xy20, const double *xy21, const double *xy22, int justcalcip, int iaset, int ibset, int icset, int indstart, int indend, int ns) const
{
    T logres; logres = 0.0;
    T tempres; tempres = 0.0;
    T xtempres; xtempres = 0.0;
    int logresvalid = 0;
    //int ns = numSplits();
    int q,r = 0;
    int z = 0;

    NiceAssert( !isfullnorm || ( !xagradOrder && !xbgradOrder && !xcgradOrder ) );

    if ( isfullnorm && !ns && !justcalcip )
    {
        // 1:1:1, 
        // 2:2:1, 1:2:2
        // 3:3:3

        if ( ( xainfo.xusize() == 1 ) && ( xbinfo.xusize() == 1 ) )
        {
            // So xcinfo.xusize() == 1 by assumption

            T tma;
            T tmb;
            T tmc;

            T logtma;
            T logtmb;
            T logtmc;

            int logtmavalid;
            int logtmbvalid;
            int logtmcvalid;

//            KK3(res,logres,logresvalid,xa,xb,xc,xainfo,xbinfo,xcinfo,xagradOrder,xbgradOrder,xcgradOrder,xaff,xbff,xcff,bias,nullptr,ia,ib,ic,xdim,xconsist,assumreal,resmode,mlid,xy00,xy10,xy11,xy20,xy21,xy22,nullptr,justcalcip,indstart,indend,iaset,ibset,icset);

            KK3(tma,logtma,logtmavalid,xa,xa,xa,xainfo,xainfo,xainfo,xagradOrder,xagradOrder,xagradOrder,xaff,xaff,xaff,bias,nullptr,ia,ia,ia,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,justcalcip,indstart,indend,iaset,iaset,iaset);
            KK3(tmb,logtmb,logtmbvalid,xb,xb,xb,xbinfo,xbinfo,xbinfo,xbgradOrder,xbgradOrder,xbgradOrder,xbff,xbff,xbff,bias,nullptr,ib,ib,ib,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,justcalcip,indstart,indend,ibset,ibset,ibset);
            KK3(tmc,logtmc,logtmcvalid,xc,xc,xc,xcinfo,xcinfo,xcinfo,xcgradOrder,xcgradOrder,xcgradOrder,xcff,xcff,xcff,bias,nullptr,ic,ic,ic,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,justcalcip,indstart,indend,icset,icset,icset);

            if ( ( ( (double) abs2(tma) <= BADZEROTOL ) && ( (double) abs2(tmb) <= BADZEROTOL ) ) ||
                 ( ( (double) abs2(tma) <= BADZEROTOL ) && ( (double) abs2(tmc) <= BADZEROTOL ) ) ||
                 ( ( (double) abs2(tmb) <= BADZEROTOL ) && ( (double) abs2(tmc) <= BADZEROTOL ) )    )
            {
                res = 1.0;
            }

            else if ( (double) abs2(tma) <= BADZEROTOL )
            {
                KK2(0,0,res,logres,logresvalid,xb,xc,xbinfo,xcinfo,xbgradOrder,xcgradOrder,xbff,xcff,bias,nullptr,ib,ic,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,justcalcip,indstart,indend,ibset,icset);

                if ( logresvalid && logtmbvalid && logtmcvalid )
                {
                    logtmb /= 2.0;
                    logtmc /= 2.0;

                    res = logres;

                    res -= logtmb;
                    res -= logtmc;

                    OP_exp(res);
                }

                else
                {
                    tmb *= tmc;
                    OP_sqrt(tmb);
                    safedivby(res,tmb); //res /= tmb;
                }
            }

            else if ( (double) abs2(tmb) <= BADZEROTOL )
            {
                KK2(0,0,res,logres,logresvalid,xa,xc,xainfo,xcinfo,xagradOrder,xcgradOrder,xaff,xcff,bias,nullptr,ia,ic,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,justcalcip,indstart,indend,iaset,icset);

                if ( logresvalid && logtmavalid && logtmcvalid )
                {
                    logtma /= 2.0;
                    logtmc /= 2.0;

                    res = logres;

                    res -= logtma;
                    res -= logtmc;

                    OP_exp(res);
                }

                else
                {
                    tma *= tmc;
                    OP_sqrt(tma);
                    safedivby(res,tma); //res /= tma;
                }
            }

            else if ( (double) abs2(tmc) <= BADZEROTOL )
            {
                KK2(0,0,res,logres,logresvalid,xa,xb,xainfo,xbinfo,xagradOrder,xbgradOrder,xaff,xbff,bias,nullptr,ia,ib,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,justcalcip,indstart,indend,iaset,ibset);

                if ( logresvalid && logtmavalid && logtmbvalid )
                {
                    logtma /= 2.0;
                    logtmb /= 2.0;

                    res = logres;

                    res -= logtma;
                    res -= logtmb;

                    OP_exp(res);
                }

                else
                {
                    tma *= tmb;
                    OP_sqrt(tma);
                    safedivby(res,tma); //res /= tma;
                }
            }

            else
            {
                KK3(res,logres,logresvalid,xa,xb,xc,xainfo,xbinfo,xcinfo,xagradOrder,xbgradOrder,xcgradOrder,xaff,xbff,xcff,bias,nullptr,ia,ib,ic,xdim,xconsist,assumreal,resmode,mlid,xy00,xy10,xy11,xy20,xy21,xy22,nullptr,justcalcip,indstart,indend,iaset,ibset,icset);

                if ( logresvalid && logtmavalid && logtmbvalid && logtmcvalid )
                {
                    logtma /= 3.0;
                    logtmb /= 3.0;
                    logtmc /= 3.0;

                    res = logres;

                    res -= logtma;
                    res -= logtmb;
                    res -= logtmc;

                    OP_exp(res);
                }

                else
                {
                    T oneonm; oneonm = 1.0/3.0;

                    tma *= tmb;
                    tma *= tmc;
                    tma = pow(tma,oneonm);
                    safedivby(res,tma); //res /= tma;
                }
            }
        }

        else if ( xainfo.xusize() == 2 )
        {
            // This is actually a 2-kernel evaluation in disguise!
            // K2([xa~xb],xc)

            T tma;
            T tmc;

            T logtma;
            T logtmc;

            int logtmavalid;
            int logtmcvalid;

//            KK3(res,logres,logresvalid,xa,xb,xc,xainfo,xbinfo,xcinfo,xagradOrder,xbgradOrder,xcgradOrder,xaff,xbff,xcff,bias,nullptr,ia,ib,ic,xdim,xconsist,assumreal,resmode,mlid,xy00,xy10,xy11,xy20,xy21,xy22,nullptr,justcalcip,indstart,indend,iaset,ibset,icset);

            KK4(tma,logtma,logtmavalid,xa,xb,xa,xb,xainfo,xbinfo,xainfo,xbinfo,xagradOrder,xbgradOrder,xagradOrder,xbgradOrder,xaff,xbff,xaff,xbff,bias,nullptr,ia,ib,ia,ib,xdim,xconsist,assumreal,resmode,mlid,nullptr,justcalcip,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,indstart,indend,iaset,ibset,iaset,ibset);
            KK2(0,0,tmc,logtmc,logtmcvalid,xc,xc,xcinfo,xcinfo,xcgradOrder,xcgradOrder,xcff,xcff,bias,nullptr,ic,ic,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,justcalcip,indstart,indend,icset,icset);

            if ( ( (double) abs2(tma) <= BADZEROTOL ) || ( (double) abs2(tmc) <= BADZEROTOL ) )
            {
                res = 1.0;
            }

            else
            {
                KK3(res,logres,logresvalid,xa,xb,xc,xainfo,xbinfo,xcinfo,xagradOrder,xbgradOrder,xcgradOrder,xaff,xbff,xcff,bias,nullptr,ia,ib,ic,xdim,xconsist,assumreal,resmode,mlid,xy00,xy10,xy11,xy20,xy21,xy22,nullptr,justcalcip,indstart,indend,iaset,ibset,icset);

                if ( logresvalid && logtmavalid && logtmcvalid )
                {
                    logtma /= 2.0;
                    logtmc /= 2.0;

                    res = logres;

                    res -= logtma;
                    res -= logtmc;

                    OP_exp(res);
                }

                else
                {
                    tma *= tmc;
                    OP_sqrt(tma);
                    safedivby(res,tma); //res /= tma;
                }
            }
        }

        else if ( xbinfo.xusize() == 2 )
        {
            // This is actually a 2-kernel evaluation in disguise!
            // K2(xa,[xb~xc])

            T tma;
            T tmb;

            T logtma;
            T logtmb;

            int logtmavalid;
            int logtmbvalid;

//            KK3(res,logres,logresvalid,xa,xb,xc,xainfo,xbinfo,xcinfo,xagradOrder,xbgradOrder,xcgradOrder,xaff,xbff,xcff,bias,nullptr,ia,ib,ic,xdim,xconsist,assumreal,resmode,mlid,xy00,xy10,xy11,xy20,xy21,xy22,nullptr,justcalcip,indstart,indend,iaset,ibset,icset);

            KK2(0,0,tma,logtma,logtmavalid,xa,xa,xainfo,xainfo,xagradOrder,xagradOrder,xaff,xaff,bias,nullptr,ia,ia,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,justcalcip,indstart,indend,iaset,iaset);
            KK4(tmb,logtmb,logtmbvalid,xb,xc,xb,xc,xbinfo,xcinfo,xbinfo,xcinfo,xbgradOrder,xcgradOrder,xbgradOrder,xcgradOrder,xbff,xcff,xbff,xcff,bias,nullptr,ib,ic,ib,ic,xdim,xconsist,assumreal,resmode,mlid,nullptr,justcalcip,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,indstart,indend,ibset,icset,ibset,icset);

            if ( ( (double) abs2(tma) <= BADZEROTOL ) || ( (double) abs2(tmb) <= BADZEROTOL ) )
            {
                res = 1.0;
            }

            else
            {
                KK3(res,logres,logresvalid,xa,xb,xc,xainfo,xbinfo,xcinfo,xagradOrder,xbgradOrder,xcgradOrder,xaff,xbff,xcff,bias,nullptr,ia,ib,ic,xdim,xconsist,assumreal,resmode,mlid,xy00,xy10,xy11,xy20,xy21,xy22,nullptr,justcalcip,indstart,indend,iaset,ibset,icset);

                if ( logresvalid && logtmavalid && logtmbvalid )
                {
                    logtma /= 2.0;
                    logtmb /= 2.0;

                    res = logres;

                    res -= logtma;
                    res -= logtmb;

                    OP_exp(res);
                }

                else
                {
                    tma *= tmb;
                    OP_sqrt(tma);
                    safedivby(res,tma); //res /= tma;
                }
            }
        }

        else
        {
            // K1([xa~xb~xc])

            res = 1.0;
        }
    }

    else if ( !isfullnorm && ns && !justcalcip )
    {
        Vector<int> splitPoint(ns);
        Vector<int> splitType(ns);

        if ( ns )
        {
            for ( q = indstart ; q < indend ; ++q )
            {
                if ( isSplit(q) )
                {
                    splitPoint("&",r) = q;
                    splitType("&",r) = isSplit(q);
                    ++r;
                }
            }
        }

        int indstarta = indstart;
        int indenda   = indend;

        int indstartb = indstart;
        int indendb   = indend;

        int indstartc = indstart;
        int indendc   = indend;

        if ( ns == 1 )
        {
            indstarta = indstart;
            indenda   = splitPoint(z);

            indstartb = splitPoint(z)+1;
            indendb   = indend;

            indstartc = indstart;
            indendc   = splitPoint(z);
        }

        else if ( ns == 2 )
        {
            indstarta = indstart;
            indenda   = splitPoint(z);

            indstartb = splitPoint(z)+1;
            indendb   = splitPoint(1);

            indstartc = splitPoint(1)+1;
            indendc   = indend;
        }

        else if ( ns >= 3 )
        {
            indstarta = indstart;
            indenda   = splitPoint(z);

            indstartb = splitPoint(z)+1;
            indendb   = splitPoint(1);

            indstartc = splitPoint(1)+1;
            indendc   = splitPoint(2);
        }

        // 1:1:1, 
        // 2:2:1, 1:2:2
        // 3:3:3

        if ( ( xainfo.xusize() == 1 ) && ( xbinfo.xusize() == 1 ) )
        {
            KK3(res,logres,logresvalid,xa,xb,xc,xainfo,xbinfo,xcinfo,xagradOrder,xbgradOrder,xcgradOrder,xaff,xbff,xcff,bias,nullptr,ia,ib,ic,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,justcalcip,indstarta,indenda,iaset,ibset,icset);
        }

        else if ( xainfo.xusize() == 2 )
        {
            KK2(0,0,res,logres,logresvalid,xa,xc,xainfo,xcinfo,xagradOrder,xcgradOrder,xaff,xcff,bias,nullptr,ia,ic,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,justcalcip,indstarta,indenda,iaset,icset);
            KK1(tempres,logres,logresvalid,xb,xbinfo,xbgradOrder,xbff,bias,nullptr,ic,xdim,xconsist,assumreal,resmode,mlid,nullptr,justcalcip,indstartb,indendb,ibset);

            if ( splitType(0) == 1 )
            {
                res *= tempres;
            }

            else
            {
                res += tempres;
            }
        }

        else if ( xbinfo.xusize() == 2 )
        {
            KK2(0,0,res,logres,logresvalid,xa,xb,xainfo,xbinfo,xagradOrder,xbgradOrder,xaff,xbff,bias,nullptr,ia,ib,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,justcalcip,indstarta,indenda,iaset,ibset);
            KK1(tempres,logres,logresvalid,xc,xcinfo,xcgradOrder,xcff,bias,nullptr,ic,xdim,xconsist,assumreal,resmode,mlid,nullptr,justcalcip,indstartb,indendb,icset);

            if ( splitType(0) == 1 )
            {
                res *= tempres;
            }

            else
            {
                res += tempres;
            }
        }

        else
        {
            // xainfo.usize() == 3

            KK1(     res,logres,logresvalid,xa,xainfo,xagradOrder,xaff,bias,nullptr,ia,xdim,xconsist,assumreal,resmode,mlid,nullptr,justcalcip,indstarta,indenda,iaset);
            KK1( tempres,logres,logresvalid,xb,xbinfo,xbgradOrder,xbff,bias,nullptr,ib,xdim,xconsist,assumreal,resmode,mlid,nullptr,justcalcip,indstartb,indendb,ibset);
            KK1(xtempres,logres,logresvalid,xc,xcinfo,xcgradOrder,xcff,bias,nullptr,ic,xdim,xconsist,assumreal,resmode,mlid,nullptr,justcalcip,indstartc,indendc,icset);

            if ( splitType(0) == 1 )
            {
                res *=  tempres;
            }

            else
            {
                res +=  tempres;
            }

            if ( splitType(1) == 1 )
            {
                res *= xtempres;
            }

            else
            {
                res += xtempres;
            }
        }
    }

    else if ( isfullnorm && ns && !justcalcip )
    {
        Vector<int> splitPoint(ns);

        if ( ns )
        {
            for ( q = indstart ; q < indend ; ++q )
            {
                if ( isSplit(q) )
                {
                    splitPoint("&",r) = q;
                    NiceAssert( isSplit(q) == 1 );
                    ++r;
                }
            }
        }


        int indstarta = indstart;
        int indenda   = indend;

//        int indstartb = indstart;
//        int indendb   = indend;
//
//        int indstartc = indstart;
//        int indendc   = indend;
//
        if ( ns == 1 )
        {
            indstarta = indstart;
            indenda   = splitPoint(z);
//
//            indstartb = splitPoint(z)+1;
//            indendb   = indend;
//
//            indstartc = indstart;
//            indendc   = splitPoint(z);
        }

        else if ( ns == 2 )
        {
            indstarta = indstart;
            indenda   = splitPoint(z);
//
//            indstartb = splitPoint(z)+1;
//            indendb   = splitPoint(1);
//
//            indstartc = splitPoint(1)+1;
//            indendc   = indend;
        }

        else if ( ns >= 3 )
        {
            indstarta = indstart;
            indenda   = splitPoint(z);
//
//            indstartb = splitPoint(z)+1;
//            indendb   = splitPoint(1);
//
//            indstartc = splitPoint(1)+1;
//            indendc   = splitPoint(2);
        }

        // 1:1:1, 
        // 2:2:1, 1:2:2
        // 3:3:3

        if ( ( xainfo.xusize() == 1 ) && ( xbinfo.xusize() == 1 ) )
        {
            T tma;
            T tmb;
            T tmc;

            T logtma;
            T logtmb;
            T logtmc;

            int logtmavalid = 0;
            int logtmbvalid = 0;
            int logtmcvalid = 0;

//            KK3(res,logres,logresvalid,xa,xb,xc,xainfo,xbinfo,xcinfo,xagradOrder,xbgradOrder,xcgradOrder,xaff,xbff,xcff,bias,nullptr,ia,ib,ic,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,justcalcip,indstarta,indenda,iaset,ibset,icset);

            KK3(tma,logtma,logtmavalid,xa,xa,xa,xainfo,xainfo,xainfo,xagradOrder,xagradOrder,xagradOrder,xaff,xaff,xaff,bias,nullptr,ia,ia,ia,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,justcalcip,indstarta,indenda,iaset,iaset,iaset);
            KK3(tmb,logtmb,logtmbvalid,xb,xb,xb,xbinfo,xbinfo,xbinfo,xbgradOrder,xbgradOrder,xbgradOrder,xbff,xbff,xbff,bias,nullptr,ib,ib,ib,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,justcalcip,indstarta,indenda,ibset,ibset,ibset);
            KK3(tmc,logtmc,logtmcvalid,xc,xc,xc,xcinfo,xcinfo,xcinfo,xcgradOrder,xcgradOrder,xcgradOrder,xcff,xcff,xcff,bias,nullptr,ic,ic,ic,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,justcalcip,indstarta,indenda,icset,icset,icset);

            if ( ( ( (double) abs2(tma) <= BADZEROTOL ) && ( (double) abs2(tmb) <= BADZEROTOL ) ) ||
                 ( ( (double) abs2(tma) <= BADZEROTOL ) && ( (double) abs2(tmc) <= BADZEROTOL ) ) ||
                 ( ( (double) abs2(tmb) <= BADZEROTOL ) && ( (double) abs2(tmc) <= BADZEROTOL ) )    )
            {
                res = 1.0;
            }

            else if ( (double) abs2(tma) <= BADZEROTOL )
            {
                KK2(0,0,res,logres,logresvalid,xb,xc,xbinfo,xcinfo,xbgradOrder,xcgradOrder,xbff,xcff,bias,nullptr,ib,ic,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,justcalcip,indstart,indend,ibset,icset);

                if ( logresvalid && logtmbvalid && logtmcvalid )
                {
                    logtmb /= 2.0;
                    logtmc /= 2.0;

                    res = logres;

                    res -= logtmb;
                    res -= logtmc;

                    OP_exp(res);
                }

                else
                {
                    tmb *= tmc;
                    OP_sqrt(tmb);
                    safedivby(res,tmb); //res /= tmb;
                }
            }

            else if ( (double) abs2(tmb) <= BADZEROTOL )
            {
                KK2(0,0,res,logres,logresvalid,xa,xc,xainfo,xcinfo,xagradOrder,xcgradOrder,xaff,xcff,bias,nullptr,ia,ic,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,justcalcip,indstart,indend,iaset,icset);

                if ( logresvalid && logtmavalid && logtmcvalid )
                {
                    logtma /= 2.0;
                    logtmc /= 2.0;

                    res = logres;

                    res -= logtma;
                    res -= logtmc;

                    OP_exp(res);
                }

                else
                {
                    tma *= tmc;
                    OP_sqrt(tma);
                    safedivby(res,tma); //res /= tma;
                }
            }

            else if ( (double) abs2(tmc) <= BADZEROTOL )
            {
                KK2(0,0,res,logres,logresvalid,xa,xb,xainfo,xbinfo,xagradOrder,xbgradOrder,xaff,xbff,bias,nullptr,ia,ib,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,justcalcip,indstart,indend,iaset,ibset);

                if ( logresvalid && logtmavalid && logtmbvalid )
                {
                    logtma /= 2.0;
                    logtmb /= 2.0;

                    res = logres;

                    res -= logtma;
                    res -= logtmb;

                    OP_exp(res);
                }

                else
                {
                    tma *= tmb;
                    OP_sqrt(tma);
                    safedivby(res,tma); //res /= tma;
                }
            }

            else
            {
                KK3(res,logres,logresvalid,xa,xb,xc,xainfo,xbinfo,xcinfo,xagradOrder,xbgradOrder,xcgradOrder,xaff,xbff,xcff,bias,nullptr,ia,ib,ic,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,justcalcip,indstarta,indenda,iaset,ibset,icset);

                if ( logresvalid && logtmavalid && logtmbvalid && logtmcvalid )
                {
                    logtma /= 3.0;
                    logtmb /= 3.0;
                    logtmc /= 3.0;

                    res = logres;

                    res -= logtma;
                    res -= logtmb;
                    res -= logtmc;

                    OP_exp(res);
                }

                else
                {
                    tma *= tmb;
                    tma *= tmc;

                    T sf; sf = 1.0/3.0;

                    safedivby(res,pow(tma,sf)); //res /= pow(tma,sf);
                }
            }
        }

        else if ( xainfo.xusize() == 2 )
        {
            T tma;
            T tmc;

            T logtma;
            T logtmc;

            int logtmavalid = 0;
            int logtmcvalid = 0;

//            KK2(res,logres,logresvalid,xa,xc,xainfo,xcinfo,xagradOrder,xcgradOrder,xaff,xcff,bias,nullptr,ia,ic,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,justcalcip,indstarta,indenda,iaset,icset);

            KK2(0,0,tma,logtma,logtmavalid,xa,xa,xainfo,xainfo,xagradOrder,xagradOrder,xaff,xaff,bias,nullptr,ia,ia,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,justcalcip,indstarta,indenda,iaset,iaset);
            KK2(0,0,tmc,logtmc,logtmcvalid,xc,xc,xcinfo,xcinfo,xcgradOrder,xcgradOrder,xcff,xcff,bias,nullptr,ic,ic,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,justcalcip,indstarta,indenda,icset,icset);

            if ( ( (double) abs2(tma) <= BADZEROTOL ) || ( (double) abs2(tmc) <= BADZEROTOL ) )
            {
                res = 1.0;
            }

            else
            {
                KK2(0,0,res,logres,logresvalid,xa,xc,xainfo,xcinfo,xagradOrder,xcgradOrder,xaff,xcff,bias,nullptr,ia,ic,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,justcalcip,indstarta,indenda,iaset,icset);

                if ( logresvalid && logtmavalid && logtmcvalid )
                {
                    logtma /= 2.0;
                    logtmc /= 2.0;

                    res = logres;

                    res -= logtma;
                    res -= logtmc;

                    OP_exp(res);
                }

                else
                {
                    tma *= tmc;
                    OP_sqrt(tma);
                    safedivby(res,tma); //res /= tma;
                }
            }
        }

        else if ( xbinfo.xusize() == 2 )
        {
            T tma;
            T tmb;

            T logtma;
            T logtmb;

            int logtmavalid = 0;
            int logtmbvalid = 0;

//            KK2(res,logres,logresvalid,xa,xb,xainfo,xbinfo,xagradOrder,xbgradOrder,xaff,xbff,bias,nullptr,ia,ib,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,justcalcip,indstarta,indenda,iaset,ibset);

            KK2(0,0,tma,logtma,logtmavalid,xa,xa,xainfo,xainfo,xagradOrder,xagradOrder,xaff,xaff,bias,nullptr,ia,ia,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,justcalcip,indstarta,indenda,iaset,iaset);
            KK2(0,0,tmb,logtmb,logtmbvalid,xb,xb,xbinfo,xbinfo,xbgradOrder,xbgradOrder,xbff,xbff,bias,nullptr,ib,ib,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,justcalcip,indstarta,indenda,ibset,ibset);

            if ( ( (double) abs2(tma) <= BADZEROTOL ) || ( (double) abs2(tmb) <= BADZEROTOL ) )
            {
                res = 1.0;
            }

            else
            {
                KK2(0,0,res,logres,logresvalid,xa,xb,xainfo,xbinfo,xagradOrder,xbgradOrder,xaff,xbff,bias,nullptr,ia,ib,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,justcalcip,indstarta,indenda,iaset,ibset);

                if ( logresvalid && logtmavalid && logtmbvalid )
                {
                    logtma /= 2.0;
                    logtmb /= 2.0;

                    res = logres;

                    res -= logtma;
                    res -= logtmb;

                    OP_exp(res);
                }

                else
                {
                    tma *= tmb;
                    OP_sqrt(tma);
                    safedivby(res,tma); //res /= tma;
                }
            }
        }

        else
        {
            res = 1.0;
        }
    }

    else
    {
        KK3(res,logres,logresvalid,xa,xb,xc,xainfo,xbinfo,xcinfo,xagradOrder,xbgradOrder,xcgradOrder,xaff,xbff,xcff,bias,pxyprod,ia,ib,ic,xdim,xconsist,assumreal,resmode,mlid,xy00,xy10,xy11,xy20,xy21,xy22,nullptr,justcalcip,indstart,indend,iaset,ibset,icset);
    }




    return res;
}

//phantomx
template <class T>
T &MercerKernel::xKK4(T &res,
                     const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, const SparseVector<gentype> &xc, const SparseVector<gentype> &xd,
                     const vecInfo &xainfo, const vecInfo &xbinfo, const vecInfo &xcinfo, const vecInfo &xdinfo,
                     int xagradOrder, int xbgradOrder, int xcgradOrder, int xdgradOrder,
                     const SparseVector<gentype> &xaff, const SparseVector<gentype> &xbff, const SparseVector<gentype> &xcff, const SparseVector<gentype> &xdff,
                     const T &bias,
                     const gentype **pxyprod,
                     int ia, int ib, int ic, int id,
                     int xdim, int xconsist, int assumreal, int resmode, int mlid, int justcalcip,
                     const double *xy00, const double *xy10, const double *xy11, const double *xy20, const double *xy21, const double *xy22, const double *xy30, const double *xy31, const double *xy32, const double *xy33, int iaset, int ibset, int icset, int idset, int indstart, int indend, int ns) const
{
    T logres; logres = 0.0;
    T atempres; atempres = 0.0;
    T btempres; btempres = 0.0;
    T ctempres; ctempres = 0.0;
    int logresvalid = 0;
    //int ns = numSplits();
    int q,r = 0;
    int z = 0;

    NiceAssert( !isfullnorm || ( !xagradOrder && !xbgradOrder && !xcgradOrder && !xdgradOrder ) );

    if ( isfullnorm && !ns && !justcalcip )
    {
        // 1:1:1:1
        // 2:2:1:1, 1:2:2:1, 1:1:2:2
        // 2:2:2:2
        // 3:3:3:1, 1:3:3:3
        // 4:4:4:4

        if ( ( xainfo.xusize() == 1 ) && ( xbinfo.xusize() == 1 ) && ( xcinfo.xusize() == 1 ) )
        {
            T tma;
            T tmb;
            T tmc;
            T tmd;

            T logtma;
            T logtmb;
            T logtmc;
            T logtmd;

            int logtmavalid;
            int logtmbvalid;
            int logtmcvalid;
            int logtmdvalid;

//            KK4(res,logres,logresvalid,xa,xb,xc,xd,xainfo,xbinfo,xcinfo,xdinfo,xagradOrder,xbgradOrder,xcgradOrder,xdgradOrder,xaff,xbff,xcff,xdff,bias,nullptr,ia,ib,ic,id,xdim,xconsist,assumreal,resmode,mlid,nullptr,justcalcip,xy00,xy10,xy11,xy20,xy21,xy22,xy30,xy31,xy32,xy33,indstart,indend,iaset,ibset,icset,idset);

            KK4(tma,logtma,logtmavalid,xa,xa,xa,xa,xainfo,xainfo,xainfo,xainfo,xagradOrder,xagradOrder,xagradOrder,xagradOrder,xaff,xaff,xaff,xaff,bias,nullptr,ia,ia,ia,ia,xdim,xconsist,assumreal,resmode,mlid,nullptr,justcalcip,xy00,xy00,xy00,xy00,xy00,xy00,xy00,xy00,xy00,xy00,indstart,indend,iaset,iaset,iaset,iaset);
            KK4(tmb,logtmb,logtmbvalid,xb,xb,xb,xb,xbinfo,xbinfo,xbinfo,xbinfo,xbgradOrder,xbgradOrder,xbgradOrder,xbgradOrder,xbff,xbff,xbff,xbff,bias,nullptr,ib,ib,ib,ib,xdim,xconsist,assumreal,resmode,mlid,nullptr,justcalcip,xy11,xy11,xy11,xy11,xy11,xy11,xy11,xy11,xy11,xy11,indstart,indend,ibset,ibset,ibset,ibset);
            KK4(tmc,logtmc,logtmcvalid,xc,xc,xc,xc,xcinfo,xcinfo,xcinfo,xcinfo,xcgradOrder,xcgradOrder,xcgradOrder,xcgradOrder,xcff,xcff,xcff,xcff,bias,nullptr,ic,ic,ic,ic,xdim,xconsist,assumreal,resmode,mlid,nullptr,justcalcip,xy22,xy22,xy22,xy22,xy22,xy22,xy22,xy22,xy22,xy22,indstart,indend,icset,icset,icset,icset);
            KK4(tmd,logtmd,logtmdvalid,xd,xd,xd,xd,xdinfo,xdinfo,xdinfo,xdinfo,xdgradOrder,xdgradOrder,xdgradOrder,xdgradOrder,xdff,xdff,xdff,xdff,bias,nullptr,id,id,id,id,xdim,xconsist,assumreal,resmode,mlid,nullptr,justcalcip,xy33,xy33,xy33,xy33,xy33,xy33,xy33,xy33,xy33,xy33,indstart,indend,idset,idset,idset,idset);

            if ( ( ( (double) abs2(tma) <= BADZEROTOL ) && ( (double) abs2(tmb) <= BADZEROTOL ) && ( (double) abs2(tmc) <= BADZEROTOL ) ) ||
                 ( ( (double) abs2(tma) <= BADZEROTOL ) && ( (double) abs2(tmb) <= BADZEROTOL ) && ( (double) abs2(tmd) <= BADZEROTOL ) ) ||
                 ( ( (double) abs2(tma) <= BADZEROTOL ) && ( (double) abs2(tmc) <= BADZEROTOL ) && ( (double) abs2(tmd) <= BADZEROTOL ) ) ||
                 ( ( (double) abs2(tmb) <= BADZEROTOL ) && ( (double) abs2(tmc) <= BADZEROTOL ) && ( (double) abs2(tmd) <= BADZEROTOL ) )    )
            {
                res = 1.0;
            }

            else if ( ( (double) abs2(tma) <= BADZEROTOL ) && ( (double) abs2(tmb) <= BADZEROTOL ) )
            {
                KK2(0,0,res,logres,logresvalid,xc,xd,xcinfo,xdinfo,xcgradOrder,xdgradOrder,xcff,xdff,bias,nullptr,ic,id,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,justcalcip,indstart,indend,icset,idset);

                if ( logresvalid && logtmcvalid && logtmdvalid )
                {
                    logtmc /= 2.0;
                    logtmd /= 2.0;

                    res = logres;

                    res -= logtmc;
                    res -= logtmd;

                    OP_exp(res);
                }

                else
                {
                    tmc *= tmd;
                    OP_sqrt(tmc);
                    safedivby(res,tmc); //res /= tmc;
                }
            }

            else if ( ( (double) abs2(tma) <= BADZEROTOL ) && ( (double) abs2(tmc) <= BADZEROTOL ) )
            {
                KK2(0,0,res,logres,logresvalid,xb,xd,xbinfo,xdinfo,xbgradOrder,xdgradOrder,xbff,xdff,bias,nullptr,ib,id,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,justcalcip,indstart,indend,ibset,idset);

                if ( logresvalid && logtmbvalid && logtmdvalid )
                {
                    logtmb /= 2.0;
                    logtmd /= 2.0;

                    res = logres;

                    res -= logtmb;
                    res -= logtmd;

                    OP_exp(res);
                }

                else
                {
                    tmb *= tmd;
                    OP_sqrt(tmb);
                    safedivby(res,tmb); //res /= tmb;
                }
            }

            else if ( ( (double) abs2(tma) <= BADZEROTOL ) && ( (double) abs2(tmd) <= BADZEROTOL ) )
            {
                KK2(0,0,res,logres,logresvalid,xb,xc,xbinfo,xcinfo,xbgradOrder,xcgradOrder,xbff,xcff,bias,nullptr,ib,ic,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,justcalcip,indstart,indend,ibset,icset);

                if ( logresvalid && logtmbvalid && logtmcvalid )
                {
                    logtmb /= 2.0;
                    logtmc /= 2.0;

                    res = logres;

                    res -= logtmb;
                    res -= logtmc;

                    OP_exp(res);
                }

                else
                {
                    tmb *= tmc;
                    OP_sqrt(tmb);
                    safedivby(res,tmb); //res /= tmb;
                }
            }

            else if ( ( (double) abs2(tmb) <= BADZEROTOL ) && ( (double) abs2(tmc) <= BADZEROTOL ) )
            {
                KK2(0,0,res,logres,logresvalid,xa,xd,xainfo,xdinfo,xagradOrder,xdgradOrder,xaff,xdff,bias,nullptr,ia,id,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,justcalcip,indstart,indend,iaset,idset);

                if ( logresvalid && logtmavalid && logtmdvalid )
                {
                    logtma /= 2.0;
                    logtmd /= 2.0;

                    res = logres;

                    res -= logtma;
                    res -= logtmd;

                    OP_exp(res);
                }

                else
                {
                    tma *= tmd;
                    OP_sqrt(tma);
                    safedivby(res,tma); //res /= tma;
                }
            }

            else if ( ( (double) abs2(tmb) <= BADZEROTOL ) && ( (double) abs2(tmd) <= BADZEROTOL ) )
            {
                KK2(0,0,res,logres,logresvalid,xa,xc,xainfo,xcinfo,xagradOrder,xcgradOrder,xaff,xcff,bias,nullptr,ia,ic,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,justcalcip,indstart,indend,iaset,icset);

                if ( logresvalid && logtmavalid && logtmcvalid )
                {
                    logtma /= 2.0;
                    logtmc /= 2.0;

                    res = logres;

                    res -= logtma;
                    res -= logtmc;

                    OP_exp(res);
                }

                else
                {
                    tma *= tmc;
                    OP_sqrt(tma);
                    safedivby(res,tma); //res /= tma;
                }
            }

            else if ( ( (double) abs2(tmc) <= BADZEROTOL ) && ( (double) abs2(tmd) <= BADZEROTOL ) )
            {
                KK2(0,0,res,logres,logresvalid,xa,xb,xainfo,xbinfo,xagradOrder,xbgradOrder,xaff,xbff,bias,nullptr,ia,ib,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,justcalcip,indstart,indend,iaset,ibset);

                if ( logresvalid && logtmavalid && logtmbvalid )
                {
                    logtma /= 2.0;
                    logtmb /= 2.0;

                    res = logres;

                    res -= logtma;
                    res -= logtmb;

                    OP_exp(res);
                }

                else
                {
                    tma *= tmb;
                    OP_sqrt(tma);
                    safedivby(res,tma); //res /= tma;
                }
            }

            else if ( (double) abs2(tma) <= BADZEROTOL )
            {
                KK3(res,logres,logresvalid,xb,xc,xd,xbinfo,xcinfo,xdinfo,xbgradOrder,xcgradOrder,xdgradOrder,xbff,xcff,xdff,bias,nullptr,ib,ic,id,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,justcalcip,indstart,indend,ibset,icset,idset);

                if ( logresvalid && logtmbvalid && logtmcvalid && logtmdvalid )
                {
                    logtmb /= 3.0;
                    logtmc /= 3.0;
                    logtmd /= 3.0;

                    res = logres;

                    res -= logtmb;
                    res -= logtmc;
                    res -= logtmd;

                    OP_exp(res);
                }

                else
                {
                    T oneonm; oneonm = 1.0/3.0;

                    tmb *= tmc;
                    tmb *= tmd;
                    tmb = pow(tmb,oneonm);
                    safedivby(res,tmb); //res /= tmb;
                }
            }

            else if ( (double) abs2(tmb) <= BADZEROTOL )
            {
                KK3(res,logres,logresvalid,xa,xc,xd,xainfo,xcinfo,xdinfo,xagradOrder,xcgradOrder,xdgradOrder,xaff,xcff,xdff,bias,nullptr,ia,ic,id,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,justcalcip,indstart,indend,iaset,icset,idset);

                if ( logresvalid && logtmavalid && logtmcvalid && logtmdvalid )
                {
                    logtma /= 3.0;
                    logtmc /= 3.0;
                    logtmd /= 3.0;

                    res = logres;

                    res -= logtma;
                    res -= logtmc;
                    res -= logtmd;

                    OP_exp(res);
                }

                else
                {
                    T oneonm; oneonm = 1.0/3.0;

                    tma *= tmc;
                    tma *= tmd;
                    tma = pow(tma,oneonm);
                    safedivby(res,tma); //res /= tma;
                }
            }

            else if ( (double) abs2(tmc) <= BADZEROTOL )
            {
                KK3(res,logres,logresvalid,xa,xb,xd,xainfo,xbinfo,xdinfo,xagradOrder,xbgradOrder,xdgradOrder,xaff,xbff,xdff,bias,nullptr,ia,ib,id,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,justcalcip,indstart,indend,iaset,ibset,idset);

                if ( logresvalid && logtmavalid && logtmbvalid && logtmdvalid )
                {
                    logtma /= 3.0;
                    logtmb /= 3.0;
                    logtmd /= 3.0;

                    res = logres;

                    res -= logtma;
                    res -= logtmb;
                    res -= logtmd;

                    OP_exp(res);
                }

                else
                {
                    T oneonm; oneonm = 1.0/3.0;

                    tma *= tmb;
                    tma *= tmd;
                    tma = pow(tma,oneonm);
                    safedivby(res,tma); //res /= tma;
                }
            }

            else if ( (double) abs2(tmd) <= BADZEROTOL )
            {
                KK3(res,logres,logresvalid,xa,xb,xc,xainfo,xbinfo,xcinfo,xagradOrder,xbgradOrder,xcgradOrder,xaff,xbff,xcff,bias,nullptr,ia,ib,ic,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,justcalcip,indstart,indend,iaset,ibset,icset);

                if ( logresvalid && logtmavalid && logtmbvalid && logtmcvalid )
                {
                    logtma /= 3.0;
                    logtmb /= 3.0;
                    logtmc /= 3.0;

                    res = logres;

                    res -= logtma;
                    res -= logtmb;
                    res -= logtmc;

                    OP_exp(res);
                }

                else
                {
                    T oneonm; oneonm = 1.0/3.0;

                    tma *= tmb;
                    tma *= tmc;
                    tma = pow(tma,oneonm);
                    safedivby(res,tma); //res /= tma;
                }
            }

            else
            {
                KK4(res,logres,logresvalid,xa,xb,xc,xd,xainfo,xbinfo,xcinfo,xdinfo,xagradOrder,xbgradOrder,xcgradOrder,xdgradOrder,xaff,xbff,xcff,xdff,bias,nullptr,ia,ib,ic,id,xdim,xconsist,assumreal,resmode,mlid,nullptr,justcalcip,xy00,xy10,xy11,xy20,xy21,xy22,xy30,xy31,xy32,xy33,indstart,indend,iaset,ibset,icset,idset);

                if ( logresvalid && logtmavalid && logtmbvalid && logtmcvalid && logtmdvalid )
                {
                    logtma /= 4.0;
                    logtmb /= 4.0;
                    logtmc /= 4.0;
                    logtmd /= 4.0;

                    res = logres;

                    res -= logtma;
                    res -= logtmb;
                    res -= logtmc;
                    res -= logtmd;

                    OP_exp(res);
                }

                else
                {
                    tma *= tmb;
                    tma *= tmc;
                    tma *= tmd;
                    OP_sqrt(tma);
                    OP_sqrt(tma);
                    safedivby(res,tma); //res /= tma;
                }
            }
        }

        else if ( ( xainfo.xusize() == 2 ) && ( xcinfo.xusize() == 1 ) )
        {
            T tma;
            T tmc;
            T tmd;

            T logtma;
            T logtmc;
            T logtmd;

            int logtmavalid;
            int logtmcvalid;
            int logtmdvalid;

//            KK4(res,logres,logresvalid,xa,xb,xc,xd,xainfo,xbinfo,xcinfo,xdinfo,xagradOrder,xbgradOrder,xcgradOrder,xdgradOrder,xaff,xbff,xcff,xdff,bias,nullptr,ia,ib,ic,id,xdim,xconsist,assumreal,resmode,mlid,nullptr,justcalcip,xy00,xy10,xy11,xy20,xy21,xy22,xy30,xy31,xy32,xy33,indstart,indend,iaset,ibset,icset,idset);

            KK6(tma,logtma,logtmavalid,xa,xb,xa,xb,xa,xb,xainfo,xbinfo,xainfo,xbinfo,xainfo,xbinfo,xagradOrder,xbgradOrder,xagradOrder,xbgradOrder,xagradOrder,xbgradOrder,xaff,xbff,xaff,xbff,xaff,xbff,bias,nullptr,ia,ib,ia,ib,ia,ib,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,justcalcip,indstart,indend,iaset,ibset,iaset,ibset,iaset,ibset);
            KK3(tmc,logtmc,logtmcvalid,xc,xc,xc,xcinfo,xcinfo,xcinfo,xcgradOrder,xcgradOrder,xcgradOrder,xcff,xcff,xcff,bias,nullptr,ic,ic,ic,xdim,xconsist,assumreal,mlid,resmode,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,justcalcip,indstart,indend,icset,icset,icset);
            KK3(tmd,logtmd,logtmdvalid,xd,xd,xd,xdinfo,xdinfo,xdinfo,xdgradOrder,xdgradOrder,xdgradOrder,xdff,xdff,xdff,bias,nullptr,id,id,id,xdim,xconsist,assumreal,mlid,resmode,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,justcalcip,indstart,indend,idset,idset,idset);

            if ( ( ( (double) abs2(tma) <= BADZEROTOL ) && ( (double) abs2(tmc) <= BADZEROTOL ) ) ||
                 ( ( (double) abs2(tma) <= BADZEROTOL ) && ( (double) abs2(tmd) <= BADZEROTOL ) ) ||
                 ( ( (double) abs2(tmc) <= BADZEROTOL ) && ( (double) abs2(tmd) <= BADZEROTOL ) )    )
            {
                res = 1.0;
            }

            else if ( (double) abs2(tma) <= BADZEROTOL )
            {
                KK2(0,0,res,logres,logresvalid,xc,xd,xcinfo,xdinfo,xcgradOrder,xdgradOrder,xcff,xdff,bias,nullptr,ic,id,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,justcalcip,indstart,indend,icset,idset);

                if ( logresvalid && logtmcvalid && logtmdvalid )
                {
                    logtmc /= 2.0;
                    logtmd /= 2.0;

                    res = logres;

                    res -= logtmc;
                    res -= logtmd;

                    OP_exp(res);
                }

                else
                {
                    tmc *= tmd;
                    OP_sqrt(tmc);
                    safedivby(res,tmc); //res /= tmc;
                }
            }

            else if ( (double) abs2(tmc) <= BADZEROTOL )
            {
                KK3(res,logres,logresvalid,xa,xb,xd,xainfo,xbinfo,xdinfo,xagradOrder,xbgradOrder,xdgradOrder,xaff,xbff,xdff,bias,nullptr,ia,ib,id,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,justcalcip,indstart,indend,iaset,ibset,idset);

                if ( logresvalid && logtmavalid && logtmdvalid )
                {
                    logtma /= 2.0;
                    logtmd /= 2.0;

                    res = logres;

                    res -= logtma;
                    res -= logtmd;

                    OP_exp(res);
                }

                else
                {
                    tma *= tmd;
                    OP_sqrt(tma);
                    safedivby(res,tma); //res /= tma;
                }
            }

            else if ( (double) abs2(tmd) <= BADZEROTOL )
            {
                KK3(res,logres,logresvalid,xa,xb,xc,xainfo,xbinfo,xcinfo,xagradOrder,xbgradOrder,xcgradOrder,xaff,xbff,xcff,bias,nullptr,ia,ib,ic,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,justcalcip,indstart,indend,iaset,ibset,icset);

                if ( logresvalid && logtmavalid && logtmcvalid )
                {
                    logtma /= 2.0;
                    logtmc /= 2.0;

                    res = logres;

                    res -= logtma;
                    res -= logtmc;

                    OP_exp(res);
                }

                else
                {
                    tma *= tmc;
                    OP_sqrt(tma);
                    safedivby(res,tma); //res /= tma;
                }
            }

            else
            {
                KK4(res,logres,logresvalid,xa,xb,xc,xd,xainfo,xbinfo,xcinfo,xdinfo,xagradOrder,xbgradOrder,xcgradOrder,xdgradOrder,xaff,xbff,xcff,xdff,bias,nullptr,ia,ib,ic,id,xdim,xconsist,assumreal,resmode,mlid,nullptr,justcalcip,xy00,xy10,xy11,xy20,xy21,xy22,xy30,xy31,xy32,xy33,indstart,indend,iaset,ibset,icset,idset);

                if ( logresvalid && logtmavalid && logtmcvalid && logtmdvalid )
                {
                    logtma /= 3.0;
                    logtmc /= 3.0;
                    logtmd /= 3.0;

                    res = logres;

                    res -= logtma;
                    res -= logtmc;
                    res -= logtmd;

                    OP_exp(res);
                }

                else
                {
                    T oneonm; oneonm = 1.0/3.0;

                    tma *= tmc;
                    tma *= tmd;
                    tma = pow(tma,oneonm);
                    safedivby(res,tma); //res /= tma;
                }
            }
        }

        else if ( ( xainfo.xusize() == 1 ) && ( xbinfo.xusize() == 2 ) )
        {
            T tma;
            T tmb;
            T tmd;

            T logtma;
            T logtmb;
            T logtmd;

            int logtmavalid;
            int logtmbvalid;
            int logtmdvalid;

//            KK4(res,logres,logresvalid,xa,xb,xc,xd,xainfo,xbinfo,xcinfo,xdinfo,xagradOrder,xbgradOrder,xcgradOrder,xdgradOrder,xaff,xbff,xcff,xdff,bias,nullptr,ia,ib,ic,id,xdim,xconsist,assumreal,resmode,mlid,nullptr,justcalcip,xy00,xy10,xy11,xy20,xy21,xy22,xy30,xy31,xy32,xy33,indstart,indend,iaset,ibset,icset,idset);

            KK3(tma,logtma,logtmavalid,xa,xa,xa,xainfo,xainfo,xainfo,xagradOrder,xagradOrder,xagradOrder,xaff,xaff,xaff,bias,nullptr,ia,ia,ia,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,justcalcip,indstart,indend,iaset,iaset,iaset);
            KK6(tmb,logtmb,logtmbvalid,xb,xc,xb,xc,xb,xc,xbinfo,xcinfo,xbinfo,xcinfo,xbinfo,xcinfo,xbgradOrder,xcgradOrder,xbgradOrder,xcgradOrder,xbgradOrder,xcgradOrder,xbff,xcff,xbff,xcff,xbff,xcff,bias,nullptr,ib,ic,ib,ic,ib,ic,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,justcalcip,indstart,indend,ibset,icset,ibset,icset,ibset,icset);
            KK3(tmd,logtmd,logtmdvalid,xd,xd,xd,xdinfo,xdinfo,xdinfo,xdgradOrder,xdgradOrder,xdgradOrder,xdff,xdff,xdff,bias,nullptr,id,id,id,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,justcalcip,indstart,indend,idset,idset,idset);

            if ( ( ( (double) abs2(tma) <= BADZEROTOL ) && ( (double) abs2(tmb) <= BADZEROTOL ) ) ||
                 ( ( (double) abs2(tma) <= BADZEROTOL ) && ( (double) abs2(tmd) <= BADZEROTOL ) ) ||
                 ( ( (double) abs2(tmb) <= BADZEROTOL ) && ( (double) abs2(tmd) <= BADZEROTOL ) )    )
            {
                res = 1.0;
            }

            else if ( (double) abs2(tma) <= BADZEROTOL )
            {
                KK3(res,logres,logresvalid,xb,xc,xd,xbinfo,xcinfo,xdinfo,xbgradOrder,xcgradOrder,xdgradOrder,xbff,xcff,xdff,bias,nullptr,ib,ic,id,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,justcalcip,indstart,indend,ibset,icset,idset);

                if ( logresvalid && logtmbvalid && logtmdvalid )
                {
                    logtmb /= 2.0;
                    logtmd /= 2.0;

                    res = logres;

                    res -= logtmb;
                    res -= logtmd;

                    OP_exp(res);
                }

                else
                {
                    tmb *= tmd;
                    OP_sqrt(tmb);
                    safedivby(res,tmb); //res /= tmb;
                }
            }

            else if ( (double) abs2(tmb) <= BADZEROTOL )
            {
                KK2(0,0,res,logres,logresvalid,xa,xd,xainfo,xdinfo,xagradOrder,xdgradOrder,xaff,xdff,bias,nullptr,ia,id,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,justcalcip,indstart,indend,iaset,idset);

                if ( logresvalid && logtmavalid && logtmdvalid )
                {
                    logtma /= 2.0;
                    logtmd /= 2.0;

                    res = logres;

                    res -= logtma;
                    res -= logtmd;

                    OP_exp(res);
                }

                else
                {
                    tma *= tmd;
                    OP_sqrt(tma);
                    safedivby(res,tma); //res /= tma;
                }
            }

            else if ( (double) abs2(tmd) <= BADZEROTOL )
            {
                KK3(res,logres,logresvalid,xa,xb,xc,xainfo,xbinfo,xcinfo,xagradOrder,xbgradOrder,xcgradOrder,xaff,xbff,xcff,bias,nullptr,ia,ib,ic,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,justcalcip,indstart,indend,iaset,ibset,icset);

                if ( logresvalid && logtmavalid && logtmbvalid )
                {
                    logtma /= 2.0;
                    logtmb /= 2.0;

                    res = logres;

                    res -= logtma;
                    res -= logtmb;

                    OP_exp(res);
                }

                else
                {
                    tma *= tmb;
                    OP_sqrt(tma);
                    safedivby(res,tma); //res /= tma;
                }
            }

            else
            {
                KK4(res,logres,logresvalid,xa,xb,xc,xd,xainfo,xbinfo,xcinfo,xdinfo,xagradOrder,xbgradOrder,xcgradOrder,xdgradOrder,xaff,xbff,xcff,xdff,bias,nullptr,ia,ib,ic,id,xdim,xconsist,assumreal,resmode,mlid,nullptr,justcalcip,xy00,xy10,xy11,xy20,xy21,xy22,xy30,xy31,xy32,xy33,indstart,indend,iaset,ibset,icset,idset);

                if ( logresvalid && logtmavalid && logtmbvalid && logtmdvalid )
                {
                    logtma /= 3.0;
                    logtmb /= 3.0;
                    logtmd /= 3.0;

                    res = logres;

                    res -= logtma;
                    res -= logtmb;
                    res -= logtmd;

                    OP_exp(res);
                }

                else
                {
                    T oneonm; oneonm = 1.0/3.0;

                    tma *= tmb;
                    tma *= tmd;
                    tma = pow(tma,oneonm);
                    safedivby(res,tma); //res /= tma;
                }
            }
        }

        else if ( ( xainfo.xusize() == 1 ) && ( xcinfo.xusize() == 2 ) )
        {
            T tma;
            T tmb;
            T tmc;

            T logtma;
            T logtmb;
            T logtmc;

            int logtmavalid;
            int logtmbvalid;
            int logtmcvalid;

//            KK4(res,logres,logresvalid,xa,xb,xc,xd,xainfo,xbinfo,xcinfo,xdinfo,xagradOrder,xbgradOrder,xcgradOrder,xdgradOrder,xaff,xbff,xcff,xdff,bias,nullptr,ia,ib,ic,id,xdim,xconsist,assumreal,resmode,mlid,nullptr,justcalcip,xy00,xy10,xy11,xy20,xy21,xy22,xy30,xy31,xy32,xy33,indstart,indend,iaset,ibset,icset,idset);

            KK3(tma,logtma,logtmavalid,xa,xa,xa,xainfo,xainfo,xainfo,xagradOrder,xagradOrder,xagradOrder,xaff,xaff,xaff,bias,nullptr,ia,ia,ia,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,justcalcip,indstart,indend,iaset,iaset,iaset);
            KK3(tmb,logtmb,logtmbvalid,xb,xb,xb,xbinfo,xbinfo,xbinfo,xbgradOrder,xbgradOrder,xbgradOrder,xbff,xbff,xbff,bias,nullptr,ib,ib,ib,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,justcalcip,indstart,indend,ibset,ibset,ibset);
            KK6(tmc,logtmc,logtmcvalid,xc,xd,xc,xd,xc,xd,xcinfo,xdinfo,xcinfo,xdinfo,xcinfo,xdinfo,xcgradOrder,xdgradOrder,xcgradOrder,xdgradOrder,xcgradOrder,xdgradOrder,xcff,xdff,xcff,xdff,xcff,xdff,bias,nullptr,ic,id,ic,id,ic,id,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,justcalcip,indstart,indend,icset,idset,icset,idset,icset,idset);

            if ( ( ( (double) abs2(tma) <= BADZEROTOL ) && ( (double) abs2(tmb) <= BADZEROTOL ) ) ||
                 ( ( (double) abs2(tma) <= BADZEROTOL ) && ( (double) abs2(tmc) <= BADZEROTOL ) ) ||
                 ( ( (double) abs2(tmb) <= BADZEROTOL ) && ( (double) abs2(tmc) <= BADZEROTOL ) )    )
            {
                res = 1.0;
            }

            else if ( (double) abs2(tma) <= BADZEROTOL )
            {
                KK3(res,logres,logresvalid,xb,xc,xd,xbinfo,xcinfo,xdinfo,xbgradOrder,xcgradOrder,xdgradOrder,xbff,xcff,xdff,bias,nullptr,ib,ic,id,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,justcalcip,indstart,indend,ibset,icset,idset);

                if ( logresvalid && logtmbvalid && logtmcvalid )
                {
                    logtmb /= 2.0;
                    logtmc /= 2.0;

                    res = logres;

                    res -= logtmb;
                    res -= logtmc;

                    OP_exp(res);
                }

                else
                {
                    tmb *= tmc;
                    OP_sqrt(tmb);
                    safedivby(res,tmb); //res /= tmb;
                }
            }

            else if ( (double) abs2(tmb) <= BADZEROTOL )
            {
                KK3(res,logres,logresvalid,xa,xc,xd,xainfo,xcinfo,xdinfo,xagradOrder,xcgradOrder,xdgradOrder,xaff,xcff,xdff,bias,nullptr,ia,ic,id,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,justcalcip,indstart,indend,iaset,icset,idset);

                if ( logresvalid && logtmavalid && logtmcvalid )
                {
                    logtma /= 2.0;
                    logtmc /= 2.0;

                    res = logres;

                    res -= logtma;
                    res -= logtmc;

                    OP_exp(res);
                }

                else
                {
                    tma *= tmc;
                    OP_sqrt(tma);
                    safedivby(res,tma); //res /= tma;
                }
            }

            else if ( (double) abs2(tmc) <= BADZEROTOL )
            {
                KK2(0,0,res,logres,logresvalid,xa,xb,xainfo,xbinfo,xagradOrder,xbgradOrder,xaff,xbff,bias,nullptr,ia,ib,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,justcalcip,indstart,indend,iaset,ibset);

                if ( logresvalid && logtmavalid && logtmbvalid )
                {
                    logtma /= 2.0;
                    logtmb /= 2.0;

                    res = logres;

                    res -= logtma;
                    res -= logtmb;

                    OP_exp(res);
                }

                else
                {
                    tma *= tmb;
                    OP_sqrt(tma);
                    safedivby(res,tma); //res /= tma;
                }
            }

            else
            {
                KK4(res,logres,logresvalid,xa,xb,xc,xd,xainfo,xbinfo,xcinfo,xdinfo,xagradOrder,xbgradOrder,xcgradOrder,xdgradOrder,xaff,xbff,xcff,xdff,bias,nullptr,ia,ib,ic,id,xdim,xconsist,assumreal,resmode,mlid,nullptr,justcalcip,xy00,xy10,xy11,xy20,xy21,xy22,xy30,xy31,xy32,xy33,indstart,indend,iaset,ibset,icset,idset);

                if ( logresvalid && logtmavalid && logtmbvalid && logtmcvalid )
                {
                    logtma /= 3.0;
                    logtmb /= 3.0;
                    logtmc /= 3.0;

                    res = logres;

                    res -= logtma;
                    res -= logtmb;
                    res -= logtmc;

                    OP_exp(res);
                }

                else
                {
                    T oneonm; oneonm = 1.0/3.0;

                    tma *= tmb;
                    tma *= tmc;
                    tma = pow(tma,oneonm);
                    safedivby(res,tma); //res /= tma;
                }
            }
        }

        else if ( ( xainfo.xusize() == 2 ) && ( xcinfo.xusize() == 2 ) )
        {
            T tma;
            T tmc;

            T logtma;
            T logtmc;

            int logtmavalid;
            int logtmcvalid;

//            KK4(res,logres,logresvalid,xa,xb,xc,xd,xainfo,xbinfo,xcinfo,xdinfo,xagradOrder,xbgradOrder,xcgradOrder,xdgradOrder,xaff,xbff,xcff,xdff,bias,nullptr,ia,ib,ic,id,xdim,xconsist,assumreal,resmode,mlid,nullptr,justcalcip,xy00,xy10,xy11,xy20,xy21,xy22,xy30,xy31,xy32,xy33,indstart,indend,iaset,ibset,icset,idset);

            KK4(tma,logtma,logtmavalid,xa,xb,xa,xb,xainfo,xbinfo,xainfo,xbinfo,xagradOrder,xbgradOrder,xagradOrder,xbgradOrder,xaff,xbff,xaff,xbff,bias,nullptr,ia,ib,ia,ib,xdim,xconsist,assumreal,resmode,mlid,nullptr,justcalcip,xy00,xy10,xy11,xy00,xy10,xy00,xy10,xy11,xy10,xy11,indstart,indend,iaset,ibset,iaset,ibset);
            KK4(tmc,logtmc,logtmcvalid,xc,xd,xc,xd,xcinfo,xdinfo,xcinfo,xdinfo,xcgradOrder,xdgradOrder,xcgradOrder,xdgradOrder,xcff,xdff,xcff,xdff,bias,nullptr,ic,id,ic,id,xdim,xconsist,assumreal,resmode,mlid,nullptr,justcalcip,xy22,xy32,xy33,xy22,xy32,xy22,xy32,xy33,xy32,xy33,indstart,indend,icset,idset,icset,idset);

            if ( ( (double) abs2(tma) <= BADZEROTOL ) || ( (double) abs2(tmc) <= BADZEROTOL ) )
            {
                res = 1.0;
            }

            else
            {
                KK4(res,logres,logresvalid,xa,xb,xc,xd,xainfo,xbinfo,xcinfo,xdinfo,xagradOrder,xbgradOrder,xcgradOrder,xdgradOrder,xaff,xbff,xcff,xdff,bias,nullptr,ia,ib,ic,id,xdim,xconsist,assumreal,resmode,mlid,nullptr,justcalcip,xy00,xy10,xy11,xy20,xy21,xy22,xy30,xy31,xy32,xy33,indstart,indend,iaset,ibset,icset,idset);

                if ( logresvalid && logtmavalid && logtmcvalid )
                {
                    logtma /= 2.0;
                    logtmc /= 2.0;

                    res = logres;

                    res -= logtma;
                    res -= logtmc;

                    OP_exp(res);
                }

                else
                {
                    tma *= tmc;
                    OP_sqrt(tma);
                    safedivby(res,tma); //res /= tma;
                }
            }
        }

        else if ( xainfo.xusize() == 3 )
        {
            T tma;
            T tmd;

            T logtma;
            T logtmd;

            int logtmavalid;
            int logtmdvalid;

//            KK4(res,logres,logresvalid,xa,xb,xc,xd,xainfo,xbinfo,xcinfo,xdinfo,xagradOrder,xbgradOrder,xcgradOrder,xdgradOrder,xaff,xbff,xcff,xdff,bias,nullptr,ia,ib,ic,id,xdim,xconsist,assumreal,resmode,mlid,nullptr,justcalcip,xy00,xy10,xy11,xy20,xy21,xy22,xy30,xy31,xy32,xy33,indstart,indend,iaset,ibset,icset,idset);

            KK6(tma,logtma,logtmavalid,xa,xb,xc,xa,xb,xc,xainfo,xbinfo,xcinfo,xainfo,xbinfo,xcinfo,xagradOrder,xbgradOrder,xcgradOrder,xagradOrder,xbgradOrder,xcgradOrder,xaff,xbff,xcff,xaff,xbff,xcff,bias,nullptr,ia,ib,ic,ia,ib,ic,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,justcalcip,indstart,indend,iaset,ibset,icset,iaset,ibset,icset);
            KK2(0,0,tmd,logtmd,logtmdvalid,xd,xd,xdinfo,xdinfo,xdgradOrder,xdgradOrder,xdff,xdff,bias,nullptr,id,id,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,justcalcip,indstart,indend,idset,idset);

            if ( ( (double) abs2(tma) <= BADZEROTOL ) || ( (double) abs2(tmd) <= BADZEROTOL ) )
            {
                res = 1.0;
            }

            else
            {
                KK4(res,logres,logresvalid,xa,xb,xc,xd,xainfo,xbinfo,xcinfo,xdinfo,xagradOrder,xbgradOrder,xcgradOrder,xdgradOrder,xaff,xbff,xcff,xdff,bias,nullptr,ia,ib,ic,id,xdim,xconsist,assumreal,resmode,mlid,nullptr,justcalcip,xy00,xy10,xy11,xy20,xy21,xy22,xy30,xy31,xy32,xy33,indstart,indend,iaset,ibset,icset,idset);

                if ( logresvalid && logtmavalid && logtmdvalid )
                {
                    logtma /= 2.0;
                    logtmd /= 2.0;

                    res = logres;

                    res -= logtma;
                    res -= logtmd;

                    OP_exp(res);
                }

                else
                {
                    tma *= tmd;
                    OP_sqrt(tma);
                    safedivby(res,tma); //res /= tma;
                }
            }
        }

        else if ( xbinfo.xusize() == 3 )
        {
            T tma;
            T tmb;

            T logtma;
            T logtmb;

            int logtmavalid;
            int logtmbvalid;

//            KK4(res,logres,logresvalid,xa,xb,xc,xd,xainfo,xbinfo,xcinfo,xdinfo,xagradOrder,xbgradOrder,xcgradOrder,xdgradOrder,xaff,xbff,xcff,xdff,bias,nullptr,ia,ib,ic,id,xdim,xconsist,assumreal,resmode,mlid,nullptr,justcalcip,xy00,xy10,xy11,xy20,xy21,xy22,xy30,xy31,xy32,xy33,indstart,indend,iaset,ibset,icset,idset);

            KK2(0,0,tmb,logtma,logtmavalid,xa,xa,xainfo,xainfo,xagradOrder,xagradOrder,xaff,xaff,bias,nullptr,ia,ia,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,justcalcip,indstart,indend,iaset,iaset);
            KK6(tma,logtmb,logtmbvalid,xb,xc,xd,xb,xc,xd,xbinfo,xcinfo,xdinfo,xbinfo,xcinfo,xdinfo,xbgradOrder,xcgradOrder,xdgradOrder,xbgradOrder,xcgradOrder,xdgradOrder,xbff,xcff,xdff,xbff,xcff,xdff,bias,nullptr,ib,ic,id,ib,ic,id,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,justcalcip,indstart,indend,ibset,icset,idset,ibset,icset,idset);

            if ( ( (double) abs2(tma) <= BADZEROTOL ) || ( (double) abs2(tmb) <= BADZEROTOL ) )
            {
                res = 1.0;
            }

            else
            {
                KK4(res,logres,logresvalid,xa,xb,xc,xd,xainfo,xbinfo,xcinfo,xdinfo,xagradOrder,xbgradOrder,xcgradOrder,xdgradOrder,xaff,xbff,xcff,xdff,bias,nullptr,ia,ib,ic,id,xdim,xconsist,assumreal,resmode,mlid,nullptr,justcalcip,xy00,xy10,xy11,xy20,xy21,xy22,xy30,xy31,xy32,xy33,indstart,indend,iaset,ibset,icset,idset);

                if ( logresvalid && logtmavalid && logtmbvalid )
                {
                    logtma /= 2.0;
                    logtmb /= 2.0;

                    res = logres;

                    res -= logtma;
                    res -= logtmb;

                    OP_exp(res);
                }

                else
                {
                    tma *= tmb;
                    OP_sqrt(tma);
                    safedivby(res,tma); //res /= tma;
                }
            }
        }

        else
        {
            res = 1.0;
        }
    }

    else if ( !isfullnorm && ns && !justcalcip )
    {
        Vector<int> splitPoint(ns);
        Vector<int> splitType(ns);

        if ( ns )
        {
            for ( q = indstart ; q < indend ; ++q )
            {
                if ( isSplit(q) )
                {
                    splitPoint("&",r) = q;
                    splitType("&",r) = isSplit(q);
                    ++r;
                }
            }
        }

        int indstarta = indstart;
        int indenda   = indend;

        int indstartb = indstart;
        int indendb   = indend;

        int indstartc = indstart;
        int indendc   = indend;

        int indstartd = indstart;
        int indendd   = indend;

        if ( ns == 1 )
        {
            indstarta = indstart;
            indenda   = splitPoint(z);

            indstartb = splitPoint(z)+1;
            indendb   = indend;

            indstartc = indstart;
            indendc   = splitPoint(z);

            indstartd = splitPoint(z)+1;
            indendd   = indend;
        }

        else if ( ns == 2 )
        {
            indstarta = indstart;
            indenda   = splitPoint(z);

            indstartb = splitPoint(z)+1;
            indendb   = splitPoint(1);

            indstartc = splitPoint(1)+1;
            indendc   = indend;

            indstartd = indstart;
            indendd   = splitPoint(z);
        }

        else if ( ns == 3 )
        {
            indstarta = indstart;
            indenda   = splitPoint(z);

            indstartb = splitPoint(z)+1;
            indendb   = splitPoint(1);

            indstartc = splitPoint(1)+1;
            indendc   = splitPoint(2);

            indstartd = splitPoint(2)+1;
            indendd   = indend;
        }

        else if ( ns >= 4 )
        {
            indstarta = indstart;
            indenda   = splitPoint(z);

            indstartb = splitPoint(z)+1;
            indendb   = splitPoint(1);

            indstartc = splitPoint(1)+1;
            indendc   = splitPoint(2);

            indstartd = splitPoint(2)+1;
            indendd   = splitPoint(3);
        }

        // 1:1:1:1
        // 2:2:1:1, 1:2:2:1, 1:1:2:2
        // 2:2:2:2
        // 3:3:3:1, 1:3:3:3
        // 4:4:4:4

        if ( ( xainfo.xusize() == 1 ) && ( xbinfo.xusize() == 1 ) && ( xcinfo.xusize() == 1 ) )
        {
            KK4(res,logres,logresvalid,xa,xb,xc,xd,xainfo,xbinfo,xcinfo,xdinfo,xagradOrder,xbgradOrder,xcgradOrder,xdgradOrder,xaff,xbff,xcff,xdff,bias,nullptr,ia,ib,ic,id,xdim,xconsist,assumreal,resmode,mlid,nullptr,justcalcip,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,indstarta,indenda,iaset,ibset,icset,idset);
        }

        else if ( ( xainfo.xusize() == 2 ) && ( xcinfo.xusize() == 1 ) )
        {
            KK3(     res,logres,logresvalid,xa,xc,xd,xainfo,xcinfo,xdinfo,xagradOrder,xcgradOrder,xdgradOrder,xaff,xcff,xdff,bias,nullptr,ia,ic,id,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,justcalcip,indstarta,indenda,iaset,icset,idset);
            KK1(atempres,logres,logresvalid,xb,xbinfo,xbgradOrder,xbff,bias,nullptr,ib,xdim,xconsist,assumreal,resmode,mlid,nullptr,justcalcip,indstartb,indendb,ibset);

            if ( splitType(0) == 1 )
            {
                res *= atempres;
            }

            else
            {
                res += atempres;
            }
        }

        else if ( ( xainfo.xusize() == 1 ) && ( xbinfo.xusize() == 2 ) )
        {
            KK3(     res,logres,logresvalid,xa,xb,xd,xainfo,xbinfo,xdinfo,xagradOrder,xbgradOrder,xdgradOrder,xaff,xbff,xdff,bias,nullptr,ia,ib,id,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,justcalcip,indstarta,indenda,iaset,ibset,idset);
            KK1(atempres,logres,logresvalid,xc,xcinfo,xcgradOrder,xcff,bias,nullptr,ic,xdim,xconsist,assumreal,resmode,mlid,nullptr,justcalcip,indstartb,indendb,icset);

            if ( splitType(0) == 1 )
            {
                res *= atempres;
            }

            else
            {
                res += atempres;
            }
        }

        else if ( ( xainfo.xusize() == 1 ) && ( xcinfo.xusize() == 2 ) )
        {
            KK3(     res,logres,logresvalid,xa,xb,xc,xainfo,xbinfo,xcinfo,xagradOrder,xbgradOrder,xcgradOrder,xaff,xbff,xcff,bias,nullptr,ia,ib,ic,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,justcalcip,indstarta,indenda,iaset,ibset,icset);
            KK1(atempres,logres,logresvalid,xd,xdinfo,xdgradOrder,xdff,bias,nullptr,id,xdim,xconsist,assumreal,resmode,mlid,nullptr,justcalcip,indstartb,indendb,idset);

            if ( splitType(0) == 1 )
            {
                res *= atempres;
            }

            else
            {
                res += atempres;
            }
        }

        else if ( ( xainfo.xusize() == 2 ) && ( xcinfo.xusize() == 2 ) )
        {
            KK2(0,0,     res,logres,logresvalid,xa,xc,xainfo,xcinfo,xagradOrder,xcgradOrder,xaff,xcff,bias,nullptr,ia,ic,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,justcalcip,indstarta,indenda,iaset,icset);
            KK2(0,0,atempres,logres,logresvalid,xb,xd,xbinfo,xdinfo,xbgradOrder,xdgradOrder,xbff,xdff,bias,nullptr,ib,id,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,justcalcip,indstartb,indendb,ibset,idset);

            if ( splitType(0) == 1 )
            {
                res *= atempres;
            }

            else
            {
                res += atempres;
            }
        }

        else if ( xainfo.xusize() == 3 )
        {
            KK2(0,0,res,logres,logresvalid,xa,xd,xainfo,xdinfo,xagradOrder,xdgradOrder,xaff,xdff,bias,nullptr,ia,id,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,justcalcip,indstarta,indenda,iaset,idset);
            KK1(atempres,logres,logresvalid,xb,xbinfo,xbgradOrder,xbff,bias,nullptr,ib,xdim,xconsist,assumreal,resmode,mlid,nullptr,justcalcip,indstartb,indendb,ibset);
            KK1(btempres,logres,logresvalid,xc,xcinfo,xcgradOrder,xcff,bias,nullptr,ic,xdim,xconsist,assumreal,resmode,mlid,nullptr,justcalcip,indstartc,indendc,icset);

            if ( splitType(0) == 1 )
            {
                res *= atempres;
            }

            else
            {
                res += atempres;
            }

            if ( splitType(1) == 1 )
            {
                res *= btempres;
            }

            else
            {
                res += btempres;
            }
        }

        else if ( xbinfo.xusize() == 3 )
        {
            KK2(0,0,res,logres,logresvalid,xa,xb,xainfo,xbinfo,xagradOrder,xbgradOrder,xaff,xbff,bias,nullptr,ia,ib,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,justcalcip,indstarta,indenda,iaset,ibset);
            KK1(atempres,logres,logresvalid,xc,xcinfo,xcgradOrder,xcff,bias,nullptr,ic,xdim,xconsist,assumreal,resmode,mlid,nullptr,justcalcip,indstartb,indendb,icset);
            KK1(btempres,logres,logresvalid,xd,xdinfo,xdgradOrder,xdff,bias,nullptr,id,xdim,xconsist,assumreal,resmode,mlid,nullptr,justcalcip,indstartc,indendc,idset);

            if ( splitType(0) == 1 )
            {
                res *= atempres;
            }

            else
            {
                res += atempres;
            }

            if ( splitType(1) == 1 )
            {
                res *= btempres;
            }

            else
            {
                res += btempres;
            }
        }

        else
        {
            KK1(     res,logres,logresvalid,xa,xainfo,xagradOrder,xaff,bias,nullptr,ia,xdim,xconsist,assumreal,resmode,mlid,nullptr,justcalcip,indstarta,indenda,iaset);
            KK1(atempres,logres,logresvalid,xb,xbinfo,xbgradOrder,xbff,bias,nullptr,ib,xdim,xconsist,assumreal,resmode,mlid,nullptr,justcalcip,indstartb,indendb,ibset);
            KK1(btempres,logres,logresvalid,xc,xcinfo,xcgradOrder,xcff,bias,nullptr,ic,xdim,xconsist,assumreal,resmode,mlid,nullptr,justcalcip,indstartc,indendc,icset);
            KK1(ctempres,logres,logresvalid,xd,xdinfo,xdgradOrder,xdff,bias,nullptr,id,xdim,xconsist,assumreal,resmode,mlid,nullptr,justcalcip,indstartd,indendd,idset);

            if ( splitType(0) == 1 )
            {
                res *= atempres;
            }

            else
            {
                res += atempres;
            }

            if ( splitType(1) == 1 )
            {
                res *= btempres;
            }

            else
            {
                res += btempres;
            }

            if ( splitType(2) == 1 )
            {
                res *= ctempres;
            }

            else
            {
                res += ctempres;
            }
        }
    }

    else if ( isfullnorm && ns && !justcalcip )
    {
        Vector<int> splitPoint(ns);

        if ( ns )
        {
            for ( q = indstart ; q < indend ; ++q )
            {
                if ( isSplit(q) )
                {
                    splitPoint("&",r) = q;
                    NiceAssert( isSplit(q) == 1 );
                    ++r;
                }
            }
        }

        int indstarta = indstart;
        int indenda   = indend;

        int indstartb = indstart;
        int indendb   = indend;

//        int indstartc = indstart;
//        int indendc   = indend;
//
//        int indstartd = indstart;
//        int indendd   = indend;

        if ( ns == 1 )
        {
            indstarta = indstart;
            indenda   = splitPoint(z);

            indstartb = splitPoint(z)+1;
            indendb   = indend;

//            indstartc = indstart;
//            indendc   = splitPoint(z);
//
//            indstartd = splitPoint(z)+1;
//            indendd   = indend;
        }

        else if ( ns == 2 )
        {
            indstarta = indstart;
            indenda   = splitPoint(z);

            indstartb = splitPoint(z)+1;
            indendb   = splitPoint(1);

//            indstartc = splitPoint(1)+1;
//            indendc   = indend;
//
//            indstartd = indstart;
//            indendd   = splitPoint(z);
        }

        else if ( ns == 3 )
        {
            indstarta = indstart;
            indenda   = splitPoint(z);

            indstartb = splitPoint(z)+1;
            indendb   = splitPoint(1);

//            indstartc = splitPoint(1)+1;
//            indendc   = splitPoint(2);
//
//            indstartd = splitPoint(2)+1;
//            indendd   = indend;
        }

        else if ( ns >= 4 )
        {
            indstarta = indstart;
            indenda   = splitPoint(z);

            indstartb = splitPoint(z)+1;
            indendb   = splitPoint(1);

//            indstartc = splitPoint(1)+1;
//            indendc   = splitPoint(2);
//
//            indstartd = splitPoint(2)+1;
//            indendd   = splitPoint(3);
        }

        // 1:1:1:1
        // 2:2:1:1, 1:2:2:1, 1:1:2:2
        // 2:2:2:2
        // 3:3:3:1, 1:3:3:3
        // 4:4:4:4

        if ( ( xainfo.xusize() == 1 ) && ( xbinfo.xusize() == 1 ) && ( xcinfo.xusize() == 1 ) )
        {
            T tma;
            T tmb;
            T tmc;
            T tmd;

            T logtma;
            T logtmb;
            T logtmc;
            T logtmd;

            int logtmavalid = 0;
            int logtmbvalid = 0;
            int logtmcvalid = 0;
            int logtmdvalid = 0;

//            KK4(res,logres,logresvalid,xa,xb,xc,xd,xainfo,xbinfo,xcinfo,xdinfo,xagradOrder,xbgradOrder,xcgradOrder,xdgradOrder,xaff,xbff,xcff,xdff,bias,nullptr,ia,ib,ic,id,xdim,xconsist,assumreal,resmode,mlid,nullptr,justcalcip,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,indstarta,indenda,iaset,ibset,icset,idset);

            KK4(tma,logtma,logtmavalid,xa,xa,xa,xa,xainfo,xainfo,xainfo,xainfo,xagradOrder,xagradOrder,xagradOrder,xagradOrder,xaff,xaff,xaff,xaff,bias,nullptr,ia,ia,ia,ia,xdim,xconsist,assumreal,resmode,mlid,nullptr,justcalcip,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,indstarta,indenda,iaset,iaset,iaset,iaset);
            KK4(tmb,logtmb,logtmbvalid,xb,xb,xb,xb,xbinfo,xbinfo,xbinfo,xbinfo,xbgradOrder,xbgradOrder,xbgradOrder,xbgradOrder,xbff,xbff,xbff,xbff,bias,nullptr,ib,ib,ib,ib,xdim,xconsist,assumreal,resmode,mlid,nullptr,justcalcip,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,indstarta,indenda,ibset,ibset,ibset,ibset);
            KK4(tmc,logtmc,logtmcvalid,xc,xc,xc,xc,xcinfo,xcinfo,xcinfo,xcinfo,xcgradOrder,xcgradOrder,xcgradOrder,xcgradOrder,xcff,xcff,xcff,xcff,bias,nullptr,ic,ic,ic,ic,xdim,xconsist,assumreal,resmode,mlid,nullptr,justcalcip,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,indstarta,indenda,icset,icset,icset,icset);
            KK4(tmd,logtmd,logtmdvalid,xd,xd,xd,xd,xdinfo,xdinfo,xdinfo,xdinfo,xdgradOrder,xdgradOrder,xdgradOrder,xdgradOrder,xdff,xdff,xdff,xdff,bias,nullptr,id,id,id,id,xdim,xconsist,assumreal,resmode,mlid,nullptr,justcalcip,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,indstarta,indenda,idset,idset,idset,idset);

            if ( ( ( (double) abs2(tma) <= BADZEROTOL ) && ( (double) abs2(tmb) <= BADZEROTOL ) && ( (double) abs2(tmc) <= BADZEROTOL ) ) ||
                 ( ( (double) abs2(tma) <= BADZEROTOL ) && ( (double) abs2(tmb) <= BADZEROTOL ) && ( (double) abs2(tmd) <= BADZEROTOL ) ) ||
                 ( ( (double) abs2(tma) <= BADZEROTOL ) && ( (double) abs2(tmc) <= BADZEROTOL ) && ( (double) abs2(tmd) <= BADZEROTOL ) ) ||
                 ( ( (double) abs2(tmb) <= BADZEROTOL ) && ( (double) abs2(tmc) <= BADZEROTOL ) && ( (double) abs2(tmd) <= BADZEROTOL ) )    )
            {
                res = 1.0;
            }

            else if ( ( (double) abs2(tma) <= BADZEROTOL ) && ( (double) abs2(tmb) <= BADZEROTOL ) )
            {
                KK2(0,0,res,logres,logresvalid,xc,xd,xcinfo,xdinfo,xcgradOrder,xdgradOrder,xcff,xdff,bias,nullptr,ic,id,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,justcalcip,indstart,indend,icset,idset);

                if ( logresvalid && logtmcvalid && logtmdvalid )
                {
                    logtmc /= 2.0;
                    logtmd /= 2.0;

                    res = logres;

                    res -= logtmc;
                    res -= logtmd;

                    OP_exp(res);
                }

                else
                {
                    tmc *= tmd;
                    OP_sqrt(tmc);
                    safedivby(res,tmc); //res /= tmc;
                }
            }

            else if ( ( (double) abs2(tma) <= BADZEROTOL ) && ( (double) abs2(tmc) <= BADZEROTOL ) )
            {
                KK2(0,0,res,logres,logresvalid,xb,xd,xbinfo,xdinfo,xbgradOrder,xdgradOrder,xbff,xdff,bias,nullptr,ib,id,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,justcalcip,indstart,indend,ibset,idset);

                if ( logresvalid && logtmbvalid && logtmdvalid )
                {
                    logtmb /= 2.0;
                    logtmd /= 2.0;

                    res = logres;

                    res -= logtmb;
                    res -= logtmd;

                    OP_exp(res);
                }

                else
                {
                    tmb *= tmd;
                    OP_sqrt(tmb);
                    safedivby(res,tmb); //res /= tmb;
                }
            }

            else if ( ( (double) abs2(tma) <= BADZEROTOL ) && ( (double) abs2(tmd) <= BADZEROTOL ) )
            {
                KK2(0,0,res,logres,logresvalid,xb,xc,xbinfo,xcinfo,xbgradOrder,xcgradOrder,xbff,xcff,bias,nullptr,ib,ic,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,justcalcip,indstart,indend,ibset,icset);

                if ( logresvalid && logtmbvalid && logtmcvalid )
                {
                    logtmb /= 2.0;
                    logtmc /= 2.0;

                    res = logres;

                    res -= logtmb;
                    res -= logtmc;

                    OP_exp(res);
                }

                else
                {
                    tmb *= tmc;
                    OP_sqrt(tmb);
                    safedivby(res,tmb); //res /= tmb;
                }
            }

            else if ( ( (double) abs2(tmb) <= BADZEROTOL ) && ( (double) abs2(tmc) <= BADZEROTOL ) )
            {
                KK2(0,0,res,logres,logresvalid,xa,xd,xainfo,xdinfo,xagradOrder,xdgradOrder,xaff,xdff,bias,nullptr,ia,id,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,justcalcip,indstart,indend,iaset,idset);

                if ( logresvalid && logtmavalid && logtmdvalid )
                {
                    logtma /= 2.0;
                    logtmd /= 2.0;

                    res = logres;

                    res -= logtma;
                    res -= logtmd;

                    OP_exp(res);
                }

                else
                {
                    tma *= tmd;
                    OP_sqrt(tma);
                    safedivby(res,tma); //res /= tma;
                }
            }

            else if ( ( (double) abs2(tmb) <= BADZEROTOL ) && ( (double) abs2(tmd) <= BADZEROTOL ) )
            {
                KK2(0,0,res,logres,logresvalid,xa,xc,xainfo,xcinfo,xagradOrder,xcgradOrder,xaff,xcff,bias,nullptr,ia,ic,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,justcalcip,indstart,indend,iaset,icset);

                if ( logresvalid && logtmavalid && logtmcvalid )
                {
                    logtma /= 2.0;
                    logtmc /= 2.0;

                    res = logres;

                    res -= logtma;
                    res -= logtmc;

                    OP_exp(res);
                }

                else
                {
                    tma *= tmc;
                    OP_sqrt(tma);
                    safedivby(res,tma); //res /= tma;
                }
            }

            else if ( ( (double) abs2(tmc) <= BADZEROTOL ) && ( (double) abs2(tmd) <= BADZEROTOL ) )
            {
                KK2(0,0,res,logres,logresvalid,xa,xb,xainfo,xbinfo,xagradOrder,xbgradOrder,xaff,xbff,bias,nullptr,ia,ib,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,justcalcip,indstart,indend,iaset,ibset);

                if ( logresvalid && logtmavalid && logtmbvalid )
                {
                    logtma /= 2.0;
                    logtmb /= 2.0;

                    res = logres;

                    res -= logtma;
                    res -= logtmb;

                    OP_exp(res);
                }

                else
                {
                    tma *= tmb;
                    OP_sqrt(tma);
                    safedivby(res,tma); //res /= tma;
                }
            }

            else if ( (double) abs2(tma) <= BADZEROTOL )
            {
                KK3(res,logres,logresvalid,xb,xc,xd,xbinfo,xcinfo,xdinfo,xbgradOrder,xcgradOrder,xdgradOrder,xbff,xcff,xdff,bias,nullptr,ib,ic,id,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,justcalcip,indstarta,indenda,ibset,icset,idset);

                if ( logresvalid && logtmbvalid && logtmcvalid && logtmcvalid )
                {
                    logtmb /= 3.0;
                    logtmc /= 3.0;
                    logtmd /= 3.0;

                    res = logres;

                    res -= logtmb;
                    res -= logtmc;
                    res -= logtmd;

                    OP_exp(res);
                }

                else
                {
                    T oneonm; oneonm = 1.0/3.0;

                    tmb *= tmc;
                    tmb *= tmd;
                    tmb = pow(tmb,oneonm);
                    safedivby(res,tmb); //res /= tmb;
                }
            }

            else if ( (double) abs2(tmb) <= BADZEROTOL )
            {
                KK3(res,logres,logresvalid,xa,xc,xd,xainfo,xcinfo,xdinfo,xagradOrder,xcgradOrder,xdgradOrder,xaff,xcff,xdff,bias,nullptr,ia,ic,id,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,justcalcip,indstarta,indenda,iaset,icset,idset);

                if ( logresvalid && logtmavalid && logtmcvalid && logtmdvalid )
                {
                    logtma /= 3.0;
                    logtmc /= 3.0;
                    logtmd /= 3.0;

                    res = logres;

                    res -= logtma;
                    res -= logtmc;
                    res -= logtmd;

                    OP_exp(res);
                }

                else
                {
                    T oneonm; oneonm = 1.0/3.0;

                    tma *= tmc;
                    tma *= tmd;
                    tma = pow(tma,oneonm);
                    safedivby(res,tma); //res /= tma;
                }
            }

            else if ( (double) abs2(tmc) <= BADZEROTOL )
            {
                KK3(res,logres,logresvalid,xa,xb,xd,xainfo,xbinfo,xdinfo,xagradOrder,xbgradOrder,xdgradOrder,xaff,xbff,xdff,bias,nullptr,ia,ib,id,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,justcalcip,indstarta,indenda,iaset,ibset,idset);

                if ( logresvalid && logtmavalid && logtmbvalid && logtmdvalid )
                {
                    logtma /= 3.0;
                    logtmb /= 3.0;
                    logtmd /= 3.0;

                    res = logres;

                    res -= logtma;
                    res -= logtmb;
                    res -= logtmd;

                    OP_exp(res);
                }

                else
                {
                    T oneonm; oneonm = 1.0/3.0;

                    tma *= tmb;
                    tma *= tmd;
                    tma = pow(tma,oneonm);
                    safedivby(res,tma); //res /= tma;
                }
            }

            else if ( (double) abs2(tmd) <= BADZEROTOL )
            {
                KK3(res,logres,logresvalid,xa,xb,xc,xainfo,xbinfo,xcinfo,xagradOrder,xbgradOrder,xcgradOrder,xaff,xbff,xcff,bias,nullptr,ia,ib,ic,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,justcalcip,indstarta,indenda,iaset,ibset,icset);

                if ( logresvalid && logtmavalid && logtmbvalid && logtmcvalid )
                {
                    logtma /= 3.0;
                    logtmb /= 3.0;
                    logtmc /= 3.0;

                    res = logres;

                    res -= logtma;
                    res -= logtmb;
                    res -= logtmc;

                    OP_exp(res);
                }

                else
                {
                    T oneonm; oneonm = 1.0/3.0;

                    tma *= tmb;
                    tma *= tmc;
                    tma = pow(tma,oneonm);
                    safedivby(res,tma); //res /= tma;
                }
            }

            else
            {
                KK4(res,logres,logresvalid,xa,xb,xc,xd,xainfo,xbinfo,xcinfo,xdinfo,xagradOrder,xbgradOrder,xcgradOrder,xdgradOrder,xaff,xbff,xcff,xdff,bias,nullptr,ia,ib,ic,id,xdim,xconsist,assumreal,resmode,mlid,nullptr,justcalcip,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,indstarta,indenda,iaset,ibset,icset,idset);

                if ( logresvalid && logtmavalid && logtmbvalid && logtmcvalid && logtmdvalid )
                {
                    logtma /= 4.0;
                    logtmb /= 4.0;
                    logtmc /= 4.0;
                    logtmd /= 4.0;

                    res = logres;

                    res -= logtma;
                    res -= logtmb;
                    res -= logtmc;
                    res -= logtmd;

                    OP_exp(res);
                }

                else
                {
                    tma *= tmb;
                    tma *= tmc;
                    tma *= tmd;

                    T sf; sf = 1.0/4.0;

                    safedivby(res,pow(tma,sf)); //res /= pow(tma,sf);
                }
            }
        }

        else if ( ( xainfo.xusize() == 2 ) && ( xcinfo.xusize() == 1 ) )
        {
            T tma;
            T tmc;
            T tmd;

            T logtma;
            T logtmc;
            T logtmd;

            int logtmavalid = 0;
            int logtmcvalid = 0;
            int logtmdvalid = 0;

            KK3(res,logres,logresvalid,xa,xc,xd,xainfo,xcinfo,xdinfo,xagradOrder,xcgradOrder,xdgradOrder,xaff,xcff,xdff,bias,nullptr,ia,ic,id,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,justcalcip,indstarta,indenda,iaset,icset,idset);

            KK3(tma,logtma,logtmavalid,xa,xa,xa,xainfo,xainfo,xainfo,xagradOrder,xagradOrder,xagradOrder,xaff,xaff,xaff,bias,nullptr,ia,ia,ia,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,justcalcip,indstarta,indenda,iaset,iaset,iaset);
            KK3(tmc,logtmc,logtmcvalid,xc,xc,xc,xcinfo,xcinfo,xcinfo,xcgradOrder,xcgradOrder,xcgradOrder,xcff,xcff,xcff,bias,nullptr,ic,ic,ic,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,justcalcip,indstarta,indenda,icset,icset,icset);
            KK3(tmd,logtmd,logtmdvalid,xd,xd,xd,xdinfo,xdinfo,xdinfo,xdgradOrder,xdgradOrder,xdgradOrder,xdff,xdff,xdff,bias,nullptr,id,id,id,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,justcalcip,indstarta,indenda,idset,idset,idset);

            if ( ( ( (double) abs2(tma) <= BADZEROTOL ) && ( (double) abs2(tmc) <= BADZEROTOL ) ) ||
                 ( ( (double) abs2(tma) <= BADZEROTOL ) && ( (double) abs2(tmd) <= BADZEROTOL ) ) ||
                 ( ( (double) abs2(tmc) <= BADZEROTOL ) && ( (double) abs2(tmd) <= BADZEROTOL ) )    )
            {
                res = 1.0;
            }

            else if ( (double) abs2(tma) <= BADZEROTOL )
            {
                KK2(0,0,res,logres,logresvalid,xc,xd,xcinfo,xdinfo,xcgradOrder,xdgradOrder,xcff,xdff,bias,nullptr,ic,id,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,justcalcip,indstart,indend,icset,idset);

                if ( logresvalid && logtmcvalid && logtmdvalid )
                {
                    logtmc /= 2.0;
                    logtmd /= 2.0;

                    res = logres;

                    res -= logtmc;
                    res -= logtmd;

                    OP_exp(res);
                }

                else
                {
                    tmc *= tmd;
                    OP_sqrt(tmc);
                    safedivby(res,tmc); //res /= tmc;
                }
            }

            else if ( (double) abs2(tmc) <= BADZEROTOL )
            {
                KK2(0,0,res,logres,logresvalid,xa,xd,xainfo,xdinfo,xagradOrder,xdgradOrder,xaff,xdff,bias,nullptr,ia,id,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,justcalcip,indstart,indend,iaset,idset);

                if ( logresvalid && logtmavalid && logtmdvalid )
                {
                    logtma /= 2.0;
                    logtmd /= 2.0;

                    res = logres;

                    res -= logtma;
                    res -= logtmd;

                    OP_exp(res);
                }

                else
                {
                    tma *= tmd;
                    OP_sqrt(tma);
                    safedivby(res,tma); //res /= tma;
                }
            }

            else if ( (double) abs2(tmd) <= BADZEROTOL )
            {
                KK2(0,0,res,logres,logresvalid,xa,xc,xainfo,xcinfo,xagradOrder,xcgradOrder,xaff,xcff,bias,nullptr,ia,ic,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,justcalcip,indstart,indend,iaset,icset);

                if ( logresvalid && logtmavalid && logtmcvalid )
                {
                    logtma /= 2.0;
                    logtmc /= 2.0;

                    res = logres;

                    res -= logtma;
                    res -= logtmc;

                    OP_exp(res);
                }

                else
                {
                    tma *= tmc;
                    OP_sqrt(tma);
                    safedivby(res,tma); //res /= tma;
                }
            }

            else
            {
                KK3(res,logres,logresvalid,xa,xc,xd,xainfo,xcinfo,xdinfo,xagradOrder,xcgradOrder,xdgradOrder,xaff,xcff,xdff,bias,nullptr,ia,ic,id,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,justcalcip,indstarta,indenda,iaset,icset,idset);

                if ( logresvalid && logtmavalid && logtmcvalid && logtmdvalid )
                {
                    logtma /= 3.0;
                    logtmc /= 3.0;
                    logtmd /= 3.0;

                    res = logres;

                    res -= logtma;
                    res -= logtmc;
                    res -= logtmd;

                    OP_exp(res);
                }

                else
                {
                    tma *= tmc;
                    tma *= tmd;

                    T sf; sf = 1.0/3.0;

                    safedivby(res,pow(tma,sf)); //res /= pow(tma,sf);
                }
            }
        }

        else if ( ( xainfo.xusize() == 1 ) && ( xbinfo.xusize() == 2 ) )
        {
            T tma;
            T tmb;
            T tmd;

            T logtma;
            T logtmb;
            T logtmd;

            int logtmavalid = 0;
            int logtmbvalid = 0;
            int logtmdvalid = 0;

//            KK3(res,logres,logresvalid,xa,xb,xd,xainfo,xbinfo,xdinfo,xagradOrder,xbgradOrder,xdgradOrder,xaff,xbff,xdff,bias,nullptr,ia,ib,id,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,justcalcip,indstarta,indenda,iaset,ibset,idset);

            KK3(tma,logtma,logtmavalid,xa,xa,xa,xainfo,xainfo,xainfo,xagradOrder,xagradOrder,xagradOrder,xaff,xaff,xaff,bias,nullptr,ia,ia,ia,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,justcalcip,indstarta,indenda,iaset,iaset,iaset);
            KK3(tmb,logtmb,logtmbvalid,xb,xb,xb,xbinfo,xbinfo,xbinfo,xbgradOrder,xbgradOrder,xbgradOrder,xbff,xbff,xbff,bias,nullptr,ib,ib,ib,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,justcalcip,indstarta,indenda,ibset,ibset,ibset);
            KK3(tmd,logtmd,logtmdvalid,xd,xd,xd,xdinfo,xdinfo,xdinfo,xdgradOrder,xdgradOrder,xdgradOrder,xdff,xdff,xdff,bias,nullptr,id,id,id,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,justcalcip,indstarta,indenda,idset,idset,idset);

            if ( ( ( (double) abs2(tma) <= BADZEROTOL ) && ( (double) abs2(tmb) <= BADZEROTOL ) ) ||
                 ( ( (double) abs2(tma) <= BADZEROTOL ) && ( (double) abs2(tmd) <= BADZEROTOL ) ) ||
                 ( ( (double) abs2(tmb) <= BADZEROTOL ) && ( (double) abs2(tmd) <= BADZEROTOL ) )    )
            {
                res = 1.0;
            }

            else if ( (double) abs2(tma) <= BADZEROTOL )
            {
                KK2(0,0,res,logres,logresvalid,xb,xd,xbinfo,xdinfo,xbgradOrder,xdgradOrder,xbff,xdff,bias,nullptr,ib,id,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,justcalcip,indstart,indend,ibset,idset);

                if ( logresvalid && logtmbvalid && logtmdvalid )
                {
                    logtmb /= 2.0;
                    logtmd /= 2.0;

                    res = logres;

                    res -= logtmb;
                    res -= logtmd;

                    OP_exp(res);
                }

                else
                {
                    tmb *= tmd;
                    OP_sqrt(tmb);
                    safedivby(res,tmb); //res /= tmb;
                }
            }

            else if ( (double) abs2(tmb) <= BADZEROTOL )
            {
                KK2(0,0,res,logres,logresvalid,xa,xd,xainfo,xdinfo,xagradOrder,xdgradOrder,xaff,xdff,bias,nullptr,ia,id,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,justcalcip,indstart,indend,iaset,idset);

                if ( logresvalid && logtmavalid && logtmdvalid )
                {
                    logtma /= 2.0;
                    logtmd /= 2.0;

                    res = logres;

                    res -= logtma;
                    res -= logtmd;

                    OP_exp(res);
                }

                else
                {
                    tma *= tmd;
                    OP_sqrt(tma);
                    safedivby(res,tma); //res /= tma;
                }
            }

            else if ( (double) abs2(tmd) <= BADZEROTOL )
            {
                KK2(0,0,res,logres,logresvalid,xa,xb,xainfo,xbinfo,xagradOrder,xbgradOrder,xaff,xbff,bias,nullptr,ia,ib,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,justcalcip,indstart,indend,iaset,ibset);

                if ( logresvalid && logtmavalid && logtmbvalid )
                {
                    logtma /= 2.0;
                    logtmb /= 2.0;

                    res = logres;

                    res -= logtma;
                    res -= logtmb;

                    OP_exp(res);
                }

                else
                {
                    tma *= tmb;
                    OP_sqrt(tma);
                    safedivby(res,tma); //res /= tma;
                }
            }

            else
            {
                KK3(res,logres,logresvalid,xa,xb,xd,xainfo,xbinfo,xdinfo,xagradOrder,xbgradOrder,xdgradOrder,xaff,xbff,xdff,bias,nullptr,ia,ib,id,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,justcalcip,indstarta,indenda,iaset,ibset,idset);

                if ( logresvalid && logtmavalid && logtmbvalid && logtmdvalid )
                {
                    logtma /= 3.0;
                    logtmb /= 3.0;
                    logtmd /= 3.0;

                    res = logres;

                    res -= logtma;
                    res -= logtmb;
                    res -= logtmd;

                    OP_exp(res);
                }

                else
                {
                    tma *= tmb;
                    tma *= tmd;

                    T sf; sf = 1.0/3.0;

                    safedivby(res,pow(tma,sf)); //res /= pow(tma,sf);
                }
            }
        }

        else if ( ( xainfo.xusize() == 1 ) && ( xcinfo.xusize() == 2 ) )
        {
            T tma;
            T tmb;
            T tmc;

            T logtma;
            T logtmb;
            T logtmc;

            int logtmavalid = 0;
            int logtmbvalid = 0;
            int logtmcvalid = 0;

            KK3(res,logres,logresvalid,xa,xb,xc,xainfo,xbinfo,xcinfo,xagradOrder,xbgradOrder,xcgradOrder,xaff,xbff,xcff,bias,nullptr,ia,ib,ic,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,justcalcip,indstarta,indenda,iaset,ibset,icset);

            KK3(tma,logtma,logtmavalid,xa,xa,xa,xainfo,xainfo,xainfo,xagradOrder,xagradOrder,xagradOrder,xaff,xaff,xaff,bias,nullptr,ia,ia,ia,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,justcalcip,indstarta,indenda,iaset,iaset,iaset);
            KK3(tmb,logtmb,logtmbvalid,xb,xb,xb,xbinfo,xbinfo,xbinfo,xbgradOrder,xbgradOrder,xbgradOrder,xbff,xbff,xbff,bias,nullptr,ib,ib,ib,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,justcalcip,indstarta,indenda,ibset,ibset,ibset);
            KK3(tmc,logtmc,logtmcvalid,xc,xc,xc,xcinfo,xcinfo,xcinfo,xcgradOrder,xcgradOrder,xcgradOrder,xcff,xcff,xcff,bias,nullptr,ic,ic,ic,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,justcalcip,indstarta,indenda,icset,icset,icset);

            if ( ( ( (double) abs2(tma) <= BADZEROTOL ) && ( (double) abs2(tmb) <= BADZEROTOL ) ) ||
                 ( ( (double) abs2(tma) <= BADZEROTOL ) && ( (double) abs2(tmc) <= BADZEROTOL ) ) ||
                 ( ( (double) abs2(tmb) <= BADZEROTOL ) && ( (double) abs2(tmc) <= BADZEROTOL ) )    )
            {
                res = 1.0;
            }

            else if ( (double) abs2(tma) <= BADZEROTOL )
            {
                KK2(0,0,res,logres,logresvalid,xb,xc,xbinfo,xcinfo,xbgradOrder,xcgradOrder,xbff,xcff,bias,nullptr,ib,ic,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,justcalcip,indstart,indend,ibset,icset);

                if ( logresvalid && logtmbvalid && logtmcvalid )
                {
                    logtmb /= 2.0;
                    logtmc /= 2.0;

                    res = logres;

                    res -= logtmb;
                    res -= logtmc;

                    OP_exp(res);
                }

                else
                {
                    tmb *= tmc;
                    OP_sqrt(tmb);
                    safedivby(res,tmb); //res /= tmb;
                }
            }

            else if ( (double) abs2(tmb) <= BADZEROTOL )
            {
                KK2(0,0,res,logres,logresvalid,xa,xc,xainfo,xcinfo,xagradOrder,xcgradOrder,xaff,xcff,bias,nullptr,ia,ic,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,justcalcip,indstart,indend,iaset,icset);

                if ( logresvalid && logtmavalid && logtmcvalid )
                {
                    logtma /= 2.0;
                    logtmc /= 2.0;

                    res = logres;

                    res -= logtma;
                    res -= logtmc;

                    OP_exp(res);
                }

                else
                {
                    tma *= tmc;
                    OP_sqrt(tma);
                    safedivby(res,tma); //res /= tma;
                }
            }

            else if ( (double) abs2(tmc) <= BADZEROTOL )
            {
                KK2(0,0,res,logres,logresvalid,xa,xb,xainfo,xbinfo,xagradOrder,xbgradOrder,xaff,xbff,bias,nullptr,ia,ib,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,justcalcip,indstart,indend,iaset,ibset);

                if ( logresvalid && logtmavalid && logtmbvalid )
                {
                    logtma /= 2.0;
                    logtmb /= 2.0;

                    res = logres;

                    res -= logtma;
                    res -= logtmb;

                    OP_exp(res);
                }

                else
                {
                    tma *= tmb;
                    OP_sqrt(tma);
                    safedivby(res,tma); //res /= tma;
                }
            }

            else
            {
                KK3(res,logres,logresvalid,xa,xb,xc,xainfo,xbinfo,xcinfo,xagradOrder,xbgradOrder,xcgradOrder,xaff,xbff,xcff,bias,nullptr,ia,ib,ic,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,justcalcip,indstarta,indenda,iaset,ibset,icset);

                if ( logresvalid && logtmavalid && logtmbvalid && logtmcvalid )
                {
                    logtma /= 3.0;
                    logtmb /= 3.0;
                    logtmc /= 3.0;

                    res = logres;

                    res -= logtma;
                    res -= logtmb;
                    res -= logtmc;

                    OP_exp(res);
                }

                else
                {
                    tma *= tmb;
                    tma *= tmc;

                    T sf; sf = 1.0/3.0;

                    safedivby(res,pow(tma,sf)); //res /= pow(tma,sf);
                }
            }
        }

        else if ( ( xainfo.xusize() == 2 ) && ( xcinfo.xusize() == 2 ) )
        {
            T tma;
            T tmb;
            T tmc;
            T tmd;

            T logtma;
            T logtmb;
            T logtmc;
            T logtmd;

            int logtmavalid = 0;
            int logtmbvalid = 0;
            int logtmcvalid = 0;
            int logtmdvalid = 0;

//            KK2(     res,logres,logresvalid,xa,xc,xainfo,xcinfo,xagradOrder,xcgradOrder,xaff,xcff,bias,nullptr,ia,ic,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,justcalcip,indstarta,indenda,iaset,icset);
//            KK2(atempres,logres,logresvalid,xb,xd,xbinfo,xdinfo,xbgradOrder,xdgradOrder,xbff,xdff,bias,nullptr,ib,id,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,justcalcip,indstartb,indendb,ibset,idset);

//            res *= atempres;

            KK2(0,0,tma,logtma,logtmavalid,xa,xa,xainfo,xainfo,xagradOrder,xagradOrder,xaff,xaff,bias,nullptr,ia,ia,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,justcalcip,indstarta,indenda,iaset,iaset);
            KK2(0,0,tmc,logtmc,logtmcvalid,xc,xc,xcinfo,xcinfo,xbgradOrder,xbgradOrder,xbff,xbff,bias,nullptr,ic,ic,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,justcalcip,indstarta,indenda,ibset,ibset);
            KK2(0,0,tmb,logtmb,logtmbvalid,xb,xb,xbinfo,xbinfo,xcgradOrder,xcgradOrder,xcff,xcff,bias,nullptr,ib,ib,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,justcalcip,indstartb,indendb,icset,icset);
            KK2(0,0,tmd,logtmd,logtmdvalid,xd,xd,xdinfo,xdinfo,xdgradOrder,xdgradOrder,xdff,xdff,bias,nullptr,id,id,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,justcalcip,indstartb,indendb,idset,idset);

            if ( ( ( (double) abs2(tma) <= BADZEROTOL ) && ( (double) abs2(tmb) <= BADZEROTOL ) && ( (double) abs2(tmc) <= BADZEROTOL ) ) ||
                 ( ( (double) abs2(tma) <= BADZEROTOL ) && ( (double) abs2(tmb) <= BADZEROTOL ) && ( (double) abs2(tmd) <= BADZEROTOL ) ) ||
                 ( ( (double) abs2(tma) <= BADZEROTOL ) && ( (double) abs2(tmc) <= BADZEROTOL ) && ( (double) abs2(tmd) <= BADZEROTOL ) ) ||
                 ( ( (double) abs2(tmb) <= BADZEROTOL ) && ( (double) abs2(tmc) <= BADZEROTOL ) && ( (double) abs2(tmd) <= BADZEROTOL ) )    )
            {
                res = 1.0;
            }

            else if ( ( (double) abs2(tma) <= BADZEROTOL ) && ( (double) abs2(tmb) <= BADZEROTOL ) )
            {
                res = 1.0;
            }

            else if ( ( (double) abs2(tma) <= BADZEROTOL ) && ( (double) abs2(tmc) <= BADZEROTOL ) )
            {
                KK2(0,0,res,logres,logresvalid,xb,xd,xbinfo,xdinfo,xbgradOrder,xdgradOrder,xbff,xdff,bias,nullptr,ib,id,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,justcalcip,indstartb,indendb,ibset,idset);

                if ( logresvalid && logtmbvalid && logtmdvalid )
                {
                    logtmb /= 2.0;
                    logtmd /= 2.0;

                    res = logres;

                    res -= logtmb;
                    res -= logtmd;

                    OP_exp(res);
                }

                else
                {
                    tmb *= tmd;
                    OP_sqrt(tmb);
                    safedivby(res,tmb); //res /= tmb;
                }
            }

            else if ( ( (double) abs2(tma) <= BADZEROTOL ) && ( (double) abs2(tmd) <= BADZEROTOL ) )
            {
                res = 1.0;
            }

            else if ( ( (double) abs2(tmb) <= BADZEROTOL ) && ( (double) abs2(tmc) <= BADZEROTOL ) )
            {
                res = 1.0;
            }

            else if ( ( (double) abs2(tmb) <= BADZEROTOL ) && ( (double) abs2(tmd) <= BADZEROTOL ) )
            {
                KK2(0,0,res,logres,logresvalid,xa,xc,xainfo,xcinfo,xagradOrder,xcgradOrder,xaff,xcff,bias,nullptr,ia,ic,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,justcalcip,indstarta,indenda,iaset,icset);

                if ( logresvalid && logtmavalid && logtmcvalid )
                {
                    logtma /= 2.0;
                    logtmc /= 2.0;

                    res = logres;

                    res -= logtma;
                    res -= logtmc;

                    OP_exp(res);
                }

                else
                {
                    tma *= tmc;
                    OP_sqrt(tma);
                    safedivby(res,tma); //res /= tma;
                }
            }

            else if ( ( (double) abs2(tmc) <= BADZEROTOL ) && ( (double) abs2(tmd) <= BADZEROTOL ) )
            {
                res = 1.0;
            }

            else if ( (double) abs2(tma) <= BADZEROTOL )
            {
                KK2(0,0,res,logres,logresvalid,xb,xd,xbinfo,xdinfo,xbgradOrder,xdgradOrder,xbff,xdff,bias,nullptr,ib,id,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,justcalcip,indstartb,indendb,ibset,idset);

                if ( logresvalid && logtmbvalid && logtmdvalid )
                {
                    logtmb /= 2.0;
                    logtmd /= 2.0;

                    res = logres;

                    res -= logtmb;
                    res -= logtmd;

                    OP_exp(res);
                }

                else
                {
                    tmb *= tmd;
                    OP_sqrt(tmb);
                    safedivby(res,tmb); //res /= tmb;
                }
            }

            else if ( (double) abs2(tmb) <= BADZEROTOL )
            {
                KK2(0,0,res,logres,logresvalid,xa,xc,xainfo,xcinfo,xagradOrder,xcgradOrder,xaff,xcff,bias,nullptr,ia,ic,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,justcalcip,indstarta,indenda,iaset,icset);

                if ( logresvalid && logtmavalid && logtmcvalid )
                {
                    logtma /= 2.0;
                    logtmc /= 2.0;

                    res = logres;

                    res -= logtma;
                    res -= logtmc;

                    OP_exp(res);
                }

                else
                {
                    tma *= tmc;
                    OP_sqrt(tma);
                    safedivby(res,tma); //res /= tma;
                }
            }

            else if ( (double) abs2(tmc) <= BADZEROTOL )
            {
                KK2(0,0,res,logres,logresvalid,xb,xd,xbinfo,xdinfo,xbgradOrder,xdgradOrder,xbff,xdff,bias,nullptr,ib,id,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,justcalcip,indstartb,indendb,ibset,idset);

                if ( logresvalid && logtmbvalid && logtmdvalid )
                {
                    logtmb /= 2.0;
                    logtmd /= 2.0;

                    res = logres;

                    res -= logtmb;
                    res -= logtmd;

                    OP_exp(res);
                }

                else
                {
                    T oneonm; oneonm = 1.0/3.0;

                    tmb *= tmd;
                    tmb = pow(tmb,oneonm);
                    safedivby(res,tmb); //res /= tmb;
                }
            }

            else if ( (double) abs2(tmd) <= BADZEROTOL )
            {
                KK2(0,0,res,logres,logresvalid,xa,xc,xainfo,xcinfo,xagradOrder,xcgradOrder,xaff,xcff,bias,nullptr,ia,ic,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,justcalcip,indstarta,indenda,iaset,icset);

                if ( logresvalid && logtmavalid && logtmcvalid )
                {
                    logtma /= 2.0;
                    logtmc /= 2.0;

                    res = logres;

                    res -= logtma;
                    res -= logtmc;

                    OP_exp(res);
                }

                else
                {
                    tma *= tmc;
                    OP_sqrt(tma);
                    safedivby(res,tma); //res /= tma;
                }
            }

            else
            {
                KK2(0,0,     res,logres,logresvalid,xa,xc,xainfo,xcinfo,xagradOrder,xcgradOrder,xaff,xcff,bias,nullptr,ia,ic,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,justcalcip,indstarta,indenda,iaset,icset);
                KK2(0,0,atempres,logres,logresvalid,xb,xd,xbinfo,xdinfo,xbgradOrder,xdgradOrder,xbff,xdff,bias,nullptr,ib,id,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,justcalcip,indstartb,indendb,ibset,idset);

                res *= atempres;

                if ( logresvalid && logtmavalid && logtmbvalid && logtmcvalid && logtmdvalid )
                {
                    logtma /= 2.0;
                    logtmb /= 2.0;
                    logtmc /= 2.0;
                    logtmd /= 2.0;

                    res = logres;

                    res -= logtma;
                    res -= logtmb;
                    res -= logtmc;
                    res -= logtmd;

                    OP_exp(res);
                }

                else
                {
                    tma *= tmb;
                    tma *= tmc;
                    tma *= tmd;

                    T sf; sf = 1.0/2.0;

                    safedivby(res,pow(tma,sf)); //res /= pow(tma,sf);
                }
            }
        }

        else if ( xainfo.xusize() == 3 )
        {
            T tma;
            T tmd;

            T logtma;
            T logtmd;

            int logtmavalid = 0;
            int logtmdvalid = 0;

//            KK2(res,logres,logresvalid,xa,xd,xainfo,xdinfo,xagradOrder,xdgradOrder,xaff,xdff,bias,nullptr,ia,id,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,justcalcip,indstarta,indenda,iaset,idset);

            KK2(0,0,tma,logtma,logtmavalid,xa,xa,xainfo,xainfo,xagradOrder,xagradOrder,xaff,xaff,bias,nullptr,ia,ia,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,justcalcip,indstarta,indenda,iaset,iaset);
            KK2(0,0,tmd,logtmd,logtmdvalid,xd,xd,xdinfo,xdinfo,xdgradOrder,xdgradOrder,xdff,xdff,bias,nullptr,id,id,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,justcalcip,indstarta,indenda,idset,idset);

            if ( ( (double) abs2(tma) <= BADZEROTOL ) || ( (double) abs2(tmd) <= BADZEROTOL ) )
            {
                res = 1.0;
            }

            else
            {
                KK2(0,0,res,logres,logresvalid,xa,xd,xainfo,xdinfo,xagradOrder,xdgradOrder,xaff,xdff,bias,nullptr,ia,id,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,justcalcip,indstarta,indenda,iaset,idset);

                if ( logresvalid && logtmavalid && logtmdvalid )
                {
                    logtma /= 2.0;
                    logtmd /= 2.0;

                    res = logres;

                    res -= logtma;
                    res -= logtmd;

                    OP_exp(res);
                }

                else
                {
                    tma *= tmd;
                    OP_sqrt(tma);
                    safedivby(res,tma); //res /= tma;
                }
            }
        }

        else if ( xbinfo.xusize() == 3 )
        {
            T tma;
            T tmb;

            T logtma;
            T logtmb;

            int logtmavalid = 0;
            int logtmbvalid = 0;

//            KK2(res,logres,logresvalid,xa,xb,xainfo,xbinfo,xagradOrder,xbgradOrder,xaff,xbff,bias,nullptr,ia,ib,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,justcalcip,indstarta,indenda,iaset,ibset);

            KK2(0,0,tma,logtma,logtmavalid,xa,xa,xainfo,xainfo,xagradOrder,xagradOrder,xaff,xaff,bias,nullptr,ia,ia,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,justcalcip,indstarta,indenda,iaset,iaset);
            KK2(0,0,tmb,logtmb,logtmbvalid,xb,xb,xbinfo,xbinfo,xbgradOrder,xbgradOrder,xbff,xbff,bias,nullptr,ib,ib,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,justcalcip,indstarta,indenda,ibset,ibset);

            if ( ( (double) abs2(tma) <= BADZEROTOL ) || ( (double) abs2(tmb) <= BADZEROTOL ) )
            {
                res = 1.0;
            }

            else
            {
                KK2(0,0,res,logres,logresvalid,xa,xb,xainfo,xbinfo,xagradOrder,xbgradOrder,xaff,xbff,bias,nullptr,ia,ib,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,justcalcip,indstarta,indenda,iaset,ibset);

                if ( logresvalid && logtmavalid && logtmbvalid )
                {
                    logtma /= 2.0;
                    logtmb /= 2.0;

                    res = logres;

                    res -= logtma;
                    res -= logtmb;

                    OP_exp(res);
                }

                else
                {
                    tma *= tmb;
                    OP_sqrt(tma);
                    safedivby(res,tma); //res /= tma;
                }
            }
        }

        else
        {
            res = 1.0;
        }
    }

    else
    {
        KK4(res,logres,logresvalid,xa,xb,xc,xd,xainfo,xbinfo,xcinfo,xdinfo,xagradOrder,xbgradOrder,xcgradOrder,xdgradOrder,xaff,xbff,xcff,xdff,bias,pxyprod,ia,ib,ic,id,xdim,xconsist,assumreal,resmode,mlid,nullptr,justcalcip,xy00,xy10,xy11,xy20,xy21,xy22,xy30,xy31,xy32,xy33,indstart,indend,iaset,ibset,icset,idset);
    }

    return res;
}

//phantomx
template <class T>
T &MercerKernel::xKKm(int m, T &res,
                     Vector<const SparseVector<gentype> *> &x,
                     Vector<const vecInfo *> &xinfo,
                     const Vector<int> &xgradOrder,
                     Vector<const SparseVector<gentype> *> &xff,
                     const T &bias,
                     Vector<int> &i,
                     const gentype **pxyprod, int xdim, int xconsist, int assumreal, int resmode, int mlid,
                     const Matrix<double> *xy, int justcalcip, const Vector<int> *xiset, int indstart, int indend, int ns) const
{
    T logres; logres = 0.0;
    T tempres; tempres = 0.0;
    int logresvalid = 0;
    //int ns = numSplits();
    int q,s,r = 0;

    NiceAssert( !isfullnorm || ( xgradOrder == 0 ) );

    if ( isfullnorm && !ns && !justcalcip )
    {
        int effm = 0;
        int ii,jj,kk=0;

        for ( ii = 0 ; ii < m ; ii += (*(xinfo(ii))).xusize() )
        {
            ++effm;
        }

        NiceAssert( ii == m );

        T tma; tma = 1.0;
        T tmb;

        KKm(m,res,logres,logresvalid,x,xinfo,xgradOrder,xff,bias,i,pxyprod,xdim,xconsist,assumreal,resmode,mlid,xy,nullptr,justcalcip,indstart,indend,xiset);

        T logtma; logtma = 0.0; // must be zero
        T logtmb; logtmb = 0.0;

        int logtmavalid = 1; // deliberately 1
        int logtmbvalid = 0;

        int effeffm = 0;

        for ( ii = 0 ; ii < m ; ii += (*(xinfo(ii))).xusize() )
        {
            int usize = (*(xinfo(ii))).xusize();
            int mcsize = usize*effm;

            Vector<const SparseVector<gentype> *> xa(mcsize);
            Vector<const vecInfo *> xainfo(mcsize);
            Vector<int> ia(mcsize);
            Vector<int> iaset(mcsize);
            Vector<int> xagradOrder(mcsize);
            Vector<const SparseVector<gentype> *>xaff(xff);

            retVector<const SparseVector<gentype> *> tmpva;
            retVector<const vecInfo *>               tmpvb;
            retVector<int>                           tmpvc;
            retVector<int>                           tmpvd;
            retVector<int>                           tmpve;
            retVector<const SparseVector<gentype> *> tmpvf;

            for ( jj = 0 ; jj < usize ; ++jj )
            {
                xa("&",jj*effm,1,((jj+1)*effm)-1,tmpva)          = x(ii+jj);
                xainfo("&",jj*effm,1,((jj+1)*effm)-1,tmpvb)      = xinfo(ii+jj);
                ia("&",jj*effm,1,((jj+1)*effm)-1,tmpvc)          = i(ii+jj);
                iaset("&",jj*effm,1,((jj+1)*effm)-1,tmpvd)       = (*xiset)(ii+jj);
                xagradOrder("&",jj*effm,1,((jj+1)*effm)-1,tmpve) = xagradOrder(ii+jj);
                xaff("&",jj*effm,1,((jj+1)*effm)-1,tmpvf)        = xaff(ii+jj);
            }

            logtmbvalid = 0;

            KKm(mcsize,tmb,logtmb,logtmbvalid,xa,xainfo,xagradOrder,xaff,bias,ia,pxyprod,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,justcalcip,indstart,indend,&iaset);

            if ( (double) abs2(tmb) > BADZEROTOL )
            {
                effeffm++;
                tma *= tmb;
                logtma += logtmb;
                logtmavalid *= logtmbvalid;
            }

            else
            {
                NiceThrow("xkkm not defined for normalised zeros");
            }

            ++kk;
        }

        if ( ( effeffm == 0 ) || ( effeffm == 1 ) )
        {
            res = 1.0;
        }

        else
        {
            if ( logresvalid && logtmavalid )
            {
                logtma /= effeffm;

                res  = logres;
                res -= logtma;

                OP_exp(res);
            }

            else
            {
                T oneonm; oneonm = 1.0/effeffm;

                tma = pow(tma,oneonm);
                safedivby(res,tma); //res /= tma;
            }
        }
    }

    else if ( !isfullnorm && ns && !justcalcip )
    {
        Vector<int> splitPoint(ns);
        Vector<int> splitType(ns);

        if ( ns )
        {
            for ( q = indstart ; q < indend ; ++q )
            {
                if ( isSplit(q) )
                {
                    splitPoint("&",r) = q;
                    splitType("&",r) = isSplit(q);
                    ++r;
                }
            }
        }

        int maxusize = 1;

        for ( q = 0 ; q < m ; ++q )
        {
            if ( (*(xinfo(q))).xusize() > maxusize )
            {
                maxusize = (*(xinfo(q))).xusize();
            }
        }

        Vector<Vector<const SparseVector<gentype> *> > xx(maxusize);
        Vector<Vector<const vecInfo *> > xxinfo(maxusize);
        Vector<Vector<int> > ii(maxusize);
        Vector<Vector<int> > iiset(maxusize);
        Vector<Vector<int> > xxgradOrder(maxusize);
        Vector<Vector<const SparseVector<gentype> *> > xxaff(maxusize);

        for ( q = 0 ; q < m ; )
        {
            int usize = (*(xinfo(q))).xusize();

            for ( r = 0 ; r < usize ; ++q,++r )
            {
                s = xx(r).size();

                xx("&",r).add(s);          xx("&",r)("&",s)          = x(q);
                xxinfo("&",r).add(s);      xxinfo("&",r)("&",s)      = xinfo(q);
                ii("&",r).add(s);          ii("&",r)("&",s)          = i(q);
                iiset("&",r).add(s);       iiset("&",r)("&",s)       = xiset ? (*xiset)(q) : 0;
                xxgradOrder("&",r).add(s); xxgradOrder("&",r)("&",s) = xgradOrder(q);
                xxaff("&",r).add(s);       xxaff("&",r)("&",s)       = xff(q);
            }
        }

        for ( r = 0 ; r < maxusize ; ++r )
        {
            int indstartq = indstart;
            int indendq   = indend;

            if ( r%(ns+1) == 0 )
            {
                indstartq = indstart;
                indendq   = splitPoint(r%(ns+1));
            }

            else if ( r%(ns+1) < ns )
            {
                indstartq = splitPoint((r-1)%(ns+1))+1;
                indendq   = splitPoint(r%(ns+1));
            }

            else
            {
                indstartq = splitPoint((r-1)%(ns+1))+1;
                indendq   = indend;
            }

            if ( r == 0 )
            {
                KKm(xx(r).size(),res,logres,logresvalid,xx("&",r),xxinfo("&",r),xxgradOrder("&",r),xxaff("&",r),bias,ii("&",r),nullptr,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,justcalcip,indstartq,indendq,&(iiset("&",r)));
            }

            else
            {
                KKm(xx(r).size(),tempres,logres,logresvalid,xx("&",r),xxinfo("&",r),xxgradOrder("&",r),xxaff("&",r),bias,ii("&",r),nullptr,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,justcalcip,indstartq,indendq,&(iiset("&",r)));

                if ( splitType(r-1) == 1 )
                {
                    res *= tempres;
                }

                else
                {
                    res += tempres;
                }
            }
        }
    }

    else if ( isfullnorm && ns && !justcalcip )
    {
        Vector<int> splitPoint(ns);

        if ( ns )
        {
            for ( q = indstart ; q < indend ; ++q )
            {
                if ( isSplit(q) )
                {
                    splitPoint("&",r) = q;
                    NiceAssert( isSplit(q) == 1 );
                    ++r;
                }
            }
        }

        int maxusize = 1;

        for ( q = 0 ; q < m ; ++q )
        {
            if ( (*(xinfo(q))).xusize() > maxusize )
            {
                maxusize = (*(xinfo(q))).xusize();
            }
        }

        Vector<Vector<const SparseVector<gentype> *> > xx(maxusize);
        Vector<Vector<const vecInfo *> > xxinfo(maxusize);
        Vector<Vector<int> > ii(maxusize);
        Vector<Vector<int> > iiset(maxusize);
        Vector<Vector<int> > xxgradOrder(maxusize);
        Vector<Vector<const SparseVector<gentype> *> > xxaff(maxusize);

        for ( q = 0 ; q < m ; )
        {
            int usize = (*(xinfo(q))).xusize();

            for ( r = 0 ; r < usize ; ++q,++r )
            {
                s = xx(r).size();

                xx("&",r).add(s);          xx("&",r)("&",s)          = x(q);
                xxinfo("&",r).add(s);      xxinfo("&",r)("&",s)      = xinfo(q);
                ii("&",r).add(s);          ii("&",r)("&",s)          = i(q);
                iiset("&",r).add(s);       iiset("&",r)("&",s)       = xiset ? (*xiset)(q) : 0;
                xxgradOrder("&",r).add(s); xxgradOrder("&",r)("&",s) = xgradOrder(q);
                xxaff("&",r).add(s);       xxaff("&",r)("&",s)       = xff(q);
            }
        }

        res = 1.0;

        for ( r = 0 ; r < maxusize ; ++r )
        {
            int indstartq = indstart;
            int indendq   = indend;

            if ( r%(ns+1) == 0 )
            {
                indstartq = indstart;
                indendq   = splitPoint(r%(ns+1));
            }

            else if ( r%(ns+1) < ns )
            {
                indstartq = splitPoint((r-1)%(ns+1))+1;
                indendq   = splitPoint(r%(ns+1));
            }

            else
            {
                indstartq = splitPoint((r-1)%(ns+1))+1;
                indendq   = indend;
            }

            int locm = xx(r).size();

            if ( locm > 1 )
            {
                KKm(locm,tempres,logres,logresvalid,xx("&",r),xxinfo("&",r),xxgradOrder("&",r),xxaff("&",r),bias,ii("&",r),nullptr,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,justcalcip,indstartq,indendq,&(iiset("&",r)));

                T logtma; logtma = 0.0; // must be zero
                T logtmb; logtmb = 0.0;
                T tma; tma = 1.0;
                T tmb;
                int logtmavalid = 1;
                int logtmbvalid = 0;
                Vector<int> repind(locm);
                int jj;
                int effeffm = 0;

                retVector<const SparseVector<gentype> *> tmpva;
                retVector<const vecInfo *>               tmpvb;
                retVector<int>                           tmpvc;
                retVector<int>                           tmpvd;
                retVector<const SparseVector<gentype> *> tmpve;

                for ( jj = 0 ; jj < locm ; ++jj )
                {
                    repind = jj;

                    KKm(locm,tmb,logtmb,logtmbvalid,xx("&",r)("&",repind,tmpva),xxinfo("&",r)("&",repind,tmpvb),xxgradOrder("&",r)("&",repind,tmpvd),xxaff("&",r)("&",repind,tmpve),bias,ii("&",r)("&",repind,tmpvc),nullptr,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,justcalcip,indstartq,indendq,&(iiset("&",r)));

                    if ( (double) abs2(tmb) > BADZEROTOL )
                    {
                        effeffm++;
                        tma *= tmb;
                        logtma += logtmb;
                        logtmavalid *= logtmbvalid;
                    }

                    else
                    {
                        NiceThrow("m-kernel normalisation with zeros not implemented yet.");
                    }
                }

                if ( ( effeffm == 0 ) || ( effeffm == 1 ) )
                {
                    tempres = 1.0;
                }

                else
                {
                    if ( logresvalid && logtmavalid )
                    {
                        logtma /= effeffm;

                        tempres  = logres;
                        tempres -= logtma;

                        OP_exp(tempres);
                    }

                    else
                    {
                        T oneonm; oneonm = 1.0/effeffm;

                        tma = pow(tma,oneonm);
                        safedivby(tempres,tma); //res /= tma;
                    }
                }

                res *= tempres;
            }
        }
    }

    else
    {
        KKm(m,res,logres,logresvalid,x,xinfo,xgradOrder,xff,bias,i,pxyprod,xdim,xconsist,assumreal,resmode,mlid,xy,nullptr,justcalcip,indstart,indend,xiset);
    }

    return res;
}


























inline int isgentype(const gentype &ind);
inline int isgentype(const double  &ind);

inline int isgentype(const gentype &ind)
{
    (void) ind;

    return 1;
}

inline int isgentype(const double &ind)
{
    (void) ind;

    return 0;
}

inline int isiteqn(const gentype &ind);
inline int isiteqn(const double  &ind);

inline int isiteqn(const gentype &ind)
{
    return ind.isValEqn();
}

inline int isiteqn(const double &ind)
{
    (void) ind;

    return 0;
}
























//phantomx
template <class T>
T &MercerKernel::KK0(T &res, T &logres, int &logresvalid,
                     const T &bias,
                     const gentype **pxyprod,
                     int xdim, int xconsist, int assumreal, int resmode, int mlid,
                     int justcalcip, int indstart, int indend, int skipbias) const
{
    if ( !skipbias && isiteqn(bias) )
    {
        // We are dealing with distributions, so need to delay finalisation 
        // of random parts of the function and then average *outside* the loop
        //
        // See Muandet et al, Learning from Distributions via Support Measure Machines

        int q;
        int maxq = numSamples();

        SparseVector<SparseVector<gentype> > subval;

        // Take maxq samples from output distribution

        for ( q = 0 ; q < maxq ; ++q )
        {
            gentype gbias(bias);
            gentype gres,glogres;

            if ( !subSample(subval,gbias) && !q )
            {
                goto postbias;
            }

            KK0(gres,glogres,logresvalid,gbias,nullptr,xdim,xconsist,assumreal,resmode,mlid,justcalcip,indstart,indend,1);

            if ( !q ) { res =  (T) gres; }
            else      { res += (T) gres; }
        }

        res /= maxq;

        logresvalid = 0;

        return res;
    }

postbias:

    LL0(res,logres,logresvalid,bias,pxyprod,xdim,xconsist,assumreal,resmode,mlid,justcalcip,indstart,indend);

    return res;
}

//phantomx
template <class T>
T &MercerKernel::KK1(T &res, T &logres, int &logresvalid,
                     const SparseVector<gentype> &xa,
                     const vecInfo &xainfo,
                     int xagradOrder,
                     const SparseVector<gentype> &xaff,
                     const T &bias,
                     const gentype **pxyprod,
                     int ia,
                     int xdim, int xconsist, int assumreal, int resmode, int mlid,
                     const double *xy, int justcalcip, int indstart, int indend,
                     int iaset,
                     int skipbias,
                     int skipxa) const
{
    (void) xaff;

    if ( xagradOrder )
    {
        if ( isFastKernelSum() && !isNormalised(indend) && !needsDiff() && !needsNorm() && !justcalcip )
        {
            // In this case we have a simple inner product kernel, no normalisation,
            // nothing complicating.  In this case:
            //
            // K1(xa) = k(<<xa>>_1) = k(<xa,1>>_2) = K2(xa,1)
            //
            // allowing us to "borrow" the gradient calculation from K2

            SparseVector<gentype> xx(xa);
            vecInfo xxinfo;

            xx = 1.0_gent;
            getvecInfo(xxinfo,xx);

            return KK2(0,0,res,logres,logresvalid,
                       xa,xx,
                       xainfo,xxinfo,
                       xagradOrder,0,
                       xaff,xx,
                       bias,
                       pxyprod,
                       ia,-1,
                       xdim,xconsist,assumreal,resmode,mlid,
                       nullptr,nullptr,nullptr,justcalcip,indstart,indend,
                       iaset,0);
        }
    }

    NiceAssert( !xagradOrder );

    if ( !skipbias && isiteqn(bias) )
    {
        // We are dealing with distributions, so need to delay finalisation 
        // of random parts of the function and then average *outside* the loop
        //
        // See Muandet et al, Learning from Distributions via Support Measure Machines

        int qb;
        int maxq = numSamples();

        SparseVector<SparseVector<gentype> > subval;

        // Take maxq samples from output distribution

        for ( qb = 0 ; qb < maxq ; ++qb )
        {
            gentype gbias(bias);

            if ( !subSample(subval,gbias) && !qb )
            {
                goto postbias;
            }

            gentype gres,glogres;

            KK1(gres,glogres,logresvalid,xa,xainfo,xagradOrder,xaff,gbias,nullptr,ia,xdim,xconsist,assumreal,resmode,mlid,nullptr,justcalcip,indstart,indend,iaset,1,skipxa);

            if ( !qb ) { res =  (T) gres; }
            else       { res += (T) gres; }
        }

        res /= maxq;

        logresvalid = 0;

        return res;
    }

postbias:

    if ( !skipxa && xainfo.xiseqn() )
    {
        // We are dealing with distributions, so need to delay finalisation 
        // of random parts of the function and then average *outside* the loop
        //
        // See Muandet et al, Learning from Distributions via Support Measure Machines

        int qxa;
        int maxq = numSamples();

        gentype gbias(bias);

        SparseVector<SparseVector<gentype> > subval;

        // Take maxq samples from output distribution

        for ( qxa = 0 ; qxa < maxq ; ++qxa )
        {
            SparseVector<gentype> xxa(xa);
            vecInfo xxainfo;

            if ( !subSample(subval,xxa,xxainfo) && !qxa )
            {
                goto postxa;
            }

            gentype gres,glogres;

            KK1(gres,glogres,logresvalid,xxa,xxainfo,xagradOrder,xaff,gbias,nullptr,ia,xdim,xconsist,assumreal,resmode,mlid,nullptr,justcalcip,indstart,indend,iaset,skipbias,1);

            if ( !qxa )        { res =  (T) gres; }
            else if ( !iaset ) { res += (T) gres; }
            else               { res =  ( ( (T) gres ) > ( (T) res ) ) ? ( (T) gres ) : ( (T) res ); }
        }

        if ( !iaset )
        {
            res /= maxq;
        }

        logresvalid = 0;

        return res;
    }

postxa:

    LL1(res,logres,logresvalid,xa,xainfo,bias,pxyprod,ia,xdim,xconsist,assumreal,resmode,mlid,xy,justcalcip,indstart,indend);

    return res;
}

//phantomx
template <class T>
T &MercerKernel::KK2(int adensetype, int bdensetype, T &res, T &logres, int &logresvalid,
                     const SparseVector<gentype> &xa, const SparseVector<gentype> &xb,
                     const vecInfo &xainfo, const vecInfo &xbinfo,
                     int xagradOrder, int xbgradOrder,
                     const SparseVector<gentype> &xaff, const SparseVector<gentype> &xbff,
                     const T &bias,
                     const gentype **pxyprod,
                     int ia, int ib,
                     int xdim, int xconsist, int assumreal, int resmode, int mlid,
                     const double *xy00, const double *xy10, const double *xy11, int justcalcip, int indstart, int indend,
                     int iaset, int ibset,
                     int skipbias,
                     int skipxa, int skipxb) const
{
    NiceAssert( adensetype >= 0 );
    NiceAssert( bdensetype >= 0 );

    int dummyind = 0;

    if ( xagradOrder && xbgradOrder )
    {
        if ( xaff.size() && xbff.size() )
        {
            // case 22

            if ( ( xagradOrder == 1 ) && ( xbgradOrder == 1 ) )
            {
                // <ex,d2K/dxdy,ey>

                T xascaleres; // xxscaleres
                T xyscaleres; // xyscaleres
                T yxscaleres; // yxscaleres
                T xbscaleres; // yyscaleres

                T constres;

                qqqd2K2delxdely(xascaleres,xbscaleres,xyscaleres,yxscaleres,constres,dummyind,xa,xb,xainfo,xbinfo,bias,pxyprod,ia,ib,xdim,xconsist,mlid,xy00,xy10,xy11,0,iaset,ibset,assumreal);

                NiceAssert( dummyind < 0 );

                gentype exa;
                gentype exy;
                gentype xey;
                gentype yey;

                gentype exey;

                innerProduct(exa,xaff,xa);
                innerProduct(exy,xaff,xb);
                innerProduct(xey,xa,xbff);
                innerProduct(yey,xb,xbff);

                innerProduct(exey,xaff,xbff);

                res = (((T) exa)*xascaleres*((T) xey))
                    + (((T) exa)*xyscaleres*((T) yey))
                    + (((T) exy)*yxscaleres*((T) xey))
                    + (((T) exy)*xbscaleres*((T) yey))
                    + (constres*((T) exey));
            }

            else
            {
                // <(ex d/dx)^n (ey d/dy)^n,K>

                int resxadim = (int) pow(xdim,xagradOrder);
                int resxbdim = (int) pow(xdim,xbgradOrder);

                res = 0.0;

                Vector<T> sc;
                Vector<Vector<int> > nn;

                Vector<int> q(xagradOrder+xagradOrder);

                retVector<int> tmpva;

                q("&",0          ,1,xagradOrder-1            ,tmpva) = 0;
                q("&",xagradOrder,1,xagradOrder+xbgradOrder-1,tmpva) = 1;

                // Here we use the result: vec(ABC) = vec(C' \otimes A).vec(B), so if
                // we let a = xifarfar, c = xjfarfar, then:
                // a'.B.c = vec(c' \otimes a').vec(B)
                //        = vec(c \otimes a)'.vec(B)
                // where vec(B) is the vectorised *transpose* gradient we usually calculate, so, getting rid of the transpose,
                // we need to take the inner product with vec(ex \otimes ey)
                // ORIGINAL INCORRECT VERSION: where vec(B) is precisely the vectorised gradient we usually calculate
                //
                // CLARIFICATION: see pdf in stable bayesian optimisation paper

                int iqa,jqa;
                gentype tmp;

                SparseVector<gentype> kres;
                SparseVector<gentype> farfarprod;
                Vector<const SparseVector<gentype> *> bord;

                // first calculate c \otimes a

                int dimmy = 0;

                //kronprod(farfarprod,*xjfarfar,*xifarfar,pow(xdim,xbgradOrder),pow(xdim,xagradOrder)); //- NB order wrong here, have tested and confirmed, following line is correct.
                kronprod(farfarprod,dimmy,xaff,xbff,resxadim,resxbdim);

                // Gradient

                qqqdnK2del(sc,nn,dummyind,q,xa,xb,xainfo,xbinfo,bias,pxyprod,ia,ib,xdim,xconsist,mlid,xy00,xy10,xy11,0,iaset,ibset,assumreal);

                NiceAssert( dummyind < 0 );

                // Then proceed in fully vectorised form

                for ( iqa = 0 ; iqa < sc.size() ; ++iqa )
                {
                    bord.resize(nn(iqa).size());

                    for ( jqa = 0 ; jqa < nn(iqa).size() ; ++jqa )
                    {
                        bord("&",jqa) = ( nn(iqa)(jqa) == 0 ) ? &xa : ( ( nn(iqa)(jqa) == 1 ) ? &xb : nullptr );
                    }

                    kronprod(kres,bord,nn(iqa),xdim);

                    innerProduct(tmp,farfarprod,kres);

                    res += ((T) tmp)*((T) sc(iqa));
                }
            }
        }

        else if ( xaff.size() && !xbff.size() )
        {
            // case 42

            if ( ( xagradOrder == 1 ) && ( xbgradOrder == 1 ) )
            {
                // <ex,d2K/dxdy,ey>

                resizeZeroVec(res,xdim);

                T xascaleres;
                T xyscaleres;
                T yxscaleres;
                T xbscaleres;

                T constres;

                int jqa;

                qqqd2K2delxdely(xascaleres,xbscaleres,xyscaleres,yxscaleres,constres,dummyind,xa,xb,xainfo,xbinfo,bias,pxyprod,ia,ib,xdim,xconsist,mlid,xy00,xy10,xy11,0,iaset,ibset,assumreal);

                NiceAssert( dummyind < 0 );

                gentype exa;
                gentype exy;

                innerProduct(exa,xaff,xa);
                innerProduct(exy,xaff,xb);

                for ( jqa = 0 ; jqa < xdim ; ++jqa )
                {
                    getVecElm(res,jqa) += ((T) exa)*((T) xascaleres)*((T) (xa(jqa)));
                    getVecElm(res,jqa) += ((T) exa)*((T) xyscaleres)*((T) (xb(jqa)));
                    getVecElm(res,jqa) += ((T) exy)*((T) yxscaleres)*((T) (xa(jqa)));
                    getVecElm(res,jqa) += ((T) exy)*((T) xbscaleres)*((T) (xb(jqa)));

                    getVecElm(res,jqa) += ((T) constres)*((T) (xaff(jqa)));
                }
            }

            else
            {
                // <(ex d/dx)^n (ey d/dy)^n,K>

                int resxadim = (int) pow(xdim,xagradOrder);
                int resxbdim = (int) pow(xdim,xbgradOrder);

                resizeZeroVec(res,resxbdim);

                Vector<T> sc;
                Vector<Vector<int> > nn;

                Vector<int> q(xagradOrder+xbgradOrder);

                retVector<int> tmpva;

                q("&",0          ,1,xagradOrder-1            ,tmpva) = 0;
                q("&",xagradOrder,1,xagradOrder+xbgradOrder-1,tmpva) = 1;

                // Here we use the result: vec(ABC) = vec(C' \otimes A).vec(B), so if
                // we let a = xifarfar, c = xjfarfar, then:
                // a'.B.c = vec(c' \otimes a').vec(B)
                //        = vec(c \otimes a)'.vec(B)
                // where vec(B) is the vectorised *transpose* gradient we usually calculate, so, getting rid of the transpose,
                // we need to take the inner product with vec(ex \otimes ey)
                // ORIGINAL INCORRECT VERSION: where vec(B) is precisely the vectorised gradient we usually calculate
                //
                // CLARIFICATION: see pdf in stable bayesian optimisation paper

                int iqa,jqa,kqa;
                gentype tmp;

                SparseVector<gentype> kres;
                Vector<const SparseVector<gentype> *> bord;

                // Gradient

                qqqdnK2del(sc,nn,dummyind,q,xa,xb,xainfo,xbinfo,bias,pxyprod,ia,ib,xdim,xconsist,mlid,xy00,xy10,xy11,0,iaset,ibset,assumreal);

                NiceAssert( dummyind < 0 );

                // Then proceed in fully vectorised form

                for ( iqa = 0 ; iqa < sc.size() ; ++iqa )
                {
                    bord.resize(nn(iqa).size());

                    for ( jqa = 0 ; jqa < nn(iqa).size() ; ++jqa )
                    {
                        bord("&",jqa) = ( nn(iqa)(jqa) == 0 ) ? &xa : ( ( nn(iqa)(jqa) == 1 ) ? &xb : nullptr );
                    }

                    kronprod(kres,bord,nn(iqa),xdim);

                    for ( jqa = 0 ; jqa < resxadim ; ++jqa )
                    {
                        for ( kqa = 0 ; kqa < resxbdim ; ++kqa )
                        {
                            getVecElm(res,kqa) += ((T) sc(iqa))*((T) (kres((jqa*resxbdim)+kqa)))*((T) (xaff)(jqa));
                        }
                    }
                }
            }
        }

        else if ( !xaff.size() && xbff.size() )
        {
            // case 24

            if ( ( xagradOrder == 1 ) && ( xbgradOrder == 1 ) )
            {
                // <ex,d2K/dxdy,ey>

                resizeZeroVec(res,xdim);

                T xascaleres;
                T xyscaleres;
                T yxscaleres;
                T xbscaleres;

                T constres;

                int jqa;

                qqqd2K2delxdely(xascaleres,xbscaleres,xyscaleres,yxscaleres,constres,dummyind,xa,xb,xainfo,xbinfo,bias,pxyprod,ia,ib,xdim,xconsist,mlid,xy00,xy10,xy11,0,iaset,ibset,assumreal);

                NiceAssert( dummyind < 0 );

                gentype xey;
                gentype yey;

                innerProduct(xey,xa,xbff);
                innerProduct(yey,xb,xbff);

                for ( jqa = 0 ; jqa < xdim ; ++jqa )
                {
                    getVecElm(res,jqa) += ((T) ((xa)(jqa)))*((T) xascaleres)*((T) xey);
                    getVecElm(res,jqa) += ((T) ((xa)(jqa)))*((T) xyscaleres)*((T) yey);
                    getVecElm(res,jqa) += ((T) ((xb)(jqa)))*((T) yxscaleres)*((T) xey);
                    getVecElm(res,jqa) += ((T) ((xb)(jqa)))*((T) xbscaleres)*((T) yey);

                    getVecElm(res,jqa) += ((T) constres)*((T) ((xbff)(jqa)));
                }
            }

            else
            {
                // <(ex d/dx)^n (ey d/dy)^n,K>

                int resxadim = (int) pow(xdim,xagradOrder);
                int resxbdim = (int) pow(xdim,xbgradOrder);

                resizeZeroVec(res,resxadim);

                Vector<T> sc;
                Vector<Vector<int> > nn;

                Vector<int> q(xagradOrder+xbgradOrder);

                retVector<int> tmpva;

                q("&",0          ,1,xagradOrder-1            ,tmpva) = 0;
                q("&",xagradOrder,1,xagradOrder+xbgradOrder-1,tmpva) = 1;

                // Here we use the result: vec(ABC) = vec(C' \otimes A).vec(B), so if
                // we let a = xifarfar, c = xjfarfar, then:
                // a'.B.c = vec(c' \otimes a').vec(B)
                //        = vec(c \otimes a)'.vec(B)
                // where vec(B) is the vectorised *transpose* gradient we usually calculate, so, getting rid of the transpose,
                // we need to take the inner product with vec(ex \otimes ey)
                // ORIGINAL INCORRECT VERSION: where vec(B) is precisely the vectorised gradient we usually calculate
                //
                // CLARIFICATION: see pdf in stable bayesian optimisation paper

                int iqa,jqa,kqa;
                gentype tmp;

                SparseVector<gentype> kres;
                Vector<const SparseVector<gentype> *> bord;

                // Gradient

                qqqdnK2del(sc,nn,dummyind,q,xa,xb,xainfo,xbinfo,bias,pxyprod,ia,ib,xdim,xconsist,mlid,xy00,xy10,xy11,0,iaset,ibset,assumreal);

                NiceAssert( dummyind < 0 );

                // Then proceed in fully vectorised form

                for ( iqa = 0 ; iqa < sc.size() ; ++iqa )
                {
                    bord.resize(nn(iqa).size());

                    for ( jqa = 0 ; jqa < nn(iqa).size() ; ++jqa )
                    {
                        bord("&",jqa) = ( nn(iqa)(jqa) == 0 ) ? &xa : ( ( nn(iqa)(jqa) == 1 ) ? &xb : nullptr );
                    }

                    kronprod(kres,bord,nn(iqa),xdim);

                    for ( jqa = 0 ; jqa < resxadim ; ++jqa )
                    {
                        for ( kqa = 0 ; kqa < resxbdim ; ++kqa )
                        {
                            getVecElm(res,jqa) += ((T) sc(iqa))*((T) (kres((jqa*resxbdim)+kqa)))*((T) (xbff)(kqa));
                        }
                    }
                }
            }
        }

        else
        {
            // case 44

            if ( ( xagradOrder == 1 ) && ( xbgradOrder == 1 ) )
            {
                // <ex,d2K/dxdy,ey>

                resizeZeroMat(res,xdim,xdim);

                T xascaleres;
                T xyscaleres;
                T yxscaleres;
                T xbscaleres;

                T constres;

                int jqa,kqa;

                qqqd2K2delxdely(xascaleres,xbscaleres,xyscaleres,yxscaleres,constres,dummyind,xa,xb,xainfo,xbinfo,bias,pxyprod,ia,ib,xdim,xconsist,mlid,xy00,xy10,xy11,0,iaset,ibset,assumreal);

                NiceAssert( dummyind < 0 );

                for ( jqa = 0 ; jqa < xdim ; ++jqa )
                {
                    for ( kqa = 0 ; kqa < xdim ; ++kqa )
                    {
                        getMatElm(res,jqa,kqa) += ((T) xascaleres)*((T) ((xa)(jqa)))*((T) ((xa)(kqa)));
                        getMatElm(res,jqa,kqa) += ((T) xbscaleres)*((T) ((xb)(jqa)))*((T) ((xb)(kqa)));
                        getMatElm(res,jqa,kqa) += ((T) xyscaleres)*((T) ((xa)(jqa)))*((T) ((xb)(kqa)));
                        getMatElm(res,jqa,kqa) += ((T) yxscaleres)*((T) ((xb)(jqa)))*((T) ((xa)(kqa)));
                    }

                    getMatElm(res,jqa,jqa) += ((T) constres);
                }
            }

            else
            {
                // <(ex d/dx)^n (ey d/dy)^n,K>

                int resxadim = (int) pow(xdim,xagradOrder);
                int resxbdim = (int) pow(xdim,xbgradOrder);

                resizeZeroMat(res,resxadim,resxbdim);

                Vector<T> sc;
                Vector<Vector<int> > nn;

                Vector<int> q(xagradOrder+xbgradOrder);

                retVector<int> tmpva;

                q("&",0          ,1,xagradOrder-1            ,tmpva) = 0;
                q("&",xagradOrder,1,xagradOrder+xbgradOrder-1,tmpva) = 1;

                // Here we use the result: vec(ABC) = vec(C' \otimes A).vec(B), so if
                // we let a = xifarfar, c = xjfarfar, then:
                // a'.B.c = vec(c' \otimes a').vec(B)
                //        = vec(c \otimes a)'.vec(B)
                // where vec(B) is the vectorised *transpose* gradient we usually calculate, so, getting rid of the transpose,
                // we need to take the inner product with vec(ex \otimes ey)
                // ORIGINAL INCORRECT VERSION: where vec(B) is precisely the vectorised gradient we usually calculate
                //
                // CLARIFICATION: see pdf in stable bayesian optimisation paper

                int iqa,jqa,kqa;

                SparseVector<gentype> kres;
                SparseVector<gentype> farfarprod;
                Vector<const SparseVector<gentype> *> bord;

                // Gradient

                qqqdnK2del(sc,nn,dummyind,q,xa,xb,xainfo,xbinfo,bias,pxyprod,ia,ib,xdim,xconsist,mlid,xy00,xy10,xy11,0,iaset,ibset,assumreal);

                NiceAssert( dummyind < 0 );

                // Then proceed in fully vectorised form

                for ( iqa = 0 ; iqa < sc.size() ; ++iqa )
                {
                    bord.resize(nn(iqa).size());

                    for ( jqa = 0 ; jqa < nn(iqa).size() ; ++jqa )
                    {
                        bord("&",jqa) = ( nn(iqa)(jqa) == 0 ) ? &xa : ( ( nn(iqa)(jqa) == 1 ) ? &xb : nullptr );
                    }

                    kronprod(kres,bord,nn(iqa),xdim);

                    for ( jqa = 0 ; jqa < resxadim ; ++jqa )
                    {
                        for ( kqa = 0 ; kqa < resxbdim ; ++kqa )
                        {
                            getMatElm(res,jqa,kqa) += ((T) sc(iqa))*((T) (kres((jqa*resxbdim)+kqa)));
                        }
                    }
                }
            }
        }
    }

    else if ( xagradOrder && !xbgradOrder )
    {
        NiceAssert( !justcalcip );

        if ( xaff.size() )
        {
            // case 2

            if ( xagradOrder == 1 )
            {
                // <ex,dK/dx> = <ex,x.ax + y.ay>
                //            = <ex,x>.ax + <ex,y>.ay

                T xascaleres;
                T xbscaleres;

                qqqdK2delx(xascaleres,xbscaleres,dummyind,xa,xb,xainfo,xbinfo,bias,pxyprod,ia,ib,xdim,xconsist,mlid,xy00,xy10,xy11,iaset,ibset,assumreal);

                NiceAssert( dummyind < 0 );

                gentype exa;
                gentype exy;

                innerProduct(exa,xaff,xa);
                innerProduct(exy,xaff,xb);

                res = (((T) exa)*xascaleres)+(((T) exy)*xbscaleres);
            }

            else
            {
                // <(ex d/dx)^n,K>

                res = 0.0;

                Vector<T> sc;
                Vector<Vector<int> > nn;

                Vector<int> q(xagradOrder);

                q = 0;

                int iqa,jqa;
                gentype tmp;

                SparseVector<gentype> kres;
                Vector<const SparseVector<gentype> *> bord;

                qqqdnK2del(sc,nn,dummyind,q,xa,xb,xainfo,xbinfo,bias,pxyprod,ia,ib,xdim,xconsist,mlid,xy00,xy10,xy11,0,iaset,ibset,assumreal);

                NiceAssert( dummyind < 0 );

                for ( iqa = 0 ; iqa < sc.size() ; ++iqa )
                {
                    bord.resize(nn(iqa).size());

                    for ( jqa = 0 ; jqa < nn(iqa).size() ; ++jqa )
                    {
                        bord("&",jqa) = ( nn(iqa)(jqa) == 0 ) ? &xa : ( ( nn(iqa)(jqa) == 1 ) ? &xb : nullptr );
                    }

                    kronprod(kres,bord,nn(iqa),xdim);

                    innerProduct(tmp,xaff,kres);

                    res += ((T) tmp)*((T) sc(iqa));
                }
            }
        }

        else
        {
            // case 4

            if ( xagradOrder == 1 )
            {
                // <ex,dK/dx> = <ex,x.ax + y.ay>
                //            = <ex,x>.ax + <ex,y>.ay

                resizeZeroVec(res,xdim);

                T xascaleres;
                T xbscaleres;

                int jqa;

                qqqdK2delx(xascaleres,xbscaleres,dummyind,xa,xb,xainfo,xbinfo,bias,pxyprod,ia,ib,xdim,xconsist,mlid,xy00,xy10,xy11,iaset,ibset,assumreal);

                NiceAssert( dummyind < 0 );

                for ( jqa = 0 ; jqa < xdim ; ++jqa )
                {
                    getVecElm(res,jqa) += ((T) xascaleres)*((T) ((xa)(jqa)));
                    getVecElm(res,jqa) += ((T) xbscaleres)*((T) ((xb)(jqa)));
                }
            }

            else
            {
                // <(ex d/dx)^n,K>

                int resdim = (int) pow(xdim,xagradOrder);

                resizeZeroVec(res,resdim);

                Vector<T> sc;
                Vector<Vector<int> > nn;

                Vector<int> q(xagradOrder);

                q = 0;

                int iqa,jqa;

                SparseVector<gentype> kres;
                Vector<const SparseVector<gentype> *> bord;

                qqqdnK2del(sc,nn,dummyind,q,xa,xb,xainfo,xbinfo,bias,pxyprod,ia,ib,xdim,xconsist,mlid,xy00,xy10,xy11,0,iaset,ibset,assumreal);

                NiceAssert( dummyind < 0 );

                for ( iqa = 0 ; iqa < sc.size() ; ++iqa )
                {
                    bord.resize(nn(iqa).size());

                    for ( jqa = 0 ; jqa < nn(iqa).size() ; ++jqa )
                    {
                        bord("&",jqa) = ( nn(iqa)(jqa) == 0 ) ? &xa : ( ( nn(iqa)(jqa) == 1 ) ? &xb : nullptr );
                    }

                    kronprod(kres,bord,nn(iqa),xdim);

                    for ( jqa = 0 ; jqa < resdim ; ++jqa )
                    {
                        getVecElm(res,jqa) += ((T) sc(iqa))*((T) kres(jqa));
                    }
                }
            }
        }
    }

    else if ( !xagradOrder && xbgradOrder )
    {
        NiceAssert( !justcalcip );

        if ( xbff.size() )
        {
            // case 20

            if ( xbgradOrder == 1 )
            {
                // <dK/dy,ey> = <xa.x + ya.y,ey>
                //            = xa.<x,ey> + ya.<y,ey>

                T xascaleres;
                T xbscaleres;

                // MOD: do by reversing x and y, assuming symmetry.
                //dK2dely(xascaleres,xbscaleres,dummyind,ia,ib,bias,altK,nullptr,xanear,xbnear,xanearinfo,xbnearinfo,iaset,ibset);
                qqqdK2delx(xbscaleres,xascaleres,dummyind,xb,xa,xbinfo,xainfo,bias,pxyprod,ib,ia,xdim,xconsist,mlid,xy11,xy10,xy00,ibset,iaset,assumreal);

                NiceAssert( dummyind < 0 );

                gentype xey;
                gentype yey;

                innerProduct(xey,xa,xbff);
                innerProduct(yey,xb,xbff);

                res = (xascaleres*((T) xey))+(xbscaleres*((T) yey));
            }

            else
            {
                // <(ex d/dy)^n,K>

                res = 0.0;

                Vector<T> sc;
                Vector<Vector<int> > nn;

                Vector<int> q(xbgradOrder);

                q = 1;

                qqqdnK2del(sc,nn,dummyind,q,xa,xb,xainfo,xbinfo,bias,pxyprod,ia,ib,xdim,xconsist,mlid,xy00,xy10,xy11,0,iaset,ibset,assumreal);

                NiceAssert( dummyind < 0 );

                int iqa,jqa;
                gentype tmp;

                SparseVector<gentype> kres;
                Vector<const SparseVector<gentype> *> bord;

                for ( iqa = 0 ; iqa < sc.size() ; ++iqa )
                {
                    bord.resize(nn(iqa).size());

                    for ( jqa = 0 ; jqa < nn(iqa).size() ; ++jqa )
                    {
                        bord("&",jqa) = ( nn(iqa)(jqa) == 0 ) ? &xa : ( ( nn(iqa)(jqa) == 1 ) ? &xb : nullptr );
                    }

                    kronprod(kres,bord,nn(iqa),xdim);

                    innerProduct(tmp,xbff,kres);

                    res += ((T) tmp)*((T) sc(iqa));
                }
            }
        }

        else
        {
            // case 40

            if ( xbgradOrder == 1 )
            {
                // <dK/dy,ey> = <xa.x + ya.y,ey>
                //            = xa.<x,ey> + ya.<y,ey>

                resizeZeroVec(res,xdim);

                T xascaleres;
                T xbscaleres;

                int jqa;

                // MOD: do by reversing x and y, assuming symmetry.
                //dK2dely(xscaleres,yscaleres,dummyind,i, j, bias,altK,nullptr,xinear,xjnear,xinearinfo,xjnearinfo,iaset,ibset);
                qqqdK2delx(xbscaleres,xascaleres,dummyind,xb,xa,xbinfo,xainfo,bias,pxyprod,ib,ia,xdim,xconsist,mlid,xy11,xy10,xy00,ibset,iaset,assumreal);

                NiceAssert( dummyind < 0 );

                for ( jqa = 0 ; jqa < xdim ; ++jqa )
                {
                    getVecElm(res,jqa) += ((T) xascaleres)*((T) ((xa)(jqa)));
                    getVecElm(res,jqa) += ((T) xbscaleres)*((T) ((xb)(jqa)));
                }
            }

            else
            {
                // <(ex d/dy)^n,K>

                int resdim = (int) pow(xdim,xbgradOrder);

                resizeZeroVec(res,resdim);

                Vector<T> sc;
                Vector<Vector<int> > nn;

                Vector<int> q(xbgradOrder);

                q = 1;

                qqqdnK2del(sc,nn,dummyind,q,xa,xb,xainfo,xbinfo,bias,pxyprod,ia,ib,xdim,xconsist,mlid,xy00,xy10,xy11,0,iaset,ibset,assumreal);

                NiceAssert( dummyind < 0 );

                int iqa,jqa;

                SparseVector<gentype> kres;
                Vector<const SparseVector<gentype> *> bord;

                for ( iqa = 0 ; iqa < sc.size() ; ++iqa )
                {
                    bord.resize(nn(iqa).size());

                    for ( jqa = 0 ; jqa < nn(iqa).size() ; ++jqa )
                    {
                        bord("&",jqa) = ( nn(iqa)(jqa) == 0 ) ? &xa : ( ( nn(iqa)(jqa) == 1 ) ? &xb : nullptr );
                    }

                    kronprod(kres,bord,nn(iqa),xdim);

                    for ( jqa = 0 ; jqa < resdim ; ++jqa )
                    {
                        getVecElm(res,jqa) += ((T) sc(iqa))*((T) kres(jqa));
                    }
                }
            }
        }
    }

    else
    {
        if ( !skipbias && isiteqn(bias) )
        {
            // We are dealing with distributions, so need to delay finalisation 
            // of random parts of the function and then average *outside* the loop
            //
            // See Muandet et al, Learning from Distributions via Support Measure Machines

            int qb;
            int maxq = numSamples();

            SparseVector<SparseVector<gentype> > subval;

            // Take maxq samples from output distribution

            for ( qb = 0 ; qb < maxq ; ++qb )
            {
                gentype gbias(bias);

                if ( !subSample(subval,gbias) && !qb )
                {
                    goto postbias;
                }

                gentype gres,glogres;

                KK2(adensetype,bdensetype,gres,glogres,logresvalid,xa,xb,xainfo,xbinfo,xagradOrder,xbgradOrder,xaff,xbff,gbias,nullptr,ia,ib,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,justcalcip,indstart,indend,iaset,ibset,1,skipxa,skipxb);

                if ( !qb ) { res =  (T) gres; }
                else       { res += (T) gres; }
            }

            res /= maxq;

            logresvalid = 0;

            return res;
        }

postbias:

        if ( !skipxa && xainfo.xiseqn() )
        {
            // We are dealing with distributions, so need to delay finalisation 
            // of random parts of the function and then average *outside* the loop
            //
            // See Muandet et al, Learning from Distributions via Support Measure Machines

            int qxa;
            int maxq = numSamples();

            gentype gbias(bias);

            SparseVector<SparseVector<gentype> > subval;

            // Take maxq samples from output distribution

            for ( qxa = 0 ; qxa < maxq ; ++qxa )
            {
                SparseVector<gentype> xxa(xa);
                vecInfo xxainfo;

                if ( !subSample(subval,xxa,xxainfo) && !qxa )
                {
                    goto postxa;
                }

                gentype gres,glogres;

                KK2(adensetype,bdensetype,gres,glogres,logresvalid,xxa,xb,xxainfo,xbinfo,xagradOrder,xbgradOrder,xaff,xbff,gbias,nullptr,ia,ib,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,justcalcip,indstart,indend,iaset,ibset,skipbias,1,skipxb);

                if ( !qxa )        { res =  (T) gres; }
                else if ( !iaset ) { res += (T) gres; }
                else               { res =  ( ( (T) gres ) > ( (T) res ) ) ? ( (T) gres ) : ( (T) res ); }
            }

            if ( !iaset )
            {
                res /= maxq;
            }

            logresvalid = 0;

            return res;
        }

postxa:

        if ( !skipxb && xbinfo.xiseqn() )
        {
            // We are dealing with distributions, so need to delay finalisation 
            // of random parts of the function and then average *outside* the loop
            //
            // See Muandet et al, Learning from Distributions via Support Measure Machines

            int qxa;
            int maxq = numSamples();

            gentype gbias(bias);

            SparseVector<SparseVector<gentype> > subval;

            // Take maxq samples from output distribution

            for ( qxa = 0 ; qxa < maxq ; ++qxa )
            {
                SparseVector<gentype> xxb(xb);
                vecInfo xxbinfo;

                if ( !subSample(subval,xxb,xxbinfo) && !qxa )
                {
                    goto postxb;
                }

                gentype gres,glogres;

                KK2(adensetype,bdensetype,gres,glogres,logresvalid,xa,xxb,xainfo,xxbinfo,xagradOrder,xbgradOrder,xaff,xbff,gbias,nullptr,ia,ib,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,justcalcip,indstart,indend,iaset,ibset,skipbias,skipxa,1);

                if ( !qxa )        { res =  (T) gres; }
                else if ( !ibset ) { res += (T) gres; }
                else               { res =  ( ( (T) gres ) > ( (T) res ) ) ? ( (T) gres ) : ( (T) res ); }
            }

            if ( !ibset )
            {
                res /= maxq;
            }

            logresvalid = 0;

            return res;
        }

postxb:

        LL2(adensetype,bdensetype,res,logres,logresvalid,xa,xb,xainfo,xbinfo,bias,pxyprod,ia,ib,xdim,xconsist,assumreal,resmode,mlid,xy00,xy10,xy11,justcalcip,indstart,indend);
    }

    return res;
}

//phantomx
template <class T>
T &MercerKernel::KK3(T &res, T &logres, int &logresvalid,
                     const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, const SparseVector<gentype> &xc,
                     const vecInfo &xainfo, const vecInfo &xbinfo, const vecInfo &xcinfo,
                     int xagradOrder, int xbgradOrder, int xcgradOrder,
                     const SparseVector<gentype> &xaff, const SparseVector<gentype> &xbff, const SparseVector<gentype> &xcff,
                     const T &bias,
                     const gentype **pxyprod,
                     int ia, int ib, int ic,
                     int xdim, int xconsist, int assumreal, int resmode, int mlid,
                     const double *xy00, const double *xy10, const double *xy11, const double *xy20, const double *xy21, const double *xy22, const Vector<int> *s, int justcalcip, int indstart, int indend,
                     int iaset, int ibset, int icset,
                     int skipbias,
                     int skipxa, int skipxb, int skipxc) const
{
//errstream() << "phantomxyzabc 10: " << xa << "\t" << xb << "\t" << xc << "\n";
//errstream() << "phantomxyzabc 11: " << xagradOrder << "\t" << xbgradOrder << "\t" << xcgradOrder << "\n";
//errstream() << "phantomxyzabc 12: " << ia << "\t" << ib << "\t" << ic << "\n";
//errstream() << "phantomxyzabc 12: " << isFastKernelSum() << "\n";
//errstream() << "phantomxyzabc 12: " << isNormalised() << "\n";
//errstream() << "phantomxyzabc 12: " << needsDiff() << "\n";
//errstream() << "phantomxyzabc 12: " << needsNorm() << "\n";
//errstream() << "phantomxyzabc 12: " << justcalcip << "\n";
    if ( xagradOrder && !xbgradOrder && !xcgradOrder )
    {
        if ( isFastKernelSum() && !isNormalised(indend) && !needsDiff() && !needsNorm() && !justcalcip )
        {
            // In this case we have a simple inner product kernel, no normalisation,
            // nothing complicating.  In this case:
            //
            // K1(xa) = k(<<xa>>_1) = k(<xa,1>>_2) = K2(xa,1)
            //
            // allowing us to "borrow" the gradient calculation from K2

            SparseVector<gentype> xx(xb);
            vecInfo xxinfo;

            xx *= xc;

            getvecInfo(xxinfo,xx);

            return KK2(0,0,res,logres,logresvalid,
                       xa,xx,
                       xainfo,xxinfo,
                       xagradOrder,0,
                       xaff,xx,
                       bias,
                       pxyprod,
                       ia,-1,
                       xdim,xconsist,assumreal,resmode,mlid,
                       nullptr,nullptr,nullptr,justcalcip,indstart,indend,
                       iaset,0);
//errstream() << "phantomxyzabc 121: " << res << "\n";
        }
    }

    if ( !xagradOrder && xbgradOrder && !xcgradOrder )
    {
        if ( isFastKernelSum() && !isNormalised(indend) && !needsDiff() && !needsNorm() && !justcalcip )
        {
            // In this case we have a simple inner product kernel, no normalisation,
            // nothing complicating.  In this case:
            //
            // K1(xa) = k(<<xa>>_1) = k(<xa,1>>_2) = K2(xa,1)
            //
            // allowing us to "borrow" the gradient calculation from K2

            SparseVector<gentype> xx(xa);
            vecInfo xxinfo;

            xx *= xc;

            getvecInfo(xxinfo,xx);

            return KK2(0,0,res,logres,logresvalid,
                       xb,xx,
                       xbinfo,xxinfo,
                       xbgradOrder,0,
                       xbff,xx,
                       bias,
                       pxyprod,
                       ib,-1,
                       xdim,xconsist,assumreal,resmode,mlid,
                       nullptr,nullptr,nullptr,justcalcip,indstart,indend,
                       ibset,0);
//errstream() << "phantomxyzabc 122: " << res << "\n";
        }
    }

    if ( !xagradOrder && !xbgradOrder && xcgradOrder )
    {
        if ( isFastKernelSum() && !isNormalised(indend) && !needsDiff() && !needsNorm() && !justcalcip )
        {
            // In this case we have a simple inner product kernel, no normalisation,
            // nothing complicating.  In this case:
            //
            // K1(xa) = k(<<xa>>_1) = k(<xa,1>>_2) = K2(xa,1)
            //
            // allowing us to "borrow" the gradient calculation from K2

            SparseVector<gentype> xx(xa);
            vecInfo xxinfo;

            xx *= xb;

            getvecInfo(xxinfo,xx);

            return KK2(0,0,res,logres,logresvalid,
                       xc,xx,
                       xcinfo,xxinfo,
                       xcgradOrder,0,
                       xcff,xx,
                       bias,
                       pxyprod,
                       ic,-1,
                       xdim,xconsist,assumreal,resmode,mlid,
                       nullptr,nullptr,nullptr,justcalcip,indstart,indend,
                       icset,0);
//errstream() << "phantomxyzabc 123: " << res << "\n";
        }
    }

    NiceAssert( !xagradOrder && !xbgradOrder && !xcgradOrder );

    if ( !skipbias && isiteqn(bias) )
    {
        // We are dealing with distributions, so need to delay finalisation 
        // of random parts of the function and then average *outside* the loop
        //
        // See Muandet et al, Learning from Distributions via Support Measure Machines

        int qb;
        int maxq = numSamples();

        SparseVector<SparseVector<gentype> > subval;

        // Take maxq samples from output distribution

        for ( qb = 0 ; qb < maxq ; ++qb )
        {
            gentype gbias(bias);

            if ( !subSample(subval,gbias) && !qb )
            {
                goto postbias;
            }

            gentype gres,glogres;

            KK3(gres,glogres,logresvalid,xa,xb,xc,xainfo,xbinfo,xcinfo,xagradOrder,xbgradOrder,xcgradOrder,xaff,xbff,xcff,gbias,nullptr,ia,ib,ic,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,justcalcip,indstart,indend,iaset,ibset,icset,1,skipxa,skipxb,skipxc);

            if ( !qb ) { res =  (T) gres; }
            else       { res += (T) gres; }
        }

        res /= maxq;

        logresvalid = 0;

        return res;
    }

postbias:

    if ( !skipxa && xainfo.xiseqn() )
    {
        // We are dealing with distributions, so need to delay finalisation 
        // of random parts of the function and then average *outside* the loop
        //
        // See Muandet et al, Learning from Distributions via Support Measure Machines

        int qxa;
        int maxq = numSamples();

        gentype gbias(bias);

        SparseVector<SparseVector<gentype> > subval;

        // Take maxq samples from output distribution

        for ( qxa = 0 ; qxa < maxq ; ++qxa )
        {
            SparseVector<gentype> xxa(xa);
            vecInfo xxainfo;

            if ( !subSample(subval,xxa,xxainfo) && !qxa )
            {
                goto postxa;
            }

            gentype gres,glogres;

            KK3(gres,glogres,logresvalid,xxa,xb,xc,xxainfo,xbinfo,xcinfo,xagradOrder,xbgradOrder,xcgradOrder,xaff,xbff,xcff,gbias,nullptr,ia,ib,ic,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,justcalcip,indstart,indend,iaset,ibset,icset,skipbias,1,skipxb,skipxc);

            if ( !qxa )        { res =  (T) gres; }
            else if ( !iaset ) { res += (T) gres; }
            else               { res =  ( ( (T) gres ) > ( (T) res ) ) ? ( (T) gres ) : ( (T) res ); }
        }

        if ( !iaset )
        {
            res /= maxq;
        }

        logresvalid = 0;

        return res;
    }

postxa:

    if ( !skipxb && xbinfo.xiseqn() )
    {
        // We are dealing with distributions, so need to delay finalisation 
        // of random parts of the function and then average *outside* the loop
        //
        // See Muandet et al, Learning from Distributions via Support Measure Machines

        int qxa;
        int maxq = numSamples();

        gentype gbias(bias);

        SparseVector<SparseVector<gentype> > subval;

        // Take maxq samples from output distribution

        for ( qxa = 0 ; qxa < maxq ; ++qxa )
        {
            SparseVector<gentype> xxb(xb);
            vecInfo xxbinfo;

            if ( !subSample(subval,xxb,xxbinfo) && !qxa )
            {
                goto postxb;
            }

            gentype gres,glogres;

            KK3(gres,glogres,logresvalid,xa,xxb,xc,xainfo,xxbinfo,xcinfo,xagradOrder,xbgradOrder,xcgradOrder,xaff,xbff,xcff,gbias,nullptr,ia,ib,ic,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,justcalcip,indstart,indend,iaset,ibset,icset,skipbias,skipxa,1,skipxc);

            if ( !qxa )        { res =  (T) gres; }
            else if ( !ibset ) { res += (T) gres; }
            else               { res =  ( ( (T) gres ) > ( (T) res ) ) ? ( (T) gres ) : ( (T) res ); }
        }

        if ( !ibset )
        {
            res /= maxq;
        }

        logresvalid = 0;

        return res;
    }

postxb:

    if ( !skipxc && xcinfo.xiseqn() )
    {
        // We are dealing with distributions, so need to delay finalisation 
        // of random parts of the function and then average *outside* the loop
        //
        // See Muandet et al, Learning from Distributions via Support Measure Machines

        int qxa;
        int maxq = numSamples();

        gentype gbias(bias);

        SparseVector<SparseVector<gentype> > subval;

        // Take maxq samples from output distribution

        for ( qxa = 0 ; qxa < maxq ; ++qxa )
        {
            SparseVector<gentype> xxc(xc);
            vecInfo xxcinfo;

            if ( !subSample(subval,xxc,xxcinfo) && !qxa )
            {
                goto postxc;
            }

            gentype gres,glogres;

            KK3(gres,glogres,logresvalid,xa,xb,xxc,xainfo,xbinfo,xxcinfo,xagradOrder,xbgradOrder,xcgradOrder,xaff,xbff,xcff,gbias,nullptr,ia,ib,ic,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,justcalcip,indstart,indend,iaset,ibset,icset,skipbias,skipxa,skipxb,1);

            if ( !qxa )        { res =  (T) gres; }
            else if ( !icset ) { res += (T) gres; }
            else               { res =  ( ( (T) gres ) > ( (T) res ) ) ? ( (T) gres ) : ( (T) res ); }
        }

        if ( !icset )
        {
            res /= maxq;
        }

        logresvalid = 0;

        return res;
    }

postxc:

    LL3(res,logres,logresvalid,xa,xb,xc,xainfo,xbinfo,xcinfo,bias,pxyprod,ia,ib,ic,xdim,xconsist,assumreal,resmode,mlid,xy00,xy10,xy11,xy20,xy21,xy22,s,justcalcip,indstart,indend);

    return res;
}

//phantomx
template <class T>
T &MercerKernel::KK4(T &res, T &logres, int &logresvalid,
                     const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, const SparseVector<gentype> &xc, const SparseVector<gentype> &xd,
                     const vecInfo &xainfo, const vecInfo &xbinfo, const vecInfo &xcinfo, const vecInfo &xdinfo,
                     int xagradOrder, int xbgradOrder, int xcgradOrder, int xdgradOrder,
                     const SparseVector<gentype> &xaff, const SparseVector<gentype> &xbff, const SparseVector<gentype> &xcff, const SparseVector<gentype> &xdff,
                     const T &bias,
                     const gentype **pxyprod,
                     int ia, int ib, int ic, int id,
                     int xdim, int xconsist, int assumreal, int resmode, int mlid,
                     const Vector<int> *s, int justcalcip,
                     const double *xy00, const double *xy10, const double *xy11, const double *xy20, const double *xy21, const double *xy22, const double *xy30, const double *xy31, const double *xy32, const double *xy33, int indstart, int indend,
                     int iaset, int ibset, int icset, int idset,
                     int skipbias,
                     int skipxa, int skipxb, int skipxc, int skipxd) const
{
    if ( xagradOrder && !xbgradOrder && !xcgradOrder && !xdgradOrder )
    {
        if ( isFastKernelSum() && !isNormalised(indend) && !needsDiff() && !needsNorm() && !justcalcip )
        {
            // In this case we have a simple inner product kernel, no normalisation,
            // nothing complicating.  In this case:
            //
            // K1(xa) = k(<<xa>>_1) = k(<xa,1>>_2) = K2(xa,1)
            //
            // allowing us to "borrow" the gradient calculation from K2

            SparseVector<gentype> xx(xb);
            vecInfo xxinfo;

            xx *= xc;
            xx *= xd;

            getvecInfo(xxinfo,xx);

            return KK2(0,0,res,logres,logresvalid,
                       xa,xx,
                       xainfo,xxinfo,
                       xagradOrder,0,
                       xaff,xx,
                       bias,
                       pxyprod,
                       ia,-1,
                       xdim,xconsist,assumreal,resmode,mlid,
                       nullptr,nullptr,nullptr,justcalcip,indstart,indend,
                       iaset,0);
        }
    }

    if ( !xagradOrder && xbgradOrder && !xcgradOrder && !xdgradOrder )
    {
        if ( isFastKernelSum() && !isNormalised(indend) && !needsDiff() && !needsNorm() && !justcalcip )
        {
            // In this case we have a simple inner product kernel, no normalisation,
            // nothing complicating.  In this case:
            //
            // K1(xa) = k(<<xa>>_1) = k(<xa,1>>_2) = K2(xa,1)
            //
            // allowing us to "borrow" the gradient calculation from K2

            SparseVector<gentype> xx(xa);
            vecInfo xxinfo;

            xx *= xc;
            xx *= xd;

            getvecInfo(xxinfo,xx);

            return KK2(0,0,res,logres,logresvalid,
                       xb,xx,
                       xbinfo,xxinfo,
                       xbgradOrder,0,
                       xbff,xx,
                       bias,
                       pxyprod,
                       ib,-1,
                       xdim,xconsist,assumreal,resmode,mlid,
                       nullptr,nullptr,nullptr,justcalcip,indstart,indend,
                       ibset,0);
        }
    }

    if ( !xagradOrder && !xbgradOrder && xcgradOrder && !xdgradOrder )
    {
        if ( isFastKernelSum() && !isNormalised(indend) && !needsDiff() && !needsNorm() && !justcalcip )
        {
            // In this case we have a simple inner product kernel, no normalisation,
            // nothing complicating.  In this case:
            //
            // K1(xa) = k(<<xa>>_1) = k(<xa,1>>_2) = K2(xa,1)
            //
            // allowing us to "borrow" the gradient calculation from K2

            SparseVector<gentype> xx(xa);
            vecInfo xxinfo;

            xx *= xb;
            xx *= xd;

            getvecInfo(xxinfo,xx);

            return KK2(0,0,res,logres,logresvalid,
                       xc,xx,
                       xcinfo,xxinfo,
                       xcgradOrder,0,
                       xcff,xx,
                       bias,
                       pxyprod,
                       ic,-1,
                       xdim,xconsist,assumreal,resmode,mlid,
                       nullptr,nullptr,nullptr,justcalcip,indstart,indend,
                       icset,0);
        }
    }

    if ( !xagradOrder && !xbgradOrder && !xcgradOrder && xdgradOrder )
    {
        if ( isFastKernelSum() && !isNormalised(indend) && !needsDiff() && !needsNorm() && !justcalcip )
        {
            // In this case we have a simple inner product kernel, no normalisation,
            // nothing complicating.  In this case:
            //
            // K1(xa) = k(<<xa>>_1) = k(<xa,1>>_2) = K2(xa,1)
            //
            // allowing us to "borrow" the gradient calculation from K2

            SparseVector<gentype> xx(xa);
            vecInfo xxinfo;

            xx *= xb;
            xx *= xc;

            getvecInfo(xxinfo,xx);

            return KK2(0,0,res,logres,logresvalid,
                       xd,xx,
                       xdinfo,xxinfo,
                       xdgradOrder,0,
                       xdff,xx,
                       bias,
                       pxyprod,
                       id,-1,
                       xdim,xconsist,assumreal,resmode,mlid,
                       nullptr,nullptr,nullptr,justcalcip,indstart,indend,
                       idset,0);
        }
    }

    NiceAssert( !xagradOrder && !xbgradOrder && !xcgradOrder && !xdgradOrder );

    (void) xbff;
    (void) xcff;
    (void) xdff;

    if ( !skipbias && isiteqn(bias) )
    {
        // We are dealing with distributions, so need to delay finalisation 
        // of random parts of the function and then average *outside* the loop
        //
        // See Muandet et al, Learning from Distributions via Support Measure Machines

        int qb;
        int maxq = numSamples();

        SparseVector<SparseVector<gentype> > subval;

        // Take maxq samples from output distribution

        for ( qb = 0 ; qb < maxq ; ++qb )
        {
            gentype gbias(bias);

            if ( !subSample(subval,gbias) && !qb )
            {
                goto postbias;
            }

            gentype gres,glogres;

            KK4(gres,glogres,logresvalid,xa,xb,xc,xd,xainfo,xbinfo,xcinfo,xdinfo,xagradOrder,xbgradOrder,xcgradOrder,xdgradOrder,xaff,xbff,xcff,xdff,gbias,nullptr,ia,ib,ic,id,xdim,xconsist,assumreal,resmode,mlid,nullptr,justcalcip,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,indstart,indend,iaset,ibset,icset,idset,1,skipxa,skipxb,skipxc,skipxd);

            if ( !qb ) { res =  (T) gres; }
            else       { res += (T) gres; }
        }

        res /= maxq;

        logresvalid = 0;

        return res;
    }

postbias:

    if ( !skipxa && xainfo.xiseqn() )
    {
        // We are dealing with distributions, so need to delay finalisation 
        // of random parts of the function and then average *outside* the loop
        //
        // See Muandet et al, Learning from Distributions via Support Measure Machines

        int qxa;
        int maxq = numSamples();

        gentype gbias(bias);

        SparseVector<SparseVector<gentype> > subval;

        // Take maxq samples from output distribution

        for ( qxa = 0 ; qxa < maxq ; ++qxa )
        {
            SparseVector<gentype> xxa(xa);
            vecInfo xxainfo;

            if ( !subSample(subval,xxa,xxainfo) && !qxa )
            {
                goto postxa;
            }

            gentype gres,glogres;

            KK4(gres,glogres,logresvalid,xxa,xb,xc,xd,xxainfo,xbinfo,xcinfo,xdinfo,xagradOrder,xbgradOrder,xcgradOrder,xdgradOrder,xaff,xbff,xcff,xdff,gbias,nullptr,ia,ib,ic,id,xdim,xconsist,assumreal,resmode,mlid,nullptr,justcalcip,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,indstart,indend,iaset,ibset,icset,idset,skipbias,1,skipxb,skipxc,skipxd);

            if ( !qxa )        { res =  (T) gres; }
            else if ( !iaset ) { res += (T) gres; }
            else               { res =  ( ( (T) gres ) > ( (T) res ) ) ? ( (T) gres ) : ( (T) res ); }
        }

        if ( !iaset )
        {
            res /= maxq;
        }

        logresvalid = 0;

        return res;
    }

postxa:

    if ( !skipxb && xbinfo.xiseqn() )
    {
        // We are dealing with distributions, so need to delay finalisation 
        // of random parts of the function and then average *outside* the loop
        //
        // See Muandet et al, Learning from Distributions via Support Measure Machines

        int qxa;
        int maxq = numSamples();

        gentype gbias(bias);

        SparseVector<SparseVector<gentype> > subval;

        // Take maxq samples from output distribution

        for ( qxa = 0 ; qxa < maxq ; ++qxa )
        {
            SparseVector<gentype> xxb(xb);
            vecInfo xxbinfo;

            if ( !subSample(subval,xxb,xxbinfo) && !qxa )
            {
                goto postxb;
            }

            gentype gres,glogres;

            KK4(gres,glogres,logresvalid,xa,xxb,xc,xd,xainfo,xxbinfo,xcinfo,xdinfo,xagradOrder,xbgradOrder,xcgradOrder,xdgradOrder,xaff,xbff,xcff,xdff,gbias,nullptr,ia,ib,ic,id,xdim,xconsist,assumreal,resmode,mlid,nullptr,justcalcip,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,indstart,indend,iaset,ibset,icset,idset,skipbias,skipxa,1,skipxc,skipxd);

            if ( !qxa )        { res =  (T) gres; }
            else if ( !ibset ) { res += (T) gres; }
            else               { res =  ( ( (T) gres ) > ( (T) res ) ) ? ( (T) gres ) : ( (T) res ); }
        }

        if ( !ibset )
        {
            res /= maxq;
        }

        logresvalid = 0;

        return res;
    }

postxb:

    if ( !skipxc && xcinfo.xiseqn() )
    {
        // We are dealing with distributions, so need to delay finalisation 
        // of random parts of the function and then average *outside* the loop
        //
        // See Muandet et al, Learning from Distributions via Support Measure Machines

        int qxa;
        int maxq = numSamples();

        gentype gbias(bias);

        SparseVector<SparseVector<gentype> > subval;

        // Take maxq samples from output distribution

        for ( qxa = 0 ; qxa < maxq ; ++qxa )
        {
            SparseVector<gentype> xxc(xc);
            vecInfo xxcinfo;

            if ( !subSample(subval,xxc,xxcinfo) && !qxa )
            {
                goto postxc;
            }

            gentype gres,glogres;

            KK4(gres,glogres,logresvalid,xa,xb,xxc,xd,xainfo,xbinfo,xxcinfo,xdinfo,xagradOrder,xbgradOrder,xcgradOrder,xdgradOrder,xaff,xbff,xcff,xdff,gbias,nullptr,ia,ib,ic,id,xdim,xconsist,assumreal,resmode,mlid,nullptr,justcalcip,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,indstart,indend,iaset,ibset,icset,idset,skipbias,skipxa,skipxb,1,skipxd);

            if ( !qxa )        { res =  (T) gres; }
            else if ( !icset ) { res += (T) gres; }
            else               { res =  ( ( (T) gres ) > ( (T) res ) ) ? ( (T) gres ) : ( (T) res ); }
        }

        if ( !icset )
        {
            res /= maxq;
        }

        logresvalid = 0;

        return res;
    }

postxc:

    if ( !skipxd && xdinfo.xiseqn() )
    {
        // We are dealing with distributions, so need to delay finalisation 
        // of random parts of the function and then average *outside* the loop
        //
        // See Muandet et al, Learning from Distributions via Support Measure Machines

        int qxa;
        int maxq = numSamples();

        gentype gbias(bias);

        SparseVector<SparseVector<gentype> > subval;

        // Take maxq samples from output distribution

        for ( qxa = 0 ; qxa < maxq ; ++qxa )
        {
            SparseVector<gentype> xxd(xd);
            vecInfo xxdinfo;

            if ( !subSample(subval,xxd,xxdinfo) && !qxa )
            {
                goto postxd;
            }

            gentype gres,glogres;

            KK4(gres,glogres,logresvalid,xa,xb,xc,xxd,xainfo,xbinfo,xcinfo,xxdinfo,xagradOrder,xbgradOrder,xcgradOrder,xdgradOrder,xaff,xbff,xcff,xdff,gbias,nullptr,ia,ib,ic,id,xdim,xconsist,assumreal,resmode,mlid,nullptr,justcalcip,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,indstart,indend,iaset,ibset,icset,idset,skipbias,skipxa,skipxb,skipxc,1);

            if ( !qxa )        { res =  (T) gres; }
            else if ( !idset ) { res += (T) gres; }
            else               { res =  ( ( (T) gres ) > ( (T) res ) ) ? ( (T) gres ) : ( (T) res ); }
        }

        if ( !idset )
        {
            res /= maxq;
        }

        logresvalid = 0;

        return res;
    }

postxd:

    LL4(res,logres,logresvalid,xa,xb,xc,xd,xainfo,xbinfo,xcinfo,xdinfo,bias,pxyprod,ia,ib,ic,id,xdim,xconsist,assumreal,resmode,mlid,s,justcalcip,xy00,xy10,xy11,xy20,xy21,xy22,xy30,xy31,xy32,xy33,indstart,indend);

    return res;
}

template <class T>
T &MercerKernel::KK6(T &res, T &logres, int &logresvalid,
                     const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, const SparseVector<gentype> &xc, const SparseVector<gentype> &xd, const SparseVector<gentype> &xe, const SparseVector<gentype> &xf,
                     const vecInfo &xainfo, const vecInfo &xbinfo, const vecInfo &xcinfo, const vecInfo &xdinfo, const vecInfo &xeinfo, const vecInfo &xfinfo,
                     int xagradOrder, int xbgradOrder, int xcgradOrder, int xdgradOrder, int xegradOrder, int xfgradOrder,
                     const SparseVector<gentype> &xaff, const SparseVector<gentype> &xbff, const SparseVector<gentype> &xcff, const SparseVector<gentype> &xdff, const SparseVector<gentype> &xeff, const SparseVector<gentype> &xf4,
                     const T &bias,
                     const gentype **pxyprod,
                     int ia, int ib, int ic, int id, int ie, int jf,
                     int xdim, int xconsist, int assumreal, int xresmode, int mlid,
                     const Matrix<double> *xy, const Vector<int> *s, int justcalcip, int indstart, int indend,
                     int iaset, int ibset, int icset, int idset, int ieset, int ifset) const
{
    (void) pxyprod;
    (void) s;
    (void) xy;
    (void) justcalcip;

    Vector<const SparseVector<gentype> *> x(6);
    Vector<const vecInfo *> xinfo(6);
    Vector<int> i(6);
    Vector<int> iset(6);
    Vector<int> xgradOrder(6);
    Vector<const SparseVector<gentype> *> xff(6);

    int z = 0;

    x("&",z)          = &xa;
    xinfo("&",z)      = &xainfo;
    i("&",z)          = ia;
    iset("&",z)       = iaset;
    xgradOrder("&",z) = xagradOrder;
    xff("&",z)        = &xaff;

    x("&",1)          = &xb;
    xinfo("&",1)      = &xbinfo;
    i("&",1)          = ib;
    iset("&",1)       = ibset;
    xgradOrder("&",1) = xbgradOrder;
    xff("&",1)        = &xbff;

    x("&",2)          = &xc;
    xinfo("&",2)      = &xcinfo;
    i("&",2)          = ic;
    iset("&",2)       = icset;
    xgradOrder("&",2) = xcgradOrder;
    xff("&",2)        = &xcff;

    x("&",3)          = &xd;
    xinfo("&",3)      = &xdinfo;
    i("&",3)          = id;
    iset("&",3)       = idset;
    xgradOrder("&",3) = xdgradOrder;
    xff("&",3)        = &xdff;

    x("&",4)          = &xe;
    xinfo("&",4)      = &xeinfo;
    i("&",4)          = ie;
    iset("&",4)       = ieset;
    xgradOrder("&",4) = xegradOrder;
    xff("&",4)        = &xeff;

    x("&",5)          = &xf;
    xinfo("&",5)      = &xfinfo;
    i("&",5)          = jf;
    iset("&",5)       = ifset;
    xgradOrder("&",5) = xfgradOrder;
    xff("&",5)        = &xf4;

    return KKm(6,res,logres,logresvalid,x,xinfo,xgradOrder,xff,bias,i,nullptr,xdim,xconsist,assumreal,xresmode,mlid,nullptr,nullptr,justcalcip,indstart,indend,&iset);
}

//phantomx
template <class T>
T &MercerKernel::KKm(int m, T &res, T &logres, int &logresvalid,
                     Vector<const SparseVector<gentype> *> &x,
                     Vector<const vecInfo *> &xinfo,
                     const Vector<int> &xgradOrder,
                     Vector<const SparseVector<gentype> *> &xff,
                     const T &bias,
                     Vector<int> &i,
                     const gentype **pxyprod, int xdim, int xconsist, int assumreal, int resmode, int mlid,
                     const Matrix<double> *xy, const Vector<int> *s, int justcalcip, int indstart, int indend,
                     const Vector<int> *iset,
                     int skipbias,
                     int skipx) const
{
    if ( 0 == m )
    {
        return KK0(res,logres,logresvalid,bias,pxyprod,xdim,xconsist,assumreal,resmode,mlid,justcalcip,indstart,indend);
    }

    else if ( 1 == m )
    {
        return KK1(res,logres,logresvalid,*(x(0)),*(xinfo(0)),xgradOrder(0),*(xff(0)),bias,pxyprod,i(0),xdim,xconsist,assumreal,resmode,mlid,nullptr,justcalcip,indstart,indend,(*iset)(0));
    }

    else if ( 2 == m )
    {
        return KK2(0,0,res,logres,logresvalid,*(x(0)),*(x(1)),*(xinfo(0)),*(xinfo(1)),xgradOrder(0),xgradOrder(1),*(xff(0)),*(xff(1)),bias,pxyprod,i(0),i(1),xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,justcalcip,indstart,indend,(*iset)(0),(*iset)(1));
    }

    else if ( 3 == m )
    {
        return KK3(res,logres,logresvalid,*(x(0)),*(x(1)),*(x(2)),*(xinfo(0)),*(xinfo(1)),*(xinfo(2)),xgradOrder(0),xgradOrder(1),xgradOrder(2),*(xff(0)),*(xff(1)),*(xff(2)),bias,pxyprod,i(0),i(1),i(2),xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,justcalcip,indstart,indend,(*iset)(0),(*iset)(1),(*iset)(2));
    }

    else if ( 4 == m )
    {
        return KK4(res,logres,logresvalid,*(x(0)),*(x(1)),*(x(2)),*(x(3)),*(xinfo(0)),*(xinfo(1)),*(xinfo(2)),*(xinfo(3)),xgradOrder(0),xgradOrder(1),xgradOrder(2),xgradOrder(3),*(xff(0)),*(xff(1)),*(xff(2)),*(xff(3)),bias,pxyprod,i(0),i(1),i(2),i(3),xdim,xconsist,assumreal,resmode,mlid,nullptr,justcalcip,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,indstart,indend,(*iset)(0),(*iset)(1),(*iset)(2),(*iset)(3));
    }

    if ( sum(xgradOrder) == 1 )
    {
        if ( isFastKernelSum() && !isNormalised(indend) && !needsDiff() && !needsNorm() && !justcalcip )
        {
            // In this case we have a simple inner product kernel, no normalisation,
            // nothing complicating.  In this case:
            //
            // K1(xa) = k(<<xa>>_1) = k(<xa,1>>_2) = K2(xa,1)
            //
            // allowing us to "borrow" the gradient calculation from K2

            retVector<int> tmpva;
            Vector<int> notj(cntintvec(m,tmpva));
            int j,k;

            max(xgradOrder,j);

            notj.remove(j);

            SparseVector<gentype> xx;
            vecInfo xxinfo;

            for ( k = 0 ; k < m-1 ; ++k )
            {
                if ( !k )
                {
                    xx = (*(x(notj(k))));
                }

                else
                {
                    xx *= (*(x(notj(k))));
                }
            }

            getvecInfo(xxinfo,xx);

            return KK2(0,0,res,logres,logresvalid,
                       *(x(j)),xx,
                       *(xinfo(j)),xxinfo,
                       xgradOrder(j),0,
                       *(xff(j)),xx,
                       bias,
                       pxyprod,
                       i(j),-1,
                       xdim,xconsist,assumreal,resmode,mlid,
                       nullptr,nullptr,nullptr,justcalcip,indstart,indend,
                       (*iset)(j),0);
        }
    }

    NiceAssert( xgradOrder == 0 );

    (void) xff;

    if ( !skipbias && isiteqn(bias) )
    {
        // We are dealing with distributions, so need to delay finalisation 
        // of random parts of the function and then average *outside* the loop
        //
        // See Muandet et al, Learning from Distributions via Support Measure Machines

        int qb;
        int maxq = numSamples();

        SparseVector<SparseVector<gentype> > subval;

        // Take maxq samples from output distribution

        for ( qb = 0 ; qb < maxq ; ++qb )
        {
            gentype gbias(bias);

            if ( !subSample(subval,gbias) && !qb )
            {
                goto postbias;
            }

            gentype gres,glogres;

            KKm(m,gres,glogres,logresvalid,x,xinfo,xgradOrder,xff,gbias,i,pxyprod,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,justcalcip,indstart,indend,iset,1,skipx);

            if ( !qb ) { res =  (T) gres; }
            else       { res += (T) gres; }
        }

        res /= maxq;

        logresvalid = 0;

        return res;
    }

postbias:

    Vector<int> isValEqn;

    if ( !skipx )
    {
        int qr;

        for ( qr = 0 ; qr < m ; ++qr )
        {
            if ( (*(xinfo(qr))).xiseqn() )
            {
                isValEqn.add(isValEqn.size());
                isValEqn("&",isValEqn.size()-1) = qr;
            }
        }
    }

    if ( !skipx && isValEqn.size() )
    {
        int q;

        Vector<SparseVector<gentype> *> yy(x.size());
        Vector<vecInfo *> yyinfo(xinfo.size());

        Vector<const SparseVector<gentype> *> xx(x);
        Vector<const vecInfo *> xxinfo(xinfo);

        SparseVector<SparseVector<gentype> > subval;

        int haschanged = 0;

        for ( q = 0 ; q < isValEqn.size() ; ++q )
        {
            MEMNEW(yy("&",isValEqn(q)),SparseVector<gentype>(*(x(isValEqn(q)))));
            MEMNEW(yyinfo("&",isValEqn(q)),vecInfo(*(xinfo(isValEqn(q)))));

            haschanged += subSample(subval,*(yy("&",isValEqn(q))),*(yyinfo("&",isValEqn(q))));

            xx("&",isValEqn(q))     = yy("&",isValEqn(q));
            xxinfo("&",isValEqn(q)) = yyinfo("&",isValEqn(q));

            //FIXME: need to implement setwise m-kernels
            NiceAssert( !iset || !(*iset)(q) );
        }

        if ( !haschanged )
        {
            for ( q = 0 ; q < isValEqn.size() ; ++q )
            {
                MEMDEL(yy("&",isValEqn(q)));
                MEMDEL(yyinfo("&",isValEqn(q)));
            }

            goto postx;
        }

        int isdone  = 0;
        int isfirst = 1;

        int maxq = numSamples();

        gentype gbias(bias);

        Vector<int> qx(isValEqn.size());

        qx = 0;

        while ( !isdone )
        {
            gentype gres,glogres;

            KKm(m,gres,glogres,logresvalid,xx,xxinfo,xgradOrder,xff,gbias,i,pxyprod,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,justcalcip,indstart,indend,iset,skipbias,1);

            if ( isfirst ) { res =  (T) gres; }
            else           { res += (T) gres; }

            for ( q = 0 ; q < qx.size() ; ++q )
            {
                *(yy("&",isValEqn(q)))     = *(x(isValEqn(q)));
                *(yyinfo("&",isValEqn(q))) = *(xinfo(isValEqn(q)));

                subSample(subval,*(yy("&",isValEqn(q))),*(yyinfo("&",isValEqn(q))));

                xx("&",isValEqn(q))     = yy("&",isValEqn(q));
                xxinfo("&",isValEqn(q)) = yyinfo("&",isValEqn(q));

                ++(qx("&",q));

                if ( qx(q) < maxq )
                {
                    break;
                }

                else
                {
                    qx("&",q) = 0;
                }
            }

            isdone  = ( q < qx.size() ) ? 0 : 1;
            isfirst = 0;
        }

        res /= pow(maxq,isValEqn.size());

        for ( q = 0 ; q < isValEqn.size() ; ++q )
        {
            MEMDEL(yy("&",isValEqn(q)));
            MEMDEL(yyinfo("&",isValEqn(q)));
        }

        return res;
    }

postx:

    LLm(m,res,logres,logresvalid,x,xinfo,bias,i,pxyprod,xdim,xconsist,assumreal,resmode,mlid,xy,s,justcalcip,indstart,indend);

    return res;
}

template <class T>
int MercerKernel::Pphim(int m, Vector<T> &res, const SparseVector<gentype> &xa, const vecInfo &xainfo, int ia, int allowfinite, int xdim, int xconsist, int assumreal, int iaset, int gradOrder, int xagradup, int indstart, int indend, int xaskip) const
{
    int dres = 0;

    if ( !xaskip && xainfo.xiseqn() && ( m != -1 ) )
    {
        // We are dealing with distributions, so need to delay finalisation
        // of random parts of the function and then average *outside* the loop
        //
        // See Muandet et al, Learning from Distributions via Support Measure Machines

        int qxa;
        int maxq = numSamples();

        SparseVector<SparseVector<gentype> > subval;

        // Take maxq samples from output distribution

        for ( qxa = 0 ; qxa < maxq ; ++qxa )
        {
            SparseVector<gentype> xxa(xa);
            vecInfo xxainfo;

            if ( !subSample(subval,xxa,xxainfo) && !qxa )
            {
                goto postxa;
            }

            Vector<T> tmpres;

            dres = Pphim(m,tmpres,xxa,xxainfo,ia,allowfinite,xdim,xconsist,assumreal,iaset,gradOrder,xagradup,indstart,indend,1);

            if ( !qxa )        { res =  tmpres; }
            else if ( !iaset ) { res += tmpres; }
            else               { NiceThrow("Set-based evaluation of feature maps doesn't work yet."); }
        }

        if ( !iaset )
        {
            res.scale(1.0/maxq);
        }

        return dres;
    }

postxa:

    dres = Qqhim(m,res,xa,xainfo,ia,allowfinite,xdim,xconsist,assumreal,gradOrder,xagradup,indstart,indend);

    return dres;
}





























//phantomx
template <class T>
T &MercerKernel::LL0(T &res, T &logres, int &logresvalid,
                     const T &bias,
                     const gentype **pxyprod,
                     int xdim, int xconsist, int assumreal, int resmode, int mlid, int justcalcip, int indstart, int indend) const
{
    NiceAssert( ! ( isFastKernelSum() && ( isAltDiff() >= 200 ) && ( isAltDiff() <= 299 ) ) );

    logresvalid = 0;

    if ( !size() )
    {
        return res = 0.0;
    }

    if ( ( ( isAltDiff() >= 100 ) && ( isAltDiff() <= 199 ) ) && !justcalcip )
    {
        res = 0;
    }

    else if ( ( resmode & 0x01 ) )
    {
        NiceAssert( !isfullnorm );
        NiceAssert( !justcalcip );
        NiceAssert( ( isAltDiff() <= 199 ) || ( isAltDiff() >= 300 ) );
        NiceAssert( !( isprod ) );

        gentype tempres;
        gentype dummyval(0);

        K0i(tempres,dummyval,xdim,resmode,mlid,indstart,indend);

        res = (T) tempres;
    }

    else if ( isprod )
    {
        NiceAssert( !( resmode & 0x80 ) );

        // Should probably replace this with a proper fast version

        Vector<const SparseVector<gentype> *> xx(0);
        Vector<const vecInfo *> xxinfo(0);
        Vector<int> ii(0);

        LLm(0,res,logres,logresvalid,xx,xxinfo,bias,ii,pxyprod,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,0,indstart,indend);
    }

    else if ( ( isFastKernelSum() || isFastKernelChain() ) && ( resmode & 0x80 ) && !justcalcip )
    {
        res = 0;
    }

    else if ( isFastKernelSum() || isFastKernelChain() || ( isFastKernelXfer() && !resmode ) || justcalcip )
    {
        int locindstart = (isFastKernelXfer()?1:indstart); // NB: isFastKernelXfer() implies indstart == 0
        int locindend   = indend; //size()-1;

        T prod;   prod   = 0.0;
        T diffis; diffis = 0.0;

        // Calculate inner products and differences if required

        if ( justcalcip )
        {
            prod = 0.0;
        }

        else
        {
            prod = bias;
        }

        if ( !( isFastKernelSum() || isFastKernelChain() || justcalcip ) )
        {
            int dummyind = 0;

            T zzz; zzz = 0.0;

            kernel8xx(0,prod,dummyind,cType(0),zzz,zzz,zzz,xdim,0,mlid);

            if ( !justcalcip )
            {
                prod *= (const T &) cWeight(0);
            }
        }

        if ( justcalcip )
        {
            res = prod;
        }

        else
        {
            if ( isNormalised(locindend) )
            {
                res = 1.0;
            }

            else
            {
                T dummy;

                logresvalid = KKpro(res,prod,diffis,nullptr,locindstart,locindend,xdim,0,logres,&dummy);
            }
        }
    }

    else
    {
        NiceAssert( ismagterm == 0 );
        NiceAssert( ( isAltDiff() <= 199 ) || ( isAltDiff() >= 300 ) );

        gentype xyprod(0.0);

        if ( pxyprod && pxyprod[0] )
        {
            xyprod = *pxyprod[0];
        }

        else
        {
            xyprod += bias;
        }

        gentype tempres;

        K0i(tempres,xyprod,xdim,resmode,mlid,indstart,indend);

        res = (T) tempres;
    }

    return res;
}

//phantomx
template <class T>
T &MercerKernel::LL1(T &res, T &logres, int &logresvalid,
                     const SparseVector<gentype> &xa, 
                     const vecInfo &xainfo, 
                     const T &bias,
                     const gentype **pxyprod,
                     int ia,  
                     int xdim, int xconsist, int assumreal, int resmode, int mlid, const double *xy, int justcalcip, int indstart, int indend) const
{
    NiceAssert( ! ( isFastKernelSum() && ( isAltDiff() >= 200 ) && ( isAltDiff() <= 299 ) ) );

    (void) xy;

    logresvalid = 0;

    if ( !size() )
    {
        return res = 0.0;
    }

    if ( ( isAltDiff() == 300 ) && !justcalcip )
    {
        goto badout;
    }

    else if ( ( isAltDiff() >= 100 ) && ( isAltDiff() <= 199 ) && !justcalcip )
    {
        goto badout;
    }

    else if ( ( resmode & 0x01 ) )
    {
        goto badout;
    }

    else if ( isprod )
    {
        NiceAssert( !justcalcip );
        NiceAssert( !( resmode & 0x80 ) );

        // Should probably replace this with a proper fast version

        Vector<const SparseVector<gentype> *> xx(1);
        Vector<const vecInfo *> xxinfo(1);
        Vector<int> ii(1);

        xx("[]",0) = &xa;
        xxinfo("[]",0) = &xainfo;
        ii("[]",0) = ia;

        LLm(1,res,logres,logresvalid,xx,xxinfo,bias,ii,pxyprod,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,0,indstart,indend);
    }

    else if ( ( isFastKernelSum() || isFastKernelChain() ) && ( resmode & 0x80 ) && !justcalcip )
    {
        res = 0;
    }

    else if ( isFastKernelSum() || isFastKernelChain() || ( isFastKernelXfer() && !resmode ) || justcalcip )
    {
        int locindstart = (isFastKernelXfer()?1:indstart); // NB: isFastKernelXfer() implies indstart == 0
        int locindend   = indend; //size()-1;

        int needxxprod = isNormalised(locindend);

        T xyprod; xyprod = 0.0;
        T diffis; diffis = 0.0;
        T xaprod; xaprod = 0.0;

        // Calculate inner products and differences if required

        if ( isFastKernelSum() || isFastKernelChain() || justcalcip )
        {
            int havexyprod = 0;

            if ( pxyprod && pxyprod[0] )
            {
                xyprod = *pxyprod[0];

                havexyprod = 1;
            }

            else if ( needsInner(0,1) || ( isFastKernelSum() && needsInner(-1,1) ) || justcalcip )
            {
                oneProductDiverted(xyprod,xa,xconsist,assumreal);

                if ( !justcalcip )
                {
                    xyprod += bias;
                }

                havexyprod = 1;
            }

            if ( needxxprod && !justcalcip && havexyprod )
            {
                xaprod = xyprod;
            }

            else if ( needxxprod && !justcalcip )
            {
                oneProductDiverted(xaprod,xa,xconsist,assumreal);

                xaprod += bias;
            }

            if ( pxyprod && pxyprod[1] )
            {
                diffis = *pxyprod[1];
            }

            else if ( ( ( needsDiff(0) || ( isFastKernelSum() && needsDiff() ) ) && ( ( isAltDiff() <= 199 ) || ( isAltDiff() >= 300 ) ) ) && !justcalcip )
            {
                // Calculate ||x-y||^2 only as required

                diff1norm(diffis,xyprod,getmnorm(xainfo,xa,1,xconsist,assumreal));
            }

            else if ( ( needsDiff(0) && ( isAltDiff() >= 200 ) && ( isAltDiff() <= 299 ) ) && !justcalcip )
            {
                goto badout;
            }
        }

        else
        {
            // ( isFastKernelXfer() && !resmode )
            // isSimpleFastKernelChain

            int havexyprod = 0;

            if ( pxyprod && pxyprod[0] )
            {
                xyprod = *pxyprod[0];

                havexyprod = 1;
            }

            else
            {
                int dummyind = 0;

                T zzz; zzz = 0.0;

                kernel8xx(0,xyprod,dummyind,cType(0),zzz,zzz,zzz,xa,xainfo,ia,xdim,0,mlid);

                havexyprod = 1;
            }

            if ( needxxprod && !justcalcip && havexyprod )
            {
                xaprod = xyprod;
            }

            else if ( needxxprod && !justcalcip )
            {
                int dummyind = 0;

                T zzz; zzz = 0.0;

                kernel8xx(0,xaprod,dummyind,cType(0),zzz,zzz,zzz,xa,xainfo,ia,xdim,0,mlid);
            }

            if ( pxyprod && pxyprod[1] )
            {
                diffis = *pxyprod[1];
            }

            else if ( ( size() >= 2 ) && needsDiff(1) && ( ( isAltDiff() <= 199 ) || ( isAltDiff() >= 300 ) ) && !justcalcip )
            {
                int dummyind = 0;

                T xanorm;

                if ( isAltDiff() == 0 )
                {
                    T zzz; zzz = 0.0;

                    kernel8xx(0,xanorm,dummyind,cType(0),zzz,zzz,zzz,xa,xainfo,ia,xdim,0,mlid);
                }

                else
                {
                    T zzz; zzz = 0.0;

                    kernel8xx(0,xanorm,dummyind,cType(0),zzz,zzz,zzz,xa,xa,xainfo,xainfo,ia,ia,xdim,0,mlid);
                }

                diff1norm(diffis,xyprod,xanorm);

                if ( !justcalcip )
                {
                    xyprod *= (const T &) cWeight(0);
                    xaprod *= (const T &) cWeight(0);
                    diffis *= (const T &) cWeight(0);
                }
            }

            else if ( needsDiff(0) && ( isAltDiff() >= 200 ) && ( isAltDiff() <= 299 ) && !justcalcip )
            {
                goto badout;
            }
        }

        if ( justcalcip )
        {
            res = xyprod;
        }

        else
        {
            if ( isNormalised(locindend) )
            {
                T dummy;

                KKpro(res,xyprod,diffis,&ia,locindstart,locindend,xdim,1,dummy,&dummy);

                T xares;
                T zerodiff; zerodiff = 0.0;

                KKpro(xares,xaprod,zerodiff,&ia,locindstart,locindend,xdim,1,dummy,&dummy);

                if ( (double) abs2(xares) <= BADZEROTOL )
                {
                    res = angle(res);
                    res = ( (double) abs2(res) <= BADZEROTOL ) ? 1.0 : res;
                }

                else
                {
                    // We normalise in log-space to improve numerical stability

                    T sgnres = angle(res);

                    res = abs2(res);
                    OP_log(res);
                    //res *= 1.0;
                    res -= log(xares);
                    //res *= 1.0;
                    OP_exp(res);
                    res *= sgnres;
                }
            }

            else
            {
                T dummy;

                logresvalid = KKpro(res,xyprod,diffis,&ia,locindstart,locindend,xdim,1,logres,&dummy);
            }
        }
    }

    else
    {
        goto badout;
    }

    return res;

badout:
    // Design decision: in ml_base.cc, if d = 0 for one of the vectors
    // referenced here then this element will never be used.  Moreover there
    // are cases (eg isAltDiff set >1 with back-referenced data) where the
    // element is not properly defined but will never be used, so what we 
    // need to do is set it 0.  However having a "d = 0" catch will fail when
    // d starts non-zero, is set zero, then set non-zero, as will happen for
    // example when calculating LOO, n-fold error etc.  In such cases you need
    // to call a reset on that row/column, but you can't do that because (a) the
    // reset often calls setd (hence infinite recursion) or (b) there is an 
    // implicit assumption that Gp is independent of d (eg in semicopy functions
    // that retain the caches for speed in LOO, n-fold calculation).  Hence I've 
    // made the decision to return 0 here to avoid a whole stack of potential
    // coding complications at the price of possible silent failure if you set
    // somthing incorrectly.

    errstream() << "!!!1!!!";

    res = 0.0;

    return res;
}

inline int isCastableToRealWithoutLoss(const double &x)
{
    (void) x;

    return 1;
}

inline int isCastableToRealWithoutLoss(const gentype &x)
{
    return x.isCastableToRealWithoutLoss();
}

template <class T>
T &MercerKernel::LL2(int adensetype, int bdensetype, T &res, T &logres, int &logresvalid,
                     const SparseVector<gentype> &xa, const SparseVector<gentype> &xb,
                     const vecInfo &xainfo, const vecInfo &xbinfo,
                     const T &bias,
                     const gentype **pxyprod,
                     int i, int j,
                     int xdim, int xconsist, int assumreal, int resmode, int mlid, const double *xy00, const double *xy10, const double *xy11, int justcalcip, int indstart, int indend) const
{
    NiceAssert( ! ( isFastKernelSum() && ( isAltDiff() >= 200 ) && ( isAltDiff() <= 299 ) ) );
    NiceAssert( ( !xy00 && !xy10 && !xy11 ) || !justcalcip );

    logresvalid = 0;

    if ( !size() )
    {
        return res = 0.0;
    }

    if ( ( resmode & 0x01 ) )
    {
        // Return equation form

        NiceAssert( !justcalcip );
        NiceAssert( ( isAltDiff() <= 199 ) || ( isAltDiff() >= 300 ) );
        NiceAssert( !( isprod && !arexysimple(xa,xb) ) );

        gentype dummyres;

//        K2i(dummyres,defaultgentype(),defaultgentype(),xainfo,xbinfo,getmnorm(xainfo,xa,2,xconsist,assumreal),getmnorm(xbinfo,xb,2,xconsist,assumreal),xa,xb,i,j,xdim,adensetype,bdensetype,resmode,mlid,indstart,indend,assumreal);
        K2i(dummyres,0_gent,0_gent,xainfo,xbinfo,getmnorm(xainfo,xa,2,xconsist,assumreal),getmnorm(xbinfo,xb,2,xconsist,assumreal),xa,xb,i,j,xdim,adensetype,bdensetype,resmode,mlid,indstart,indend,assumreal);

        res = (T) dummyres;
    }

    else if ( isprod && !arexysimple(xa,xb) )
    {
        NiceAssert( !justcalcip );
        NiceAssert( !( resmode & 0x80 ) );

        // Kernel is of the form prod_i K(x_i,y_i)
        // x and y are not simple

        if ( xconsist && ( size() == 1 ) && isSimpleKernel() )
        {
            NiceAssert( xa.nindsize() == xb.nindsize() );

            SparseVector<gentype> xxa;
            SparseVector<gentype> xxb;

            vecInfo xxainfo;
            vecInfo xxbinfo;

            int ii;

            T tempres;

            if ( xa.nindsize() )
            {
                for ( ii = 0 ; ii < xa.nindsize() ; ++ii )
                {
                    xxa("&",0) = xa.direcref(ii);
                    xxb("&",0) = xb.direcref(ii);

                    getvecInfo(xxainfo,xxa,nullptr,xconsist,assumreal);
                    getvecInfo(xxbinfo,xxb,nullptr,xconsist,assumreal);

                    T dummya;
                    int dummyb;

                    LL2(adensetype,bdensetype,tempres,dummya,dummyb,xxa,xxb,xxainfo,xxbinfo,bias,nullptr,i,j,1,1,assumreal,0,mlid,nullptr,nullptr,nullptr,0,indstart,indend);

                    tempres /= (const T &) cWeight(0);

                    if ( !ii ) { res =  tempres; }
                    else       { res *= tempres; }
                }
            }

            else
            {
                res = 1;
            }
        }

        else
        {
            SparseVector<gentype> indres;

            combind(indres,xa,xb);

            SparseVector<gentype> xxa;
            SparseVector<gentype> xxb;

            vecInfo xxainfo;
            vecInfo xxbinfo;

            int ii;

            T tempres;

            if ( indres.nindsize() )
            {
                for ( ii = 0 ; ii < indres.nindsize() ; ++ii )
                {
                    xxa("&",0) = xa(indres.ind(ii));
                    xxb("&",0) = xb(indres.ind(ii));

                    getvecInfo(xxainfo,xxa,nullptr,xconsist,assumreal);
                    getvecInfo(xxbinfo,xxb,nullptr,xconsist,assumreal);

                    T dummya;
                    int dummyb;

                    LL2(adensetype,bdensetype,tempres,dummya,dummyb,xxa,xxb,xxainfo,xxbinfo,bias,nullptr,i,j,1,1,assumreal,0,mlid,nullptr,nullptr,nullptr,0,indstart,indend);

                    tempres /= (const T &) cWeight(0);

                    if ( !ii ) { res =  tempres; }
                    else       { res *= tempres; }
                }
            }

            else
            {
                res = 1;
            }
        }

        res *= (const T &) cWeight(0);
    }

    else if ( ( isFastKernelSum() || isFastKernelChain() ) && ( resmode & 0x80 ) && !justcalcip )
    {
        res = 0;
    }

    else if ( ( isFastKernelSum() || isFastKernelChain() || ( isFastKernelXfer() && !resmode ) || justcalcip ) && !adensetype && !bdensetype )
    {
// SEE ALSO LL2FAST
        int locindstart = (isFastKernelXfer()?1:indstart); // NB: isFastKernelXfer() implies indstart == 0
        int locindend   = indend; //size()-1;

        int needaaprod = isNormalised(locindend) || needsNorm(locindend);

        T xyprod; xyprod = 0.0;

        T yxprod; yxprod = 0.0;
        T aaprod; aaprod = 0.0;
        T bbprod; bbprod = 0.0;

        T diffis; diffis = 0.0;

        if ( isFastKernelSum() || isFastKernelChain() || justcalcip )
        {
            if ( xy10 && !justcalcip )
            {
                xyprod = *xy10;
                yxprod = *xy10;

                xyprod += bias;
                yxprod += bias;
            }

            else if ( pxyprod && pxyprod[0] )
            {
                xyprod = *pxyprod[0];
                yxprod = xyprod;
            }

            else if ( needsInner(0,2) || ( isFastKernelSum() && needsInner(-1,2) ) || justcalcip )
            {
                innerProductDiverted(xyprod,xa,xb,xconsist,assumreal);
                innerProductDivertedRevConj(yxprod,xyprod,xa,xb,xconsist,assumreal);

                if ( !justcalcip )
                {
                    xyprod += bias;
                    yxprod += bias;
                }
            }

            if ( needaaprod && !justcalcip )
            {
                if ( xy00 && xy11 )
                {
                    aaprod = (*xy00);
                    bbprod = (*xy11);

                    aaprod += bias;
                    bbprod += bias;
                }

                else if ( assumreal )
                {
                    aaprod = getmnorm(xainfo,xa,2,xconsist,assumreal);
                    bbprod = getmnorm(xbinfo,xb,2,xconsist,assumreal);

                    aaprod += bias;
                    bbprod += bias;
                }

                else
                {
                    aaprod = getmnorm(xainfo,xa,2,xconsist,assumreal);
                    bbprod = getmnorm(xbinfo,xb,2,xconsist,assumreal);

                    if ( !isCastableToRealWithoutLoss(aaprod) || !isCastableToRealWithoutLoss(bbprod) )
                    {
                        innerProductDiverted(aaprod,xa,xa,xconsist,assumreal);
                        innerProductDiverted(bbprod,xb,xb,xconsist,assumreal);
                    }

                    aaprod += bias;
                    bbprod += bias;
                }
            }

            if ( ( needsDiff(0) || ( isFastKernelSum() && needsDiff() ) ) && !justcalcip )
            {
                if ( pxyprod && pxyprod[1] )
                {
                    diffis = *pxyprod[1];
                }

                else
                {
                    // Calculate ||x-y||^2 only as required

                    if ( assumreal )
                    {
                        diff2norm(diffis,(double) xyprod,(double) getmnorm(xainfo,xa,2,xconsist,assumreal),(double) getmnorm(xbinfo,xb,2,xconsist,assumreal));
                    }

                    else
                    {
                        diff2norm(diffis,(xyprod+yxprod)/2.0,getmnorm(xainfo,xa,2,xconsist,assumreal),getmnorm(xbinfo,xb,2,xconsist,assumreal));
                    }
                }
            }

            xyprod += yxprod;
            xyprod *= 0.5;
        }

        else
        {
            // ( isFastKernelXfer() && !resmode )
            NiceAssert( !( resmode & 0x80 ) );

            if ( xy10 && !justcalcip )
            {
                xyprod = (*xy10);
            }

            else if ( pxyprod && pxyprod[0] )
            {
                xyprod = *pxyprod[0];
            }

            else
            {
                int dummyind = 0;

                T zzz; zzz = 0.0;

                kernel8xx(0,xyprod,dummyind,cType(0),zzz,zzz,zzz,xa,xb,xainfo,xbinfo,i,j,xdim,0,mlid);
            }

            if ( needaaprod && !justcalcip )
            {
                if ( xy00 && xy11 )
                {
                    aaprod = (*xy00);
                    bbprod = (*xy11);
                }

                else
                {
                    int dummyind = 0;

                    T zzz; zzz = 0.0;

//errstream() << "phantomxyz mer 1\n";
                    kernel8xx(0,aaprod,dummyind,cType(0),zzz,zzz,zzz,xa,xa,xainfo,xainfo,i,i,xdim,0,mlid);
//errstream() << "phantomxyz mer 1b " << xxprod << "\n";
                    kernel8xx(0,bbprod,dummyind,cType(0),zzz,zzz,zzz,xb,xb,xbinfo,xbinfo,j,j,xdim,0,mlid);
//errstream() << "phantomxyz mer 1c " << yyprod << "\n";
                }
            }

            if ( ( size() >= 2 ) && needsDiff(1) && !justcalcip )
            {
                if ( pxyprod && pxyprod[1] )
                {
                    diffis = *pxyprod[1];
                }

                else
                {
                    T xanorm;
                    T xbnorm;

                    int dummyind = 0;

                    T zzz; zzz = 0.0;

//errstream() << "phantomxyz mer 2\n";
                    kernel8xx(0,xanorm,dummyind,cType(0),zzz,zzz,zzz,xa,xa,xainfo,xainfo,i,i,xdim,0,mlid);
//errstream() << "phantomxyz mer 2b" << xanorm << "\n";
                    kernel8xx(0,xbnorm,dummyind,cType(0),zzz,zzz,zzz,xb,xb,xbinfo,xbinfo,j,j,xdim,0,mlid);
//errstream() << "phantomxyz mer 2c" << ynorm << "\n";

                    diff2norm(diffis,xyprod,xanorm,xbnorm);
                }
            }

            if ( !justcalcip )
            {
                xyprod *= (const T &) cWeight(0);
                yxprod *= (const T &) cWeight(0);
                aaprod *= (const T &) cWeight(0);
                bbprod *= (const T &) cWeight(0);

                diffis *= (const T &) cWeight(0);
            }
        }

        if ( justcalcip )
        {
            res = xyprod;
        }

        else
        {
            if ( isNormalised(locindend) )
            {
//errstream() << "phantomxyz mer 3 cType = " << cType(0) << "\n";
//errstream() << "phantomxyz mer 3 xyprod = " << xyprod << "\n";
//errstream() << "phantomxyz mer 3 aaprod = " << aaprod << "\n";
//errstream() << "phantomxyz mer 3 bbprod = " << bbprod << "\n";
//errstream() << "phantomxyz mer 3 diffis = " << diffis << "\n";
                T dummy;

                T xyvals[2] = { aaprod,bbprod };
                T aavals[2] = { aaprod,aaprod };
                T bbvals[2] = { bbprod,bbprod };

                int ixy[2] = { i,j };
                int iaa[2] = { i,i };
                int ibb[2] = { j,j };

                KKpro(res,xyprod,diffis,ixy,locindstart,locindend,xdim,2,dummy,xyvals);

                T xares;
                T xbres;

                const static T zerodiff(0.0);

                KKpro(xares,aaprod,zerodiff,iaa,locindstart,locindend,xdim,2,dummy,aavals);
                KKpro(xbres,bbprod,zerodiff,ibb,locindstart,locindend,xdim,2,dummy,bbvals);

                NiceAssert( !testisvnan(xares) );
                NiceAssert( !testisvnan(xbres) );

                NiceAssert( !testisinf(xares) );
                NiceAssert( !testisinf(xbres) );

                if ( ( (double) abs2(xares) <= BADZEROTOL ) || ( (double) abs2(xbres) <= BADZEROTOL ) )
                {
                    res = angle(res);
                    res = ( (double) abs2(res) <= BADZEROTOL ) ? 1.0 : res;
                }

                else
                {
                    // We normalise in log-space to improve numerical stability

                    T sgnres = angle(res);

                    res = abs2(res);
                    OP_log(res);
                    res *= 2.0;
                    res -= log(xares);
                    res -= log(xbres);
                    res *= 0.5;
                    OP_exp(res);
                    res *= sgnres;
                }

//T xressave = xres;
//                xres *= yres;
//                OP_sqrt(xres);
//
//                NiceAssert( !testisvnan(xres) );
//                NiceAssert( !testisinf(xres) );
//
//T ressave = res;
//                safedivby(res,xres); //res /= xres;
//
//if ( testisinf(res) )
//{
//errstream() << "phantomx 0: res = " << ressave << "\n";
//errstream() << "phantomx 1: xres = " << xressave << "\n";
//errstream() << "phantomx 2: yres = " << yres << "\n";
//errstream() << "phantomx 3: sqrt(xres*yres) = " << xres << "\n";
//errstream() << "phantomx 4: res/sqrt(xres*yres) = " << res << "\n";
//}
//

// The above code tends to under/overflow with wild abandon.  So
// let's attack this with maths.  If xres or yres = 0 then, assuming
// a vaguely sane kernel, res must also be zero, so:
//
// res/sqrt(xres.yres) = exp(log(res)-(log(xres)-log(yres))/2)
// res/sqrt(xres.yres) = exp((2*log(res)-log(xres)-log(yres))/2)

/*
const static T zerores(0.0); // zerores = 0.0;

if ( ( xres == zerores ) || ( yres == zerores ) )
{
    res = 1.0; // Correct up to unavoidable sign ambiguity
}

else
{
    T sgnres = angle(res);

    res = abs2(res);
    OP_log(res);
    res *= 2.0;
    res -= log(xres);
    res -= log(yres);
    res *= 0.5;
    OP_exp(res);
    res *= sgnres;
}
*/

                NiceAssert( !testisvnan(res) );
                NiceAssert( !testisinf(res) );
            }

            else
            {
//errstream() << "phantomxyz mer 4 cType = " << cType(0) << "\n";
//errstream() << "phantomxyz mer 4 xyprod = " << xyprod << "\n";
//errstream() << "phantomxyz mer 4 diffis = " << diffis << "\n";
                T xyvals[2] = { aaprod,bbprod };
                int ixy[2] = { i,j };

                logresvalid = KKpro(res,xyprod,diffis,ixy,locindstart,locindend,xdim,2,logres,xyvals);
            }
        }
    }

    else
    {
        NiceAssert( ismagterm == 0 );
        NiceAssert( ( isAltDiff() <= 199 ) || ( isAltDiff() >= 300 ) );

        gentype xyprod(0.0);
        gentype yxprod(0.0);

        gentype xanorm(0.0);
        gentype xbnorm(0.0);

        if ( xy10 && xy00 && xy11)
        {
            xyprod = (*xy10);
            yxprod = (*xy10);

            xyprod += bias;
            yxprod += bias;

            xanorm = (*xy00);
            xbnorm = (*xy11);
        }

        else if ( pxyprod && pxyprod[0] )
        {
            xyprod = *pxyprod[0];
            yxprod = xyprod;

            xanorm = getmnorm(xainfo,xa,2,xconsist,assumreal);
            xbnorm = getmnorm(xbinfo,xb,2,xconsist,assumreal);
        }

        else if ( needsInner(-1,2) )
        {
            // This may be used by some kernels and not others, so calculate anyhow

            innerProductDiverted(xyprod,xa,xb,xconsist,assumreal);
            innerProductDivertedRevConj(yxprod,xyprod,xa,xb,xconsist,assumreal);

            xyprod += bias;
            yxprod += bias;

            xanorm = getmnorm(xainfo,xa,2,xconsist,assumreal);
            xbnorm = getmnorm(xbinfo,xb,2,xconsist,assumreal);
        }

        else
        {
            xanorm = getmnorm(xainfo,xa,2,xconsist,assumreal);
            xbnorm = getmnorm(xbinfo,xb,2,xconsist,assumreal);
        }

        gentype tempres;

        K2i(tempres,xyprod,yxprod,xainfo,xbinfo,xanorm,xbnorm,xa,xb,i,j,xdim,adensetype,bdensetype,0,mlid,indstart,indend,assumreal);

        res = (T) tempres;
    }

    return res;
}

//phantomx
template <class T>
T &MercerKernel::LL3(T &res, T &logres, int &logresvalid,
                     const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, const SparseVector<gentype> &xc, 
                     const vecInfo &xainfo, const vecInfo &xbinfo, const vecInfo &xcinfo, 
                     const T &bias,
                     const gentype **pxyprod,
                     int ia, int ib, int ic, 
                     int xdim, int xconsist, int assumreal, int resmode, int mlid, 
                     const double *xy00, const double *xy10, const double *xy11, const double *xy20, const double *xy21, const double *xy22, const Vector<int> *s, int justcalcip, int indstart, int indend) const
{
    NiceAssert( ! ( isFastKernelSum() && ( isAltDiff() >= 200 ) && ( isAltDiff() <= 299 ) ) );

    logresvalid = 0;

    if ( !size() )
    {
        return res = 0.0;
    }

    if ( ( isAltDiff() == 300 ) && !justcalcip )
    {
        goto badout;
    }

    else if ( !s && ( isAltDiff() >= 100 ) && ( isAltDiff() <= 199 ) && !justcalcip )
    {
        goto badout;
    }

    else if ( ( resmode & 0x01 ) )
    {
        goto badout;
    }

    else if ( isprod && !arexysimple(xa,xb,xc) )
    {
        NiceAssert( !justcalcip );
        NiceAssert( !( resmode & 0x80 ) );

        // Should probably replace this with a proper fast version

        Vector<const SparseVector<gentype> *> xx(3);
        Vector<const vecInfo *> xxinfo(3);
        Vector<int> ii(3);

        xx("[]",0) = &xa;
        xx("[]",1) = &xb;
        xx("[]",2) = &xc;

        xxinfo("[]",0) = &xainfo;
        xxinfo("[]",1) = &xbinfo;
        xxinfo("[]",2) = &xcinfo;

        ii("[]",0) = ia;
        ii("[]",1) = ib;
        ii("[]",2) = ic;

        LLm(3,res,logres,logresvalid,xx,xxinfo,bias,ii,pxyprod,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,0,indstart,indend);
    }

    else if ( ( isFastKernelSum() || isFastKernelChain() ) && ( resmode & 0x80 ) && !justcalcip )
    {
        res = 0;
    }

    else if ( isFastKernelSum() || isFastKernelChain() || ( isFastKernelXfer() && !resmode ) || justcalcip )
    {
        int locindstart = (isFastKernelXfer()?1:indstart); // NB: isFastKernelXfer() implies indstart == 0
        int locindend   = indend; //size()-1;

        int needxxprod = isNormalised(locindend);

        T xyprod; xyprod = 0.0;
        T diffis; diffis = 0.0;
        T xaprod; xaprod = 0.0;
        T xbprod; xbprod = 0.0;
        T xcprod; xcprod = 0.0;

        // Calculate inner products and differences if required

        if ( isFastKernelSum() || isFastKernelChain() || justcalcip )
        {
            if ( pxyprod && pxyprod[0] )
            {
                xyprod = *pxyprod[0];
            }

            else if ( needsInner(0,3) || ( isFastKernelSum() && needsInner(-1,3) ) || justcalcip )
            {
                threeProductDiverted(xyprod,xa,xb,xc,xconsist,assumreal);

                if ( !justcalcip )
                {
                    xyprod += bias;
                }
            }

            if ( needxxprod && !justcalcip )
            {
                threeProductDiverted(xaprod,xa,xa,xa,xconsist,assumreal);
                threeProductDiverted(xbprod,xb,xb,xb,xconsist,assumreal);
                threeProductDiverted(xcprod,xc,xc,xc,xconsist,assumreal);

                xaprod += bias;
                xbprod += bias;
                xcprod += bias;
            }

            if ( pxyprod && pxyprod[1] )
            {
                diffis = *pxyprod[1];
            }

            else if ( ( ( needsDiff(0) || ( isFastKernelSum() && needsDiff() ) ) && ( ( isAltDiff() <= 199 ) || ( isAltDiff() >= 300 ) ) ) && !justcalcip )
            {
                // Calculate ||x-y||^2 only as required

                double altxyr00 = 0;
                double altxyr10 = 0;
                double altxyr11 = 0;
                double altxyr20 = 0;
                double altxyr21 = 0;
                double altxyr22 = 0;

                fillXYMatrix(altxyr00,altxyr10,altxyr11,altxyr20,altxyr21,altxyr22,xa,xb,xc,xainfo,xbinfo,xcinfo,xy00,xy10,xy11,xy20,xy21,xy22,0,assumreal);

                diff3norm(diffis,xyprod,getmnorm(xainfo,xa,3,xconsist,assumreal),getmnorm(xbinfo,xb,3,xconsist,assumreal),getmnorm(xcinfo,xc,3,xconsist,assumreal),altxyr00,altxyr10,altxyr11,altxyr20,altxyr21,altxyr22,s);
            }

            else if ( ( needsDiff(0) && ( isAltDiff() >= 200 ) && ( isAltDiff() <= 299 ) ) && !justcalcip )
            {
                goto badout;
            }
        }

        else
        {
            // ( isFastKernelXfer() && !resmode )
            // isSimpleFastKernelChain

            if ( pxyprod && pxyprod[0] )
            {
                xyprod = *pxyprod[0];
            }

            else
            {
                int dummyind = 0;

                T zzz; zzz = 0.0;

                kernel8xx(0,xyprod,dummyind,cType(0),zzz,zzz,zzz,xa,xb,xc,xainfo,xbinfo,xcinfo,ia,ib,ic,xdim,0,mlid);
            }

            if ( needxxprod && !justcalcip )
            {
                int dummyind = 0;

                T zzz; zzz = 0.0;

                kernel8xx(0,xaprod,dummyind,cType(0),zzz,zzz,zzz,xa,xa,xa,xainfo,xainfo,xainfo,ia,ia,ia,xdim,0,mlid);
                kernel8xx(0,xbprod,dummyind,cType(0),zzz,zzz,zzz,xb,xb,xb,xbinfo,xbinfo,xbinfo,ib,ib,ib,xdim,0,mlid);
                kernel8xx(0,xcprod,dummyind,cType(0),zzz,zzz,zzz,xc,xc,xc,xcinfo,xcinfo,xcinfo,ic,ic,ic,xdim,0,mlid);
            }

            if ( pxyprod && pxyprod[1] )
            {
                diffis = *pxyprod[1];
            }

            else if ( ( size() >= 2 ) && needsDiff(1) && ( ( isAltDiff() <= 199 ) || ( isAltDiff() >= 300 ) ) && !justcalcip )
            {
                int dummyind = 0;

                T xanorm;
                T xbnorm;
                T xcnorm;

                double altxyr00 = 0;
                double altxyr10 = 0;
                double altxyr11 = 0;
                double altxyr20 = 0;
                double altxyr21 = 0;
                double altxyr22 = 0;

                if ( isAltDiff() == 0 )
                {
                    T zzz; zzz = 0.0;

                    kernel8xx(0,xanorm,dummyind,cType(0),zzz,zzz,zzz,xa,xa,xa,xainfo,xainfo,xainfo,ia,ia,ia,xdim,0,mlid);
                    kernel8xx(0,xbnorm,dummyind,cType(0),zzz,zzz,zzz,xb,xb,xb,xbinfo,xbinfo,xbinfo,ib,ib,ib,xdim,0,mlid);
                    kernel8xx(0,xcnorm,dummyind,cType(0),zzz,zzz,zzz,xc,xc,xc,xcinfo,xcinfo,xcinfo,ic,ic,ic,xdim,0,mlid);

                    // needsMatDiff() == 0 here by definition
                }

                else
                {
                    T zzz; zzz = 0.0;

                    kernel8xx(0,xanorm,dummyind,cType(0),zzz,zzz,zzz,xa,xa,xainfo,xainfo,ia,ia,xdim,0,mlid);
                    kernel8xx(0,xbnorm,dummyind,cType(0),zzz,zzz,zzz,xb,xb,xbinfo,xbinfo,ib,ib,xdim,0,mlid);
                    kernel8xx(0,xcnorm,dummyind,cType(0),zzz,zzz,zzz,xc,xc,xcinfo,xcinfo,ic,ic,xdim,0,mlid);

                    if ( needsMatDiff() )
                    {
                        // needsMatDiff() == +1 by definition here

                        kernel8xx(0,altxyr10,dummyind,cType(0),zzz,zzz,zzz,xb,xa,xbinfo,xainfo,ib,ia,xdim,0,mlid);
                        kernel8xx(0,altxyr20,dummyind,cType(0),zzz,zzz,zzz,xc,xa,xcinfo,xainfo,ic,ia,xdim,0,mlid);
                        kernel8xx(0,altxyr21,dummyind,cType(0),zzz,zzz,zzz,xc,xb,xcinfo,xbinfo,ic,ib,xdim,0,mlid);

                        altxyr00 = xanorm;
                        altxyr11 = xbnorm;
                        altxyr22 = xcnorm;
                    }
                }

                diff3norm(diffis,xyprod,xanorm,xbnorm,xcnorm,altxyr00,altxyr10,altxyr11,altxyr20,altxyr21,altxyr22,s);

                if ( !justcalcip )
                {
                    xyprod *= (const T &) cWeight(0);

                    xaprod *= (const T &) cWeight(0);
                    xbprod *= (const T &) cWeight(0);
                    xcprod *= (const T &) cWeight(0);

                    diffis *= (const T &) cWeight(0);
                }
            }

            else if ( needsDiff(0) && ( isAltDiff() >= 200 ) && ( isAltDiff() <= 299 ) && !justcalcip )
            {
                goto badout;
            }
        }

        if ( justcalcip )
        {
            res = xyprod;
        }

        else
        {
            if ( isNormalised(locindend) )
            {
                T dummy;

                int ixyz[3] = { ia,ib,ic };
                int ixxx[3] = { ia,ia,ia };
                int iyyy[3] = { ib,ib,ib };
                int izzz[3] = { ic,ic,ic };

                KKpro(res,xyprod,diffis,ixyz,locindstart,locindend,xdim,3,dummy,&dummy);

                T xares;
                T xbres;
                T xcres;

                T zerodiff; zerodiff = 0.0;

                KKpro(xares,xaprod,zerodiff,ixxx,locindstart,locindend,xdim,3,dummy,&dummy);
                KKpro(xbres,xbprod,zerodiff,iyyy,locindstart,locindend,xdim,3,dummy,&dummy);
                KKpro(xcres,xcprod,zerodiff,izzz,locindstart,locindend,xdim,3,dummy,&dummy);

                if ( ( ( (double) abs2(xares) <= BADZEROTOL ) && ( (double) abs2(xbres) <= BADZEROTOL ) ) ||
                     ( ( (double) abs2(xares) <= BADZEROTOL ) && ( (double) abs2(xcres) <= BADZEROTOL ) ) ||
                     ( ( (double) abs2(xbres) <= BADZEROTOL ) && ( (double) abs2(xcres) <= BADZEROTOL ) )    )
                {
                    res = angle(res);
                    res = ( (double) abs2(res) <= BADZEROTOL ) ? 1.0 : res;
                }

                else if ( (double) abs2(xares) <= BADZEROTOL )
                {
                    // Fallback to LL2

                    LL2(0,0,res,logres,logresvalid,xb,xc,xbinfo,xcinfo,bias,nullptr,ib,ic,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,justcalcip,indstart,indend);
                }

                else if ( (double) abs2(xbres) <= BADZEROTOL )
                {
                    // Fallback to LL2

                    LL2(0,0,res,logres,logresvalid,xa,xc,xainfo,xcinfo,bias,nullptr,ia,ic,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,justcalcip,indstart,indend);
                }

                else if ( (double) abs2(xcres) <= BADZEROTOL )
                {
                    // Fallback to LL2

                    LL2(0,0,res,logres,logresvalid,xa,xb,xainfo,xbinfo,bias,nullptr,ia,ib,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,justcalcip,indstart,indend);
                }

                else
                {
                    // We normalise in log-space to improve numerical stability

                    T sgnres = angle(res);

                    res = abs2(res);
                    OP_log(res);
                    res *= 3.0;
                    res -= log(xares);
                    res -= log(xbres);
                    res -= log(xcres);
                    res *= (1.0/3.0);
                    OP_exp(res);
                    res *= sgnres;
                }
            }

            else
            {
                T dummy;

                int ixyz[3] = { ia,ib,ic };

                logresvalid = KKpro(res,xyprod,diffis,ixyz,locindstart,locindend,xdim,3,logres,&dummy);
            }
        }
    }

    else
    {
        goto badout;
    }

    return res;

badout:
    // Design decision: in ml_base.cc, if d = 0 for one of the vectors
    // referenced here then this element will never be used.  Moreover there
    // are cases (eg isAltDiff set >1 with back-referenced data) where the
    // element is not properly defined but will never be used, so what we 
    // need to do is set it 0.  However having a "d = 0" catch will fail when
    // d starts non-zero, is set zero, then set non-zero, as will happen for
    // example when calculating LOO, n-fold error etc.  In such cases you need
    // to call a reset on that row/column, but you can't do that because (a) the
    // reset often calls setd (hence infinite recursion) or (b) there is an 
    // implicit assumption that Gp is independent of d (eg in semicopy functions
    // that retain the caches for speed in LOO, n-fold calculation).  Hence I've 
    // made the decision to return 0 here to avoid a whole stack of potential
    // coding complications at the price of possible silent failure if you set
    // somthing incorrectly.

    errstream() << "!!!3!!!";

    res = 0.0;

    return res;
}

//phantomx
template <class T>
T &MercerKernel::LL4(T &res, T &logres, int &logresvalid,
                     const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, const SparseVector<gentype> &xc, const SparseVector<gentype> &xd,
                     const vecInfo &xainfo, const vecInfo &xbinfo, const vecInfo &xcinfo, const vecInfo &xdinfo,
                     const T &bias,
                     const gentype **pxyprod,
                     int ia, int ib, int ic, int id, 
                     int xdim, int xconsist, int assumreal, int resmode, int mlid, 
                     const Vector<int> *s, int justcalcip,
                     const double *xy00, const double *xy10, const double *xy11, const double *xy20, const double *xy21, const double *xy22, const double *xy30, const double *xy31, const double *xy32, const double *xy33, int indstart, int indend) const
{
    NiceAssert( ! ( isFastKernelSum() && ( isAltDiff() >= 200 ) && ( isAltDiff() <= 299 ) ) );
    NiceAssert( ( xy00 && xy10 && xy11 && xy20 && xy21 && xy22 && xy30 && xy31 && xy32 && xy33 ) || ( !xy00 && !xy10 && !xy11 && !xy20 && !xy21 && !xy22 && !xy30 && !xy31 && !xy32 && !xy33 ) );

    logresvalid = 0;

    T dummya;
    int dummyb = 0;

    if ( !size() )
    {
        return res = 0.0;
    }

    if ( ( isAltDiff() == 300 ) && !justcalcip )
    {
        NiceAssert( !s );

        T tempresa; tempresa = 0.0;
        T tempresb; tempresb = 0.0;

        res = 0.0;

        LL2(0,0,tempresa,dummya,dummyb,xa,xb,xainfo,xbinfo,bias,nullptr,ia,ib,xdim,xconsist,assumreal,resmode,mlid,xy00,xy10,xy11,justcalcip,indstart,indend); 
        LL2(0,0,tempresb,dummya,dummyb,xc,xd,xcinfo,xdinfo,bias,nullptr,ic,id,xdim,xconsist,assumreal,resmode,mlid,xy22,xy32,xy33,justcalcip,indstart,indend); 

        tempresa *= tempresb; 
        res += tempresa;

        LL2(0,0,tempresa,dummya,dummyb,xa,xc,xainfo,xcinfo,bias,nullptr,ia,ic,xdim,xconsist,assumreal,resmode,mlid,xy00,xy20,xy22,justcalcip,indstart,indend); 
        LL2(0,0,tempresb,dummya,dummyb,xb,xd,xcinfo,xdinfo,bias,nullptr,ib,id,xdim,xconsist,assumreal,resmode,mlid,xy11,xy31,xy33,justcalcip,indstart,indend); 

        tempresa *= tempresb; 
        res += tempresa;

        LL2(0,0,tempresa,dummya,dummyb,xa,xd,xainfo,xdinfo,bias,nullptr,ia,id,xdim,xconsist,assumreal,resmode,mlid,xy00,xy30,xy33,justcalcip,indstart,indend); 
        LL2(0,0,tempresb,dummya,dummyb,xb,xc,xbinfo,xcinfo,bias,nullptr,ib,ic,xdim,xconsist,assumreal,resmode,mlid,xy11,xy21,xy22,justcalcip,indstart,indend); 

        tempresa *= tempresb; 
        res += tempresa;

        res /= 3;
    }

    else if ( !s && ( isAltDiff() >= 100 ) && ( isAltDiff() <= 199 ) && !justcalcip )
    {
        Vector<int> ss(4);
        T tempres; tempres = 0.0;
        int z = 0;

        res = 0.0;

        if ( isAltDiff() == 103 )
        {
            ss("&",z) = +1; ss("&",1) = +1; ss("&",2) = +1; ss("&",3) = +1; LL4(tempres,dummya,dummyb,xa,xb,xc,xd,xainfo,xbinfo,xcinfo,xdinfo,bias,nullptr,ia,ib,ic,id,xdim,xconsist,assumreal,resmode,mlid,&ss,0,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,indstart,indend); res += tempres;
            ss("&",z) = +1; ss("&",1) = +1; ss("&",2) = -1; ss("&",3) = -1; LL4(tempres,dummya,dummyb,xa,xb,xc,xd,xainfo,xbinfo,xcinfo,xdinfo,bias,nullptr,ia,ib,ic,id,xdim,xconsist,assumreal,resmode,mlid,&ss,0,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,indstart,indend); res += tempres;
            ss("&",z) = +1; ss("&",1) = -1; ss("&",2) = +1; ss("&",3) = -1; LL4(tempres,dummya,dummyb,xa,xb,xc,xd,xainfo,xbinfo,xcinfo,xdinfo,bias,nullptr,ia,ib,ic,id,xdim,xconsist,assumreal,resmode,mlid,&ss,0,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,indstart,indend); res += tempres;
            ss("&",z) = +1; ss("&",1) = -1; ss("&",2) = -1; ss("&",3) = +1; LL4(tempres,dummya,dummyb,xa,xb,xc,xd,xainfo,xbinfo,xcinfo,xdinfo,bias,nullptr,ia,ib,ic,id,xdim,xconsist,assumreal,resmode,mlid,&ss,0,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,indstart,indend); res += tempres;

            ss("&",z) = -1; ss("&",1) = -1; ss("&",2) = -1; ss("&",3) = -1; LL4(tempres,dummya,dummyb,xa,xb,xc,xd,xainfo,xbinfo,xcinfo,xdinfo,bias,nullptr,ia,ib,ic,id,xdim,xconsist,assumreal,resmode,mlid,&ss,0,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,indstart,indend); res += tempres;
            ss("&",z) = -1; ss("&",1) = -1; ss("&",2) = +1; ss("&",3) = +1; LL4(tempres,dummya,dummyb,xa,xb,xc,xd,xainfo,xbinfo,xcinfo,xdinfo,bias,nullptr,ia,ib,ic,id,xdim,xconsist,assumreal,resmode,mlid,&ss,0,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,indstart,indend); res += tempres;
            ss("&",z) = -1; ss("&",1) = +1; ss("&",2) = -1; ss("&",3) = +1; LL4(tempres,dummya,dummyb,xa,xb,xc,xd,xainfo,xbinfo,xcinfo,xdinfo,bias,nullptr,ia,ib,ic,id,xdim,xconsist,assumreal,resmode,mlid,&ss,0,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,indstart,indend); res += tempres;
            ss("&",z) = -1; ss("&",1) = +1; ss("&",2) = +1; ss("&",3) = -1; LL4(tempres,dummya,dummyb,xa,xb,xc,xd,xainfo,xbinfo,xcinfo,xdinfo,bias,nullptr,ia,ib,ic,id,xdim,xconsist,assumreal,resmode,mlid,&ss,0,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,indstart,indend); res += tempres;

            res /= 8;
        }

        else if ( isAltDiff() == 104 )
        {
            ss("&",z) = 0; ss("&",1) = 1; ss("&",2) = 2; ss("&",3) = 3; LL4(tempres,dummya,dummyb,xa,xb,xc,xd,xainfo,xbinfo,xcinfo,xdinfo,bias,nullptr,ia,ib,ic,id,xdim,xconsist,assumreal,resmode,mlid,&ss,0,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,indstart,indend); res += tempres;
            ss("&",z) = 0; ss("&",1) = 1; ss("&",2) = 3; ss("&",3) = 2; LL4(tempres,dummya,dummyb,xa,xb,xc,xd,xainfo,xbinfo,xcinfo,xdinfo,bias,nullptr,ia,ib,ic,id,xdim,xconsist,assumreal,resmode,mlid,&ss,0,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,indstart,indend); res += tempres;
            ss("&",z) = 0; ss("&",1) = 2; ss("&",2) = 1; ss("&",3) = 3; LL4(tempres,dummya,dummyb,xa,xb,xc,xd,xainfo,xbinfo,xcinfo,xdinfo,bias,nullptr,ia,ib,ic,id,xdim,xconsist,assumreal,resmode,mlid,&ss,0,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,indstart,indend); res += tempres;
            ss("&",z) = 0; ss("&",1) = 2; ss("&",2) = 3; ss("&",3) = 1; LL4(tempres,dummya,dummyb,xa,xb,xc,xd,xainfo,xbinfo,xcinfo,xdinfo,bias,nullptr,ia,ib,ic,id,xdim,xconsist,assumreal,resmode,mlid,&ss,0,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,indstart,indend); res += tempres;
            ss("&",z) = 0; ss("&",1) = 3; ss("&",2) = 1; ss("&",3) = 2; LL4(tempres,dummya,dummyb,xa,xb,xc,xd,xainfo,xbinfo,xcinfo,xdinfo,bias,nullptr,ia,ib,ic,id,xdim,xconsist,assumreal,resmode,mlid,&ss,0,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,indstart,indend); res += tempres;
            ss("&",z) = 0; ss("&",1) = 3; ss("&",2) = 2; ss("&",3) = 1; LL4(tempres,dummya,dummyb,xa,xb,xc,xd,xainfo,xbinfo,xcinfo,xdinfo,bias,nullptr,ia,ib,ic,id,xdim,xconsist,assumreal,resmode,mlid,&ss,0,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,indstart,indend); res += tempres;

            ss("&",z) = 1; ss("&",1) = 0; ss("&",2) = 2; ss("&",3) = 3; LL4(tempres,dummya,dummyb,xa,xb,xc,xd,xainfo,xbinfo,xcinfo,xdinfo,bias,nullptr,ia,ib,ic,id,xdim,xconsist,assumreal,resmode,mlid,&ss,0,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,indstart,indend); res += tempres;
            ss("&",z) = 1; ss("&",1) = 0; ss("&",2) = 3; ss("&",3) = 2; LL4(tempres,dummya,dummyb,xa,xb,xc,xd,xainfo,xbinfo,xcinfo,xdinfo,bias,nullptr,ia,ib,ic,id,xdim,xconsist,assumreal,resmode,mlid,&ss,0,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,indstart,indend); res += tempres;
            ss("&",z) = 1; ss("&",1) = 2; ss("&",2) = 0; ss("&",3) = 3; LL4(tempres,dummya,dummyb,xa,xb,xc,xd,xainfo,xbinfo,xcinfo,xdinfo,bias,nullptr,ia,ib,ic,id,xdim,xconsist,assumreal,resmode,mlid,&ss,0,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,indstart,indend); res += tempres;
            ss("&",z) = 1; ss("&",1) = 2; ss("&",2) = 3; ss("&",3) = 0; LL4(tempres,dummya,dummyb,xa,xb,xc,xd,xainfo,xbinfo,xcinfo,xdinfo,bias,nullptr,ia,ib,ic,id,xdim,xconsist,assumreal,resmode,mlid,&ss,0,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,indstart,indend); res += tempres;
            ss("&",z) = 1; ss("&",1) = 3; ss("&",2) = 0; ss("&",3) = 2; LL4(tempres,dummya,dummyb,xa,xb,xc,xd,xainfo,xbinfo,xcinfo,xdinfo,bias,nullptr,ia,ib,ic,id,xdim,xconsist,assumreal,resmode,mlid,&ss,0,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,indstart,indend); res += tempres;
            ss("&",z) = 1; ss("&",1) = 3; ss("&",2) = 2; ss("&",3) = 0; LL4(tempres,dummya,dummyb,xa,xb,xc,xd,xainfo,xbinfo,xcinfo,xdinfo,bias,nullptr,ia,ib,ic,id,xdim,xconsist,assumreal,resmode,mlid,&ss,0,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,indstart,indend); res += tempres;

            ss("&",z) = 2; ss("&",1) = 1; ss("&",2) = 0; ss("&",3) = 3; LL4(tempres,dummya,dummyb,xa,xb,xc,xd,xainfo,xbinfo,xcinfo,xdinfo,bias,nullptr,ia,ib,ic,id,xdim,xconsist,assumreal,resmode,mlid,&ss,0,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,indstart,indend); res += tempres;
            ss("&",z) = 2; ss("&",1) = 1; ss("&",2) = 3; ss("&",3) = 0; LL4(tempres,dummya,dummyb,xa,xb,xc,xd,xainfo,xbinfo,xcinfo,xdinfo,bias,nullptr,ia,ib,ic,id,xdim,xconsist,assumreal,resmode,mlid,&ss,0,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,indstart,indend); res += tempres;
            ss("&",z) = 2; ss("&",1) = 0; ss("&",2) = 1; ss("&",3) = 3; LL4(tempres,dummya,dummyb,xa,xb,xc,xd,xainfo,xbinfo,xcinfo,xdinfo,bias,nullptr,ia,ib,ic,id,xdim,xconsist,assumreal,resmode,mlid,&ss,0,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,indstart,indend); res += tempres;
            ss("&",z) = 2; ss("&",1) = 0; ss("&",2) = 3; ss("&",3) = 1; LL4(tempres,dummya,dummyb,xa,xb,xc,xd,xainfo,xbinfo,xcinfo,xdinfo,bias,nullptr,ia,ib,ic,id,xdim,xconsist,assumreal,resmode,mlid,&ss,0,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,indstart,indend); res += tempres;
            ss("&",z) = 2; ss("&",1) = 3; ss("&",2) = 1; ss("&",3) = 0; LL4(tempres,dummya,dummyb,xa,xb,xc,xd,xainfo,xbinfo,xcinfo,xdinfo,bias,nullptr,ia,ib,ic,id,xdim,xconsist,assumreal,resmode,mlid,&ss,0,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,indstart,indend); res += tempres;
            ss("&",z) = 2; ss("&",1) = 3; ss("&",2) = 0; ss("&",3) = 1; LL4(tempres,dummya,dummyb,xa,xb,xc,xd,xainfo,xbinfo,xcinfo,xdinfo,bias,nullptr,ia,ib,ic,id,xdim,xconsist,assumreal,resmode,mlid,&ss,0,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,indstart,indend); res += tempres;

            ss("&",z) = 3; ss("&",1) = 1; ss("&",2) = 2; ss("&",3) = 0; LL4(tempres,dummya,dummyb,xa,xb,xc,xd,xainfo,xbinfo,xcinfo,xdinfo,bias,nullptr,ia,ib,ic,id,xdim,xconsist,assumreal,resmode,mlid,&ss,0,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,indstart,indend); res += tempres;
            ss("&",z) = 3; ss("&",1) = 1; ss("&",2) = 0; ss("&",3) = 2; LL4(tempres,dummya,dummyb,xa,xb,xc,xd,xainfo,xbinfo,xcinfo,xdinfo,bias,nullptr,ia,ib,ic,id,xdim,xconsist,assumreal,resmode,mlid,&ss,0,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,indstart,indend); res += tempres;
            ss("&",z) = 3; ss("&",1) = 2; ss("&",2) = 1; ss("&",3) = 0; LL4(tempres,dummya,dummyb,xa,xb,xc,xd,xainfo,xbinfo,xcinfo,xdinfo,bias,nullptr,ia,ib,ic,id,xdim,xconsist,assumreal,resmode,mlid,&ss,0,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,indstart,indend); res += tempres;
            ss("&",z) = 3; ss("&",1) = 2; ss("&",2) = 0; ss("&",3) = 1; LL4(tempres,dummya,dummyb,xa,xb,xc,xd,xainfo,xbinfo,xcinfo,xdinfo,bias,nullptr,ia,ib,ic,id,xdim,xconsist,assumreal,resmode,mlid,&ss,0,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,indstart,indend); res += tempres;
            ss("&",z) = 3; ss("&",1) = 0; ss("&",2) = 1; ss("&",3) = 2; LL4(tempres,dummya,dummyb,xa,xb,xc,xd,xainfo,xbinfo,xcinfo,xdinfo,bias,nullptr,ia,ib,ic,id,xdim,xconsist,assumreal,resmode,mlid,&ss,0,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,indstart,indend); res += tempres;
            ss("&",z) = 3; ss("&",1) = 0; ss("&",2) = 2; ss("&",3) = 1; LL4(tempres,dummya,dummyb,xa,xb,xc,xd,xainfo,xbinfo,xcinfo,xdinfo,bias,nullptr,ia,ib,ic,id,xdim,xconsist,assumreal,resmode,mlid,&ss,0,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,indstart,indend); res += tempres;

            res /= 24;
        }
    }

    else if ( ( resmode & 0x01 ) )
    {
        NiceAssert( !justcalcip );
        NiceAssert( ( isAltDiff() <= 199 ) || ( isAltDiff() >= 300 ) );
        NiceAssert( !( isprod && !arexysimple(xa,xb) && !arexysimple(xa,xc) && !arexysimple(xa,xd) ) );

        double altxyr00 = 0;
        double altxyr10 = 0;
        double altxyr11 = 0;
        double altxyr20 = 0;
        double altxyr21 = 0;
        double altxyr22 = 0;
        double altxyr30 = 0;
        double altxyr31 = 0;
        double altxyr32 = 0;
        double altxyr33 = 0;

        fillXYMatrix(altxyr00,altxyr10,altxyr11,altxyr20,altxyr21,altxyr22,altxyr30,altxyr31,altxyr32,altxyr33,xa,xb,xc,xd,xainfo,xbinfo,xcinfo,xdinfo,xy00,xy10,xy11,xy20,xy21,xy22,xy30,xy31,xy32,xy33,0,assumreal);

        gentype tempres;

        //K4i(tempres,defaultgentype(),xainfo,xbinfo,xcinfo,xdinfo,getmnorm(xainfo,xa,4,xconsist,assumreal),getmnorm(xbinfo,xb,4,xconsist,assumreal),getmnorm(xcinfo,xc,4,xconsist,assumreal),getmnorm(xdinfo,xd,4,xconsist,assumreal),xa,xb,xc,xd,ia,ib,ic,id,xdim,resmode,mlid,altxyr00,altxyr10,altxyr11,altxyr20,altxyr21,altxyr22,altxyr30,altxyr31,altxyr32,altxyr33,s,indstart,indend,assumreal);
        K4i(tempres,0_gent,xainfo,xbinfo,xcinfo,xdinfo,getmnorm(xainfo,xa,4,xconsist,assumreal),getmnorm(xbinfo,xb,4,xconsist,assumreal),getmnorm(xcinfo,xc,4,xconsist,assumreal),getmnorm(xdinfo,xd,4,xconsist,assumreal),xa,xb,xc,xd,ia,ib,ic,id,xdim,resmode,mlid,altxyr00,altxyr10,altxyr11,altxyr20,altxyr21,altxyr22,altxyr30,altxyr31,altxyr32,altxyr33,s,indstart,indend,assumreal);

        res = (T) tempres;
    }

    else if ( isprod && !arexysimple(xa,xb,xc,xd) )
    {
        NiceAssert( !justcalcip );
        NiceAssert( !( resmode & 0x80 ) );

        // Should probably replace this with a proper fast version

        Vector<const SparseVector<gentype> *> xx(4);
        Vector<const vecInfo *> xxinfo(4);
        Vector<int> ii(4);

        xx("[]",0) = &xa;
        xx("[]",1)         = &xb;
        xx("[]",2)         = &xc;
        xx("[]",3)         = &xd;

        xxinfo("[]",0) = &xainfo;
        xxinfo("[]",1)         = &xbinfo;
        xxinfo("[]",2)         = &xcinfo;
        xxinfo("[]",3)         = &xdinfo;

        ii("[]",0) = ia;
        ii("[]",1)         = ib;
        ii("[]",2)         = ic;
        ii("[]",3)         = id;

        LLm(4,res,logres,logresvalid,xx,xxinfo,bias,ii,pxyprod,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,0,indstart,indend);
    }

    else if ( ( isFastKernelSum() || isFastKernelChain() ) && ( resmode & 0x80 ) && !justcalcip )
    {
        res = 0;
    }

    else if ( isFastKernelSum() || isFastKernelChain() || ( isFastKernelXfer() && !resmode ) || justcalcip )
    {
        int locindstart = (isFastKernelXfer()?1:indstart); // NB: isFastKernelXfer() implies indstart == 0
        int locindend   = indend; //size()-1;

        int needxxprod = isNormalised(locindend);

        T xyprod; xyprod = 0.0;
        T diffis; diffis = 0.0;
        T xaprod; xaprod = 0.0;
        T xbprod; xbprod = 0.0;
        T xcprod; xcprod = 0.0;
        T xdprod; xdprod = 0.0;

        // Calculate inner products and differences if required

        if ( isFastKernelSum() || isFastKernelChain() || justcalcip )
        {
            if ( pxyprod && pxyprod[0] )
            {
                xyprod = *pxyprod[0];
            }

            else if ( needsInner(0,4) || ( isFastKernelSum() && needsInner(-1,4) ) || justcalcip )
            {
                fourProductDiverted(xyprod,xa,xb,xc,xd,xconsist,assumreal);

                if ( !justcalcip )
                {
                    xyprod += bias;
                }
            }

            if ( needxxprod && !justcalcip )
            {
                fourProductDiverted(xaprod,xa,xa,xa,xa,xconsist,assumreal);
                fourProductDiverted(xbprod,xb,xb,xb,xb,xconsist,assumreal);
                fourProductDiverted(xcprod,xc,xc,xc,xc,xconsist,assumreal);
                fourProductDiverted(xdprod,xd,xd,xd,xd,xconsist,assumreal);

                xaprod += bias;
                xbprod += bias;
                xcprod += bias;
                xdprod += bias;
            }

            if ( pxyprod && pxyprod[1] )
            {
                diffis = *pxyprod[1];
            }

            else if ( ( ( needsDiff(0) || ( isFastKernelSum() && needsDiff() ) ) && ( ( isAltDiff() <= 199 ) || ( isAltDiff() >= 300 ) ) ) && !justcalcip )
            {
                // Calculate ||x-y||^2 only as required

                double altxyr00 = 0;
                double altxyr10 = 0;
                double altxyr11 = 0;
                double altxyr20 = 0;
                double altxyr21 = 0;
                double altxyr22 = 0;
                double altxyr30 = 0;
                double altxyr31 = 0;
                double altxyr32 = 0;
                double altxyr33 = 0;

                fillXYMatrix(altxyr00,altxyr10,altxyr11,altxyr20,altxyr21,altxyr22,altxyr30,altxyr31,altxyr32,altxyr33,xa,xb,xc,xd,xainfo,xbinfo,xcinfo,xdinfo,xy00,xy10,xy11,xy20,xy21,xy22,xy30,xy31,xy32,xy33,0,assumreal);

                diff4norm(diffis,xyprod,getmnorm(xainfo,xa,4,xconsist,assumreal),getmnorm(xbinfo,xb,4,xconsist,assumreal),getmnorm(xcinfo,xc,4,xconsist,assumreal),getmnorm(xdinfo,xd,4,xconsist,assumreal),altxyr00,altxyr10,altxyr11,altxyr20,altxyr21,altxyr22,altxyr30,altxyr31,altxyr32,altxyr33,s);
            }

            else if ( ( needsDiff(0) && ( isAltDiff() >= 200 ) && ( isAltDiff() <= 299 ) ) && !justcalcip )
            {
                NiceAssert( !needxxprod );

                // At this point we need to calculate diffis using altdiffis method 2xx
                // xyprod is not used by kernel, but need to fill it in for use by rest of chain
                // we only need to cycle through diffis for relevant s vectors
                // We need the xy matrix to do this

                int z = 0;
                T tempres;

                double ssxyzz = 0;
                double ssxy1z = 0;
                double ssxy11 = 0;
                double ssxy2z = 0;
                double ssxy21 = 0;
                double ssxy22 = 0;
                double ssxy3z = 0;
                double ssxy31 = 0;
                double ssxy32 = 0;
                double ssxy33 = 0;

                double &ssxyz1 = ssxy1z;
                double &ssxyz2 = ssxy2z;
                double &ssxyz3 = ssxy3z;
                double &ssxy12 = ssxy21;
                double &ssxy13 = ssxy31;
                double &ssxy23 = ssxy32;

                fillXYMatrix(ssxyzz,ssxy1z,ssxy11,ssxy2z,ssxy21,ssxy22,ssxy3z,ssxy31,ssxy32,ssxy33,xa,xb,xc,xd,xainfo,xbinfo,xcinfo,xdinfo,xy00,xy10,xy11,xy20,xy21,xy22,xy30,xy31,xy32,xy33,1,assumreal);

                xyprod = 0.0;

                if ( isAltDiff() == 203 )
                {
                    T dummy;

                    int ii[4] = { ia,ib,ic,id };

                    // ++--

                    diffis  =  ssxyzz + ssxyz1 - ssxyz2 - ssxyz3; 
                    diffis +=  ssxy1z + ssxy11 - ssxy12 - ssxy13; 
                    diffis += -ssxy2z - ssxy21 + ssxy22 + ssxy23; 
                    diffis += -ssxy3z - ssxy31 + ssxy32 + ssxy33; 

                    KKpro(tempres,xyprod,diffis,ii,locindstart,locindstart,xdim,4,dummy,&dummy);
                    xyprod += tempres;

                    // +-+-

                    diffis  =  ssxyzz - ssxyz1 + ssxyz2 - ssxyz3;
                    diffis += -ssxy1z + ssxy11 - ssxy12 + ssxy13;
                    diffis +=  ssxy2z - ssxy21 + ssxy22 - ssxy23;
                    diffis += -ssxy3z + ssxy31 - ssxy32 + ssxy33;

                    KKpro(tempres,xyprod,diffis,ii,locindstart,locindstart,xdim,4,dummy,&dummy);
                    xyprod += tempres;

                    // +--+

                    diffis  =  ssxyzz - ssxyz1 - ssxyz2 + ssxyz3;
                    diffis += -ssxy1z + ssxy11 + ssxy12 - ssxy13;
                    diffis += -ssxy2z + ssxy21 + ssxy22 - ssxy23;
                    diffis +=  ssxy3z - ssxy31 - ssxy32 + ssxy33;

                    KKpro(tempres,xyprod,diffis,ii,locindstart,locindstart,xdim,4,dummy,&dummy);
                    xyprod += tempres;

                    // --++

                    diffis  =  ssxyzz + ssxyz1 - ssxyz2 - ssxyz3;
                    diffis +=  ssxy1z + ssxy11 - ssxy12 - ssxy13;
                    diffis += -ssxy2z - ssxy21 + ssxy22 + ssxy23;
                    diffis += -ssxy3z - ssxy31 + ssxy32 + ssxy33;

                    KKpro(tempres,xyprod,diffis,ii,locindstart,locindstart,xdim,4,dummy,&dummy);
                    xyprod += tempres;

                    // -+-+

                    diffis  =  ssxyzz - ssxyz1 + ssxyz2 - ssxyz3;
                    diffis += -ssxy1z + ssxy11 - ssxy12 + ssxy13;
                    diffis +=  ssxy2z - ssxy21 + ssxy22 - ssxy23;
                    diffis += -ssxy3z + ssxy31 - ssxy32 + ssxy33;

                    KKpro(tempres,xyprod,diffis,ii,locindstart,locindstart,xdim,4,dummy,&dummy);
                    xyprod += tempres;

                    // -++-

                    diffis  =  ssxyzz - ssxyz1 - ssxyz2 + ssxyz3;
                    diffis += -ssxy1z + ssxy11 + ssxy12 - ssxy13;
                    diffis += -ssxy2z + ssxy21 + ssxy22 - ssxy23;
                    diffis +=  ssxy3z - ssxy31 - ssxy32 + ssxy33;

                    KKpro(tempres,xyprod,diffis,ii,locindstart,locindstart,xdim,4,dummy,&dummy);
                    xyprod += tempres;

                    // ++++

                    diffis  =  ssxyzz + ssxyz1 + ssxyz2 + ssxyz3;
                    diffis +=  ssxy1z + ssxy11 + ssxy12 + ssxy13;
                    diffis +=  ssxy2z + ssxy21 + ssxy22 + ssxy23;
                    diffis +=  ssxy3z + ssxy31 + ssxy32 + ssxy33;

                    KKpro(tempres,xyprod,diffis,ii,locindstart,locindstart,xdim,4,dummy,&dummy);
                    xyprod += tempres;

                    // ----

                    diffis  =  ssxyzz + ssxyz1 + ssxyz2 + ssxyz3;
                    diffis +=  ssxy1z + ssxy11 + ssxy12 + ssxy13;
                    diffis +=  ssxy2z + ssxy21 + ssxy22 + ssxy23;
                    diffis +=  ssxy3z + ssxy31 + ssxy32 + ssxy33;

                    KKpro(tempres,xyprod,diffis,ii,locindstart,locindstart,xdim,4,dummy,&dummy);
                    xyprod += tempres;

                    xyprod /= 8;
                }

                else if ( isAltDiff() == 204 )
                {
                    Matrix<double> ssxy;

                    ssxy.resize(4,4);

                    ssxy("&",z,z) = ssxyzz; ssxy("&",z,1) = ssxyz1; ssxy("&",z,2) = ssxyz2; ssxy("&",z,3) = ssxyz3;
                    ssxy("&",1,z) = ssxy1z; ssxy("&",1,1) = ssxy11; ssxy("&",1,2) = ssxy12; ssxy("&",1,3) = ssxy13;
                    ssxy("&",2,z) = ssxy2z; ssxy("&",2,1) = ssxy21; ssxy("&",2,2) = ssxy22; ssxy("&",2,3) = ssxy23;
                    ssxy("&",3,z) = ssxy3z; ssxy("&",3,1) = ssxy31; ssxy("&",3,2) = ssxy32; ssxy("&",3,3) = ssxy33;

                    T dummy;

                    int ii[4] = { ia,ib,ic,id };

                    Vector<int> ss(4);

                    ss("&",z) = 0; ss("&",1) = 1; ss("&",2) = 2; ss("&",3) = 3;

                    diffis =  ssxy(ss(z),ss(z)) - ssxy(ss(z),ss(1));
                    diffis = -ssxy(ss(1),ss(z)) - ssxy(ss(1),ss(1));

                    diffis =  ssxy(ss(2),ss(2)) - ssxy(ss(2),ss(3));
                    diffis = -ssxy(ss(3),ss(2)) - ssxy(ss(3),ss(3));

                    KKpro(tempres,xyprod,diffis,ii,locindstart,locindstart,xdim,4,dummy,&dummy);
                    xyprod += tempres;

                    ss("&",z) = 0; ss("&",1) = 1; ss("&",2) = 3; ss("&",3) = 2;

                    diffis =  ssxy(ss(z),ss(z)) - ssxy(ss(z),ss(1));
                    diffis = -ssxy(ss(1),ss(z)) - ssxy(ss(1),ss(1));

                    diffis =  ssxy(ss(2),ss(2)) - ssxy(ss(2),ss(3));
                    diffis = -ssxy(ss(3),ss(2)) - ssxy(ss(3),ss(3));

                    KKpro(tempres,xyprod,diffis,ii,locindstart,locindstart,xdim,4,dummy,&dummy);
                    xyprod += tempres;

                    ss("&",z) = 0; ss("&",1) = 2; ss("&",2) = 1; ss("&",3) = 3;

                    diffis =  ssxy(ss(z),ss(z)) - ssxy(ss(z),ss(1));
                    diffis = -ssxy(ss(1),ss(z)) - ssxy(ss(1),ss(1));

                    diffis =  ssxy(ss(2),ss(2)) - ssxy(ss(2),ss(3));
                    diffis = -ssxy(ss(3),ss(2)) - ssxy(ss(3),ss(3));

                    KKpro(tempres,xyprod,diffis,ii,locindstart,locindstart,xdim,4,dummy,&dummy);
                    xyprod += tempres;

                    ss("&",z) = 0; ss("&",1) = 2; ss("&",2) = 3; ss("&",3) = 1;

                    diffis =  ssxy(ss(z),ss(z)) - ssxy(ss(z),ss(1));
                    diffis = -ssxy(ss(1),ss(z)) - ssxy(ss(1),ss(1));

                    diffis =  ssxy(ss(2),ss(2)) - ssxy(ss(2),ss(3));
                    diffis = -ssxy(ss(3),ss(2)) - ssxy(ss(3),ss(3));

                    KKpro(tempres,xyprod,diffis,ii,locindstart,locindstart,xdim,4,dummy,&dummy);
                    xyprod += tempres;

                    ss("&",z) = 0; ss("&",1) = 3; ss("&",2) = 1; ss("&",3) = 2;

                    diffis =  ssxy(ss(z),ss(z)) - ssxy(ss(z),ss(1));
                    diffis = -ssxy(ss(1),ss(z)) - ssxy(ss(1),ss(1));

                    diffis =  ssxy(ss(2),ss(2)) - ssxy(ss(2),ss(3));
                    diffis = -ssxy(ss(3),ss(2)) - ssxy(ss(3),ss(3));

                    KKpro(tempres,xyprod,diffis,ii,locindstart,locindstart,xdim,4,dummy,&dummy);
                    xyprod += tempres;

                    ss("&",z) = 0; ss("&",1) = 3; ss("&",2) = 2; ss("&",3) = 1;

                    diffis =  ssxy(ss(z),ss(z)) - ssxy(ss(z),ss(1));
                    diffis = -ssxy(ss(1),ss(z)) - ssxy(ss(1),ss(1));

                    diffis =  ssxy(ss(2),ss(2)) - ssxy(ss(2),ss(3));
                    diffis = -ssxy(ss(3),ss(2)) - ssxy(ss(3),ss(3));

                    KKpro(tempres,xyprod,diffis,ii,locindstart,locindstart,xdim,4,dummy,&dummy);
                    xyprod += tempres;


                    ss("&",z) = 1; ss("&",1) = 0; ss("&",2) = 2; ss("&",3) = 3;

                    diffis =  ssxy(ss(z),ss(z)) - ssxy(ss(z),ss(1));
                    diffis = -ssxy(ss(1),ss(z)) - ssxy(ss(1),ss(1));

                    diffis =  ssxy(ss(2),ss(2)) - ssxy(ss(2),ss(3));
                    diffis = -ssxy(ss(3),ss(2)) - ssxy(ss(3),ss(3));

                    KKpro(tempres,xyprod,diffis,ii,locindstart,locindstart,xdim,4,dummy,&dummy);
                    xyprod += tempres;

                    ss("&",z) = 1; ss("&",1) = 0; ss("&",2) = 3; ss("&",3) = 2;

                    diffis =  ssxy(ss(z),ss(z)) - ssxy(ss(z),ss(1));
                    diffis = -ssxy(ss(1),ss(z)) - ssxy(ss(1),ss(1));

                    diffis =  ssxy(ss(2),ss(2)) - ssxy(ss(2),ss(3));
                    diffis = -ssxy(ss(3),ss(2)) - ssxy(ss(3),ss(3));

                    KKpro(tempres,xyprod,diffis,ii,locindstart,locindstart,xdim,4,dummy,&dummy);
                    xyprod += tempres;

                    ss("&",z) = 1; ss("&",1) = 2; ss("&",2) = 0; ss("&",3) = 3;

                    diffis =  ssxy(ss(z),ss(z)) - ssxy(ss(z),ss(1));
                    diffis = -ssxy(ss(1),ss(z)) - ssxy(ss(1),ss(1));

                    diffis =  ssxy(ss(2),ss(2)) - ssxy(ss(2),ss(3));
                    diffis = -ssxy(ss(3),ss(2)) - ssxy(ss(3),ss(3));

                    KKpro(tempres,xyprod,diffis,ii,locindstart,locindstart,xdim,4,dummy,&dummy);
                    xyprod += tempres;

                    ss("&",z) = 1; ss("&",1) = 2; ss("&",2) = 3; ss("&",3) = 0;

                    diffis =  ssxy(ss(z),ss(z)) - ssxy(ss(z),ss(1));
                    diffis = -ssxy(ss(1),ss(z)) - ssxy(ss(1),ss(1));

                    diffis =  ssxy(ss(2),ss(2)) - ssxy(ss(2),ss(3));
                    diffis = -ssxy(ss(3),ss(2)) - ssxy(ss(3),ss(3));

                    KKpro(tempres,xyprod,diffis,ii,locindstart,locindstart,xdim,4,dummy,&dummy);
                    xyprod += tempres;

                    ss("&",z) = 1; ss("&",1) = 3; ss("&",2) = 0; ss("&",3) = 2;

                    diffis =  ssxy(ss(z),ss(z)) - ssxy(ss(z),ss(1));
                    diffis = -ssxy(ss(1),ss(z)) - ssxy(ss(1),ss(1));

                    diffis =  ssxy(ss(2),ss(2)) - ssxy(ss(2),ss(3));
                    diffis = -ssxy(ss(3),ss(2)) - ssxy(ss(3),ss(3));

                    KKpro(tempres,xyprod,diffis,ii,locindstart,locindstart,xdim,4,dummy,&dummy);
                    xyprod += tempres;

                    ss("&",z) = 1; ss("&",1) = 3; ss("&",2) = 2; ss("&",3) = 0;

                    diffis =  ssxy(ss(z),ss(z)) - ssxy(ss(z),ss(1));
                    diffis = -ssxy(ss(1),ss(z)) - ssxy(ss(1),ss(1));

                    diffis =  ssxy(ss(2),ss(2)) - ssxy(ss(2),ss(3));
                    diffis = -ssxy(ss(3),ss(2)) - ssxy(ss(3),ss(3));

                    KKpro(tempres,xyprod,diffis,ii,locindstart,locindstart,xdim,4,dummy,&dummy);
                    xyprod += tempres;


                    ss("&",z) = 2; ss("&",1) = 1; ss("&",2) = 0; ss("&",3) = 3;

                    diffis =  ssxy(ss(z),ss(z)) - ssxy(ss(z),ss(1));
                    diffis = -ssxy(ss(1),ss(z)) - ssxy(ss(1),ss(1));

                    diffis =  ssxy(ss(2),ss(2)) - ssxy(ss(2),ss(3));
                    diffis = -ssxy(ss(3),ss(2)) - ssxy(ss(3),ss(3));

                    KKpro(tempres,xyprod,diffis,ii,locindstart,locindstart,xdim,4,dummy,&dummy);
                    xyprod += tempres;

                    ss("&",z) = 2; ss("&",1) = 1; ss("&",2) = 3; ss("&",3) = 0;

                    diffis =  ssxy(ss(z),ss(z)) - ssxy(ss(z),ss(1));
                    diffis = -ssxy(ss(1),ss(z)) - ssxy(ss(1),ss(1));

                    diffis =  ssxy(ss(2),ss(2)) - ssxy(ss(2),ss(3));
                    diffis = -ssxy(ss(3),ss(2)) - ssxy(ss(3),ss(3));

                    KKpro(tempres,xyprod,diffis,ii,locindstart,locindstart,xdim,4,dummy,&dummy);
                    xyprod += tempres;

                    ss("&",z) = 2; ss("&",1) = 0; ss("&",2) = 1; ss("&",3) = 3;

                    diffis =  ssxy(ss(z),ss(z)) - ssxy(ss(z),ss(1));
                    diffis = -ssxy(ss(1),ss(z)) - ssxy(ss(1),ss(1));

                    diffis =  ssxy(ss(2),ss(2)) - ssxy(ss(2),ss(3));
                    diffis = -ssxy(ss(3),ss(2)) - ssxy(ss(3),ss(3));

                    KKpro(tempres,xyprod,diffis,ii,locindstart,locindstart,xdim,4,dummy,&dummy);
                    xyprod += tempres;

                    ss("&",z) = 2; ss("&",1) = 0; ss("&",2) = 3; ss("&",3) = 1;

                    diffis =  ssxy(ss(z),ss(z)) - ssxy(ss(z),ss(1));
                    diffis = -ssxy(ss(1),ss(z)) - ssxy(ss(1),ss(1));

                    diffis =  ssxy(ss(2),ss(2)) - ssxy(ss(2),ss(3));
                    diffis = -ssxy(ss(3),ss(2)) - ssxy(ss(3),ss(3));

                    KKpro(tempres,xyprod,diffis,ii,locindstart,locindstart,xdim,4,dummy,&dummy);
                    xyprod += tempres;

                    ss("&",z) = 2; ss("&",1) = 3; ss("&",2) = 1; ss("&",3) = 0;

                    diffis =  ssxy(ss(z),ss(z)) - ssxy(ss(z),ss(1));
                    diffis = -ssxy(ss(1),ss(z)) - ssxy(ss(1),ss(1));

                    diffis =  ssxy(ss(2),ss(2)) - ssxy(ss(2),ss(3));
                    diffis = -ssxy(ss(3),ss(2)) - ssxy(ss(3),ss(3));

                    KKpro(tempres,xyprod,diffis,ii,locindstart,locindstart,xdim,4,dummy,&dummy);
                    xyprod += tempres;

                    ss("&",z) = 2; ss("&",1) = 3; ss("&",2) = 0; ss("&",3) = 1;

                    diffis =  ssxy(ss(z),ss(z)) - ssxy(ss(z),ss(1));
                    diffis = -ssxy(ss(1),ss(z)) - ssxy(ss(1),ss(1));

                    diffis =  ssxy(ss(2),ss(2)) - ssxy(ss(2),ss(3));
                    diffis = -ssxy(ss(3),ss(2)) - ssxy(ss(3),ss(3));

                    KKpro(tempres,xyprod,diffis,ii,locindstart,locindstart,xdim,4,dummy,&dummy);
                    xyprod += tempres;


                    ss("&",z) = 3; ss("&",1) = 1; ss("&",2) = 2; ss("&",3) = 0;

                    diffis =  ssxy(ss(z),ss(z)) - ssxy(ss(z),ss(1));
                    diffis = -ssxy(ss(1),ss(z)) - ssxy(ss(1),ss(1));

                    diffis =  ssxy(ss(2),ss(2)) - ssxy(ss(2),ss(3));
                    diffis = -ssxy(ss(3),ss(2)) - ssxy(ss(3),ss(3));

                    KKpro(tempres,xyprod,diffis,ii,locindstart,locindstart,xdim,4,dummy,&dummy);
                    xyprod += tempres;

                    ss("&",z) = 3; ss("&",1) = 1; ss("&",2) = 0; ss("&",3) = 2;

                    diffis =  ssxy(ss(z),ss(z)) - ssxy(ss(z),ss(1));
                    diffis = -ssxy(ss(1),ss(z)) - ssxy(ss(1),ss(1));

                    diffis =  ssxy(ss(2),ss(2)) - ssxy(ss(2),ss(3));
                    diffis = -ssxy(ss(3),ss(2)) - ssxy(ss(3),ss(3));

                    KKpro(tempres,xyprod,diffis,ii,locindstart,locindstart,xdim,4,dummy,&dummy);
                    xyprod += tempres;

                    ss("&",z) = 3; ss("&",1) = 2; ss("&",2) = 1; ss("&",3) = 0;

                    diffis =  ssxy(ss(z),ss(z)) - ssxy(ss(z),ss(1));
                    diffis = -ssxy(ss(1),ss(z)) - ssxy(ss(1),ss(1));

                    diffis =  ssxy(ss(2),ss(2)) - ssxy(ss(2),ss(3));
                    diffis = -ssxy(ss(3),ss(2)) - ssxy(ss(3),ss(3));

                    KKpro(tempres,xyprod,diffis,ii,locindstart,locindstart,xdim,4,dummy,&dummy);
                    xyprod += tempres;

                    ss("&",z) = 3; ss("&",1) = 2; ss("&",2) = 0; ss("&",3) = 1;

                    diffis =  ssxy(ss(z),ss(z)) - ssxy(ss(z),ss(1));
                    diffis = -ssxy(ss(1),ss(z)) - ssxy(ss(1),ss(1));

                    diffis =  ssxy(ss(2),ss(2)) - ssxy(ss(2),ss(3));
                    diffis = -ssxy(ss(3),ss(2)) - ssxy(ss(3),ss(3));

                    KKpro(tempres,xyprod,diffis,ii,locindstart,locindstart,xdim,4,dummy,&dummy);
                    xyprod += tempres;

                    ss("&",z) = 3; ss("&",1) = 0; ss("&",2) = 1; ss("&",3) = 2;

                    diffis =  ssxy(ss(z),ss(z)) - ssxy(ss(z),ss(1));
                    diffis = -ssxy(ss(1),ss(z)) - ssxy(ss(1),ss(1));

                    diffis =  ssxy(ss(2),ss(2)) - ssxy(ss(2),ss(3));
                    diffis = -ssxy(ss(3),ss(2)) - ssxy(ss(3),ss(3));

                    KKpro(tempres,xyprod,diffis,ii,locindstart,locindstart,xdim,4,dummy,&dummy);
                    xyprod += tempres;

                    ss("&",z) = 3; ss("&",1) = 0; ss("&",2) = 2; ss("&",3) = 1;

                    diffis =  ssxy(ss(z),ss(z)) - ssxy(ss(z),ss(1));
                    diffis = -ssxy(ss(1),ss(z)) - ssxy(ss(1),ss(1));

                    diffis =  ssxy(ss(2),ss(2)) - ssxy(ss(2),ss(3));
                    diffis = -ssxy(ss(3),ss(2)) - ssxy(ss(3),ss(3));

                    KKpro(tempres,xyprod,diffis,ii,locindstart,locindstart,xdim,4,dummy,&dummy);
                    xyprod += tempres;


                    xyprod /= 24;
                }

                ++locindstart;
            }
        }

        else
        {
            // ( isFastKernelXfer() && !resmode )
            // isSimpleFastKernelChain

            if ( pxyprod && pxyprod[0] )
            {
                xyprod = *pxyprod[0];
            }

            else
            {
                int dummyind = 0;

                T zzz; zzz = 0.0;

                kernel8xx(0,xyprod,dummyind,cType(0),zzz,zzz,zzz,xa,xb,xc,xd,xainfo,xbinfo,xcinfo,xdinfo,ia,ib,ic,id,xdim,0,mlid);
            }

            if ( needxxprod && !justcalcip )
            {
                int dummyind = 0;

                T zzz; zzz = 0.0;

                kernel8xx(0,xaprod,dummyind,cType(0),zzz,zzz,zzz,xa,xa,xa,xa,xainfo,xainfo,xainfo,xainfo,ia,ia,ia,ia,xdim,0,mlid);
                kernel8xx(0,xbprod,dummyind,cType(0),zzz,zzz,zzz,xb,xb,xb,xb,xbinfo,xbinfo,xbinfo,xbinfo,ib,ib,ib,ib,xdim,0,mlid);
                kernel8xx(0,xcprod,dummyind,cType(0),zzz,zzz,zzz,xc,xc,xc,xc,xcinfo,xcinfo,xcinfo,xcinfo,ic,ic,ic,ic,xdim,0,mlid);
                kernel8xx(0,xdprod,dummyind,cType(0),zzz,zzz,zzz,xd,xd,xd,xd,xdinfo,xdinfo,xdinfo,xdinfo,id,id,id,id,xdim,0,mlid);
            }

            if ( pxyprod && pxyprod[1] )
            {
                diffis = *pxyprod[1];
            }

            else if ( ( size() >= 2 ) && needsDiff(1) && ( ( isAltDiff() <= 199 ) || ( isAltDiff() >= 300 ) ) && !justcalcip )
            {
                int dummyind = 0;

                T xanorm;
                T xbnorm;
                T xcnorm;
                T xdnorm;

                double altxyr00 = 0;
                double altxyr10 = 0;
                double altxyr11 = 0;
                double altxyr20 = 0;
                double altxyr21 = 0;
                double altxyr22 = 0;
                double altxyr30 = 0;
                double altxyr31 = 0;
                double altxyr32 = 0;
                double altxyr33 = 0;

                if ( isAltDiff() == 0 )
                {
                    T zzz; zzz = 0.0;

                    kernel8xx(0,xanorm,dummyind,cType(0),zzz,zzz,zzz,xa,xa,xa,xa,xainfo,xainfo,xainfo,xainfo,ia,ia,ia,ia,xdim,0,mlid);
                    kernel8xx(0,xbnorm,dummyind,cType(0),zzz,zzz,zzz,xb,xb,xb,xb,xbinfo,xbinfo,xbinfo,xbinfo,ib,ib,ib,ib,xdim,0,mlid);
                    kernel8xx(0,xcnorm,dummyind,cType(0),zzz,zzz,zzz,xc,xc,xc,xc,xcinfo,xcinfo,xcinfo,xcinfo,ic,ic,ic,ic,xdim,0,mlid);
                    kernel8xx(0,xdnorm,dummyind,cType(0),zzz,zzz,zzz,xd,xd,xd,xd,xdinfo,xdinfo,xdinfo,xdinfo,id,id,id,id,xdim,0,mlid);

                    // needsMatDiff() == 0 here by definition
                }

                else
                {
                    T zzz; zzz = 0.0;

                    kernel8xx(0,xanorm,dummyind,cType(0),zzz,zzz,zzz,xa,xa,xainfo,xainfo,ia,ia,xdim,0,mlid);
                    kernel8xx(0,xbnorm,dummyind,cType(0),zzz,zzz,zzz,xb,xb,xbinfo,xbinfo,ib,ib,xdim,0,mlid);
                    kernel8xx(0,xcnorm,dummyind,cType(0),zzz,zzz,zzz,xc,xc,xcinfo,xcinfo,ic,ic,xdim,0,mlid);
                    kernel8xx(0,xdnorm,dummyind,cType(0),zzz,zzz,zzz,xd,xd,xdinfo,xdinfo,id,id,xdim,0,mlid);

                    if ( needsMatDiff() == +1 )
                    {
                        kernel8xx(0,altxyr10,dummyind,cType(0),zzz,zzz,zzz,xb,xa,xbinfo,xainfo,ib,ia,xdim,0,mlid);
                        kernel8xx(0,altxyr20,dummyind,cType(0),zzz,zzz,zzz,xc,xa,xcinfo,xainfo,ic,ia,xdim,0,mlid);
                        kernel8xx(0,altxyr21,dummyind,cType(0),zzz,zzz,zzz,xc,xb,xcinfo,xbinfo,ic,ib,xdim,0,mlid);
                        kernel8xx(0,altxyr30,dummyind,cType(0),zzz,zzz,zzz,xd,xa,xdinfo,xainfo,id,ia,xdim,0,mlid);
                        kernel8xx(0,altxyr31,dummyind,cType(0),zzz,zzz,zzz,xd,xb,xdinfo,xbinfo,id,ib,xdim,0,mlid);
                        kernel8xx(0,altxyr32,dummyind,cType(0),zzz,zzz,zzz,xd,xc,xdinfo,xcinfo,id,ic,xdim,0,mlid);

                        altxyr00 = xanorm;
                        altxyr11 = xbnorm;
                        altxyr22 = xcnorm;
                        altxyr33 = xdnorm;
                    }

                    else if ( needsMatDiff() == -1 )
                    {
                        kernel8xx(0,altxyr10,dummyind,cType(0),zzz,zzz,zzz,xb,xa,xbinfo,xainfo,ib,ia,xdim,0,mlid);
                        //kernel8xx(0,altxyr20,dummyind,cType(0),zzz,zzz,zzz,xc,xa,xcinfo,xainfo,ic,ia,xdim,0,mlid);
                        //kernel8xx(0,altxyr21,dummyind,cType(0),zzz,zzz,zzz,xc,xb,xcinfo,xbinfo,ic,ib,xdim,0,mlid);
                        //kernel8xx(0,altxyr30,dummyind,cType(0),zzz,zzz,zzz,xd,xa,xdinfo,xainfo,id,ia,xdim,0,mlid);
                        //kernel8xx(0,altxyr31,dummyind,cType(0),zzz,zzz,zzz,xd,xb,xdinfo,xbinfo,id,ib,xdim,0,mlid);
                        kernel8xx(0,altxyr32,dummyind,cType(0),zzz,zzz,zzz,xd,xc,xdinfo,xcinfo,id,ic,xdim,0,mlid);

                        altxyr00 = xanorm;
                        altxyr11 = xbnorm;
                        altxyr22 = xcnorm;
                        altxyr33 = xdnorm;
                    }
                }

                diff4norm(diffis,xyprod,xanorm,xbnorm,xcnorm,xdnorm,altxyr00,altxyr10,altxyr11,altxyr20,altxyr21,altxyr22,altxyr30,altxyr31,altxyr32,altxyr33,s);

                if ( !justcalcip )
                {
                    xyprod *= (const T &) cWeight(0);

                    xaprod *= (const T &) cWeight(0);
                    xbprod *= (const T &) cWeight(0);
                    xcprod *= (const T &) cWeight(0);
                    xdprod *= (const T &) cWeight(0);

                    diffis *= (const T &) cWeight(0);
                }
            }

            else if ( needsDiff(0) && ( isAltDiff() >= 200 ) && ( isAltDiff() <= 299 ) && !justcalcip )
            {
                // At this point we need to calculate diffis using altdiffis method 2xx
                // xyprod is not used by kernel
                // we only need to cycle through diffis for relevant s vectors
                // We need the xy matrix to do this

                int z = 0;
                T tempres; tempres = 0.0;
                int dummyind = 0;

                Matrix<double> altxy(4,4);
                const Matrix<double> &ssxy = altxy;

                T zzz; zzz = 0.0;

                kernel8xx(0,altxy("&",z,z),dummyind,cType(0),zzz,zzz,zzz,xa,xa,xainfo,xainfo,ia,ia,xdim,0,mlid);
                kernel8xx(0,altxy("&",z,1),dummyind,cType(0),zzz,zzz,zzz,xa,xb,xainfo,xbinfo,ia,ib,xdim,0,mlid);
                kernel8xx(0,altxy("&",z,2),dummyind,cType(0),zzz,zzz,zzz,xa,xc,xainfo,xcinfo,ia,ic,xdim,0,mlid);
                kernel8xx(0,altxy("&",z,3),dummyind,cType(0),zzz,zzz,zzz,xa,xd,xainfo,xdinfo,ia,id,xdim,0,mlid);
                kernel8xx(0,altxy("&",1,1),dummyind,cType(0),zzz,zzz,zzz,xb,xb,xbinfo,xbinfo,ib,ib,xdim,0,mlid);
                kernel8xx(0,altxy("&",1,2),dummyind,cType(0),zzz,zzz,zzz,xb,xc,xbinfo,xcinfo,ib,ic,xdim,0,mlid);
                kernel8xx(0,altxy("&",1,3),dummyind,cType(0),zzz,zzz,zzz,xb,xd,xbinfo,xdinfo,ib,id,xdim,0,mlid);
                kernel8xx(0,altxy("&",2,2),dummyind,cType(0),zzz,zzz,zzz,xc,xc,xcinfo,xcinfo,ic,ic,xdim,0,mlid);
                kernel8xx(0,altxy("&",2,3),dummyind,cType(0),zzz,zzz,zzz,xc,xd,xcinfo,xdinfo,ic,id,xdim,0,mlid);
                kernel8xx(0,altxy("&",3,3),dummyind,cType(0),zzz,zzz,zzz,xd,xd,xdinfo,xdinfo,id,id,xdim,0,mlid);

                altxy("&",1,z) = altxy(z,1);
                altxy("&",2,z) = altxy(z,2);
                altxy("&",2,1) = altxy(1,2);
                altxy("&",3,z) = altxy(z,3);
                altxy("&",3,1) = altxy(1,3);
                altxy("&",3,2) = altxy(2,3);

                xyprod = 0.0;

                if ( isAltDiff() == 203 )
                {
                    T dummy;

                    int ii[4] = { ia,ib,ic,id };

                    // ++--

                    diffis  =  ssxy(z,z) + ssxy(z,1) - ssxy(z,2) - ssxy(z,3); 
                    diffis +=  ssxy(1,z) + ssxy(1,1) - ssxy(1,2) - ssxy(1,3); 
                    diffis += -ssxy(2,z) - ssxy(2,1) + ssxy(2,2) + ssxy(2,3); 
                    diffis += -ssxy(3,z) - ssxy(3,1) + ssxy(3,2) + ssxy(3,3); 

                    KKpro(tempres,xyprod,diffis,ii,locindstart,locindstart,xdim,4,dummy,&dummy);
                    xyprod += tempres;

                    // +-+-

                    diffis  =  ssxy(z,z) - ssxy(z,1) + ssxy(z,2) - ssxy(z,3);
                    diffis += -ssxy(1,z) + ssxy(1,1) - ssxy(1,2) + ssxy(1,3);
                    diffis +=  ssxy(2,z) - ssxy(2,1) + ssxy(2,2) - ssxy(2,3);
                    diffis += -ssxy(3,z) + ssxy(3,1) - ssxy(3,2) + ssxy(3,3);

                    KKpro(tempres,xyprod,diffis,ii,locindstart,locindstart,xdim,4,dummy,&dummy);
                    xyprod += tempres;

                    // +--+

                    diffis  =  ssxy(z,z) - ssxy(z,1) - ssxy(z,2) + ssxy(z,3);
                    diffis += -ssxy(1,z) + ssxy(1,1) + ssxy(1,2) - ssxy(1,3);
                    diffis += -ssxy(2,z) + ssxy(2,1) + ssxy(2,2) - ssxy(2,3);
                    diffis +=  ssxy(3,z) - ssxy(3,1) - ssxy(3,2) + ssxy(3,3);

                    KKpro(tempres,xyprod,diffis,ii,locindstart,locindstart,xdim,4,dummy,&dummy);
                    xyprod += tempres;

                    // --++

                    diffis  =  ssxy(z,z) + ssxy(z,1) - ssxy(z,2) - ssxy(z,3);
                    diffis +=  ssxy(1,z) + ssxy(1,1) - ssxy(1,2) - ssxy(1,3);
                    diffis += -ssxy(2,z) - ssxy(2,1) + ssxy(2,2) + ssxy(2,3);
                    diffis += -ssxy(3,z) - ssxy(3,1) + ssxy(3,2) + ssxy(3,3);

                    KKpro(tempres,xyprod,diffis,ii,locindstart,locindstart,xdim,4,dummy,&dummy);
                    xyprod += tempres;

                    // -+-+

                    diffis  =  ssxy(z,z) - ssxy(z,1) + ssxy(z,2) - ssxy(z,3);
                    diffis += -ssxy(1,z) + ssxy(1,1) - ssxy(1,2) + ssxy(1,3);
                    diffis +=  ssxy(2,z) - ssxy(2,1) + ssxy(2,2) - ssxy(2,3);
                    diffis += -ssxy(3,z) + ssxy(3,1) - ssxy(3,2) + ssxy(3,3);

                    KKpro(tempres,xyprod,diffis,ii,locindstart,locindstart,xdim,4,dummy,&dummy);
                    xyprod += tempres;

                    // -++-

                    diffis  =  ssxy(z,z) - ssxy(z,1) - ssxy(z,2) + ssxy(z,3);
                    diffis += -ssxy(1,z) + ssxy(1,1) + ssxy(1,2) - ssxy(1,3);
                    diffis += -ssxy(2,z) + ssxy(2,1) + ssxy(2,2) - ssxy(2,3);
                    diffis +=  ssxy(3,z) - ssxy(3,1) - ssxy(3,2) + ssxy(3,3);

                    KKpro(tempres,xyprod,diffis,ii,locindstart,locindstart,xdim,4,dummy,&dummy);
                    xyprod += tempres;

                    // ++++

                    diffis  =  ssxy(z,z) + ssxy(z,1) + ssxy(z,2) + ssxy(z,3);
                    diffis +=  ssxy(1,z) + ssxy(1,1) + ssxy(1,2) + ssxy(1,3);
                    diffis +=  ssxy(2,z) + ssxy(2,1) + ssxy(2,2) + ssxy(2,3);
                    diffis +=  ssxy(3,z) + ssxy(3,1) + ssxy(3,2) + ssxy(3,3);

                    KKpro(tempres,xyprod,diffis,ii,locindstart,locindstart,xdim,4,dummy,&dummy);
                    xyprod += tempres;
	
                    // ----

                    diffis  =  ssxy(z,z) + ssxy(z,1) + ssxy(z,2) + ssxy(z,3);
                    diffis +=  ssxy(1,z) + ssxy(1,1) + ssxy(1,2) + ssxy(1,3);
                    diffis +=  ssxy(2,z) + ssxy(2,1) + ssxy(2,2) + ssxy(2,3);
                    diffis +=  ssxy(3,z) + ssxy(3,1) + ssxy(3,2) + ssxy(3,3);

                    KKpro(tempres,xyprod,diffis,ii,locindstart,locindstart,xdim,4,dummy,&dummy);
                    xyprod += tempres;

                    xyprod /= 8;
                }

                else if ( isAltDiff() == 204 )
                {
                    T dummy;

                    int ii[4] = { ia,ib,ic,id };

                    Vector<int> ss(4);

                    ss("&",z) = 0; ss("&",1) = 1; ss("&",2) = 2; ss("&",3) = 3;

                    diffis =  ssxy(ss(z),ss(z)) - ssxy(ss(z),ss(1));
                    diffis = -ssxy(ss(1),ss(z)) - ssxy(ss(1),ss(1));

                    diffis =  ssxy(ss(2),ss(2)) - ssxy(ss(2),ss(3));
                    diffis = -ssxy(ss(3),ss(2)) - ssxy(ss(3),ss(3));

                    KKpro(tempres,xyprod,diffis,ii,locindstart,locindstart,xdim,4,dummy,&dummy);
                    xyprod += tempres;

                    ss("&",z) = 0; ss("&",1) = 1; ss("&",2) = 3; ss("&",3) = 2;

                    diffis =  ssxy(ss(z),ss(z)) - ssxy(ss(z),ss(1));
                    diffis = -ssxy(ss(1),ss(z)) - ssxy(ss(1),ss(1));

                    diffis =  ssxy(ss(2),ss(2)) - ssxy(ss(2),ss(3));
                    diffis = -ssxy(ss(3),ss(2)) - ssxy(ss(3),ss(3));

                    KKpro(tempres,xyprod,diffis,ii,locindstart,locindstart,xdim,4,dummy,&dummy);
                    xyprod += tempres;

                    ss("&",z) = 0; ss("&",1) = 2; ss("&",2) = 1; ss("&",3) = 3;

                    diffis =  ssxy(ss(z),ss(z)) - ssxy(ss(z),ss(1));
                    diffis = -ssxy(ss(1),ss(z)) - ssxy(ss(1),ss(1));

                    diffis =  ssxy(ss(2),ss(2)) - ssxy(ss(2),ss(3));
                    diffis = -ssxy(ss(3),ss(2)) - ssxy(ss(3),ss(3));

                    KKpro(tempres,xyprod,diffis,ii,locindstart,locindstart,xdim,4,dummy,&dummy);
                    xyprod += tempres;

                    ss("&",z) = 0; ss("&",1) = 2; ss("&",2) = 3; ss("&",3) = 1;

                    diffis =  ssxy(ss(z),ss(z)) - ssxy(ss(z),ss(1));
                    diffis = -ssxy(ss(1),ss(z)) - ssxy(ss(1),ss(1));

                    diffis =  ssxy(ss(2),ss(2)) - ssxy(ss(2),ss(3));
                    diffis = -ssxy(ss(3),ss(2)) - ssxy(ss(3),ss(3));

                    KKpro(tempres,xyprod,diffis,ii,locindstart,locindstart,xdim,4,dummy,&dummy);
                    xyprod += tempres;

                    ss("&",z) = 0; ss("&",1) = 3; ss("&",2) = 1; ss("&",3) = 2;

                    diffis =  ssxy(ss(z),ss(z)) - ssxy(ss(z),ss(1));
                    diffis = -ssxy(ss(1),ss(z)) - ssxy(ss(1),ss(1));

                    diffis =  ssxy(ss(2),ss(2)) - ssxy(ss(2),ss(3));
                    diffis = -ssxy(ss(3),ss(2)) - ssxy(ss(3),ss(3));

                    KKpro(tempres,xyprod,diffis,ii,locindstart,locindstart,xdim,4,dummy,&dummy);
                    xyprod += tempres;

                    ss("&",z) = 0; ss("&",1) = 3; ss("&",2) = 2; ss("&",3) = 1;

                    diffis =  ssxy(ss(z),ss(z)) - ssxy(ss(z),ss(1));
                    diffis = -ssxy(ss(1),ss(z)) - ssxy(ss(1),ss(1));

                    diffis =  ssxy(ss(2),ss(2)) - ssxy(ss(2),ss(3));
                    diffis = -ssxy(ss(3),ss(2)) - ssxy(ss(3),ss(3));

                    KKpro(tempres,xyprod,diffis,ii,locindstart,locindstart,xdim,4,dummy,&dummy);
                    xyprod += tempres;


                    ss("&",z) = 1; ss("&",1) = 0; ss("&",2) = 2; ss("&",3) = 3;

                    diffis =  ssxy(ss(z),ss(z)) - ssxy(ss(z),ss(1));
                    diffis = -ssxy(ss(1),ss(z)) - ssxy(ss(1),ss(1));

                    diffis =  ssxy(ss(2),ss(2)) - ssxy(ss(2),ss(3));
                    diffis = -ssxy(ss(3),ss(2)) - ssxy(ss(3),ss(3));

                    KKpro(tempres,xyprod,diffis,ii,locindstart,locindstart,xdim,4,dummy,&dummy);
                    xyprod += tempres;

                    ss("&",z) = 1; ss("&",1) = 0; ss("&",2) = 3; ss("&",3) = 2;

                    diffis =  ssxy(ss(z),ss(z)) - ssxy(ss(z),ss(1));
                    diffis = -ssxy(ss(1),ss(z)) - ssxy(ss(1),ss(1));

                    diffis =  ssxy(ss(2),ss(2)) - ssxy(ss(2),ss(3));
                    diffis = -ssxy(ss(3),ss(2)) - ssxy(ss(3),ss(3));

                    KKpro(tempres,xyprod,diffis,ii,locindstart,locindstart,xdim,4,dummy,&dummy);
                    xyprod += tempres;

                    ss("&",z) = 1; ss("&",1) = 2; ss("&",2) = 0; ss("&",3) = 3;

                    diffis =  ssxy(ss(z),ss(z)) - ssxy(ss(z),ss(1));
                    diffis = -ssxy(ss(1),ss(z)) - ssxy(ss(1),ss(1));

                    diffis =  ssxy(ss(2),ss(2)) - ssxy(ss(2),ss(3));
                    diffis = -ssxy(ss(3),ss(2)) - ssxy(ss(3),ss(3));

                    KKpro(tempres,xyprod,diffis,ii,locindstart,locindstart,xdim,4,dummy,&dummy);
                    xyprod += tempres;

                    ss("&",z) = 1; ss("&",1) = 2; ss("&",2) = 3; ss("&",3) = 0;

                    diffis =  ssxy(ss(z),ss(z)) - ssxy(ss(z),ss(1));
                    diffis = -ssxy(ss(1),ss(z)) - ssxy(ss(1),ss(1));

                    diffis =  ssxy(ss(2),ss(2)) - ssxy(ss(2),ss(3));
                    diffis = -ssxy(ss(3),ss(2)) - ssxy(ss(3),ss(3));

                    KKpro(tempres,xyprod,diffis,ii,locindstart,locindstart,xdim,4,dummy,&dummy);
                    xyprod += tempres;

                    ss("&",z) = 1; ss("&",1) = 3; ss("&",2) = 0; ss("&",3) = 2;

                    diffis =  ssxy(ss(z),ss(z)) - ssxy(ss(z),ss(1));
                    diffis = -ssxy(ss(1),ss(z)) - ssxy(ss(1),ss(1));

                    diffis =  ssxy(ss(2),ss(2)) - ssxy(ss(2),ss(3));
                    diffis = -ssxy(ss(3),ss(2)) - ssxy(ss(3),ss(3));

                    KKpro(tempres,xyprod,diffis,ii,locindstart,locindstart,xdim,4,dummy,&dummy);
                    xyprod += tempres;

                    ss("&",z) = 1; ss("&",1) = 3; ss("&",2) = 2; ss("&",3) = 0;

                    diffis =  ssxy(ss(z),ss(z)) - ssxy(ss(z),ss(1));
                    diffis = -ssxy(ss(1),ss(z)) - ssxy(ss(1),ss(1));

                    diffis =  ssxy(ss(2),ss(2)) - ssxy(ss(2),ss(3));
                    diffis = -ssxy(ss(3),ss(2)) - ssxy(ss(3),ss(3));

                    KKpro(tempres,xyprod,diffis,ii,locindstart,locindstart,xdim,4,dummy,&dummy);
                    xyprod += tempres;


                    ss("&",z) = 2; ss("&",1) = 1; ss("&",2) = 0; ss("&",3) = 3;

                    diffis =  ssxy(ss(z),ss(z)) - ssxy(ss(z),ss(1));
                    diffis = -ssxy(ss(1),ss(z)) - ssxy(ss(1),ss(1));

                    diffis =  ssxy(ss(2),ss(2)) - ssxy(ss(2),ss(3));
                    diffis = -ssxy(ss(3),ss(2)) - ssxy(ss(3),ss(3));

                    KKpro(tempres,xyprod,diffis,ii,locindstart,locindstart,xdim,4,dummy,&dummy);
                    xyprod += tempres;

                    ss("&",z) = 2; ss("&",1) = 1; ss("&",2) = 3; ss("&",3) = 0;

                    diffis =  ssxy(ss(z),ss(z)) - ssxy(ss(z),ss(1));
                    diffis = -ssxy(ss(1),ss(z)) - ssxy(ss(1),ss(1));

                    diffis =  ssxy(ss(2),ss(2)) - ssxy(ss(2),ss(3));
                    diffis = -ssxy(ss(3),ss(2)) - ssxy(ss(3),ss(3));

                    KKpro(tempres,xyprod,diffis,ii,locindstart,locindstart,xdim,4,dummy,&dummy);
                    xyprod += tempres;

                    ss("&",z) = 2; ss("&",1) = 0; ss("&",2) = 1; ss("&",3) = 3;

                    diffis =  ssxy(ss(z),ss(z)) - ssxy(ss(z),ss(1));
                    diffis = -ssxy(ss(1),ss(z)) - ssxy(ss(1),ss(1));

                    diffis =  ssxy(ss(2),ss(2)) - ssxy(ss(2),ss(3));
                    diffis = -ssxy(ss(3),ss(2)) - ssxy(ss(3),ss(3));

                    KKpro(tempres,xyprod,diffis,ii,locindstart,locindstart,xdim,4,dummy,&dummy);
                    xyprod += tempres;

                    ss("&",z) = 2; ss("&",1) = 0; ss("&",2) = 3; ss("&",3) = 1;

                    diffis =  ssxy(ss(z),ss(z)) - ssxy(ss(z),ss(1));
                    diffis = -ssxy(ss(1),ss(z)) - ssxy(ss(1),ss(1));

                    diffis =  ssxy(ss(2),ss(2)) - ssxy(ss(2),ss(3));
                    diffis = -ssxy(ss(3),ss(2)) - ssxy(ss(3),ss(3));

                    KKpro(tempres,xyprod,diffis,ii,locindstart,locindstart,xdim,4,dummy,&dummy);
                    xyprod += tempres;

                    ss("&",z) = 2; ss("&",1) = 3; ss("&",2) = 1; ss("&",3) = 0;

                    diffis =  ssxy(ss(z),ss(z)) - ssxy(ss(z),ss(1));
                    diffis = -ssxy(ss(1),ss(z)) - ssxy(ss(1),ss(1));

                    diffis =  ssxy(ss(2),ss(2)) - ssxy(ss(2),ss(3));
                    diffis = -ssxy(ss(3),ss(2)) - ssxy(ss(3),ss(3));

                    KKpro(tempres,xyprod,diffis,ii,locindstart,locindstart,xdim,4,dummy,&dummy);
                    xyprod += tempres;

                    ss("&",z) = 2; ss("&",1) = 3; ss("&",2) = 0; ss("&",3) = 1;

                    diffis =  ssxy(ss(z),ss(z)) - ssxy(ss(z),ss(1));
                    diffis = -ssxy(ss(1),ss(z)) - ssxy(ss(1),ss(1));

                    diffis =  ssxy(ss(2),ss(2)) - ssxy(ss(2),ss(3));
                    diffis = -ssxy(ss(3),ss(2)) - ssxy(ss(3),ss(3));

                    KKpro(tempres,xyprod,diffis,ii,locindstart,locindstart,xdim,4,dummy,&dummy);
                    xyprod += tempres;


                    ss("&",z) = 3; ss("&",1) = 1; ss("&",2) = 2; ss("&",3) = 0;

                    diffis =  ssxy(ss(z),ss(z)) - ssxy(ss(z),ss(1));
                    diffis = -ssxy(ss(1),ss(z)) - ssxy(ss(1),ss(1));

                    diffis =  ssxy(ss(2),ss(2)) - ssxy(ss(2),ss(3));
                    diffis = -ssxy(ss(3),ss(2)) - ssxy(ss(3),ss(3));

                    KKpro(tempres,xyprod,diffis,ii,locindstart,locindstart,xdim,4,dummy,&dummy);
                    xyprod += tempres;

                    ss("&",z) = 3; ss("&",1) = 1; ss("&",2) = 0; ss("&",3) = 2;

                    diffis =  ssxy(ss(z),ss(z)) - ssxy(ss(z),ss(1));
                    diffis = -ssxy(ss(1),ss(z)) - ssxy(ss(1),ss(1));

                    diffis =  ssxy(ss(2),ss(2)) - ssxy(ss(2),ss(3));
                    diffis = -ssxy(ss(3),ss(2)) - ssxy(ss(3),ss(3));

                    KKpro(tempres,xyprod,diffis,ii,locindstart,locindstart,xdim,4,dummy,&dummy);
                    xyprod += tempres;

                    ss("&",z) = 3; ss("&",1) = 2; ss("&",2) = 1; ss("&",3) = 0;

                    diffis =  ssxy(ss(z),ss(z)) - ssxy(ss(z),ss(1));
                    diffis = -ssxy(ss(1),ss(z)) - ssxy(ss(1),ss(1));

                    diffis =  ssxy(ss(2),ss(2)) - ssxy(ss(2),ss(3));
                    diffis = -ssxy(ss(3),ss(2)) - ssxy(ss(3),ss(3));

                    KKpro(tempres,xyprod,diffis,ii,locindstart,locindstart,xdim,4,dummy,&dummy);
                    xyprod += tempres;

                    ss("&",z) = 3; ss("&",1) = 2; ss("&",2) = 0; ss("&",3) = 1;

                    diffis =  ssxy(ss(z),ss(z)) - ssxy(ss(z),ss(1));
                    diffis = -ssxy(ss(1),ss(z)) - ssxy(ss(1),ss(1));

                    diffis =  ssxy(ss(2),ss(2)) - ssxy(ss(2),ss(3));
                    diffis = -ssxy(ss(3),ss(2)) - ssxy(ss(3),ss(3));

                    KKpro(tempres,xyprod,diffis,ii,locindstart,locindstart,xdim,4,dummy,&dummy);
                    xyprod += tempres;

                    ss("&",z) = 3; ss("&",1) = 0; ss("&",2) = 1; ss("&",3) = 2;

                    diffis =  ssxy(ss(z),ss(z)) - ssxy(ss(z),ss(1));
                    diffis = -ssxy(ss(1),ss(z)) - ssxy(ss(1),ss(1));

                    diffis =  ssxy(ss(2),ss(2)) - ssxy(ss(2),ss(3));
                    diffis = -ssxy(ss(3),ss(2)) - ssxy(ss(3),ss(3));

                    KKpro(tempres,xyprod,diffis,ii,locindstart,locindstart,xdim,4,dummy,&dummy);
                    xyprod += tempres;

                    ss("&",z) = 3; ss("&",1) = 0; ss("&",2) = 2; ss("&",3) = 1;

                    diffis =  ssxy(ss(z),ss(z)) - ssxy(ss(z),ss(1));
                    diffis = -ssxy(ss(1),ss(z)) - ssxy(ss(1),ss(1));

                    diffis =  ssxy(ss(2),ss(2)) - ssxy(ss(2),ss(3));
                    diffis = -ssxy(ss(3),ss(2)) - ssxy(ss(3),ss(3));

                    KKpro(tempres,xyprod,diffis,ii,locindstart,locindstart,xdim,4,dummy,&dummy);
                    xyprod += tempres;


                    xyprod /= 24;
                }

                diffis *= (const T &) cWeight(0);

                ++locindstart;
            }
        }

        if ( justcalcip )
        {
            res = xyprod;
        }

        else
        {
            if ( isNormalised(locindend) )
            {
                T dummy;

                int iabcd[4] = { ia,ib,ic,id };
                int iaaaa[4] = { ia,ia,ia,ia };
                int ibbbb[4] = { ib,ib,ib,ib };
                int icccc[4] = { ic,ic,ic,ic };
                int idddd[4] = { id,id,id,id };

                KKpro(res,xyprod,diffis,iabcd,locindstart,locindend,xdim,4,dummy,&dummy);

                T xares;
                T xbres;
                T xcres;
                T xdres;

                T zerodiff; zerodiff = 0.0;

                KKpro(xares,xaprod,zerodiff,iaaaa,locindstart,locindend,xdim,4,dummy,&dummy);
                KKpro(xbres,xbprod,zerodiff,ibbbb,locindstart,locindend,xdim,4,dummy,&dummy);
                KKpro(xcres,xcprod,zerodiff,icccc,locindstart,locindend,xdim,4,dummy,&dummy);
                KKpro(xdres,xdprod,zerodiff,idddd,locindstart,locindend,xdim,4,dummy,&dummy);

                if ( ( ( (double) abs2(xares) <= BADZEROTOL ) && ( (double) abs2(xbres) <= BADZEROTOL ) && ( (double) abs2(xcres) <= BADZEROTOL ) ) ||
                     ( ( (double) abs2(xares) <= BADZEROTOL ) && ( (double) abs2(xbres) <= BADZEROTOL ) && ( (double) abs2(xdres) <= BADZEROTOL ) ) ||
                     ( ( (double) abs2(xares) <= BADZEROTOL ) && ( (double) abs2(xcres) <= BADZEROTOL ) && ( (double) abs2(xdres) <= BADZEROTOL ) ) ||
                     ( ( (double) abs2(xbres) <= BADZEROTOL ) && ( (double) abs2(xcres) <= BADZEROTOL ) && ( (double) abs2(xdres) <= BADZEROTOL ) )    )
                {
                    res = angle(res);
                    res = ( (double) abs2(res) <= BADZEROTOL ) ? 1.0 : res;
                }

                else if ( ( (double) abs2(xares) <= BADZEROTOL ) && ( (double) abs2(xbres) <= BADZEROTOL ) )
                {
                    // Fallback to LL2

                    LL2(0,0,res,logres,logresvalid,xc,xd,xcinfo,xdinfo,bias,nullptr,ic,id,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,justcalcip,indstart,indend);
                }

                else if ( ( (double) abs2(xares) <= BADZEROTOL ) && ( (double) abs2(xcres) <= BADZEROTOL ) )
                {
                    // Fallback to LL2

                    LL2(0,0,res,logres,logresvalid,xb,xd,xbinfo,xdinfo,bias,nullptr,ib,id,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,justcalcip,indstart,indend);
                }

                else if ( ( (double) abs2(xares) <= BADZEROTOL ) && ( (double) abs2(xdres) <= BADZEROTOL ) )
                {
                    // Fallback to LL2

                    LL2(0,0,res,logres,logresvalid,xb,xc,xbinfo,xcinfo,bias,nullptr,ib,ic,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,justcalcip,indstart,indend);
                }

                else if ( ( (double) abs2(xbres) <= BADZEROTOL ) && ( (double) abs2(xcres) <= BADZEROTOL ) )
                {
                    // Fallback to LL2

                    LL2(0,0,res,logres,logresvalid,xa,xd,xainfo,xdinfo,bias,nullptr,ia,id,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,justcalcip,indstart,indend);
                }

                else if ( ( (double) abs2(xbres) <= BADZEROTOL ) && ( (double) abs2(xdres) <= BADZEROTOL ) )
                {
                    // Fallback to LL2

                    LL2(0,0,res,logres,logresvalid,xa,xc,xainfo,xcinfo,bias,nullptr,ia,ic,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,justcalcip,indstart,indend);
                }

                else if ( ( (double) abs2(xcres) <= BADZEROTOL ) && ( (double) abs2(xdres) <= BADZEROTOL ) )
                {
                    // Fallback to LL2

                    LL2(0,0,res,logres,logresvalid,xa,xb,xainfo,xbinfo,bias,nullptr,ia,ib,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,justcalcip,indstart,indend);
                }

                else if ( (double) abs2(xares) <= BADZEROTOL )
                {
                    // Fallback to LL3

                    LL3(res,logres,logresvalid,xb,xc,xd,xbinfo,xcinfo,xdinfo,bias,nullptr,ib,ic,id,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,justcalcip,indstart,indend);
                }

                else if ( (double) abs2(xbres) <= BADZEROTOL )
                {
                    // Fallback to LL3

                    LL3(res,logres,logresvalid,xa,xc,xd,xainfo,xcinfo,xdinfo,bias,nullptr,ia,ic,id,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,justcalcip,indstart,indend);
                }

                else if ( (double) abs2(xcres) <= BADZEROTOL )
                {
                    // Fallback to LL3

                    LL3(res,logres,logresvalid,xa,xb,xd,xainfo,xbinfo,xdinfo,bias,nullptr,ia,ib,id,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,justcalcip,indstart,indend);
                }

                else if ( (double) abs2(xdres) <= BADZEROTOL )
                {
                    // Fallback to LL3

                    LL3(res,logres,logresvalid,xa,xb,xc,xainfo,xbinfo,xcinfo,bias,nullptr,ia,ib,ic,xdim,xconsist,assumreal,resmode,mlid,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,nullptr,justcalcip,indstart,indend);
                }

                else
                {
                    // We normalise in log-space to improve numerical stability

                    T sgnres = angle(res);

                    res = abs2(res);
                    OP_log(res);
                    res *= 4.0;
                    res -= log(xares);
                    res -= log(xbres);
                    res -= log(xcres);
                    res -= log(xdres);
                    res *= 0.25;
                    OP_exp(res);
                    res *= sgnres;
                }
            }

            else
            {
                T dummy;

                int iabcd[4] = { ia,ib,ic,id };

                logresvalid = KKpro(res,xyprod,diffis,iabcd,locindstart,locindend,xdim,4,logres,&dummy);
            }
        }
    }

    else
    {
        NiceAssert( ismagterm == 0 );
        NiceAssert( ( isAltDiff() <= 199 ) || ( isAltDiff() >= 300 ) );

        gentype xyprod(0.0);

        if ( pxyprod && pxyprod[0] )
        {
            xyprod = (const T &) *pxyprod[0];
        }

        else if ( needsInner(-1,4) )
        {
            // This may be used by some kernels and not others, so calculate anyhow

            fourProductDiverted(xyprod,xa,xb,xc,xd,xconsist,assumreal);

            xyprod += bias;
        }

        double altxyr00 = 0;
        double altxyr10 = 0;
        double altxyr11 = 0;
        double altxyr20 = 0;
        double altxyr21 = 0;
        double altxyr22 = 0;
        double altxyr30 = 0;
        double altxyr31 = 0;
        double altxyr32 = 0;
        double altxyr33 = 0;

        fillXYMatrix(altxyr00,altxyr10,altxyr11,altxyr20,altxyr21,altxyr22,altxyr30,altxyr31,altxyr32,altxyr33,xa,xb,xc,xd,xainfo,xbinfo,xcinfo,xdinfo,xy00,xy10,xy11,xy20,xy21,xy22,xy30,xy31,xy32,xy33,0,assumreal);

        gentype tempres;

        K4i(tempres,xyprod,xainfo,xbinfo,xcinfo,xdinfo,getmnorm(xainfo,xa,4,xconsist,assumreal),getmnorm(xbinfo,xb,4,xconsist,assumreal),getmnorm(xcinfo,xc,4,xconsist,assumreal),getmnorm(xdinfo,xd,4,xconsist,assumreal),xa,xb,xc,xd,ia,ib,ic,id,xdim,resmode,mlid,altxyr00,altxyr10,altxyr11,altxyr20,altxyr21,altxyr22,altxyr30,altxyr31,altxyr32,altxyr33,s,indstart,indend,assumreal);

        res = (T) tempres;
    }

    return res;
}

//phantomx
template <class T>
T &MercerKernel::LLm(int m, T &res, T &logres, int &logresvalid,
                     Vector<const SparseVector<gentype> *> &x,
                     Vector<const vecInfo *> &xinfo,
                     const T &bias,
                     Vector<int> &iv,
                     const gentype **pxyprod, int xdim, int xconsist, int assumreal, int resmode, int mlid, 
                     const Matrix<double> *xy, const Vector<int> *s, int justcalcip, int indstart, int indend) const
{
    Vector<int> i(iv);

    NiceAssert( ! ( isFastKernelSum() && ( isAltDiff() >= 200 ) && ( isAltDiff() <= 300 ) ) );

    logresvalid = 0;

    T dummya;
    int dummyb = 0;

    if ( (m%2) && ( isAltDiff() >= 100 ) )
    {
        goto badout;
    }

    if ( !size() )
    {
        return res = 0.0;
    }

    if ( isAltDiff() == 300 )
    {
        NiceThrow("I should probably implement this someday");
    }

    else if ( !s && ( isAltDiff() >= 100 ) && ( isAltDiff() <= 199 ) && !justcalcip )
    {
        Vector<int> ss(m);
        T tempres; tempres = 0.0;
        int ii,jj;

        res = 0.0;

        if ( isAltDiff() == 103 )
        {
            int isdone = 0;

            ss = 1;

            while ( !isdone )
            {
                if ( sum(ss)%4 == 0 )
                {
                    LLm(m,tempres,dummya,dummyb,x,xinfo,bias,i,nullptr,xdim,xconsist,assumreal,resmode,mlid,xy,&ss,0,indstart,indend);
                    res += tempres;
                }

                isdone = 1;
                ii = 0;

                while ( ( ii < m ) && isdone )
                {
                    if ( ss(ii) == 1 )
                    {
                        ss("&",ii) = -1;
                        isdone = 0;
                    }

                    else
                    {
                        ss("&",ii) = +1;
                        ++ii;
                    }
                }
            }

            res /= (1<<(m-1));
        }

        else if ( isAltDiff() == 104 )
        {
            Vector<int> ss(m);
            int isdone = 0;
            int cnt = 0;
            int z = 0;

            ss = z;

            while ( !isdone )
            {
                int noreps = 1;

                for ( ii = 0 ; ( ii < m ) && noreps ; ++ii )
                {
                    for ( jj = ii+1 ; ( jj < m ) && noreps ; ++jj )
                    {
                        if ( ss(ii) == ss(jj) )
                        {
                            noreps = 0;
                        }
                    }
                }

                if ( noreps )
                {
                    ++cnt;
                    LLm(m,tempres,dummya,dummyb,x,xinfo,bias,i,nullptr,xdim,xconsist,assumreal,resmode,mlid,xy,&ss,0,indstart,indend);
                    res += tempres;
                }

                isdone = 1;
                ii = 0;

                while ( ( ii < m ) && isdone )
                {
                    ++(ss("&",ii));

                    if ( ss(ii) < m )
                    {
                        isdone = 0;
                    }

                    else
                    {
                        ss("&",ii) = z;
                        ++ii;
                    }
                }
            }

            res /= cnt;
        }
    }

    else if ( ( resmode & 0x01 ) )
    {
        NiceAssert( !justcalcip );
        NiceAssert( ( isAltDiff() <= 199 ) || ( isAltDiff() >= 300 ) );
        NiceAssert( !( isprod && !arexysimple(m,x) ) );

        Vector<const gentype *> xnormde(x.size());

        if ( m )
        {
            int ii;

            retVector<const gentype *> tmpva;

            for ( ii = 0 ; ii < m ; ++ii )
            {
                xnormde("&",i,tmpva) = &getmnorm(*(xinfo(ii)),*(x(ii)),m,xconsist,assumreal);
            }
        }

        Matrix<double> altxy;

        gentype tempres;

        //Kmi(tempres,defaultgentype(),xinfo,xnormde,x,i,xdim,x.size(),resmode,mlid,fillXYMatrix(m,altxy,x,xinfo,xy,0,assumreal),s,indstart,indend,assumreal);
        Kmi(tempres,0_gent,xinfo,xnormde,x,i,xdim,x.size(),resmode,mlid,fillXYMatrix(m,altxy,x,xinfo,xy,0,assumreal),s,indstart,indend,assumreal);

        res = (T) tempres;
    }

    else if ( isprod && !arexysimple(m,x) )
    {
        NiceAssert( !justcalcip );
        NiceAssert( !( resmode & 0x80 ) );

        // Kernel is of the form prod_i K(x_i,y_i)
        // x and y are not simple

        if ( xconsist && ( size() == 1 ) && isSimpleKernel() )
        {
            //NiceAssert( x.nindsize() == y.nindsize() );

            Vector<SparseVector<gentype> > xx(x.size());
            Vector<const SparseVector<gentype> *> xxx(x.size());

            Vector<vecInfo> xxinfo(x.size());
            Vector<const vecInfo *> xxxinfo(x.size());

            if ( m && (*(x(0))).nindsize() )
            {
                int ii,jj;
                T tempres;

                for ( jj = 0 ; jj < m ; ++jj )
                {
                    xxx    ("&",jj) = &(xx    (jj));
                    xxxinfo("&",jj) = &(xxinfo(jj));
                }

                for ( ii = 0 ; ii < (*(x(0))).nindsize() ; ++ii )
                {
                    for ( jj = 0 ; jj < m ; ++jj )
                    {
                        xx("&",jj)("&",0) = (*(x(jj))).direcref(ii);
                        getvecInfo(xxinfo("&",jj),xx(jj),nullptr,xconsist,assumreal);
                    }

                    LLm(m,tempres,dummya,dummyb,xxx,xxxinfo,bias,i,nullptr,1,1,resmode,assumreal,mlid,nullptr,nullptr,0,indstart,indend);

                    tempres /= (const T &) cWeight(0);

                    if ( !ii ) { res =  tempres; }
                    else       { res *= tempres; }
                }
            }

            else
            {
                res = 1;
            }
        }

        else
        {
            SparseVector<gentype> indres;

            combind(m,indres,x);

            Vector<SparseVector<gentype> > xx(x.size());
            Vector<const SparseVector<gentype> *> xxx(x.size());

            Vector<vecInfo> xxinfo(x.size());
            Vector<const vecInfo *> xxxinfo(x.size());

            if ( m && indres.size() )
            {
                int ii,jj;
                T tempres;

                for ( jj = 0 ; jj < m ; ++jj )
                {
                    xxx    ("&",jj) = &(xx    (jj));
                    xxxinfo("&",jj) = &(xxinfo(jj));
                }

                for ( ii = 0 ; ii < indres.nindsize() ; ++ii )
                {
                    for ( jj = 0 ; jj < m ; ++jj )
                    {
                        xx("&",jj)("&",0) = (*(x(jj))).direcref(indres.ind(ii));
                        getvecInfo(xxinfo("&",jj),xx(jj),nullptr,xconsist,assumreal);
                    }

                    LLm(m,tempres,dummya,dummyb,xxx,xxxinfo,bias,i,nullptr,1,1,assumreal,resmode,mlid,nullptr,nullptr,0,indstart,indend);

                    tempres /= (const T &) cWeight(0);

                    if ( !ii ) { res =  tempres; }
                    else       { res *= tempres; }
                }
            }

            else
            {
                res = 1;
            }
        }

        res *= (const T &) cWeight(0);
    }

    else if ( ( isFastKernelSum() || isFastKernelChain() ) && ( resmode & 0x80 ) && !justcalcip )
    {
        res = 0;
    }

    else if ( isFastKernelSum() || isFastKernelChain() || ( isFastKernelXfer() && !resmode ) || justcalcip )
    {
        int locindstart = (isFastKernelXfer()?1:indstart); // NB: isFastKernelXfer() implies indstart == 0
        int locindend   = indend; //size()-1;

        int needxxprod = isNormalised(locindend);

        T xyprod; xyprod = 0.0;
        Vector<T> xxprod(x.size());
        T diffis; diffis = 0.0;

        xxprod = diffis; // diffis = 0.0

        if ( isFastKernelSum() || isFastKernelChain() || justcalcip )
        {
            if ( pxyprod && pxyprod[0] )
            {
                xyprod = *pxyprod[0];
            }

            else if ( needsInner(0,m) || ( isFastKernelSum() && needsInner(-1,m) ) || justcalcip )
            {
                mProductDiverted(m,xyprod,x,xconsist,assumreal);

                if ( !justcalcip )
                {
                    xyprod += bias;
                }
            }

            if ( needxxprod && !justcalcip )
            {
                int ii;
                Vector<int> iii(x.size());

                retVector<const SparseVector<gentype> *> tmpva;
                retVector<const vecInfo *>               tmpvb;

                for ( ii = 0 ; ii < m ; ++ii )
                {
                    iii = ii;

                    mProductDiverted(m,xxprod("&",ii),x(iii,tmpva),xconsist,assumreal);

                    if ( !justcalcip )
                    {
                        xxprod("&",ii) += bias;
                    }
                }
            }

            if ( pxyprod && pxyprod[1] )
            {
                diffis = *pxyprod[1];
            }

            else if ( ( ( needsDiff(0) || ( isFastKernelSum() && needsDiff() ) ) && ( ( isAltDiff() <= 199 ) || ( isAltDiff() >= 300 ) ) ) && !justcalcip )
            {
                Vector<T> xnormrr(x.size());
                Vector<const T *> xnormde(x.size());

                if ( m )
                {
                    int ii;

                    for ( ii = 0 ; ii < m ; ++ii )
                    {
                        xnormrr("&",ii) = getmnorm(*(xinfo(ii)),*(x(ii)),m,xconsist,assumreal);
                        xnormde("&",ii) = &xnormrr(ii); //&getmnorm(*(xinfo(ii)),*(x(ii)),m,xconsist,assumreal);
                    }
                }

                Matrix<double> altxy;

                diffmnorm(m,diffis,xyprod,xnormde,fillXYMatrix(m,altxy,x,xinfo,xy,0,assumreal),s);
            }

            else if ( ( needsDiff(0) && ( isAltDiff() >= 200 ) && ( isAltDiff() <= 299 ) ) && !justcalcip )
            {
                // At this point we need to calculate diffis using altdiffis method 2xx
                // xyprod is not used by kernel, but need to fill it in for use by rest of chain
                // we only need to cycle through diffis for relevant s vectors
                // We need the xy matrix to do this

                T tempres;
                int ii,jj;

                Matrix<double> altxy(m,m);
                const Matrix<double> *sxy = &fillXYMatrix(m,altxy,x,xinfo,xy,1,assumreal);
                const Matrix<double> &ssxy = *sxy;

                xyprod = 0.0;

                if ( isAltDiff() == 203 )
                {
                    T dummy;

                    Vector<int> ss(m);

                    int isdone = 0;

                    ss = 1;

                    while ( !isdone )
                    {
                        if ( sum(ss)%4 == 0 )
                        {
                            diffis = 0.0;

                            for ( ii = 0 ; ii < m ; ++ii )
                            {
                                for ( jj = 0 ; jj < m ; ++jj )
                                {
                                    diffis += ss(ii)*ss(jj)*ssxy(ii,jj);
                                }
                            }

                            KKpro(tempres,xyprod,diffis,&(i("&",0)),locindstart,locindstart,xdim,m,dummy,&dummy);
                            xyprod += tempres;
                        }

                        isdone = 1;
                        ii = 0;

                        while ( ( ii < m ) && isdone )
                        {
                            if ( ss(ii) == 1 )
                            {
                                ss("&",ii) = -1;
                                isdone = 0;
                            }

                            else
                            {
                                ss("&",ii) = +1;
                                ++ii;
                            }
                        }
                    }

                    xyprod /= (1<<(m-1));
                }

                else if ( isAltDiff() == 204 )
                {
                    Vector<int> ss(m);

                    int isdone = 0;
                    int cnt = 0;
                    int z = 0;

                    ss = z;

                    while ( !isdone )
                    {
                        T dummy;

                        int noreps = 1;

                        for ( ii = 0 ; ( ii < m ) && noreps ; ++ii )
                        {
                            for ( jj = ii+1 ; ( jj < m ) && noreps ; ++jj )
                            {
                                if ( ss(ii) == ss(jj) )
                                {
                                    noreps = 0;
                                }
                            }
                        }

                        if ( noreps )
                        {
                            diffis = 0.0;

                            for ( ii = 0 ; ii < m ; ii += 2 )
                            {
                                diffis +=  ssxy(ss(ii  ),ss(ii  )) - ssxy(ss(ii  ),ss(ii+1));
                                diffis += -ssxy(ss(ii+1),ss(ii  )) + ssxy(ss(ii+1),ss(ii+1));
                            }

                            KKpro(tempres,xyprod,diffis,&(i("&",0)),locindstart,locindstart,xdim,m,dummy,&dummy);
                            xyprod += tempres;

                            ++cnt;
                        }

                        isdone = 1;
                        ii = 0;

                        while ( ( ii < m ) && isdone )
                        {
                            ++(ss("&",ii));

                            if ( ss(ii) < m )
                            {
                                isdone = 0;
                            }

                            else
                            {
                                ss("&",ii) = z;
                                ++ii;
                            }
                        }
                    }

                    xyprod /= cnt;
                }

                ++locindstart;
            }
        }

        else
        {
            // ( isFastKernelXfer() && !resmode )
            NiceAssert( !( resmode & 0x80 ) );

            int dummyind = 0;

            if ( pxyprod && pxyprod[0] )
            {
                xyprod = *pxyprod[0];
            }

            else
            {
                T zzz; zzz = 0.0;

                Vector<const T *> zq(m);

                kernel8xx(0,xyprod,dummyind,cType(0),zzz,zzz,zzz,x,xinfo,i,xdim,m,0,mlid);
            }

            if ( needxxprod && !justcalcip )
            {
                int ii;
                Vector<int> iii(x.size());

                retVector<const SparseVector<gentype> *> tmpva;
                retVector<const vecInfo *>               tmpvb;
                retVector<int>                           tmpvc;

                for ( ii = 0 ; ii < m ; ++ii )
                {
                    iii = ii;

                    T zzz; zzz = 0.0;

                    kernel8xx(0,xxprod("&",ii),dummyind,cType(0),zzz,zzz,zzz,x("&",iii,tmpva),xinfo("&",iii,tmpvb),i("&",iii,tmpvc),xdim,m,0,mlid);
                }
            }

            if ( pxyprod && pxyprod[1] )
            {
                diffis = *pxyprod[1];
            }

            else if ( ( size() >= 2 ) && needsDiff(1) && ( ( isAltDiff() <= 199 ) || ( isAltDiff() >= 300 ) ) && !justcalcip )
            {
                Matrix<double> altxy;

                Vector<T> xnormdex(x.size());
                Vector<const T *> xnormde(x.size());

                Vector<const SparseVector<gentype> *> xx(x.size());
                Vector<const vecInfo *> xxinfo(xinfo.size());
                Vector<int> iii(i.size());

                if ( needsMatDiff() )
                {
                    altxy.resize(m,m);
                }

                if ( m )
                {
                    int ii,jj;

                    for ( ii = 0 ; ii < m ; ++ii )
                    {
                        xx = x(ii);
                        xxinfo = xinfo(ii);
                        iii = i(ii);

                        if ( isAltDiff() == 0 )
                        {
                            T zzz; zzz = 0.0;

                            kernel8xx(0,xnormdex("&",ii),dummyind,cType(0),zzz,zzz,zzz,xx,xxinfo,iii,xdim,m,0,mlid);
                        }

                        else
                        {
                            T zzz; zzz = 0.0;

                            kernel8xx(0,xnormdex("&",ii),dummyind,cType(0),zzz,zzz,zzz,*x(ii),*x(ii),*xinfo(ii),*xinfo(ii),i(ii),i(ii),xdim,0,mlid);

                            if ( needsMatDiff() )
                            {
                                altxy("&",ii,ii) = xnormdex("&",ii);

                                if ( ii )
                                {
                                    for ( jj = 0 ; jj < ii ; ++jj )
                                    {
                                        if ( ii != jj )
                                        {
                                            if ( ( needsMatDiff() == +1 ) || ( ( jj == ii-1 ) && ( !(ii%2) ) ) )
                                            {
                                                kernel8xx(0,altxy("&",ii,jj),dummyind,cType(0),zzz,zzz,zzz,*x(ii),*x(jj),*xinfo(ii),*xinfo(jj),i(ii),i(jj),xdim,0,mlid);
                                                    altxy("&",jj,ii) = altxy("&",ii,jj);
                                                    setconj(altxy("&",jj,ii));
                                            }
                                        }
                                    }
                                }
                            }
                        }

                        xnormde("&",ii) = &(xnormdex(ii));
                    }
                }

                diffmnorm(m,diffis,xyprod,xnormde,altxy,s);

                diffis *= (const T &) cWeight(0);
            }

            else if ( needsDiff(0) && ( isAltDiff() >= 200 ) && ( isAltDiff() <= 299 ) && !justcalcip )
            {
                // At this point we need to calculate diffis using altdiffis method 2xx
                // xyprod is not used by kernel
                // we only need to cycle through diffis for relevant s vectors
                // We need the xy matrix to do this

                T tempres; tempres = 0.0;

                Matrix<double> altxy(m,m);
                Matrix<double> &ssxy = altxy;

                Vector<T> xnormdex(x.size());
                Vector<const T *> xnormde(x.size());

                Vector<const SparseVector<gentype> *> xx(x.size());
                Vector<const vecInfo *> xxinfo(xinfo.size());
                Vector<int> iii(i.size());

                if ( m )
                {
                    int ii,jj;
                    int dummyind = 0;

                    for ( ii = 0 ; ii < m ; ++ii )
                    {
                        xx = x(ii);
                        xxinfo = xinfo(ii);
                        iii = i(ii);

                        T zzz; zzz = 0.0;

                        kernel8xx(0,xnormdex("&",ii),dummyind,cType(0),zzz,zzz,zzz,*x(ii),*x(ii),*xinfo(ii),*xinfo(ii),i(ii),i(ii),xdim,0,mlid);

                        if ( needsMatDiff() )
                        {
                            altxy("&",ii,ii) = xnormdex("&",ii);

                            if ( ii )
                            {
                                for ( jj = 0 ; jj < ii ; ++jj )
                                {
                                    if ( ii != jj )
                                    {
                                        if ( ( needsMatDiff() == +1 ) || ( ( jj == ii-1 ) && ( !(ii%2) ) ) )
                                        {
                                            T zzz; zzz = 0.0;

                                            kernel8xx(0,altxy("&",ii,jj),dummyind,cType(0),zzz,zzz,zzz,*x(ii),*x(jj),*xinfo(ii),*xinfo(jj),i(ii),i(jj),xdim,0,mlid);
                                                altxy("&",jj,ii) = altxy("&",ii,jj);
                                                setconj(altxy("&",jj,ii));
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                xyprod = 0.0;

                if ( isAltDiff() == 203 )
                {
                    T dummy;

                    Vector<int> ss(m);
                    int isdone = 0;
                    int ii,jj;

                    ss = 1;

                    while ( !isdone )
                    {
                        if ( sum(ss)%4 == 0 )
                        {
                            diffis = 0.0;

                            for ( ii = 0 ; ii < m ; ++ii )
                            {
                                for ( jj = 0 ; jj < m ; ++jj )
                                {
                                    diffis += ss(ii)*ss(jj)*ssxy(ii,jj);
                                }
                            }

                            KKpro(tempres,xyprod,diffis,&(i("&",0)),locindstart,locindstart,xdim,m,dummy,&dummy);
                            xyprod += tempres;
                        }

                        isdone = 1;
                        ii = 0;

                        while ( ( ii < m ) && isdone )
                        {
                            if ( ss(ii) == 1 )
                            {
                                ss("&",ii) = -1;
                                isdone = 0;
                            }

                            else
                            {
                                ss("&",ii) = +1;
                                ++ii;
                            }
                        }
                    }

                    xyprod /= (1<<(m-1));
                }

                else if ( isAltDiff() == 204 )
                {
                    Vector<int> ss(m);
                    int isdone = 0;
                    int cnt = 0;
                    int z = 0;
                    int ii,jj;

                    ss = z;

                    while ( !isdone )
                    {
                        T dummy;

                        int noreps = 1;

                        for ( ii = 0 ; ( ii < m ) && noreps ; ++ii )
                        {
                            for ( jj = ii+1 ; ( jj < m ) && noreps ; ++jj )
                            {
                                if ( ss(ii) == ss(jj) )
                                {
                                    noreps = 0;
                                }
                            }
                        }

                        if ( noreps )
                        {
                            diffis = 0.0;

                            for ( ii = 0 ; ii < m ; ii += 2 )
                            {
                                diffis +=  ssxy(ss(ii  ),ss(ii  )) - ssxy(ss(ii  ),ss(ii+1));
                                diffis += -ssxy(ss(ii+1),ss(ii  )) + ssxy(ss(ii+1),ss(ii+1));
                            }

                            KKpro(tempres,xyprod,diffis,&(i("&",0)),locindstart,locindstart,xdim,m,dummy,&dummy);
                            xyprod += tempres;

                            ++cnt;
                        }

                        isdone = 1;
                        ii = 0;

                        while ( ( ii < m ) && isdone )
                        {
                            ++(ss("&",ii));

                            if ( ss(ii) < m )
                            {
                                isdone = 0;
                            }

                            else
                            {
                                ss("&",ii) = z;
                                ++ii;
                            }
                        }
                    }

                    xyprod /= cnt;
                }

                ++locindstart;
            }

            diffis *= (const T &) cWeight(0);
        }

        if ( justcalcip )
        {
            res = xyprod;
        }

        else
        {
            if ( isNormalised(locindend) )
            {
                T dummy;

                KKpro(res,xyprod,diffis,&(i("&",0)),locindstart,locindend,xdim,m,dummy,&dummy);

                T zerodiff; zerodiff = 0.0;
                int ii;
                Vector<int> iii(x.size());
                T xxres;
                T xxxres;

                int effeffm = 0;

                xxxres = 1.0;

                Vector<int> iw(m);

                for ( ii = 0 ; ii < m ; ++ii )
                {
                    iw = i(ii);

                    iii = ii;

                    KKpro(xxres,xxprod(ii),zerodiff,&(iw("&",0)),locindstart,locindend,xdim,m,dummy,&dummy);

                    if ( (double) abs2(xxres) > BADZEROTOL )
                    {
                        effeffm++;
                        xxxres *= xxres;
                    }

                    else
                    {
                        NiceThrow("LLm not defined for normalised zeros");
                    }
                }

                if ( ( effeffm == 0 ) || ( effeffm == 1 ) )
                {
                    res = angle(res);
                    res = ( (double) abs2(res) <= BADZEROTOL ) ? 1.0 : res;
                }

                else
                {
                    // We normalise in log-space to improve numerical stability

                    T sgnres = angle(res);

                    res = abs2(res);
                    OP_log(res);
                    res *= ((double) effeffm);
                    res -= log(xxxres);
                    res *= 1.0/((double) effeffm);
                    OP_exp(res);
                    res *= sgnres;
                }
            }

            else
            {
                T dummy;

                logresvalid = KKpro(res,xyprod,diffis,&(i("&",0)),locindstart,locindend,xdim,m,logres,&dummy);
            }
        }
    }

    else
    {
        NiceAssert( ismagterm == 0 );
        NiceAssert( ( isAltDiff() <= 199 ) || ( isAltDiff() >= 300 ) );

        gentype xyprod(0.0);

        if ( pxyprod && pxyprod[0] )
        {
            xyprod = *pxyprod[0];
        }

        else if ( needsInner(-1,m) )
        {
            // This may be used by some kernels and not others, so calculate anyhow

            mProductDiverted(m,xyprod,x,xconsist,assumreal);

            xyprod += bias;
        }

        Vector<const gentype *> xnormde(x.size());

        if ( m )
        {
            int ii;

            for ( ii = 0 ; ii < m ; ++ii )
            {
                xnormde("&",ii) = &getmnorm(*(xinfo(ii)),*(x(ii)),m,xconsist,assumreal);
            }
        }

        Matrix<double> altxy;

        gentype tempres;

        Kmi(tempres,xyprod,xinfo,xnormde,x,i,xdim,m,0,mlid,fillXYMatrix(m,altxy,x,xinfo,xy,0,assumreal),s,indstart,indend,assumreal);

        res = (T) tempres;
    }

    return res;

badout:
    // Design decision: in ml_base.cc, if d = 0 for one of the vectors
    // referenced here then this element will never be used.  Moreover there
    // are cases (eg isAltDiff set >1 with back-referenced data) where the
    // element is not properly defined but will never be used, so what we 
    // need to do is set it 0.  However having a "d = 0" catch will fail when
    // d starts non-zero, is set zero, then set non-zero, as will happen for
    // example when calculating LOO, n-fold error etc.  In such cases you need
    // to call a reset on that row/column, but you can't do that because (a) the
    // reset often calls setd (hence infinite recursion) or (b) there is an 
    // implicit assumption that Gp is independent of d (eg in semicopy functions
    // that retain the caches for speed in LOO, n-fold calculation).  Hence I've 
    // made the decision to return 0 here to avoid a whole stack of potential
    // coding complications at the price of possible silent failure if you set
    // somthing incorrectly.

    errstream() << "!!!modd!!!";

    res = 0.0;

    return res;
}



//int MercerKernel::Qqhim(int m, Vector<T> &res, const SparseVector<gentype> &xa, const vecInfo &xainfo, int ia, int allowfinite, int xdim, int xconsist, int assumreal, int gradOrder, int xagradup, int indstart, int indend) const
template <class T>
int MercerKernel::Qqhim(int m, Vector<T> &res, const SparseVector<gentype> &xa, const vecInfo &xainfo, int ia, int allowfinite, int xdim, int xconsist, int assumreal, int gradOrder, int xagradup, int indstart, int indend) const
{
    NiceAssert( ! ( isFastKernelSum() && ( isAltDiff() >= 200 ) && ( isAltDiff() <= 299 ) ) );
    NiceAssert( !isprod );
    NiceAssert( size() );
    NiceAssert( isFastKernelSum() );

    int dres = QQpro(m,res,xa,xainfo,ia,allowfinite,xdim,xconsist,assumreal,gradOrder,xagradup,indstart,indend);

    if ( isNormalised(indend) && ( m != -1 ) )
    {
        double resnorm = res.absp(m);

        if ( resnorm == 0.0 )
        {
            res = (T) std::pow((double) res.size(),-1.0/m);
        }

        else
        {
            res.scale(1.0/resnorm);
        }
    }

    return dres;
}











template <class T>
void MercerKernel::xdKK2(T &xygrad, T &xnormgrad, int &minmaxind, 
                         const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, 
                         const vecInfo &xainfo, const vecInfo &xbinfo, 
                         const T &bias, 
                         const gentype **pxyprod, 
                         int ia, int ib, 
                         int xdim, int xconsist, int assumreal, int mlid, 
                         const double *xy00, const double *xy10, const double *xy11, int deepDeriv, int iaset, int ibset) const
{
    // isfullnorm should happen here, but doesn't
    NiceAssert( !isfullnorm );

    dKK2(xygrad,xnormgrad,minmaxind,xa,xb,xainfo,xbinfo,bias,pxyprod,ia,ib,xdim,xconsist,assumreal,mlid,xy00,xy10,xy11,deepDeriv,iaset,ibset);
}

template <class T>
void MercerKernel::xd2KK2(T &xygrad, T &xnormgrad, T &xyxygrad, T &xyxnormgrad, T &xyynormgrad, T &xnormxnormgrad, T &xnormynormgrad, T &ynormynormgrad, int &minmaxind, 
                          const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, 
                          const vecInfo &xainfo, const vecInfo &xbinfo, 
                          const T &bias, 
                          const gentype **pxyprod, 
                          int ia, int ib, 
                          int xdim, int xconsist, int assumreal, int mlid, 
                          const double *xy00, const double *xy10, const double *xy11, int deepDeriv, int iaset, int ibset) const
{
    // isfullnorm should happen here, but doesn't
    NiceAssert( !isfullnorm );

    d2KK2(xygrad,xnormgrad,xyxygrad,xyxnormgrad,xyynormgrad,xnormxnormgrad,xnormynormgrad,ynormynormgrad,minmaxind,xa,xb,xainfo,xbinfo,bias,pxyprod,ia,ib,xdim,xconsist,assumreal,mlid,xy00,xy10,xy11,deepDeriv,iaset,ibset);
}

template <class T>
void MercerKernel::xdnKK2del(Vector<T> &sc, Vector<Vector<int> > &n, int &minmaxind, const Vector<int> &q, 
                             const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, 
                             const vecInfo &xainfo, const vecInfo &xbinfo, 
                             const T &bias, 
                             const gentype **pxyprod, 
                             int ia, int ib, 
                             int xdim, int xconsist, int assumreal, int mlid, 
                             const double *xy00, const double *xy10, const double *xy11, int deepDeriv, int iaset, int ibset) const
{
    // isfullnorm should happen here, but doesn't
    NiceAssert( !isfullnorm );

    dnKK2del(sc,n,minmaxind,q,xa,xb,xainfo,xbinfo,bias,pxyprod,ia,ib,xdim,xconsist,assumreal,mlid,xy00,xy10,xy11,deepDeriv,iaset,ibset);
}







//phantomx
template <class T>
void MercerKernel::dKK2(T &xygrad, T &xnormgrad, int &minmaxind,
                    const SparseVector<gentype> &xa, const SparseVector<gentype> &xb,
                    const vecInfo &xainfo, const vecInfo &xbinfo,
                    const T &bias,
                    const gentype **pxyprod,
                    int ia, int ib,
                    int xdim, int xconsist, int assumreal, int mlid, 
                    const double *xy00, const double *xy10, const double *xy11, int deepDeriv, 
                    int iaset, int ibset,
                    int skipbias,
                    int skipxa, int skipxb) const
{
    if ( !skipbias && isiteqn(bias) )
    {
        // We are dealing with distributions, so need to delay finalisation 
        // of random parts of the function and then average *outside* the loop
        //
        // See Muandet et al, Learning from Distributions via Support Measure Machines

        int qb;
        int maxq = numSamples();

        SparseVector<SparseVector<gentype> > subval;

        // Take maxq samples from output distribution

        for ( qb = 0 ; qb < maxq ; ++qb )
        {
            gentype gbias(bias);

            if ( !subSample(subval,gbias) && !qb )
            {
                goto postbias;
            }

            gentype gxygrad,gxnormgrad;

            dKK2(gxygrad,gxnormgrad,minmaxind,xa,xb,xainfo,xbinfo,gbias,nullptr,ia,ib,xdim,xconsist,assumreal,mlid,nullptr,nullptr,nullptr,deepDeriv,iaset,ibset,1,skipxa,skipxb);

            if ( !qb ) { xygrad =  (T) gxygrad; xnormgrad =  (T) gxnormgrad; }
            else       { xygrad += (T) gxygrad; xnormgrad += (T) gxnormgrad; }
        }

        xygrad    /= maxq;
        xnormgrad /= maxq;

        return;
    }

postbias:

    if ( !skipxa && xainfo.xiseqn() )
    {
        // We are dealing with distributions, so need to delay finalisation 
        // of random parts of the function and then average *outside* the loop
        //
        // See Muandet et al, Learning from Distributions via Support Measure Machines

        int qxa;
        int maxq = numSamples();

        gentype gbias(bias);

        SparseVector<SparseVector<gentype> > subval;

        T res; res = 0.0;
        int logresvalid = 1;

        // Take maxq samples from output distribution

        for ( qxa = 0 ; qxa < maxq ; ++qxa )
        {
            SparseVector<gentype> xxa(xa);
            vecInfo xxainfo;

            if ( !subSample(subval,xxa,xxainfo) && !qxa )
            {
                goto postxa;
            }

            gentype gres,glogres;

            KK2(0,0,gres,glogres,logresvalid,xxa,xb,xxainfo,xbinfo,0,0,xxa,xb,gbias,nullptr,ia,ib,xdim,xconsist,assumreal,0,mlid,nullptr,nullptr,nullptr,0,0,size()-1,iaset,ibset);

            gentype gxygrad,gxnormgrad;

            dKK2(gxygrad,gxnormgrad,minmaxind,xxa,xb,xxainfo,xbinfo,gbias,nullptr,ia,ib,xdim,xconsist,assumreal,mlid,nullptr,nullptr,nullptr,deepDeriv,iaset,ibset,skipbias,1,skipxb);

            if ( !qxa )                    { res =  (T) gres; xygrad =  (T) gxygrad; xnormgrad =  (T) gxnormgrad; }
            else if ( !iaset )             { res += (T) gres; xygrad += (T) gxygrad; xnormgrad += (T) gxnormgrad; }
            else if ( (T) gres > (T) res ) { res =  (T) gres; xygrad =  (T) gxygrad; xnormgrad =  (T) gxnormgrad; }
        }

        if ( !iaset )
        {
            xygrad    /= maxq;
            xnormgrad /= maxq;
        }

        return;
    }

postxa:

    if ( !skipxb && xbinfo.xiseqn() )
    {
        // We are dealing with distributions, so need to delay finalisation 
        // of random parts of the function and then average *outside* the loop
        //
        // See Muandet et al, Learning from Distributions via Support Measure Machines

        int qxa;
        int maxq = numSamples();

        gentype gbias(bias);

        SparseVector<SparseVector<gentype> > subval;

        T res; res = 0.0;
        int logresvalid = 1;

        // Take maxq samples from output distribution

        for ( qxa = 0 ; qxa < maxq ; ++qxa )
        {
            SparseVector<gentype> xxb(xb);
            vecInfo xxbinfo;

            if ( !subSample(subval,xxb,xxbinfo) && !qxa )
            {
                goto postxb;
            }

            gentype gres,glogres;

            KK2(0,0,gres,glogres,logresvalid,xa,xxb,xainfo,xxbinfo,0,0,xa,xxb,gbias,nullptr,ia,ib,xdim,xconsist,assumreal,0,mlid,nullptr,nullptr,nullptr,0,0,size()-1,iaset,ibset);

            gentype gxygrad,gxnormgrad;

            dKK2(gxygrad,gxnormgrad,minmaxind,xa,xxb,xainfo,xxbinfo,gbias,nullptr,ia,ib,xdim,xconsist,assumreal,mlid,nullptr,nullptr,nullptr,deepDeriv,iaset,ibset,skipbias,skipxa,1);

            if ( !qxa )                    { res =  (T) gres; xygrad =  (T) gxygrad; xnormgrad =  (T) gxnormgrad; }
            else if ( !ibset )             { res += (T) gres; xygrad += (T) gxygrad; xnormgrad += (T) gxnormgrad; }
            else if ( (T) gres > (T) res ) { res =  (T) gres; xygrad =  (T) gxygrad; xnormgrad =  (T) gxnormgrad; }
        }

        if ( !ibset )
        {
            xygrad    /= maxq;
            xnormgrad /= maxq;
        }

        return;
    }

postxb:

    dLL2(xygrad,xnormgrad,minmaxind,xa,xb,xainfo,xbinfo,bias,pxyprod,ia,ib,xdim,xconsist,assumreal,mlid,xy00,xy10,xy11,deepDeriv);
}

//phantomx
template <class T>
void MercerKernel::d2KK2(T &xygrad, T &xnormgrad, T &xyxygrad, T &xyxnormgrad, T &xyynormgrad, T &xnormxnormgrad, T &xnormynormgrad, T &ynormynormgrad, int &minmaxind, 
                    const SparseVector<gentype> &xa, const SparseVector<gentype> &xb,
                    const vecInfo &xainfo, const vecInfo &xbinfo,
                    const T &bias,
                    const gentype **pxyprod,
                    int ia, int ib,
                    int xdim, int xconsist, int assumreal, int mlid, 
                    const double *xy00, const double *xy10, const double *xy11, int deepDeriv, 
                    int iaset, int ibset,
                    int skipbias,
                    int skipxa, int skipxb) const
{
    if ( !skipbias && isiteqn(bias) )
    {
        // We are dealing with distributions, so need to delay finalisation 
        // of random parts of the function and then average *outside* the loop
        //
        // See Muandet et al, Learning from Distributions via Support Measure Machines

        int qb;
        int maxq = numSamples();

        SparseVector<SparseVector<gentype> > subval;

        // Take maxq samples from output distribution

        for ( qb = 0 ; qb < maxq ; ++qb )
        {
            gentype gbias(bias);

            if ( !subSample(subval,gbias) && !qb )
            {
                goto postbias;
            }

            gentype tempxygrad;
            gentype tempxnormgrad;
            gentype tempxyxygrad;
            gentype tempxyxnormgrad;
            gentype tempxyynormgrad;
            gentype tempxnormxnormgrad;
            gentype tempxnormynormgrad;
            gentype tempynormynormgrad;

            d2KK2(tempxygrad,tempxnormgrad,tempxyxygrad,tempxyxnormgrad,tempxyynormgrad,tempxnormxnormgrad,tempxnormynormgrad,tempynormynormgrad,minmaxind,xa,xb,xainfo,xbinfo,gbias,pxyprod,ia,ib,xdim,xconsist,assumreal,mlid,nullptr,nullptr,nullptr,deepDeriv,iaset,ibset,1,skipxa,skipxb);

            if ( !qb )
            {
                xygrad         = (T) tempxygrad;
                xnormgrad      = (T) tempxnormgrad;
                xyxygrad       = (T) tempxyxygrad;
                xyxnormgrad    = (T) tempxyxnormgrad;
                xyynormgrad    = (T) tempxyynormgrad;
                xnormxnormgrad = (T) tempxnormxnormgrad;
                xnormynormgrad = (T) tempxnormynormgrad;
                ynormynormgrad = (T) tempynormynormgrad;
            }

            else
            {
                xygrad         += (T) tempxygrad;
                xnormgrad      += (T) tempxnormgrad;
                xyxygrad       += (T) tempxyxygrad;
                xyxnormgrad    += (T) tempxyxnormgrad;
                xyynormgrad    += (T) tempxyynormgrad;
                xnormxnormgrad += (T) tempxnormxnormgrad;
                xnormynormgrad += (T) tempxnormynormgrad;
                ynormynormgrad += (T) tempynormynormgrad;
            }
        }

        xygrad         /= maxq;
        xnormgrad      /= maxq;
        xyxygrad       /= maxq;
        xyxnormgrad    /= maxq;
        xyynormgrad    /= maxq;
        xnormxnormgrad /= maxq;
        xnormynormgrad /= maxq;
        ynormynormgrad /= maxq;

        return;
    }

postbias:

    if ( !skipxa && xainfo.xiseqn() )
    {
        // We are dealing with distributions, so need to delay finalisation 
        // of random parts of the function and then average *outside* the loop
        //
        // See Muandet et al, Learning from Distributions via Support Measure Machines

        int qxa;
        int maxq = numSamples();

        gentype gbias(bias);

        SparseVector<SparseVector<gentype> > subval;

        T res; res = 0.0;
        int logresvalid = 1;

        // Take maxq samples from output distribution

        for ( qxa = 0 ; qxa < maxq ; ++qxa )
        {
            SparseVector<gentype> xxa(xa);
            vecInfo xxainfo;

            if ( !subSample(subval,xxa,xxainfo) && !qxa )
            {
                goto postxa;
            }

            gentype gres,glogres;

            KK2(0,0,gres,glogres,logresvalid,xxa,xb,xxainfo,xbinfo,0,0,xxa,xb,gbias,nullptr,ia,ib,xdim,xconsist,assumreal,0,mlid,nullptr,nullptr,nullptr,0,0,size()-1,iaset,ibset);

            gentype tempxygrad;
            gentype tempxnormgrad;
            gentype tempxyxygrad;
            gentype tempxyxnormgrad;
            gentype tempxyynormgrad;
            gentype tempxnormxnormgrad;
            gentype tempxnormynormgrad;
            gentype tempynormynormgrad;

            d2KK2(tempxygrad,tempxnormgrad,tempxyxygrad,tempxyxnormgrad,tempxyynormgrad,tempxnormxnormgrad,tempxnormynormgrad,tempynormynormgrad,minmaxind,xxa,xb,xxainfo,xbinfo,gbias,pxyprod,ia,ib,xdim,xconsist,assumreal,mlid,nullptr,nullptr,nullptr,deepDeriv,iaset,ibset,skipbias,1,skipxb);

            if ( !qxa )
            {
                res            = (T) gres;
                xygrad         = (T) tempxygrad;
                xnormgrad      = (T) tempxnormgrad;
                xyxygrad       = (T) tempxyxygrad;
                xyxnormgrad    = (T) tempxyxnormgrad;
                xyynormgrad    = (T) tempxyynormgrad;
                xnormxnormgrad = (T) tempxnormxnormgrad;
                xnormynormgrad = (T) tempxnormynormgrad;
                ynormynormgrad = (T) tempynormynormgrad;
            }

            else if ( !iaset )
            {
                res            += (T) gres;
                xygrad         += (T) tempxygrad;
                xnormgrad      += (T) tempxnormgrad;
                xyxygrad       += (T) tempxyxygrad;
                xyxnormgrad    += (T) tempxyxnormgrad;
                xyynormgrad    += (T) tempxyynormgrad;
                xnormxnormgrad += (T) tempxnormxnormgrad;
                xnormynormgrad += (T) tempxnormynormgrad;
                ynormynormgrad += (T) tempynormynormgrad;
            }

            else if ( (T) gres > (T) res )
            {
                res            = (T) gres;
                xygrad         = (T) tempxygrad;
                xnormgrad      = (T) tempxnormgrad;
                xyxygrad       = (T) tempxyxygrad;
                xyxnormgrad    = (T) tempxyxnormgrad;
                xyynormgrad    = (T) tempxyynormgrad;
                xnormxnormgrad = (T) tempxnormxnormgrad;
                xnormynormgrad = (T) tempxnormynormgrad;
                ynormynormgrad = (T) tempynormynormgrad;
            }
        }

        if ( !iaset )
        {
            xygrad         /= maxq;
            xnormgrad      /= maxq;
            xyxygrad       /= maxq;
            xyxnormgrad    /= maxq;
            xyynormgrad    /= maxq;
            xnormxnormgrad /= maxq;
            xnormynormgrad /= maxq;
            ynormynormgrad /= maxq;
        }

        return;
    }

postxa:

    if ( !skipxb && xbinfo.xiseqn() )
    {
        // We are dealing with distributions, so need to delay finalisation 
        // of random parts of the function and then average *outside* the loop
        //
        // See Muandet et al, Learning from Distributions via Support Measure Machines

        int qxa;
        int maxq = numSamples();

        gentype gbias(bias);

        SparseVector<SparseVector<gentype> > subval;

        T res; res = 0.0;
        int logresvalid = 1;

        // Take maxq samples from output distribution

        for ( qxa = 0 ; qxa < maxq ; ++qxa )
        {
            SparseVector<gentype> xxb(xb);
            vecInfo xxbinfo;

            if ( !subSample(subval,xxb,xxbinfo) && !qxa )
            {
                goto postxb;
            }

            gentype gres,glogres;

            KK2(0,0,gres,glogres,logresvalid,xa,xxb,xainfo,xxbinfo,0,0,xa,xxb,gbias,nullptr,ia,ib,xdim,xconsist,assumreal,0,mlid,nullptr,nullptr,nullptr,0,0,size()-1,iaset,ibset);

            gentype tempxygrad;
            gentype tempxnormgrad;
            gentype tempxyxygrad;
            gentype tempxyxnormgrad;
            gentype tempxyynormgrad;
            gentype tempxnormxnormgrad;
            gentype tempxnormynormgrad;
            gentype tempynormynormgrad;

            d2KK2(tempxygrad,tempxnormgrad,tempxyxygrad,tempxyxnormgrad,tempxyynormgrad,tempxnormxnormgrad,tempxnormynormgrad,tempynormynormgrad,minmaxind,xa,xxb,xainfo,xxbinfo,gbias,pxyprod,ia,ib,xdim,xconsist,assumreal,mlid,nullptr,nullptr,nullptr,deepDeriv,iaset,ibset,skipbias,skipxa,1);

            if ( !qxa )
            {
                res            = (T) gres;
                xygrad         = (T) tempxygrad;
                xnormgrad      = (T) tempxnormgrad;
                xyxygrad       = (T) tempxyxygrad;
                xyxnormgrad    = (T) tempxyxnormgrad;
                xyynormgrad    = (T) tempxyynormgrad;
                xnormxnormgrad = (T) tempxnormxnormgrad;
                xnormynormgrad = (T) tempxnormynormgrad;
                ynormynormgrad = (T) tempynormynormgrad;
            }

            else if ( !ibset )
            {
                res            += (T) gres;
                xygrad         += (T) tempxygrad;
                xnormgrad      += (T) tempxnormgrad;
                xyxygrad       += (T) tempxyxygrad;
                xyxnormgrad    += (T) tempxyxnormgrad;
                xyynormgrad    += (T) tempxyynormgrad;
                xnormxnormgrad += (T) tempxnormxnormgrad;
                xnormynormgrad += (T) tempxnormynormgrad;
                ynormynormgrad += (T) tempynormynormgrad;
            }

            else if ( (T) gres > (T) res )
            {
                res            = (T) gres;
                xygrad         = (T) tempxygrad;
                xnormgrad      = (T) tempxnormgrad;
                xyxygrad       = (T) tempxyxygrad;
                xyxnormgrad    = (T) tempxyxnormgrad;
                xyynormgrad    = (T) tempxyynormgrad;
                xnormxnormgrad = (T) tempxnormxnormgrad;
                xnormynormgrad = (T) tempxnormynormgrad;
                ynormynormgrad = (T) tempynormynormgrad;
            }
        }

        if ( !ibset )
        {
            xygrad         /= maxq;
            xnormgrad      /= maxq;
            xyxygrad       /= maxq;
            xyxnormgrad    /= maxq;
            xyynormgrad    /= maxq;
            xnormxnormgrad /= maxq;
            xnormynormgrad /= maxq;
            ynormynormgrad /= maxq;
        }

        return;
    }

postxb:

    d2LL2(xygrad,xnormgrad,xyxygrad,xyxnormgrad,xyynormgrad,xnormxnormgrad,xnormynormgrad,ynormynormgrad,minmaxind,xa,xb,xainfo,xbinfo,bias,pxyprod,ia,ib,xdim,xconsist,assumreal,mlid,xy00,xy10,xy11,deepDeriv);
}

template <class T>
void MercerKernel::dnKK2del(Vector<T> &sc, Vector<Vector<int> > &nn, int &minmaxind, 
                           const Vector<int> &qq, 
                           const SparseVector<gentype> &xa, const SparseVector<gentype> &xb, 
                           const vecInfo &xainfo, const vecInfo &xbinfo, 
                           const T &bias, const gentype **pxyprod, 
                           int ia, int ib, 
                           int xdim, int xconsist, int assumreal, int mlid, 
                           const double *xy00, const double *xy10, const double *xy11, int deepDeriv,
                           int iaset, int ibset,
                           int skipbias,
                           int skipxa, int skipxb) const
{
    int t;

    if ( !skipbias && isiteqn(bias) )
    {
        // We are dealing with distributions, so need to delay finalisation 
        // of random parts of the function and then average *outside* the loop
        //
        // See Muandet et al, Learning from Distributions via Support Measure Machines

        int qb;
        int maxq = numSamples();

        SparseVector<SparseVector<gentype> > subval;

        // Take maxq samples from output distribution

        for ( qb = 0 ; qb < maxq ; ++qb )
        {
            gentype gbias(bias);

            if ( !subSample(subval,gbias) && !qb )
            {
                goto postbias;
            }

            Vector<gentype> tempsc(sc.size());

            dnKK2del(tempsc,nn,minmaxind,qq,xa,xb,xainfo,xbinfo,gbias,pxyprod,ia,ib,xdim,xconsist,assumreal,mlid,xy00,xy10,xy11,deepDeriv,iaset,ibset,1,skipxa,skipxb);

            if ( !qb )
            {
                sc.resize(tempsc.size());

                for ( t = 0 ; t < sc.size() ; ++t )
                {
                    sc("&",t) = (T) tempsc(t);
                }
            }

            else
            {
                for ( t = 0 ; t < sc.size() ; ++t )
                {
                    sc("&",t) += (T) tempsc(t);
                }
            }
        }

        for ( t = 0 ; t < sc.size() ; ++t )
        {
            sc("&",t) /= maxq;
        }

        return;
    }

postbias:

    if ( !skipxa && xainfo.xiseqn() )
    {
        // We are dealing with distributions, so need to delay finalisation 
        // of random parts of the function and then average *outside* the loop
        //
        // See Muandet et al, Learning from Distributions via Support Measure Machines

        int qxa;
        int maxq = numSamples();

        gentype gbias(bias);

        SparseVector<SparseVector<gentype> > subval;

        T res; res = 0.0;
        int logresvalid = 1;

        // Take maxq samples from output distribution

        for ( qxa = 0 ; qxa < maxq ; ++qxa )
        {
            SparseVector<gentype> xxa(xa);
            vecInfo xxainfo;

            if ( !subSample(subval,xxa,xxainfo) && !qxa )
            {
                goto postxa;
            }

            gentype gres,glogres;

            KK2(0,0,gres,glogres,logresvalid,xxa,xb,xxainfo,xbinfo,0,0,xxa,xb,gbias,nullptr,ia,ib,xdim,xconsist,assumreal,0,mlid,nullptr,nullptr,nullptr,0,0,size()-1,iaset,ibset);

            Vector<gentype> tempsc(sc.size());

            dnKK2del(tempsc,nn,minmaxind,qq,xxa,xb,xxainfo,xbinfo,gbias,pxyprod,ia,ib,xdim,xconsist,assumreal,mlid,xy00,xy10,xy11,deepDeriv,iaset,ibset,skipbias,1,skipxb);

            if ( !qxa )
            {
                res = (T) gres;

                sc.resize(tempsc.size());

                for ( t = 0 ; t < sc.size() ; ++t )
                {
                    sc("&",t) = (T) tempsc(t);
                }
            }

            else if ( !iaset )
            {
                res += (T) gres;

                for ( t = 0 ; t < sc.size() ; ++t )
                {
                    sc("&",t) += (T) tempsc(t);
                }
            }

            else if ( (T) gres > (T) res )
            {
                res = (T) gres;

                for ( t = 0 ; t < sc.size() ; ++t )
                {
                    sc("&",t) = (T) tempsc(t);
                }
            }
        }

        if ( !iaset )
        {
            for ( t = 0 ; t < sc.size() ; ++t )
            {
                sc("&",t) /= maxq;
            }
        }

        return;
    }

postxa:

    if ( !skipxb && xbinfo.xiseqn() )
    {
        // We are dealing with distributions, so need to delay finalisation 
        // of random parts of the function and then average *outside* the loop
        //
        // See Muandet et al, Learning from Distributions via Support Measure Machines

        int qxa;
        int maxq = numSamples();

        gentype gbias(bias);

        SparseVector<SparseVector<gentype> > subval;

        T res; res = 0.0;
        int logresvalid = 1;

        // Take maxq samples from output distribution

        for ( qxa = 0 ; qxa < maxq ; ++qxa )
        {
            SparseVector<gentype> xxb(xb);
            vecInfo xxbinfo;

            if ( !subSample(subval,xxb,xxbinfo) && !qxa )
            {
                goto postxb;
            }

            gentype gres,glogres;

            KK2(0,0,gres,glogres,logresvalid,xa,xxb,xainfo,xxbinfo,0,0,xa,xxb,gbias,nullptr,ia,ib,xdim,xconsist,assumreal,0,mlid,nullptr,nullptr,nullptr,0,0,size()-1,iaset,ibset);

            Vector<gentype> tempsc(sc.size());

            dnKK2del(tempsc,nn,minmaxind,qq,xa,xxb,xainfo,xxbinfo,gbias,pxyprod,ia,ib,xdim,xconsist,assumreal,mlid,xy00,xy10,xy11,deepDeriv,iaset,ibset,skipbias,skipxa,1);

            if ( !qxa )
            {
                res = (T) gres;

                sc.resize(tempsc.size());

                for ( t = 0 ; t < sc.size() ; ++t )
                {
                    sc("&",t) = (T) tempsc(t);
                }
            }

            else if ( !ibset )
            {
                res += (T) gres;
 
                for ( t = 0 ; t < sc.size() ; ++t )
                {
                    sc("&",t) += (T) tempsc(t);
                }
            }

            else if ( (T) gres > (T) res )
            {
                res = (T) gres;

                for ( t = 0 ; t < sc.size() ; ++t )
                {
                    sc("&",t) = (T) tempsc(t);
                }
            }
        }

        if ( !ibset )
        {
            for ( t = 0 ; t < sc.size() ; ++t )
            {
                sc("&",t) /= maxq;
            }
        }

        return;
    }

postxb:

    dnLL2del(sc,nn,minmaxind,qq,xa,xb,xainfo,xbinfo,bias,pxyprod,ia,ib,xdim,xconsist,assumreal,mlid,xy00,xy10,xy11,deepDeriv);
}
















//phantomx
template <class T>
void MercerKernel::dLL2(T &xygrad, T &xnormgrad, int &minmaxind,
                    const SparseVector<gentype> &x, const SparseVector<gentype> &y,
                    const vecInfo &xinfo, const vecInfo &yinfo,
                    const T &bias,
                    const gentype **pxyprod,
                    int i, int j,
                    int xdim, int xconsist, int assumreal, int mlid, 
                    const double *xy00, const double *xy10, const double *xy11, int deepDeriv) const
{
    T res;

    NiceAssert( !( isFastKernelSum() && ( isAltDiff() >= 200 ) && ( isAltDiff() <= 299 ) ) );
    NiceAssert( !( isprod && !arexysimple(x,y) ) );

    minmaxind = -1;

    if ( isFastKernelSum() || isFastKernelChain() )
    {
        int needxxprod = isNormalised() || needsNorm();

        T xyprod; xyprod = 0.0;
        T yxprod; yxprod = 0.0;

        T xxprod; xxprod = 0.0;
        T yyprod; yyprod = 0.0;

        T diffis; diffis = 0.0;

        if ( xy10 )
        {
            xyprod = (*xy10);
            yxprod = (*xy10);

            xyprod += bias;
            yxprod += bias;
        }

        else if ( pxyprod && pxyprod[0] )
        {
            xyprod = *pxyprod[0];
            yxprod = xyprod;
        }

        else if ( needsInner(0,2) || ( isFastKernelSum() && needsInner(-1,2) ) )
        {
            innerProductDiverted(xyprod,x,y,xconsist,assumreal);
            innerProductDivertedRevConj(yxprod,xyprod,x,y,xconsist,assumreal);

            xyprod += bias;
            yxprod += bias;
        }

        xyprod += yxprod;
        xyprod *= 0.5;

        if ( needxxprod )
        {
            if ( xy00 && xy11 )
            {
                xxprod = (*xy00);
                yyprod = (*xy11);

                xxprod += bias;
                yyprod += bias;
            }

            else
            {
                innerProductDiverted(xxprod,x,x,xconsist,assumreal);
                innerProductDiverted(yyprod,y,y,xconsist,assumreal);

                xxprod += bias;
                yyprod += bias;
            }
        }

        if ( ( needsDiff(0) || ( isFastKernelSum() && needsDiff() ) ) )
        {
            if ( xy00 && xy11 )
            {
                diff2norm(diffis,(double) xyprod,(*xy00),(*xy11));
            }

            else if ( pxyprod && pxyprod[1] )
            {
                diffis = *pxyprod[1];
            }

            else
            {
                // Calculate ||x-y||^2 only as required

                if ( assumreal )
                {
                    diff2norm(diffis,(double) xyprod,(double) getmnorm(xinfo,x,2,xconsist,assumreal),(double) getmnorm(yinfo,y,2,xconsist,assumreal));
                }

                else
                {
                    diff2norm(diffis,(xyprod+yxprod)/2.0,getmnorm(xinfo,x,2,xconsist,assumreal),getmnorm(yinfo,y,2,xconsist,assumreal));
                }
            }
        }

        dKKpro(xygrad,xnormgrad,res,xyprod,diffis,i,j,0,size()-1,xdim,2,xxprod,yyprod);
    }

    else if ( isFastKernelXfer() )
    {
        NiceAssert( ismagterm == 0 );

        T xyprod; xyprod = 0.0;
        T yxprod; yxprod = 0.0;
        T diffis; diffis = 0.0;

        if ( ( !( size() >= 2 ) || !needsDiff(1) ) && deepDeriv )
        {
            T zzz; zzz = 0.0;

            dkernel8xx(0,xygrad,xnormgrad,xyprod,minmaxind,cType(0),zzz,zzz,zzz,x,y,xinfo,yinfo,i,j,xdim,48,mlid);

            xyprod *= (const T &) cWeight(0);

            xygrad    *= (const T &) cWeight(0);
            xnormgrad *= (const T &) cWeight(0);

            T dxyprod; dxyprod = 0.0;
            T dxnorm;  dxnorm  = 0.0;

            T dummy;

            dKKpro(dxyprod,dxnorm,res,xyprod,diffis,i,j,1,size()-1,xdim,2,dummy,dummy);

            xygrad    *= dxyprod;
            xnormgrad *= dxyprod;
        }

        else if ( ( !( size() >= 2 ) || !needsDiff(1) ) && !deepDeriv )
        {
            int dummyind = 0;

            if ( xy10 )
            {
                xyprod = (*xy10);
                yxprod = (*xy10);

                xyprod += bias;
                yxprod += bias;
            }

            else if ( pxyprod && pxyprod[0] )
            {
                xyprod = *pxyprod[0];
                yxprod = xyprod;
            }

            else
            {
                T zzz; zzz = 0.0;

                kernel8xx(0,xyprod,dummyind,cType(0),zzz,zzz,zzz,x,y,xinfo,yinfo,i,j,xdim,0,mlid);

                xyprod += bias;
                yxprod  = xyprod;
            }

            xyprod += yxprod;
            xyprod *= 0.5;

            xyprod *= (const T &) cWeight(0);

            T dummy;

            dKKpro(xygrad,xnormgrad,res,xyprod,diffis,i,j,1,size()-1,xdim,2,dummy,dummy);
        }

        else if ( ( size() >= 2 ) && needsDiff(1) && deepDeriv )
        {
            T sxygrad;    sxygrad    = 0.0;
            T sxnormgrad; sxnormgrad = 0.0;

            T zzz; zzz = 0.0;

            dkernel8xx(0,sxygrad,sxnormgrad,xyprod,minmaxind,cType(0),zzz,zzz,zzz,x,y,xinfo,yinfo,i,j,xdim,48,mlid);

            xyprod *= (const T &) cWeight(0);

            xygrad    *= (const T &) cWeight(0);
            xnormgrad *= (const T &) cWeight(0);

            T xnorm;
            T ynorm;

            T dxxgrad; dxxgrad = 0.0;
            T dyygrad; dyygrad = 0.0;

            T dxnormgrad; dxnormgrad = 0.0;
            T dynormgrad; dynormgrad = 0.0;

            dkernel8xx(0,dxxgrad,dxnormgrad,xnorm,minmaxind,cType(0),zzz,zzz,zzz,x,x,xinfo,xinfo,i,i,xdim,48,mlid);
            dkernel8xx(0,dyygrad,dynormgrad,ynorm,minmaxind,cType(0),zzz,zzz,zzz,y,y,yinfo,yinfo,j,j,xdim,48,mlid);

            diff2norm(diffis,xyprod,xnorm,ynorm);

            diffis *= (const T &) cWeight(0);

            dxxgrad *= (const T &) cWeight(0);
            dyygrad *= (const T &) cWeight(0);

            dxnormgrad *= (const T &) cWeight(0);
            dynormgrad *= (const T &) cWeight(0);

            T dxyprod; dxyprod = 0.0;
            T dxnorm;  dxnorm  = 0.0;

            T dummy;

            dKKpro(dxyprod,dxnorm,res,xyprod,diffis,i,j,1,size()-1,xdim,2,dummy,dummy);

            xygrad = dxyprod*sxygrad;

            xnormgrad  = dxyprod*sxnormgrad;
            xnormgrad += dxnorm*dxxgrad;
            xnormgrad += dxnorm*dxnormgrad;
            xnormgrad += dxnorm*dxnormgrad;
        }

        else
        {
            int dummyind = 0;

            if ( xy10 )
            {
                xyprod = (*xy10);
                yxprod = (*xy10);

                xyprod += bias;
                yxprod += bias;
            }

            else if ( pxyprod && pxyprod[0] )
            {
                xyprod = *pxyprod[0];
                yxprod = xyprod;
            }

            else
            {
                T zzz; zzz = 0.0;

                kernel8xx(0,xyprod,dummyind,cType(0),zzz,zzz,zzz,x,y,xinfo,yinfo,i,j,xdim,0,mlid);

                xyprod += bias;
                yxprod  = xyprod;
            }

            xyprod += yxprod;
            xyprod *= 0.5;

            if ( xy00 && xy11 )
            {
                diff2norm(diffis,(double) xyprod,(*xy00),(*xy11));
            }

            else if ( pxyprod && pxyprod[1] )
            {
                diffis = *pxyprod[1];
            }

            else
            {
                T xnorm; xnorm = 0.0;
                T ynorm; ynorm = 0.0;

                int dummyind;

                T zzz; zzz = 0.0;

                kernel8xx(0,xnorm,dummyind,cType(0),zzz,zzz,zzz,x,x,xinfo,xinfo,i,i,xdim,0,mlid);
                kernel8xx(0,ynorm,dummyind,cType(0),zzz,zzz,zzz,y,y,yinfo,yinfo,j,j,xdim,0,mlid);

                if ( assumreal )
                {
                    diff2norm(diffis,(double) xyprod,(double) xnorm,(double) ynorm);
                }

                else
                {
                    diff2norm(diffis,(xyprod+yxprod)/2.0,xnorm,ynorm);
                }
            }

            xyprod *= (const T &) cWeight(0);
            diffis *= (const T &) cWeight(0);

            T dummy;

            dKKpro(xygrad,xnormgrad,res,xyprod,diffis,i,j,1,size()-1,xdim,2,dummy,dummy);
        }
    }

    else
    {
        NiceAssert( ismagterm == 0 );

        NiceAssert( deepDeriv );
        NiceAssert( ( isAltDiff() <= 199 ) || ( isAltDiff() >= 300 ) );

        gentype xyprod; xyprod = 0.0;
        gentype yxprod; yxprod = 0.0;

        gentype xnorm; xnorm = 0.0;
        gentype ynorm; ynorm = 0.0;

        if ( xy10 && xy00 && xy11 )
        {
            xyprod = (*xy10);
            yxprod = (*xy10);

            xyprod += bias;
            yxprod += bias;

            xnorm = (*xy00);
            ynorm = (*xy11);
        }

        else if ( pxyprod && pxyprod[0] )
        {
            xyprod = *pxyprod[0];
            yxprod = xyprod;

            xnorm = getmnorm(xinfo,x,2,xconsist,assumreal);
            ynorm = getmnorm(yinfo,y,2,xconsist,assumreal);
        }

        else if ( needsInner(-1,2) )
        {
            // This may be used by some kernels and not others, so calculate anyhow

            innerProductDiverted(xyprod,x,y,xconsist,assumreal);
            innerProductDivertedRevConj(yxprod,xyprod,x,y,xconsist,assumreal);

            xyprod += bias;
            yxprod += bias;

            xnorm = getmnorm(xinfo,x,2,xconsist,assumreal);
            ynorm = getmnorm(yinfo,y,2,xconsist,assumreal);
        }

        else
        {
            xnorm = getmnorm(xinfo,x,2,xconsist,assumreal);
            ynorm = getmnorm(yinfo,y,2,xconsist,assumreal);
        }

        gentype tempres;
        gentype tempxygrad;
        gentype tempxnormgrad;

        dKdaz(tempxnormgrad,tempxygrad,minmaxind,xyprod,yxprod,xinfo,yinfo,xnorm,ynorm,x,y,i,j,xdim,mlid,assumreal);

        xygrad    = (T) tempxygrad;
        xnormgrad = (T) tempxnormgrad;
    }
}






//phantomx
template <class T>
void MercerKernel::d2LL2(T &xygrad, T &xnormgrad, T &xyxygrad, T &xyxnormgrad, T &xyynormgrad, T &xnormxnormgrad, T &xnormynormgrad, T &ynormynormgrad, int &minmaxind, 
                    const SparseVector<gentype> &x, const SparseVector<gentype> &y,
                    const vecInfo &xinfo, const vecInfo &yinfo,
                    const T &bias,
                    const gentype **pxyprod,
                    int i, int j,
                    int xdim, int xconsist, int assumreal, int mlid, 
                    const double *xy00, const double *xy10, const double *xy11, int deepDeriv) const
{
    T res;

    NiceAssert( !( isFastKernelSum() && ( isAltDiff() >= 200 ) && ( isAltDiff() <= 299 ) ) );
    NiceAssert( !( isprod && !arexysimple(x,y) ) );

    minmaxind = -1;

    if ( isFastKernelSum() || isFastKernelChain() )
    {
        int needxxprod = isNormalised() || needsNorm();

        T xyprod; xyprod = 0.0;
        T yxprod; yxprod = 0.0;

        T xxprod; xxprod = 0.0;
        T yyprod; yyprod = 0.0;

        T diffis; diffis = 0.0;

        if ( xy10 )
        {
            xyprod = (*xy10);
            yxprod = (*xy10);

            xyprod += bias;
            yxprod += bias;
        }

        else if ( pxyprod && pxyprod[0] )
        {
            xyprod = *pxyprod[0];
            yxprod = xyprod;
        }

        else if ( needsInner(0,2) || ( isFastKernelSum() && needsInner(-1,2) ) )
        {
            innerProductDiverted(xyprod,x,y,xconsist,assumreal);
            innerProductDivertedRevConj(yxprod,xyprod,x,y,xconsist,assumreal);

            xyprod += bias;
            yxprod += bias;
        }

        xyprod += yxprod;
        xyprod *= 0.5;

        if ( needxxprod )
        {
            if ( xy00 && xy11 )
            {
                xxprod = (*xy00);
                yyprod = (*xy11);

                xxprod += bias;
                yyprod += bias;
            }

            else
            {
                innerProductDiverted(xxprod,x,x,xconsist,assumreal);
                innerProductDiverted(yyprod,y,y,xconsist,assumreal);

                xxprod += bias;
                yyprod += bias;
            }
        }

        if ( ( needsDiff(0) || ( isFastKernelSum() && needsDiff() ) ) )
        {
            if ( xy00 && xy11 )
            {
                diff2norm(diffis,(double) xyprod,(*xy00),(*xy11));
            }

            else if ( pxyprod && pxyprod[1] )
            {
                diffis = *pxyprod[1];
            }

            else
            {
                // Calculate ||x-y||^2 only as required

                if ( assumreal )
                {
                    diff2norm(diffis,(double) xyprod,(double) getmnorm(xinfo,x,2,xconsist,assumreal),(double) getmnorm(yinfo,y,2,xconsist,assumreal));
                }

                else
                {
                    diff2norm(diffis,(xyprod+yxprod)/2.0,getmnorm(xinfo,x,2,xconsist,assumreal),getmnorm(yinfo,y,2,xconsist,assumreal));
                }
            }
        }

        d2KKpro(xygrad,xnormgrad,xyxygrad,xyxnormgrad,xyynormgrad,xnormxnormgrad,xnormynormgrad,ynormynormgrad,res,xyprod,diffis,i,j,0,size()-1,xdim,2,xxprod,yyprod);
    }

    else if ( isFastKernelXfer() && !deepDeriv )
    {
        NiceAssert( ismagterm == 0 );

        T xyprod; xyprod = 0.0;
        T yxprod; yxprod = 0.0;
        T diffis; diffis = 0.0;

        if ( !( size() >= 2 ) || !needsDiff(1) )
        {
            int dummyind = 0;

            if ( xy10 )
            {
                xyprod = (*xy10);
                yxprod = (*xy10);

                xyprod += bias;
                yxprod += bias;
            }

            else if ( pxyprod && pxyprod[0] )
            {
                xyprod = *pxyprod[0];
                yxprod = xyprod;
            }

            else
            {
                T zzz; zzz = 0.0;

                kernel8xx(0,xyprod,dummyind,cType(0),zzz,zzz,zzz,x,y,xinfo,yinfo,i,j,xdim,0,mlid);

                xyprod += bias;
                yxprod  = xyprod;
            }

            xyprod += yxprod;
            xyprod *= 0.5;

            xyprod *= (const T &) cWeight(0);

            T dummy; dummy = 0.0;

            d2KKpro(xygrad,xnormgrad,xyxygrad,xyxnormgrad,xyynormgrad,xnormxnormgrad,xnormynormgrad,ynormynormgrad,res,xyprod,diffis,i,j,1,size()-1,xdim,2,dummy,dummy);
        }

        else
        {
            int dummyind = 0;

            if ( xy10 )
            {
                xyprod = (*xy10);
                yxprod = (*xy10);

                xyprod += bias;
                yxprod += bias;
            }

            else if ( pxyprod && pxyprod[0] )
            {
                xyprod = *pxyprod[0];
                yxprod = xyprod;
            }

            else
            {
                T zzz; zzz = 0.0;

                kernel8xx(0,xyprod,dummyind,cType(0),zzz,zzz,zzz,x,y,xinfo,yinfo,i,j,xdim,0,mlid);

                xyprod += bias;
                yxprod  = xyprod;
            }

            xyprod += yxprod;
            xyprod *= 0.5;

            if ( xy00 && xy11 )
            {
                diff2norm(diffis,(double) xyprod,(*xy00),(*xy11));
            }

            else if ( pxyprod && pxyprod[1] )
            {
                diffis = *pxyprod[1];
            }

            else
            {
                T xnorm; xnorm = 0.0;
                T ynorm; ynorm = 0.0;

                int dummyind;

                T zzz; zzz = 0.0;

                kernel8xx(0,xnorm,dummyind,cType(0),zzz,zzz,zzz,x,x,xinfo,xinfo,i,i,xdim,0,mlid);
                kernel8xx(0,ynorm,dummyind,cType(0),zzz,zzz,zzz,y,y,yinfo,yinfo,j,j,xdim,0,mlid);

                if ( assumreal )
                {
                    diff2norm(diffis,(double) xyprod,(double) xnorm,(double) ynorm);
                }

                else
                {
                    diff2norm(diffis,(xyprod+yxprod)/2.0,xnorm,ynorm);
                }
            }

            xyprod *= (const T &) cWeight(0);
            diffis *= (const T &) cWeight(0);

            T dummy;

            d2KKpro(xygrad,xnormgrad,xyxygrad,xyxnormgrad,xyynormgrad,xnormxnormgrad,xnormynormgrad,ynormynormgrad,res,xyprod,diffis,i,j,1,size()-1,xdim,2,dummy,dummy);
        }
    }

    else
    {
        NiceThrow("Second-order derivatives only implemented for simple cases");
    }
}





template <class T>
void MercerKernel::dnLL2del(Vector<T> &sc, Vector<Vector<int> > &nn, int &minmaxind, 
                           const Vector<int> &q, 
                           const SparseVector<gentype> &x, const SparseVector<gentype> &y, 
                           const vecInfo &xinfo, const vecInfo &yinfo, 
                           const T &bias, const gentype **pxyprod, 
                           int i, int j, 
                           int xdim, int xconsist, int assumreal, int mlid, 
                           const double *xy00, const double *xy10, const double *xy11, int deepDeriv) const
{
    (void) mlid;

    NiceAssert( ismagterm == 0 );

    NiceAssert( !( isFastKernelSum() && ( isAltDiff() >= 200 ) && ( isAltDiff() <= 299 ) ) );
    NiceAssert( !( isprod && !arexysimple(x,y) ) );

    minmaxind = -1;

    if ( isFastKernelSum() || isFastKernelChain() )
    {
//errstream() << "phantomzyza 0\n";
        // Evaluate all requires inner products

        T xyprod; xyprod = 0.0;
        T yxprod; yxprod = 0.0;
        T diffis; diffis = 0.0;

        if ( xy10 )
        {
            xyprod = (*xy10);
            yxprod = (*xy10);

            xyprod += bias;
            yxprod += bias;
        }

        else if ( pxyprod && pxyprod[0] )
        {
            xyprod = *pxyprod[0];
            yxprod = xyprod;
        }

        else if ( needsInner(0,2) || ( isFastKernelSum() && needsInner(-1,2) ) )
        {
            innerProductDiverted(xyprod,x,y,xconsist,assumreal);
            innerProductDivertedRevConj(yxprod,xyprod,x,y,xconsist,assumreal);

            xyprod += bias;
            yxprod += bias;
        }

        xyprod += yxprod;
        xyprod *= 0.5;

        // Evaluate ||x-y||^2 if needed

        if ( ( needsDiff(0) || ( isFastKernelSum() && needsDiff() ) ) )
        {
            if ( xy00 && xy11 )
            {
                diff2norm(diffis,(double) xyprod,(*xy00),(*xy11));
            }

            else if ( pxyprod && pxyprod[1] )
            {
                diffis = *pxyprod[1];
            }

            else
            {
                // Calculate ||x-y||^2 only as required

                if ( assumreal )
                {
                    diff2norm(diffis,(double) xyprod,(double) getmnorm(xinfo,x,2,xconsist,assumreal),(double) getmnorm(yinfo,y,2,xconsist,assumreal));
                }

                else
                {
                    diff2norm(diffis,(xyprod+yxprod)/2.0,getmnorm(xinfo,x,2,xconsist,assumreal),getmnorm(yinfo,y,2,xconsist,assumreal));
                }
            }
        }




        // Gradient evaluate begins here

        int n = q.size();
        int z = 0;
        int ii,jj,k,l;

        // dnK/dx{q0}.dx{q1}... K(x,y) =  sum_i sc_i kronProd_{j=0,1,...} [ x{nn_ij}   if nn_ij = 0,1
        //                                                                [ kd{nn_ij}  if nn_ij < 0
        //
        // where: x{0} = x
        //        x{1} = y
        //        kd{a} kd{a} = kronecker-delta
        //
        // Method: initially compute nn,gd, where:
        //
        // gd(i) = [ g0 g1 g3 ]
        //
        // defines:
        //
        // sc(i) = K_{0,0,...,0,1,1,...,1,2,2,...,3}  (0 repeated g0 times, 1 g1 times, 2 g2 times)
        //
        // is a gradient of K wrt ||x||^2 (rn = 0), ||y||^2 (rn = 1), <x,y> (rn = 2)

//errstream() << "phantomzyza 1\n";
        Vector<Vector<int> > gd;

        sc.resize(1);
        nn.resize(1);
        gd.resize(1);

        sc("&",z) = 1.0;
        nn("&",z).resize(z);
        gd("&",z).resize(3);

        gd("&",z) = z;

        retVector<T>            tmpva;
        retVector<Vector<int> > tmpvb;
        
        for ( ii = n-1 ; ii >= 0 ; --ii )
        {
//errstream() << "phantomzyza 1x: ii = " << ii << "\n";
            for ( jj = sc.size()-1 ; jj >= 0 ; --jj )
            {
//errstream() << "phantomzyza 2: jj = " << jj << "\n";
                l = nn(jj).size();
                
//errstream() << "phantomzyza 2a: sc = " << sc << "\n";
//errstream() << "phantomzyza 2a: jj+1 = " << jj+1 << "\n";
//errstream() << "phantomzyza 2a: l+2 = " << l+2 << "\n";
                sc.addpad(jj+1,l+2);
//errstream() << "phantomzyza 2a: nn = " << nn << "\n";
//errstream() << "phantomzyza 2a: jj+1 = " << jj+1 << "\n";
//errstream() << "phantomzyza 2a: l+2 = " << l+2 << "\n";
                nn.addpad(jj+1,l+2);
//errstream() << "phantomzyza 2a: gd = " << gd << "\n";
//errstream() << "phantomzyza 2a: jj+1 = " << jj+1 << "\n";
//errstream() << "phantomzyza 2a: l+2 = " << l+2 << "\n";
                gd.addpad(jj+1,l+2);
                
//errstream() << "phantomzyza 2b\n";
                sc("&",jj+1,1,jj+l+2,tmpva) = sc(jj);
                nn("&",jj+1,1,jj+l+2,tmpvb) = nn(jj);
                gd("&",jj+1,1,jj+l+2,tmpvb) = gd(jj);
                
//errstream() << "phantomzyza 2c\n";
                for ( k = jj+l+2 ; k >= jj ; --k )
                {
//errstream() << "phantomzyza 3: k = " << k << "\n";
//errstream() << "phantomzyza 3a: q = " << q << "\n";
//errstream() << "phantomzyza 3a: ii = " << ii << "\n";
//errstream() << "phantomzyza 3a: q(ii) = " << q(ii) << "\n";
//errstream() << "phantomzyza 3: k = " << k << "\n";
//errstream() << "phantomzyza 3: k-jj-3 = " << k-jj-3 << "\n";
//errstream() << "phantomzyza 3: nn = " << nn << "\n";
//errstream() << "phantomzyza 3: nn(k) = " << nn(k) << "\n";
                    if ( ( q(ii) == z ) && ( k == jj ) )
                    {
                        // d/dx, d/d||x||^2
                            
//errstream() << "phantomzyza 3b\n";
                        //gd("&",k).add(gd(k).size());
                        //gd("&",k)("&",gd(k).size()-1) = z;
                        //
                        //nn("&",k).add(nn(k).size());
                        //nn("&",k)("&",nn(k).size()-1) = z;

                        ++(gd("&",k)("&",z));
                        
                        nn("&",k).add(z);
                        nn("&",k)("&",z) = z;

                        sc("&",k) *= 2.0;
                    }
                        
                    else if ( ( q(ii) == 1 ) && ( k == jj+1 ) )
                    {
                        // d/dy, d/d||y||^2
                            
//errstream() << "phantomzyza 3d\n";
                        //gd("&",k).add(gd(k).size());
                        //gd("&",k)("&",gd(k).size()-1) = 1;
                        //
                        //nn("&",k).add(nn(k).size());
                        //nn("&",k)("&",nn(k).size()-1) = 1;

                        ++(gd("&",k)("&",1));
                        
                        nn("&",k).add(z);
                        nn("&",k)("&",z) = 1;
                        
                        sc("&",k) *= 2.0;
                    }
                        
                    else if ( ( q(ii) == z ) && ( k == jj+2 ) )
                    {
                        // d/dx, d/d<x,y>
                            
//errstream() << "phantomzyza 3c\n";
                        //gd("&",k).add(gd(k).size());
                        //gd("&",k)("&",gd(k).size()-1) = 2;
                        //
                        //nn("&",k).add(nn(k).size());
                        //nn("&",k)("&",nn(k).size()-1) = 1;

                        ++(gd("&",k)("&",2));
                        
                        nn("&",k).add(z);
                        nn("&",k)("&",z) = 1;
                            
                        //sc("&",k) *= 1.0;
                    }
                        
                    else if ( ( q(ii) == 1 ) && ( k == jj+2 ) )
                    {
                        // d/dy, d/d<x,y>
                            
//errstream() << "phantomzyza 3e\n";
                        //gd("&",k).add(gd(k).size());
                        //gd("&",k)("&",gd(k).size()-1) = 2;
                        //
                        //nn("&",k).add(nn(k).size());
                        //nn("&",k)("&",nn(k).size()-1) = z;

                        ++(gd("&",k)("&",2));
                        
                        nn("&",k).add(z);
                        nn("&",k)("&",z) = z;
                            
                        //sc("&",k) *= 1.0;
                    }
                    
                    else if ( ( k-jj-3 >= 0 ) && ( q(ii) == nn(k)(k-jj-3) ) )
                    {
//errstream() << "phantomzyza 3f\n";
                        //nn("&",k)("&",k-jj-3) = -ii;
                        //nn("&",k).add(k-jj-3);
                        //nn("&",k)("&",k-jj-3) = -ii;

                        nn("&",k)("&",k-jj-3) = -(ii+1);
                        nn("&",k).add(z);
                        nn("&",k)("&",z) = -(ii+1);
                            
                        //sc("&",k) *= 1.0;
                    }
                    
                    else
                    {
//errstream() << "phantomzyza 3g\n";
                        sc.remove(k);
                        nn.remove(k);
                        gd.remove(k);
                    }
//errstream() << "phantomzyza 3f\n";
                }
            }
        }
        
//errstream() << "phantomzyza 4\n";
//errstream() << "phantomzyza 4: sc = " << sc << "\n";
//errstream() << "phantomzyza 4: nn = " << nn << "\n";
//errstream() << "phantomzyza 4: gd = " << gd << "\n";

        // scratch-pad may be used by dnKKpro to pre-calculate on first call and re-use results later
        // (for example the RBF kernel calculates K(x,y) and stores it here as the derivatives are
        // simply scaled versions of this).

        T scratch;
        int isfirstcalc = 1;

        // gradpad keeps results for different kernel gradients to avoid later re-calculation

        SparseVector<SparseVector<SparseVector<T> > > gradpad;

        for ( k = nn.size()-1 ; k >= 0 ; --k )
        {
//errstream() << "phantomzyza 5: k = " << k << "\n";
            if ( !(gradpad.isindpresent(gd(k)(z))) || !((gradpad(gd(k)(z))).isindpresent(gd(k)(1))) || !(((gradpad(gd(k)(z)))(gd(k)(1))).isindpresent(gd(k)(2))) )
            {
                dnKKpro(((gradpad("&",gd(k)(z)))("&",gd(k)(1)))("&",gd(k)(2)),gd(k),xyprod,diffis,i,j,0,size()-1,xdim,2,isfirstcalc,scratch);
                isfirstcalc = 0;
            }

//errstream() << "phantomzyza 6\n";
            
            sc("&",k) *= ((gradpad(gd(k)(z)))(gd(k)(1)))(gd(k)(2));

            if ( (double) abs2(sc(k)) == 0 )
            {
                sc.remove(k);
                nn.remove(k);
                gd.remove(k);
            }
//errstream() << "phantomzyza 7\n";
        }

        // Finally we do a quick, non-exhaustive scan of adjacent terms to see if
        // any can be combined.  gd is no longer relevant, so ignore that.  This
        // should actually catch most repeats due to the ordering applied previously.

        for ( k = nn.size()-1 ; k >= 1 ; --k )
        {
            if ( nn(k) == nn(k-1) )
            {
                sc("&",k-1) += sc(k);

                sc.remove(k);
                nn.remove(k);
            }
        }
    }

    else if ( isFastKernelXfer() && !deepDeriv )
    {
        NiceThrow("High-order kernel transfer only implemented for simple cases");
    }

    else
    {
        NiceThrow("High-order derivative only implemented for simple cases");
    }
}
























#endif

